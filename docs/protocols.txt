
The protocol named "optical alignment" can be found at the xmipp3 plugin.
Its help description is:
 
    Wrapper protocol to Xmipp Movie Alignment by Optical Flow
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
from: None
to: None
Use ALIGN frames range to SUM?: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Save aligned micrograph: None
Save movie: Save Aligned movie
: Set to true if you want the GPU implementation of Optical Flow
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Window size: Window size (shifts are assumed to be constant within this window).
Group Size: The number of frames in each group at the last step
Use previous movie alignment to SUM frames?: Input movies could have alignment information froma previous protocol. If you select *Yes*, the previous alignment will be taken into account.
Compute PSD (before/after)?: If Yes, the protocol will compute for each movie the PSD of the average micrograph (without OF alignement) and after that, to compare each PSDs
Keep images in RAM ?: If True, the protocol will increase the demand of RAM, decreasing disc access
Apply Dose filter: Apply a dose-dependent filter to frames before summing them. Pre-exposure and dose per frame should  be specified during movies import.
Save unweighted micrographs?: Yes by default, if you have selected to apply a dose-dependent filter to the frames
Apply Dose filter before alignment?: if *True*, you apply dose filter before perform the alignment; else will apply after alignment.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "apply deformation field - Zernike3D" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for PDB deformation based on Zernike3D basis. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Zernike3D volume(s): Volume(s) with Zernike3D coefficients assigned.
Input volume mask: None
Zernike Degree: Degree Zernike Polynomials of the deformation=1,2,3,...
Harmonical Degree: Degree Spherical Harmonics of the deformation=1,2,3,...
Apply to structure?: If True, you will be able to provide an atomic structure to be deformed based on the Zernike3D coefficients associated to the input volume(s). If False, the coefficients will be applied to the volume(s) directly.
Input PDB: Atomic structure to apply the deformation fields defined by the Zernike3D coefficients associated to the input volume. For better results, the volume(s) and structure should be aligned
Move structure to box origin?: If PDB has been aligned inside Scipion, set to False. Otherwise, this option will correctly place the PDB in the origin of the volume.

The protocol named "metaprotocol heterogeneity subset" can be found at the xmipp3 plugin.
Its help description is:
  Metaprotocol to select a set of particles from a 3DClasses and a
    Volume from a SetOfVolumes
     .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of 3D classes: Select the set of 3D classes to select an specific set of particles.
Input Idx: Identifier of the volume and particles selected

The protocol named "metaprotocol golden highres" can be found at the xmipp3 plugin.
Its help description is:
  Metaprotocol to run golden version of highres.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Full-size Images: Select a set of images at full resolution
Initial volumes: Select a set of volumes with 2 volumes or a single volume
Radius of particle (px): This is the radius (in pixels) of the spherical mask covering the particle in the input images
Symmetry group: If no symmetry is present, give c1
Initial resolution: In Angstroms. The minimum resolution to be used in the first step of the protocol. Then, the resolution will be automatically adjusted.
Maximum resolution: In Angstroms. The maximum resolution to be used along the protocol. Set it to -1 for automatic adjustment.
Discard particles?: Discard particles when two distributions are estimated?
Split method: When discard particles is allowed, choose the method between hypothesis testing or Otsu thresholding
Adaptive threshold HT: Choose if you want to use an adaptive threshold for the hypothesis testing.
Max. shift (%): Maximum shift as a percentage of the image size
Min.: Side views are around 90 degrees, top views around 0
Max.: You may generate redudant galleries by setting this angle to 180, this may help if c1 symmetry is considered
Mask: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
Symmetrize volume within mask?: None
Mask symmetry: If no symmetry is present, give c1
Mask: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
Apply helical symmetry?: None
Radius: In Angstroms
Dihedral symmetry: None
Min. Rotation: In degrees
Max. Rotation: In degrees
Min. Z shift: In angstroms
Max. Z shift: In angstroms
Post-processing command: A command template that is used to post-process the reconstruction. The following variables can be used %(sampling)s %(dim)s %(volume)s %(iterDir)s. The command should read Spider volumes and modify the input volume.the command should be accessible either from the PATH or provide the absolute path.
Examples: 
xmipp_transform_filter -i %(volume)s --fourier low_pass 15 --sampling %(sampling)s
/home/joe/myScript %(volume)s sampling=%(sampling)s dim=%(dim)s
Significant denoising Real space: None
Significant denoising Fourier space: None
Laplacian denoising: It can only be used if there is a mask
Blind deconvolution: None
Attenuate undershooting: None
Attenuate undershooting (K): Values below avg-K*sigma are attenuated
Evaluate difference: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "auto-picking (step 2)" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to pick particles automatically in a set of
    micrographs using previous training .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Model source: The files model_* can be copied from a previous protocol execution within this project or copied from an external directory. This latter option is useful incases in which the same kind of molecule is processed many times.
Xmipp particle picking run: Select the previous xmipp particle picking run.
Xmipp particle picking model directory: The directory must contain the files model_*, config.xmd and templates.stk
Micrographs to pick: Select from which set of micrographs to pick using the training from supervised run.If you use Same as supervised, the same set of micrographs used for training the picker will be used at this point. If you select Other, you can select another set of micrograph (normally from the same specimen) and pick them completely automatic using the trained picker.
Micrographs: Select other set of micrographs to pick using the trained picker.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "add noise particles" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a set of particles, the protocol will add noise to them 
    The types of noise are Uniform, Student and Gaussian.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select a set of particles.
Noise Type: None
Standard Deviation: Please, introduce the standard deviation value.Mean value can be changed in advanced mode.
Mean: Please, introduce the mean value (default = 0).
Degree of Freedom: Please, introduce the Degree of Freedom.Mean value can be changed in advanced mode.
Standard Deviation: Please, introduce the standard deviation value.Mean value can be changed in advanced mode.
Mean: Please, introduce the mean value (default = 0).
Minimum Value: Please, introduce the minimum value. (default = 0)
Maximum Value: Please, introduce the maximum value (default = 1).
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "add noise volume/s" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a set of volumes, or a volume the protocol will add noise to them 
    The types of noise are Uniform, Student and Gaussian.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume/s: Select a volume or Set of volumes.
Noise Type: None
Standard Deviation: Please, introduce the standard deviation value.Mean value can be changed in advanced mode.
Mean: Please, introduce the mean value (default = 0).
Degree of Freedom: Please, introduce the Degree of Freedom.Mean value can be changed in advanced mode.
Standard Deviation: Please, introduce the standard deviation value.Mean value can be changed in advanced mode.
Mean: Please, introduce the mean value (default = 0).
Minimum Value: Please, introduce the minimum value. (default = 0)
Maximum Value: Please, introduce the maximum value (default = 1).
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "align volume" can be found at the xmipp3 plugin.
Its help description is:
  
    Aligns a set of volumes using cross correlation 
    or a Fast Fourier method. 

     .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Reference volume: Reference volume to be used for the alignment.
Input volume(s): Select one or more volumes (Volume or SetOfVolumes)
to be aligned againt the reference volume.
Apply mask?: Apply a 3D Binary mask to the volumes
Mask type: Select the type of mask you want to apply
Mask radius: Insert the radius for the mask
Mask file: Select the volume mask object
Alignment algorithm: Exhaustive searches all possible combinations within a search space.Local searches around a given position.Be aware that the Fast Fourier algorithm requires a special compilationof Xmipp (--cltomo flag). It performs the same job as the  exhaustive method but much faster.
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Rot: None
Tilt: None
Psi: None
X: None
Y: None
Z: None
Optimize scale: Choose YES if you want to optimize the scale of input volume/s based on the reference
Initial scale: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "align volume web" can be found at the xmipp3 plugin.
Its help description is:
  Aligns a set of volumes using cross correlation.
    Based on Xmipp protocol for aligning volumes, but
    the parameters are restricted for ease of use.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Reference volume: Reference volume to be used for the alignment.
Input volume(s): Select one or more volumes (Volume or SetOfVolumes)
to be aligned againt the reference volume.
Apply mask?: Apply a 3D Binary mask to the volumes
Mask type: Select the type of mask you want to apply
Mask radius: Insert the radius for the mask
Mask file: Select the volume mask object
Alignment algorithm: Exhaustive searches all possible combinations within a search space.Local searches around a given position.Be aware that the Fast Fourier algorithm requires a special compilationof Xmipp (--cltomo flag). It performs the same job as the  exhaustive method but much faster.
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Rot: None
Tilt: None
Psi: None
X: None
Y: None
Z: None
Optimize scale: Choose YES if you want to optimize the scale of input volume/s based on the reference
Initial scale: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "align volume and particles" can be found at the xmipp3 plugin.
Its help description is:
  
    Aligns a volume (inputVolume) using a Fast Fourier method
    with respect to a reference one (inputReference).
     The obtained alignment parameters are used to align the set of particles or subtomograms
     (inputParticles) that generated the input volume.
     .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Reference volume: Reference volume to be used for the alignment.
Input volume: Select one volume to be aligned against the reference volume.
Input particles: Select one set of particles to be aligned against the reference set of particles using the transformation calculated with the reference and input volumes.
Alignment mode: None
Symmetry group: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] page for a description of the symmetries accepted by Xmipp
Wrap: Wrap the input volume when aligning to the reference
Apply mask?: Apply a 3D Binary mask to the volumes
Mask type: Select the type of mask you want to apply
Mask radius: Insert the radius for the mask
Mask file: Select the volume mask object
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "analyze local defocus" can be found at the xmipp3 plugin.
Its help description is:
 Assigns to each micrograph a coefficient (R2) which evaluates the result of the
        local defocus adjustment and displays the local defocus for all the particles in each micrograph..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: None
Input images: Set of particles with assigned local defocus

The protocol named "break symmetry" can be found at the xmipp3 plugin.
Its help description is:
 
    Given an input set of particles with angular assignment, find an
    equivalent angular assignment for a given symmetry.

    Be aware that input symmetry values follows Xmipp conventions as described in:
    http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Symmetry group: See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format in Xmipp.
If no symmetry is present, use _c1_.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "angular graph consistency" can be found at the xmipp3 plugin.
Its help description is:
 
    Performs soft alignment validation of a set of particles previously aligned
    confronting them using Graph filtered correlations representation. This
    protocol produces an histogram with two groups of particles.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: Select the input volume(s).
Input particles: Select the input projection images.
Symmetry group: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
Angular Sampling (degrees): Angular distance (in degrees) between neighboring projection points 
correlation level for validation: threshold correlation to be used in validation. Keep this value in the range [0.90 -- 0.97]
Minimum allowed tilt angle: Tilts below this value will not be considered for the alignment
Maximum allowed tilt angle without mirror check: Tilts above this value will not be considered for the alignment without mirror check
Target resolution (A): Low pass filter the particles to this resolution. This usually helps a lot obtaining good alignment. You should have a good reason to modify this value outside the range  [8-10] A
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "apply alignment 2d" can be found at the xmipp3 plugin.
Its help description is:
  Apply alignment parameters and produce a new set of images. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: Select the particles that you want to apply thealignment parameters.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "apply transformation matrix" can be found at the xmipp3 plugin.
Its help description is:
  
    Apply transformation matrix  of an aligned volume on 
    a set of particles to modify their angular assignment.
    Note:
    These particles are practically related to the 
    aligned volume (but before alignment).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Aligned particles that their  angular assignment needs to be modified.
Input volume: Volume that we want to use its transformation matrix to modify angular assignment of input particles. (This is normally the output volume of protocol_align_volume)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "assign tiltpairs" can be found at the xmipp3 plugin.
Its help description is:
     
    From two sets of points (tilted and untilted) the protocol determines
    the affine transformation between these sets.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Micrograph tilt pair: Select micrographs tilt pair.
Input type: Select a Set of Coordinates or a Set or Particles.
Untilted input: Select the untilted input set, it can be either coordinates or particles (that contains coordinates.
Tilted input: Select the tilted input set, it can be either coordinates or particles (that contains coordinates. It should be of the same type of the input untilted.
Tilt angle: Tilt angle estimation, the method will look for the assignment in the interval of [tilt_angle-15, tilt_angle+15].
 By default: tilt angle = -1, if there is not any information about the tilt angle
Threshold value: Parameter between 0 and 1 that allows to define if 
a tilt point can be matched with a certain untilt point.
The matching is performed only if the distance is lesser
than threshold * particlesize.
Maximum shift (pixels): Maximum allowed distance (in pixels) that the tilt micrograph can be shifted respect to the untilted micrograph
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "boost particles" can be found at the xmipp3 plugin.
Its help description is:
  This protocol tries to boost the frequencies of the particles to imporve them, based on an adjustment on its correspondent projections from a reference volume. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particles : Specify a SetOfParticles
Reference volume : Specify a volume.
Circular mask radius: : Radius of the circular mask to avoid edge artifacts. If -1 it is half the X dimension of the input particles
Maximum resolution: : Maximum resolution (in A) of the data 
Ignore particles with negative beta0 or R2?: : Particles with negative beta0 or R2 will not appear in the output set as they are considered bad particles. Moreover, negative betas will not contribute to mean beta if "mean" option is selected
Limit frequency?: : Limit frequency in the adjustment process to the frequency correspondent to the resolution indicated in "Maximum resolution" field above
Decay of the filter (sigma): : Decay of the filter (sigma) to smooth the mask transition
Fourier padding factor: : The volume is zero padded by this factor to produce projections
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "cl2d" can be found at the xmipp3 plugin.
Its help description is:
  Classifies a set of images using a clustering algorithm to subdivide
    the original dataset into a given number of classes. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input images: Select the input images to be classified.
Number of classes:: Number of classes (or references) to be generated.
Random initialization of classes:: Initialize randomly the first classes. If you don't initialize randomly, you must supply a set of initial classes
Initial classes: Set of initial classes to start the classification
Number of initial classes:: Initial number of classes used in the first level.
Number of iterations:: Maximum number of iterations within each level.
Comparison method: Use correlation or correntropy
Clustering method: Use the classical clustering criterion or the robust
Additional parameters: Additional parameters for classify_CL2D: 
 --verbose, --corrSplit, ...
Perform core analysis: An image belongs to the core if it is close (see Junk Zscore and PCA Zscore) to the class center
Junk Zscore: Which is the average Z-score to be considered as junk. Typical values go from 1.5 to 3. For the Gaussian distribution 99.5% of the data is within a Z-score of 3. Lower Z-scores reject more images. Higher Z-scores accept more images.
PCA Zscore: Which is the PCA Z-score to be considered as junk. Typical values go from 1.5 to 3. For the Gaussian distribution 99.5% of the data is within a Z-score of 3. Lower Z-scores reject more images. Higher Z-scores accept more images.
Perform stable core analysis: Two images belong to the stable core if they have been essentially together along the classification process
Tolerance: An image belongs to the stable core if it has been with other images in the same class in all the previous levels except possibly a few of them. Tolerance defines how few is few. Tolerance=0 means that an image must be in all previous levels with the rest of images in the core.
Compute class hierarchy: None
Analyze rejected particles: To see the analysis you need to browse the execution directory and go into the different levels
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "align with cl2d" can be found at the xmipp3 plugin.
Its help description is:
  Aligns a set of particles using the CL2D algorithm. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Use a Reference Image ?: If you set to *Yes*, you should provide a reference image.
If *No*, the default generation is done by averaging subsets of the input images.
Reference image: Image that will serve as class reference. If the input is a set, then the first image will be used as reference.
Maximum shift (px):: None
Number of iterations:: Maximum number of iterations
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "2D classes mapping" can be found at the xmipp3 plugin.
Its help description is:
  Create a low dimensional mapping from a SetOfClasses2D with interactive selection of classes.
    Use mouse left-click to select/deselect classes individually or mouse right-click to select/deselect
    several classes..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input 2D classes: Select the input classes to be mapped.
Interactive class selection?: None
Dimension reduction method: None
Distance metric to compare images: None

The protocol named "ctf consensus" can be found at the xmipp3 plugin.
Its help description is:
 
    Protocol to make a selection of meaningful CTFs in basis of the defocus
    values, the astigmatism, the resolution, other Xmipp parameters, and
    the agreement with a secondary CTF for the same set of micrographs.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input CTF: Select the estimated CTF to evaluate
Use Defocus for selection: Use this button to decide if carry out the selection taking into account or not the defocus values.
Min: None
Max: None
Use Astigmatism for selection: Use this button to decide if carry out the selection taking into account or not the astigmatism value.
Astigmatism (A): Maximum value allowed for astigmatism in Angstroms. If the evaluated CTF has a larger Astigmatism, it will be discarded.
Use Astigmatism percentage for selection: Use this button to decide if carry out the selection taking into account or not the astigmatism value.
Astigmatism percentage: Maximum value allowed for astigmatism percentage (|defocus_U-defocus_V|/mean_defocus). If the evaluated CTF has a larger Astigmatism Percentage, it will be discarded.
Use Resolution for selection: Use this button to decide if carry out the selection taking into account or not the resolution value.
Resolution (A): Minimum value for resolution in Angstroms. If the evaluated CTF has not reached that minimum, it will be discarded.
Use Xmipp criteria for selection: Use this button to decide if carrying out the selection taking into account the Xmipp parameters.
Only available when Xmipp CTF estimation was used for the _Input CTF_ or for the _Secondary CTF_.
Minimum 1st zero: Minimun value of CritFirstZero
Min: None
Max: None
Correlation 1st-3rd zero: Minimum value of correlation between 1st and 3rd zeros
CTF Margin: Minimum value of CritCtfMargin
CritIceness: Minimum value of the iceness.
Min: None
Max: None
Calculate Consensus Resolution: Option for calculating consensus resolution. The algorithm assumes that two CTF are consistent if the phase (wave aberration function) of the two CTFs are closer than 90 degrees.
The reported consensusResolution is the resolution at which the two CTF phases differ in 90 degrees.
Secondary CTF: CTF to be compared with reference CTF
Minimum consensus resolution (A).: Minimum value for the consensus resolution in Angstroms.
If there are noticeable discrepancies between the two estimations below this resolution, it will be discarded.
Average equivalent metadata?: If *Yes*, making an average of those metadata present in both CTF estimations (defocus, astigmatism angle...)
 If *No*, the primary estimation metadata will persist.
Include all secondary metadata?: If *Yes*, all metadata in the *Secondary CTF* will be included in the resulting CTF.
 If *No*, only the primary metadata (plus consensus scores) will be in the resulting CTF.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "ctf_correct_wiener2d" can be found at the xmipp3 plugin.
Its help description is:
     
    Perform CTF correction by Wiener filtering.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input projection images .
Isotropic Correction: If true, Consider that there is not astigmatism and then it is performed an isotropic correction.
Padding factor: Padding factor for Wiener correction 
Wiener constant:  Wiener-filter constant (if < 0: use FREALIGN default)
Correct for CTF envelope:  Only in cases where the envelope is well estimated correct for it
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "defocus group" can be found at the xmipp3 plugin.
Its help description is:
 
    Given a set of CTFs group them by defocus value.
    The output is a metadata file containing 
     a list of defocus values that delimite 
    each defocus group.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles with CTF: Select the input particles. 
 they should have information about the CTF (hasCTF=True)
Error for grouping: Maximum error when grouping, the higher the more groupsThis is a 1D program, only defocus U is used
 The frequency at which the phase difference between the CTFs
belonging to 2 particles is equal to Pi/2 is computed 
 If this difference is less than 1/(2*factor*sampling_rate)
then images are placed in different groups

The protocol named "ctf estimation" can be found at the xmipp3 plugin.
Its help description is:
  Protocol to estimate CTF on a set of micrographs using Xmipp. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Do recalculate ctf?: None
Input previous run: None
: None
Input Micrographs: None
Automatic Downsampling Factor: Recommended value to downsample
Manual CTF Downsampling factor: Set to 1 for no downsampling. Non-integer downsample factors are possible. This downsampling is only used for estimating the CTF and it does not affect any further calculation. Ideally the estimation of the CTF is optimal when the Thon rings are not too concentrated at the origin (too small to be seen) and not occupying the whole power spectrum (since this downsampling might entail aliasing).
Use defoci from a previous CTF estimation: None
Previous CTF estimation: Choose some CTF estimation related to input micrographs, in case you want to use the defocus values found previously
Optimize defocus: If set to False, then the previous defocus is taken
Find additional phase shift?: If the data was collected with phase plate, this will find additional phase shift due to phase plate
Automatic CTF downsampling detection: If this option is chosen, the algorithm automatically tries by default the suggested Downsample factor; and if it fails, +1; and if it fails, -1.
Allow amplitude constrast refinement: The amplitude contrast is normally kept fixed, but insome experiments it has been found that refining it might result in some improvement in the final FSC. This is not a standard practice, and should be used with caution
Skip borders: Remove the borders of the micrograph. If True, two times the window size will be cropped.
Lowest: None
Highest: None
Min: None
Max: None
Window size: The PSD is estimated from small patches of this size. Bigger patches allow identifying more details. However, since there are fewer windows, estimations are noisier.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "center particles" can be found at the xmipp3 plugin.
Its help description is:
  Realignment of un-centered particles. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Classes: Set of classes to be read
Set of micrographs: Set of micrographs related to the selected input classes
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "compare angles" can be found at the xmipp3 plugin.
Its help description is:
     
    Compare two sets of angles. The output is a list of all common particles with
    the angular difference between both assignments. The output is constructed by 
    keeping the information from the Set 1 and adding the shiftDiff and angularDiff.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles 1: Select the input experimental images with an angular assignment.
Input particles 2: Select the input experimental images with an angular assignment.
Symmetry group: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] page for a description of the symmetries accepted by Xmipp

The protocol named "compare reprojections" can be found at the xmipp3 plugin.
Its help description is:
 Compares a set of classes or averages with the corresponding projections of a reference volume.
    The set of images must have a 3D angular assignment and the protocol computes the residues
    (the difference between the experimental images and the reprojections). The zscore of the mean
    and variance of the residues are computed. Large values of these scores may indicate outliers.
    The protocol also analyze the covariance matrix of the residual and computes the logarithm of
    its determinant [Cherian2013]. The extremes of this score (called zScoreResCov), that is
    values particularly low or high, may indicate outliers..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input images: None
Volume to compare images to: Volume to be used for class comparison
Use input angular assignment (if available): None
Optimize gray scale: None
Ignore CTF: By ignoring the CTF you will create projections more similar to what a person expects, while by using the CTF you will create projections more similar to what the microscope sees
Evaluate residuals: If this option is chosen, then the residual covariance matrix is calculated and characterized. But this option takes time and disk space
Symmetry group: See http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format. If no symmetry is present, give c1
Angular sampling rate: In degrees. This sampling defines how fine the projection gallery from the volume is explored.
Filter at resolution: : Resolution (A) at which subtraction will be performed, filtering the volume projections.Value 0 implies no filtering.
Decay of the filter (sigma): : Decay of the filter (sigma parameter) to smooth the mask transition
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "consensus classes" can be found at the xmipp3 plugin.
Its help description is:
  Compare several SetOfClasses.
        Return the consensus clustering based on a objective function
        that uses the similarity between clusters intersections and
        the entropy of the clustering formed.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input classes: Select several sets of classes where to evaluate the intersections.
Minimum class size: Minimum output class size. If set to zero it will not have any effect
Metric: Distance metric used when comparing clusters

The protocol named "consensus local defocus" can be found at the xmipp3 plugin.
Its help description is:
 This protocol compares the estimations of local defocus computed by different protocols for a set of particles.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles to assign the consensus defocus: Particle set of interest to estimate the defocus
Input defocus estimations: Sets of particles with different local defocus estimations to compare

The protocol named "picking consensus" can be found at the xmipp3 plugin.
Its help description is:
 
    Protocol to estimate the agreement between different particle picking
    algorithms. The protocol takes several Sets of Coordinates calculated
    by different programs and/or different parameter settings. Let's say:
    we consider N independent pickings. Then, a coordinate is considered
    to be a correct particle if M pickers have selected the same particle
    (within a radius in pixels specified in the form).

    If you want to be very strict, then set M=N; that is, a coordinate
    represents a particle if it has been selected by all particles (this
    is the default behaviour). Then you may relax this condition by setting
    M=N-1, N-2, ...

    If you want to be very flexible, set M=1, in this way it suffices that
    1 picker has selected the coordinate to be considered as a particle. Note
    that in this way, the cleaning of the dataset has to be performed by other
    means (screen particles, 2D and 3D classification, ...).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the set of coordinates to compare
Radius: All coordinates within this radius (in pixels) are presumed to correspond to the same particle
Consensus: How many times need a particle to be selected to be considered as a consensus particle.
*Set to -1* to indicate that it needs to be selected by all algorithms: *AND* operation.
*Set to 1* to indicate that it suffices that only 1 algorithm selects the particle: *OR* operation.
Consensus mode: If the number of votes to progress to the output must be either (=) strictly speaking equals to the consensus number or (>=) at least equals.

The protocol named "convert pdbs to volumes" can be found at the xmipp3 plugin.
Its help description is:
  Convert atomic structure(s) into volume(s) .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Input structure(s) : Specify input atomic structure(s).
Sampling rate (Å/px): Sampling rate (Angstroms/pixel)
Use a volume as an empty template?: Use an existing volume to define the size and origin for the output volume. If this optionis selected, make sure that "Center PDB" in advanced parameters is set to *No*.
Input volume : The origin and the final size of the output volume will be taken from this volume.
Set final size?: None
Box side size (px): This size should apply to all volumes
Final size (px) Z: Final size in Z in pixels. If no value is provided, protocol will estimate it.
Final size (px) Y: Final size in Y in pixels. If no value is provided, protocol will estimate it.
Final size (px) X: Final size in X in pixels. If desired output size is x = y = z you can only fill this field. If no value is provided, protocol will estimate it.
Center PDB: Center PDB with the center of mass.
Store centered PDB: Set to 'Yes' if you want to save centered PDB. It will be stored in the output directory of this protocol.
Convert CIF to PDB: If set to true and input atom struct file is a CIF, it will get converted to PDB.
Clean tmp files: Delete all non-output files once the protocol has finished producing them.

The protocol named "core analysis" can be found at the xmipp3 plugin.
Its help description is:
  Analyzes the core of a 2D classification. The core is calculated through
    the Mahalanobis distance from each image to the center of the class. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input classes: Set of input classes to be analyzed
Junk Zscore: Which is the average Z-score to be considered as junk. Typical values go from 1.5 to 3. For the Gaussian distribution 99.5% of the data is within a Z-score of 3. Lower Z-scores reject more images. Higher Z-scores accept more images.
PCA Zscore: Which is the PCA Z-score to be considered as junk. Typical values go from 1.5 to 3. For the Gaussian distribution 99.5% of the data is within a Z-score of 3. Lower Z-scores reject more images. Higher Z-scores accept more images.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "create gallery" can be found at the xmipp3 plugin.
Its help description is:
 
    Create a gallery of projections from a volume.
    This gallery of projections may help to understand the images
    observed in the microscope.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: None
Symmetry group: Seehttps://github.com/I2PC/xmipp-portal/wiki/Symmetry for a description of the symmetry groups format. If no symmetry is present, give c1
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Maximum frequency: Normalized to 0.5
Shift sigma: In pixels

The protocol named "create 2d mask" can be found at the xmipp3 plugin.
Its help description is:
  Create a 2D mask.
    The mask can be created with a given geometrical shape (Circle, Rectangle,
    Crown...) or it can be obtained from operating on a 2d image or a previuous
    mask. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Sampling Rate (Å/px): None
Mask size (px): Select the mask dimensions in pixels. The mask will be size x size pixels
Mask type: None
Radius (px): Mask radius, if -1, the radius will be MaskSize/2
Box size: Mask box size, if -1, the box size will be MaskSize/2
Inner radius (px): Inner radius in pixels
Outer radius (px): Outer radius in pixels, if -1, the outer radius will be MaskSize/2
Sigma (px): Gaussian sigma in pixels. If -1, sigma will be MaskSize/6
Border decay (px): This is the fall-off of the two borders of the crown
Shift Center: Shift Mask Center to a new origin.
X center offset: New x center coordinate
Y center offset: New y center coordinate

The protocol named "create 3d mask" can be found at the xmipp3 plugin.
Its help description is:
  Create a 3D mask.
    The mask can be created with a given geometrical shape (Sphere, Box,
    Cylinder...) or it can be obtained from operating on a 3d volume or a
    previous mask.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Mask source: None
Input volume: Select the volume that will be used to create the mask
Operation: None
Threshold: Select the threshold. Gray values lesser than the thresholdwill be set to zero, otherwise will be one (mask area).
Segmentation type: None
Number of voxels: None
Number of aminoacids: None
Mass (Da): None
Sampling Rate (Å/px): None
Mask size (px): Select the mask dimensions in voxels. The mask will be size x size x size voxels
Mask type: None
Radius (px): Mask radius, if -1, the radius will be MaskSize/2
Shift center of the mask?: None
X: None
Y: None
Z: None
Box size: Mask box size, if -1, the box size will be MaskSize/2
Inner radius (px): Inner radius in pixels
Outer radius (px): Outer radius in pixels, if -1, the outer radius will be MaskSize/2
Height (px): Cylinder height in pixels. If -1, height will be MaskSize
Sigma (px): Gaussian sigma in pixels. If -1, sigma will be MaskSize/6
Border decay (px): This is the fall-off of the two borders of the crown
Feature File: Create a mask using a feature file. Follows an example of feature file 
# XMIPP_STAR_1 *
# Type of feature (sph, blo, gau, Cyl, dcy, cub, ell, con)(Required)
# The operation after adding the feature to the phantom (+/=) (Required)
# The feature density (Required)
# The feature center (Required)
# The vector for special parameters of each vector (Required)
# Sphere: [radius] 
# Blob : [radius alpha m] Gaussian : [sigma]
# Cylinder : [xradius yradius height rot tilt psi]
# DCylinder : [radius height separation rot tilt psi]
# Cube : [xdim ydim zdim rot tilt psi]
# Ellipsoid : [xradius yradius zradius rot tilt psi]
# Cone : [radius height rot tilt psi]
data_block1
 _dimensions3D  '34 34 34' 
 _phantomBGDensity  0.
 _scale  1.
data_block2
loop_
 _featureType
 _featureOperation
 _featureDensity
 _featureCenter
 _featureSpecificVector
sph + 1 '3.03623188  0.02318841 -5.04130435' '7'

Remove small objects: To remove small clusters of points. The input mask has to be binary.
Minimum size: Connected components whose size is smaller than this number in voxels will be removed
Keep largest component: To keep cluster greater than a given size. The input mask has to be binary
Symmetrize mask: None
Symmetry group: To obtain a symmetric mask. See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry 
for a description of the symmetry groups format. 
If no symmetry is present, give c1
Apply morphological operation: Dilation (dilate white region). 
Erosion (erode white region). 
Closing (Dilation+Erosion, removes black spots). 
Opening (Erosion+Dilation, removes white spots). 

Operation: None
Structural element size: The larger this value, the more the effect will be noticed
Invert the mask: None
Smooth borders: Smoothing is performed by convolving the mask with a Gaussian.
Gaussian sigma (px): The larger this value, the more the effect will be noticed

The protocol named "crop/resize particles" can be found at the xmipp3 plugin.
Its help description is:
  Crop or resize a set of particles .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles/Mask: Input particles or 2D Mask to be cropped/resized.
Resize particles?: If you set to *Yes*, you should provide a resize option.
Resize option: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Dimensions_: Set the output dimensions. Resize operation can be done in Fourier space.
_Factor_: Set a resize factor to resize. 
 _Pyramid_: Use positive level value to expand and negative to reduce. 
Pyramid uses spline pyramids for the interpolation. All the rest uses normally interpolation
(cubic B-spline or bilinear interpolation). If you set the method to dimensions, you may choose
between interpolation and Fourier cropping.
Resize sampling rate (Å/px): Set the new output sampling rate.
Use fourier method to resize?: If you set to *True*, the final dimensions must be lower than the original ones.
New image size (px): Size in pixels of the particle images <x> <y=x> <z=x>.
Resize factor: New size is the old one x resize factor.
Pyramid level: Use positive value to expand and negative to reduce.
Huge file: If the file is huge, very likely you may have problems doing the antialiasing filter (because there is no memory for the input and its Fourier tranform). This option removes the antialiasing filter (meaning you will get aliased results), and performs a bilinear interpolation (to avoid having to produce the B-spline coefficients).
Apply a window operation?: If you set to *Yes*, you should provide a window option.
Window operation: Select how to change the size of the particles.
_cls.RESIZE_: provide the new size (in pixels) for your particles.
_crop_: choose how many pixels to crop from each border.

Crop size (px): Amount of pixels cropped from each border.
e.g: if you set 10 pixels, the dimensions of the
object (SetOfParticles, Volume or SetOfVolumes) will be
reduced in 20 pixels (2 borders * 10 pixels)
Window size (px): Size in pixels of the output object. It will be expanded or cutted in all directions such that the origin remains the same.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "crop/resize volumes" can be found at the xmipp3 plugin.
Its help description is:
  Crop or resize a set of volumes .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: Can be a density volume or a SetOfVolumes.
Resize volumes?: If you set to *Yes*, you should provide a resize option.
Resize option: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Dimensions_: Set the output dimensions. Resize operation can be done in Fourier space.
_Factor_: Set a resize factor to resize. 
 _Pyramid_: Use positive level value to expand and negative to reduce. 
Pyramid uses spline pyramids for the interpolation. All the rest uses normally interpolation
(cubic B-spline or bilinear interpolation). If you set the method to dimensions, you may choose
between interpolation and Fourier cropping.
Resize sampling rate (Å/px): Set the new output sampling rate.
Use fourier method to resize?: If you set to *True*, the final dimensions must be lower than the original ones.
New image size (px): Size in pixels of the particle images <x> <y=x> <z=x>.
Resize factor: New size is the old one x resize factor.
Pyramid level: Use positive value to expand and negative to reduce.
Huge file: If the file is huge, very likely you may have problems doing the antialiasing filter (because there is no memory for the input and its Fourier tranform). This option removes the antialiasing filter (meaning you will get aliased results), and performs a bilinear interpolation (to avoid having to produce the B-spline coefficients).
Apply a window operation?: If you set to *Yes*, you should provide a window option.
Window operation: Select how to change the size of the particles.
_cls.RESIZE_: provide the new size (in pixels) for your particles.
_crop_: choose how many pixels to crop from each border.

Crop size (px): Amount of pixels cropped from each border.
e.g: if you set 10 pixels, the dimensions of the
object (SetOfParticles, Volume or SetOfVolumes) will be
reduced in 20 pixels (2 borders * 10 pixels)
Window size (px): Size in pixels of the output object. It will be expanded or cutted in all directions such that the origin remains the same.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "deep center" can be found at the xmipp3 plugin.
Its help description is:
 Predict the center particles using deep learning..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Input Image set: The set of particles to predict
Train models: Choose if you want to train a model using a centered set of particles
Number of models: The maximum number of model available in xmipp is 5.
Input train set: The set of particles to train the models
Number of epochs: Number of epochs for training.
Batch size for training: Batch size for training.
Learning rate: Learning rate for training.
Image shifting: A measure of the number of pixels that particles can be shifted in each direction from the center.
Patience: Training will be stopped if the number of epochs without improvement is greater than patience.
Tolerance in pixels: Max difference between predictions and their mean value.
Maximum number of models dropped per particle: If more models are dropped, the particle is discarded.

The protocol named "deep denoising" can be found at the xmipp3 plugin.
Its help description is:
 None.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. In case to use several GPUs separate with comas:0,1,2
Train or predict model: *Train*: Train the model using noisy particles or their projections in an initial volume*Predict*: The particles are denoised with a pretrained model
Continue training? (or train from scratch): Setting "yes" you can continue training from pretrained model  or your previous executions. If you choose"no" the model will be trained from scratch. yes option is experimental
Use your own model (or use pretrained): Setting "yes" you can choose your own model trained. If you choose"no" a general model pretrained will be assign
Set your model: Choose the protocol where your model is trained
Select model type: If you set to *GAN*, GAN will be employed employed. If you set to *U-Net* U-Net will be used instead
Input projections to train (mandatory)/compare (optional): use the protocol generate reprojections to generate the projections. If compare reprojections protocol output is used as "Input noisy particles", this field is ignored
Input noisy particles to denoise: Input noisy particles from the protocol generate reprojections if you are training or from any other protocol if you are predicting. If compare reprojections protocol output is used as "Input noisy particles", "Input projections to train" is ignored
Input "empty" particles (optional): Input "empty" particles to learn how to deal with pure noise
Scale images to (px): Scale particles to desired size to improve trainingThe recommended particle size is 128 px. The size must be even.Do not use loss=perceptualLoss or loss=Both if  96< size <150.
Number of epochs: Number of epochs for neural network training. GAN requires much more epochs (>100) to obtain succesfull results
Learning rate: Learning rate for neural network training
Model depth: Indicate the model depth. For 128-64 px images, 4 is the recommend value.  larger images may require bigger models
Regularization strength: Indicate the regularization strength. Make it bigger if sufferening overfitting and smaller if suffering underfitting
Select how to generate training set: *ParticlesAndSyntheticNoise*: Train using particles and synthetic noise
or
*OnlyParticles*: using only particles
or
*Both*: Train using both strategies
Select loss for training: *MSE*: Train using mean squered error or
*PerceptualLoss*: Train using DeepConsensus perceptual loss
 or
*Both*: Train using both DeepConsensus perceptual loss and mean squered error

D/G trainig ratio: Indicate the number of times the discriminator is trained for each generator training step. If discriminator loss is going to 0, make it smaller, whereas if the discriminator is not training, make it bigger
D/G loss ratio: Indicate the 10^lossRatio times that the generator loss is stronger than  the discriminator loss. If discriminator loss is going to 0, make it smaller, whereas if the generator is not training, make it bigger
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "deep global assignment" can be found at the xmipp3 plugin.
Its help description is:
 Predict Euler Angles using deep learning..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Input Image set: The set of particles to predict
Train models: Choose if you want to train a model using a centered set of particles
Number of models: The maximum number of model available in xmipp is 5.
Input train set: The set of particles to train the models
Number of epochs: Number of epochs for training.
Batch size for training: Batch size for training.
Learning rate: Learning rate for training.
Image shifting: A measure of the number of pixels that particles can be shifted in each direction from the center.
Patience: Training will be stopped if the number of epochs without improvement is greater than patience.
Tolerance in pixels: Max difference between predictions and their mean value.
Maximum number of models dropped per particle: If more models are dropped, the particle is discarded.
Order of symmetry: Order of the group of the molecule.

The protocol named "deep hand" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to returns handedness of structure from trained deep learning model
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: Volume to process
Mask Threshold: Threshold for mask creation
Alpha Threshold: Threshold for alpha helix determination
Hand Threshold: Hand threshold to flip volume

The protocol named "deep micrograph cleaner" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to remove coordinates in carbon zones or large impurities.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the SetOfCoordinates 
Micrographs source: By default, the micrographs from which the computation will be performed will be the ones used in the picking step ( _same as coordinates_ option ). 
If you select other option, you must provide a different set of micrographs to evaluate its regions. 
*Note*: In the _other_ case, ensure that provided micrographs and coordinates are related by micName or by micId. Difference in pixel size will be handled automatically.
*Note2*: *Particles must be dark* over a bright background. If not, use the _other_ option to provide an inverted setOfMicrograph.
Input micrographs: Select the SetOfMicrographs from which to extract.
Coordinates scale: If you select _same as coordinates_ option output coordinates will be mapped to the original micrographs and thus, they will preserve the scale.
If you select _scale to micrographs_ option, output coordinates will be mapped to the new micrographs and rescaled accordingly.
Threshold: Deep learning goodness score to select/discard coordinates. The bigger the threshold the more coordiantes will be ruled out. Ranges from 0 to 1. Use -1 to skip thresholding. Manual thresholding can be performed after execution through analyze results button. 
0.75 <= Recommended threshold <= 0.9
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*0*    Put in the same step all the items  available.
 *>1*   The number of items that will be grouped into a step. -1, automatic decission
saveMasks: Save predicted masks?
: This protocol has both CPU and GPU implementation. Select the one you want to use. CPU may become quite slow.
: Add a list of GPU devices that can be used.

The protocol named "local deepRes" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a map the protocol assigns local resolutions to each voxel of the map.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Input Volume: Select a volume for determining its local resolution.
Mask: Binary mask. The mask determines which points are specimen and which are not
Expected resolutions range: The program uses a trained network to determine resolutions between 2.5Å-13.0Å  or resolutions between 1.5Å-6.0Å

The protocol named "deepEMhancer" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a map the protocol performs automatic deep post-processing to enhance visualization. Usage guide at
    https://github.com/rsanchezgarc/deepEMhancer
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. Select the GPU ID in which the protocol will run (select only 1 GPU)
Would you like to use half maps?: DeepEMhancer uses either half maps or non-sharpened non-masked input volumes. Please, select the type of input map(s) you will provide
Are the half maps included in the volume?: When you import a map, you can associate half maps to it. Select *yes* if the half maps are associatedto the input volume. If half maps are not associated, select *No* andyou will be able to provide then as regular maps
Volume Half 1: Select half map 1 to apply deep postprocessing. 
Volume Half 2: Select half map 2 to apply deep postprocessing. 
Input Volume: Select a volume to apply deep postprocessing. Unmasked, non-sharpened input required
Input normalization: Input normalization is critical for the algorithm to work.
If you select *Automatic normalization* input will beautomatically normalized (generally works but may fail).
If you select *Normalization from statistics* input will benormalized according the statistics of the noise of the volume and thus, you will need to providethe mean and standard deviation of the noise. Additionally, a binary mask (1 protein, 0 not protein) for the protein can be used for normalization if you select *Normalization from binary mask* . The mask should be as tight as possible.
nBad results may be obtained if normalization does not work, so you may want to try different options if not good enough results are observerd
binary mask: The mask determines which voxels are protein (1) and which are not (0)
noise mean: The mean of the noise used to normalize the input
noise standard deviation: The standard deviation of the noise used to normalize the input
Model power: Select the deep learning model to use.
If you select *tight target* the postprocessing will be more sharpen, but some regions of the protein could be masked out.
If you select *wide target* input will be less sharpen but most of the regions of the protein will be preserved
Option *highRes*,  is recommended for high resolution volumes
Remove small CC after processing: If you set to *Yes*, a post-processing step will be launched to remove small connected componentsthat are likely noise. This step may remove protein in some unlikely situations, but generally, itslighly improves results
Relative size (0. to 1.) CC to remove: The relative size of a small connected component to be removed, as the fraction of total voxels>0 
Batch size: Number of cubes to process simultaneously. Make it lower if CUDA Out Of Memory error happens and increase it if low GPU performance observed

The protocol named "denoise particles" can be found at the xmipp3 plugin.
Its help description is:
  Remove particles noise by filtering them. 
    This filtering process is based on a projection over a basis created
    from some averages (extracted from classes). This filtering is not 
    intended for processing particles. The huge filtering they will be 
    passed through is known to remove part of the signal with the noise. 
    However this is a good method for clearly see which particle are we 
    going to process before it's done.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: Input images you want to filter. It is important that the images have alignment information with respect to the chosen set of classes. This is the standard situation after CL2D or ML2D.
Input Classes: Select the input classes for the basis construction against images will be projected to.
Max. number of classes: Maximum number of classes.
Number of PCA bases: Number of PCA bases.
Number of PCA bases on which to project: Number of PCA bases on which to project.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "eliminate empty classes" can be found at the xmipp3 plugin.
Its help description is:
  Takes a set of classes (or averages) and using statistical methods
    (variances of sub-parts of input image) eliminates those samples,
    where there is no object/particle (only noise is presented there).
    Threshold parameter can be used for fine-tuning the algorithm for
    type of data. Also discards classes with less population than a given
    percentage.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input classes: Select the input averages to be classified.
Threshold used in elimination: Higher threshold => more particles will be eliminated. Set to -1 for no elimination, even so the "xmipp_scoreEmptiness" value will be attached to every paricle for a posterior inspection.
Use class population: Consider class population to reject a class.
Min. population (%): Minimum population to accept a class.
Classes with less population than the mean population times this value will be rejected.
Add features: Add features used for the ranking to each one of the input particles.
Turning on denoising: Option for turning on denoising method while computing emptiness feature.
Denoising factor:: Factor to be used during Gaussian blurring. Higher value applies stronger denoising, could be more precise but also slower.

The protocol named "eliminate empty particles" can be found at the xmipp3 plugin.
Its help description is:
  Takes a set of particles and using statistical methods
    (variance of variances of sub-parts of input image) eliminates those samples,
    where there is no object/particle (only noise is presented there).
    Threshold parameter can be used for fine-tuning the algorithm for type of data.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input particles to be classified.
Threshold used in elimination:: Higher threshold => more particles will be eliminated. Set to -1 for no elimination, even so the "xmipp_scoreEmptiness" value will be attached to every paricle for a posterior inspection.
Add features: Add features used for the ranking to each one of the input particles.
Turning on denoising: Option for turning on denoising method while computing emptiness feature.
Denoising factor:: Factor to be used during Gaussian blurring. Higher value applies stronger denoising, could be more precise but also slower.

The protocol named "enrich" can be found at the xmipp3 plugin.
Its help description is:
     
    Method to get two volume from different classes (with different conformation)
    and correcting (deforming) all images of one of the volumes (input volume) 
    with respect to the another one as a reference, using optical flow algorithm.
    The output is a setOfParticles contaied deformed reference particles.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
do Gold Standard?: If YES provide half1 and half2 maps for referenceand for input volumes.
Reference volume: This is the volume that will be used as the reference in OF algorithm. If you want to use Gold-Standard provide here half1 map
Reference volume half1: This is the half1 volume that will be used as the reference for half1 in OF algorithm.
Reference volume half2: This is half2 volume that will be used as the reference for half2 in OF algorithm.
Input volume: Volume that we want to process its related particles.
Input volume half1: Volume that we want to process its related particles. It should represent half1 map.
Input volume half2: Volume that we want to process its related particles. It should represent half2 map.
Input particles: Aligned particles related to the input volume. These particles will be processed (deformed) based on the reference volume using OF algorithm.If selected doGoldStandard True the particles have to have  information about the halfId they belong.
Reference and input volumes need to be aligned?: Input and reference volumes must be aligned. If you have not aligned them before choose this option, so protocol will handle it internally.
Use Fast Rotational Matching.: Use Fast Rotational Matching. Before use it you have to install it by scipion install frmThis method for volume alignment is much more fast than exhaustive search
Resolution Limit (A): Resolution limit used to low pass filter both input and reference map(s).Based on previous experimental results, a good value for  seems to be 20A 
Window size: Size of the search window at each pyramid level (shifts are assumed to be constant within this window).
pyramid Scale: Parameter, specifying the image scale (<1) to build pyramids for each image. pyrScale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous one.
Number of Levels: Number of pyramid layers including the initial image; levels=1 means that no extra layers are created and only the original images are used.
Iterations: Number of iterations the algorithm does at each pyramid level.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "extract movie particles" can be found at the xmipp3 plugin.
Its help description is:
  Extract a set of Particles from each frame of a set of Movies.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
Input coordinates: None
Particle box size (px): In pixels. The box size is the size of the boxed particles, actual particles may be smaller than this.
Apply movie alignments to extract?: If the input movies contains frames alignment, you decide whether to use that information for extracting the particles taking into account the shifts between frames.
First: None
Last: None
Fill pixels outside borders: Xmipp by default create blank particles whose boxes fall outside of the micrograph borders. Set this option to True if you want those pixels outside the borders to be filled with the closest pixel value available
Dust removal (Recommended): Sets pixels with unusually large values to random values from a Gaussian with zero-mean and unity-standard deviation.
Threshold for dust removal: Pixels with a signal higher or lower than this value times the standard deviation of the image will be affected. For cryo, 3.5 is a good value. For high-contrast negative stain, the signal itself may be affected so that a higher value may be preferable.
Invert contrast: Invert the contrast if your particles are black over a white background.
Normalize (Recommended): It subtract a ramp in the gray values and normalizes so that in the  background there is 0 mean and standard deviation 1.
Normalization type: OldXmipp (mean(Image)=0, stddev(Image)=1). 
NewXmipp (mean(background)=0, stddev(background)=1)
Ramp (subtract background+NewXmipp).
Background radius (px): Pixels outside this circle are assumed to be noise and their stddev is set to 1. Radius for background circle definition (in pix.). If this value is 0, then half the box size is used.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "extract particles" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to extract particles from a set of coordinates.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the SetOfCoordinates 
Micrographs source: By default the particles will be extracted from the micrographs used in the picking step ( _same as picking_ option ). 
If you select _other_ option, you must provide a different set of micrographs to extract from. 
*Note*: In the _other_ case, ensure that provided micrographs and coordinates are related by micName or by micId. Difference in pixel size will be handled automatically.
Input micrographs: Select the SetOfMicrographs from which to extract.
CTF estimation: Choose some CTF estimation related to input micrographs. 
 CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
Downsampling factor: Select a value greater than 1.0 to reduce the size of micrographs before extracting the particles. If 1.0 is used, no downsample is applied. Non-integer downsample factors are possible. 
Particle box size (px): This is size of the boxed particles (in pixels). Note that if you use downsample option, the particles are boxed out after downsampling. Use the wizard to check boxSize changes after downsampling or using a different pixel size. 
Fill pixels outside borders: Xmipp by default skips particles whose boxes fall outside of the micrograph borders. Set this option to True if you want those pixels outside the borders to be filled with the closest pixel value available
Dust removal (Recommended): Sets pixels with unusually large values to random values from a Gaussian with zero-mean and unity-standard deviation.
Threshold for dust removal: Pixels with a signal higher or lower than this value times the standard deviation of the image will be affected. For cryo, 3.5 is a good value. For high-contrast negative stain, the signal itself may be affected so that a higher value may be preferable.
Invert contrast: Invert the contrast if your particles are black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background. Frealign (up to v9.07) requires black particles over a white background
Phase flipping: Use the information from the CTF to compensate for phase reversals.
Phase flip is recommended in Xmipp or Eman
(even Wiener filtering and bandpass filter are recommended for obtaining better 2D classes)
Otherwise (Frealign, Relion, Spider, ...), phase flip is not recommended.
Normalize (Recommended): It subtract a ramp in the gray values and normalizes so that in the background there is 0 mean and standard deviation 1.
Normalization type: OldXmipp (mean(Image)=0, stddev(Image)=1). 
NewXmipp (mean(background)=0, stddev(background)=1) 
  Ramp (subtract background+NewXmipp).
Background radius (px): Pixels outside this circle are assumed to be noise and their stddev is set to 1. Radius for background circle definition (in pix.). If this value is 0, then half the box size is used.
Patch size for the variance filter (px): Windows size to make the variance filtter and compute the Gini coeff. A twice of the particle size is recommended. Set at -1 applies 1.5*BoxSize.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "extract particle pairs" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to extract particles from a set of tilted pairs coordinates.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates tilted pairs: Select the CoordinatesTiltPairs
Micrographs source: By default the particles will be extracted from the micrographs used in the picking step ( _same as picking_ option ).
If you select _other_ option, you must provide a different set of micrographs to extract from.
*Note*: In the _other_ case, ensure that provided micrographs and coordinates are related by micName or by micId. Difference in pixel size will be handled automatically.
Input tilt pair micrographs: Select the tilt pair micrographs from which to extract.
CTF estimation (untilted mics): Choose some CTF estimation related to input UNTILTED micrographs. 
 CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
CTF estimation (tilted mics): Choose some CTF estimation related to input TILTED micrographs. 
 CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
Downsampling factor: Select a value greater than 1.0 to reduce the size of micrographs before extracting the particles. If 1.0 is used, no downsample is applied. Non-integer downsample factors are possible. 
Particle box size: In pixels. The box size is the size of the boxed particles, actual particles may be smaller than this. If you do downsampling after extraction, provide final box size here.
Fill pixels outside borders: Xmipp by default skips particles whose boxes fall outside of the micrograph borders. Set this option to True if you want those pixels outside the borders to be filled with the closest pixel value available
Dust removal (Recommended): Sets pixels with unusually large values to random values from a Gaussian with zero-mean and unity-standard deviation.
Threshold for dust removal: Pixels with a signal higher or lower than this value times the standard deviation of the image will be affected. For cryo, 3.5 is a good value. For high-contrast negative stain, the signal itself may be affected so that a higher value may be preferable.
Invert contrast: Invert the contrast if your particles are black over a white background. Xmipp, Spider, Relion and Eman require white particles over a black background, Frealign (up to v9.07) requires black particles over a white background
Phase flipping: Use the information from the CTF to compensate for phase reversals.
Phase flip is recommended in Xmipp or Eman
(even Wiener filtering and bandpass filter are recommended for obtaining better 2D classes)
Otherwise (Frealign, Relion, Spider, ...), phase flip is not recommended.
Normalize (Recommended): It subtract a ramp in the gray values and normalizes so that in the background there is 0 mean and standard deviation 1.
Normalization type: OldXmipp (mean(Image)=0, stddev(Image)=1).
NewXmipp (mean(background)=0, stddev(background)=1)
Ramp (subtract background+NewXmipp).
Background radius: Pixels outside this circle are assumed to be noise and their stddev is set to 1. Radius for background circle definition (in pix.). If this value is 0, then half the box size is used.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "extract asymmetric unit" can be found at the xmipp3 plugin.
Its help description is:
  generates files for volumes and FSCs to submit structures to EMDB
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: This volume will be cropped
Symmetry: See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format in Xmipp.
If no symmetry is present, use _c1_.
Symmetry Order: Order of cyclic symmetry.
offset: rotate unit cell around z-axis by offset degrees
Inner Radius (px): inner Mask radius, if -1, the radius will be 0
Outer Radius (px): outer Mask radius, if -1, the radius will be volume_size/2
Expand Factor: Increment cropped region by this factor

The protocol named "resolution fso" can be found at the xmipp3 plugin.
Its help description is:
     
    Given two half maps the protocol estimates Fourier Shell Occupancy to determine the global anisotropy of the map.
    See more information here: https://github.com/I2PC/xmipp/wiki/FSO---Fourier-Shell-Occupancy
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Are the half volumes stored with the input volume?: Usually, the half volumes are stored as properties of the input volume. If this is not the case, set this to False and specify the two halves you want to use.
Input Half Maps: Select a half maps for determining its  resolution anisotropy and resolution.
Half Map 1: Select one map for determining the directional FSC resolution.
Half Map 2: Select the second map for determining the directional FSC resolution.
Mask: The mask determines which points are specimen and which are not
Cone Angle: Angle between the axis of the cone and the generatrix. An angle of 17 degrees is the best angle (see Nat MethodsJL Vilas 2023) to measuare the directional FSCs
Estimate 3DFSC : Set to estimate the 3DFSCD map. This is a 3D function that depends of the resolution.The profile of the 3DFSC along a given direction is the directiontal FSC
FSC Threshold: Threshold for the fsc. By default the standard 0.143. Other common thresholds are 0.5 and 0.3.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "filter particles" can be found at the xmipp3 plugin.
Its help description is:
  Apply Fourier filters to a set of particles  .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Filter space: None
Filter mode: Depending on the filter mode some frequency (freq.) components
are kept and some are removed.
 _low pass_: components below *High freq.* are preserved.
 _high pass_: components above *Low freq.* are preserved.
 _band pass_: components between *Low freq.* and *High freq.* are preserved. 
ctf: apply first CTF in CTFset to all the particles. This is normally for simulated data.
   : This is not a CTF correction.
Filter mode: median: replace each pixel with the median of neighboring pixels.

Filter mode: DAUB4: filter using the DAUB4 wavelet transform.
 
Provide resolution in Angstroms?: If *Yes*, the resolution values for the filter
should be provided in Angstroms. If *No*, the
values should be in normalized frequencies (between 0 and 0.5).
Lowest: None
Highest: None
Decay length: Amplitude decay in a [[https://en.wikipedia.org/wiki/Raised-cosine_filter][raised cosine]]
Lowest: None
Highest: None
Frequency decay: Amplitude decay in a [[https://en.wikipedia.org/wiki/Raised-cosine_filter][raised cosine]]
CTF Object: Object with CTF information if empty it will take the CTF information related with the first particle.
Note that this is normally used with simulated data.
mode: filter mode to be applied in wavelet space
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "filter volumes" can be found at the xmipp3 plugin.
Its help description is:
  Apply Fourier filters to a set of volumes .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: Can be a density volume or a SetOfVolumes.
Filter space: None
Filter mode: Depending on the filter mode some frequency (freq.) components
are kept and some are removed.
 _low pass_: components below *High freq.* are preserved.
 _high pass_: components above *Low freq.* are preserved.
 _band pass_: components between *Low freq.* and *High freq.* are preserved. 
ctf: apply first CTF in CTFset to all the particles. This is normally for simulated data.
   : This is not a CTF correction.
Filter mode: median: replace each pixel with the median of neighboring pixels.

Filter mode: DAUB4: filter using the DAUB4 wavelet transform.
 
Provide resolution in Angstroms?: If *Yes*, the resolution values for the filter
should be provided in Angstroms. If *No*, the
values should be in normalized frequencies (between 0 and 0.5).
Lowest: None
Highest: None
Decay length: Amplitude decay in a [[https://en.wikipedia.org/wiki/Raised-cosine_filter][raised cosine]]
Lowest: None
Highest: None
Frequency decay: Amplitude decay in a [[https://en.wikipedia.org/wiki/Raised-cosine_filter][raised cosine]]
CTF Object: Object with CTF information if empty it will take the CTF information related with the first particle.
Note that this is normally used with simulated data.
mode: filter mode to be applied in wavelet space
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "FlexAlign" can be found at the xmipp3 plugin.
Its help description is:
 
    Wrapper protocol to Xmipp Movie Alignment by cross-correlation
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
from: None
to: None
Use ALIGN frames range to SUM?: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Save aligned micrograph: None
Save movie: Save Aligned movie
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Maximum resolution (A): Maximum resolution in A that will be preserved during correlation.
Compute PSD?: If Yes, the protocol will compute PSD for each movie before and after the alignment
Maximum shift (A): Maximum allowed distance (in A) that each frame can be shifted with respect to the next.
Compute local alignment?: If Yes, the protocol will try to determine local shifts, similarly to MotionCor2.
Auto control points: If on, protocol will automatically determine necessary number of control points.
X: None
Y: None
t: None
Auto patches: If on, protocol will automatically determine necessary number of patches.
X: None
Y: None
Min size of the patch (A): How many A should contain each patch?
Group N frames: Group every specified number of frames by adding them together.                         The alignment is then performed on the summed frames.
Rotate gain reference:: Rotate gain reference counter-clockwise.
Flip gain reference:: Flip gain reference after rotation. For tiff movies, gain is automatically upside-down flipped
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "generate reprojections" can be found at the xmipp3 plugin.
Its help description is:
 Compares a set of classes or averages with the corresponding projections of a reference volume.
    The set of images must have a 3D angular assignment and the protocol computes the residues
    (the difference between the experimental images and the reprojections). The zscore of the mean
    and variance of the residues are computed. Large values of these scores may indicate outliers.
    The protocol also analyze the covariance matrix of the residual and computes the logarithm of
    its determinant [Cherian2013]. The extremes of this score (called zScoreResCov), that is
    values particularly low or high, may indicate outliers..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input images: None
Volume to compare images to: Volume to be used for class comparison
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "gl2d" can be found at the xmipp3 plugin.
Its help description is:
  2D alignment using Xmipp GPU Correlation algorithm. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
: Add a list of GPU devices that can be used
Use a Set of Reference Images ?: If you set to *Yes*, you should provide a set of reference images.
If *No*, the default generation is done by averaging subsets of the input images.
Reference images: Set of images that will serve as class reference
Number of classes:: Number of classes (or references) to be generated
Maximum shift (%):: Maximum shift allowed during the alignment as percentage of the input set size
Number of best images:: Number of classes to assign every input image during the alignment
Number of iterations in split stage:: Maximum number of iterations in split stage
Number of iterations in classify stage:: Maximum number of iterations when the  classification of the whole image set is carried out
Allow attraction ?: If you set to *Yes*, you allow to generate classes with low number of images associated.
If *No*, all the generated classes will be balanced
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "helical symmetry" can be found at the xmipp3 plugin.
Its help description is:
  Estimate helical parameters and symmetrize.
    
    Helical symmetry is defined as V(r,rot,z)=V(r,rot+k*DeltaRot,z+k*Deltaz).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: None
Cylinder inner radius: The helix is supposed to occupy this radius in voxels around the Z axis. Leave it as -1 for symmetrizing the whole volume
Cylinder outer radius: The helix is supposed to occupy this radius in voxels around the Z axis. Leave it as -1 for symmetrizing the whole volume
Apply dihedral symmetry: None
Force the dihedral axis to be in X: If this option is chosen, then the dihedral axis is not searched and it is assumed that it is around X.
Apply Cn symmetry: None
Cn symmetry: None
Height fraction: The helical parameters are only sought using the fraction indicated by this number. In this way, you can avoid including planes that are poorly resolved at the extremes of the volume. However, note that the algorithm can perfectly work with a fraction of 1.
Minimum rotational angle: In degrees
Maximum rotational angle: In degrees
Angular step: In degrees
Minimum shift Z: In Angstroms
Maximum shift Z: In Angstroms
Shift step: In Angstroms
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "operate particles" can be found at the xmipp3 plugin.
Its help description is:
  Apply an operation to two sets of particles  .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Operation: Binary operations: 
*plus*: Sums two images, volumes or adds a numerical value to an image. 
*minus*: Subtracts two images, volumes or subtracts a numerical value to an image. 
*multiply*: Multiplies two images, volumes, or multiplies per a given number. 
*divide*: Divides two images, volumes, or divides per a given number. 
*minimum*: Minimum of two images, volumes, or number (pixel-wise). 
*maximum*: Maximum of two images, volumes, or number (pixel-wise). 
*dot product*: Dot product between two images or volumes. 
Unary operations: 
*log*: Computes the natural logarithm of an image. 
*log10*: Computes the decimal logarithm of an image. 
*sqrt*: Computes the square root of an image 
*abs*: Computes the absolute value of an image. 
*pow*: Computes the power of an image. 
*slice*: Extracts a given slice from a volume (first slice=0). 
*column*: Extracts a given column from a image or volume. 
*row*: Extracts a given row from a image or volume. 
*radial average*: Compute the radial average of an image. 
*reset*: Set the image to 0
Second operand is a value?: Set to true if you want to use a value of the second operand
Input Particles (2nd): Set a SetOfParticles. The particles must be the same dimensions as the input particles.
Input value : Set the desire float value
Input value : This value must be integer
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "operate volumes" can be found at the xmipp3 plugin.
Its help description is:
  Apply an operation to two sets of volumes .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: Can be a density volume or a SetOfVolumes.
Operation: Binary operations: 
*plus*: Sums two images, volumes or adds a numerical value to an image. 
*minus*: Subtracts two images, volumes or subtracts a numerical value to an image. 
*multiply*: Multiplies two images, volumes, or multiplies per a given number. 
*divide*: Divides two images, volumes, or divides per a given number. 
*minimum*: Minimum of two images, volumes, or number (pixel-wise). 
*maximum*: Maximum of two images, volumes, or number (pixel-wise). 
*dot product*: Dot product between two images or volumes. 
Unary operations: 
*log*: Computes the natural logarithm of an image. 
*log10*: Computes the decimal logarithm of an image. 
*sqrt*: Computes the square root of an image 
*abs*: Computes the absolute value of an image. 
*pow*: Computes the power of an image. 
*slice*: Extracts a given slice from a volume (first slice=0). 
*column*: Extracts a given column from a image or volume. 
*row*: Extracts a given row from a image or volume. 
*radial average*: Compute the radial average of an image. 
*reset*: Set the image to 0
Second operand is a value?: Set to true if you want to use a value of the second operand
Input Volumes (2nd): This parameter depends of the input volume(s). If it is set a volume (or a SetOfVolumes) as input, this must be a *Volume* (or *SetOfVolumes*) object.
Input value : Set the desire float value
Input value : This value must be integer
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "kerdensom" can be found at the xmipp3 plugin.
Its help description is:
 
    Classifies a set of images using  Kohonen's Self-Organizing Feature Maps (SOM) 
    and Fuzzy c-means clustering technique (FCM) .
    
    The kerdenSOM algorithm anneals from an initial high regularization factor
    to a final lower one, in a user-defined number of steps.
    
    KerdenSOM is an excellent tool for classification, especially when
    using a large number of data and classes and when the transition between
    the classes is almost continuous, with no clear separation between them.
    
    The input images must be previously aligned.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input images: Select the input images from the project.It should be a SetOfParticles class
Use a Mask ?: If you set to *Yes*, you should provide a mask
Mask: Mask image will serve to enhance the classification
X: None
Y: None
Initial regularization factor: The kerdenSOM algorithm anneals from an initial high regularization factorto a final lower one, in a user-defined number of steps.If the output map is too smooth, lower the regularization factorsIf the output map is not organized, higher the regularization factorsSee [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/KerDenSOM][KerDenSOM]]
Final regularization factor:: None
Regularization steps:: Number of steps to lower the regularization factor
Additional parameters:: Additional parameters for kerdensom program. 
 For a complete descriptionSee [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/KerDenSOM][KerDenSOM]]

The protocol named "localdeblur sharpening" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a resolution map the protocol calculate the sharpened map.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Map: Select a volume for sharpening.
Resolution Map: Select a local resolution map. LocalDeblur has been specially designed to work with resolution maps obtained with MonoRes, however resolution map from ResMap and BlocRes are also accepted.
lambda: Regularization Param.The method determines this parameter automatically. This parameter is directly related to the convergence. Increasing it would accelerate the convergence, however it presents the risk of falling into local minima.
K: K = 0.025 works well for all tested cases. K should be in the 0.01-0.05 range. For maps with FSC resolution lower than 6Å, K = 0.01 can be a good alternative.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "estimate local defocus" can be found at the xmipp3 plugin.
Its help description is:
 Compares a set of particles with the corresponding projections of a reference volume.
    The set of particles must have a 3D angular assignment.
    This protocol refines the CTF, computing local defocus change.
    The maximun allowed defocus is a parameter introduced by the user (advanced).
    The protocol gives back the input set of particles with the refine local defocus and the defocus change with relation to the global defocus..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input images: None
Volume to compare images to: Volume to be used for class comparison
Maximum defocus change (A): None
Maximum gray scale change: The reprojection is modified as a*P+b, a is restricted to the interval [1-maxGrayScale,1+maxGrayScale]
Maximum gray shift change: The reprojection is modified as a*P+b, b is restricted to the interval [-maxGrayShift,maxGrayShift]
Force defocusV to be equal than defocusU: As the CTF usually suffers from astigmatism (it is not spherical but ellipsoidal), the defocus vary if computed in X or Y direction, being defocus U value the defocus in X direction and defocus V value the defocus in Y direction.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "volume local adjustment" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to adjust locally volume intensity to a reference volume. Occupancy volume is saved in protocol folder. Based on 
    https://www.sciencedirect.com/science/article/pii/S1047847723000874?via%3Dihub.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Reference volume: Specify a volume to be used as reference volume.
Input volume: Specify a volume which will be adjusted to the reference volume.
Mask for reference volume: Specify a mask to define region of interest (which is signal in white (1s) and background in black (0s))
Neighborhood (A): Side length (in Angstroms) of a square which will define the region of adjustment
Perform subtraction?: Perform subtraction of reference volume minus input volume in real space

The protocol named "ml2d" can be found at the xmipp3 plugin.
Its help description is:
 
    Perform (multi-reference) 2D-alignment using 
    a maximum-likelihood ( *ML* ) target function.
    
    Initial references can be generated from random subsets of the experimental
    images or can be provided by the user (this can introduce bias). The output
    of the protocol consists of the refined 2D classes (weighted averages over 
    all experimental images). The experimental images are not altered at all.    
    
    Although the calculations can be rather time-consuming (especially for 
    many, large experimental images and a large number of references we 
    strongly recommend to let the calculations converge. 
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input images from the project.
Generate classes?: If you set to *No*, you should provide class images. If *Yes*, the default generation is done by averaging subsets of the input images (less bias introduced).
Number of classes:: Number of classes to be generated.
Class image(s): Image(s) that will serve as initial 2D classes
Use MLF2D instead of ML2D?: None
Use CTF-amplitude correction?: If set to *Yes*, the input images file should contains.
 If set to *No*, provide the images pixel size in Angstrom.
Are the images CTF phase flipped?: You can run MLF with or without having phase flipped the images.
High-resolution limit (Ang): No frequencies higher than this limit will be taken into account.
If zero is given, no limit is imposed.
Also include mirror in the alignment?: Including the mirror transformation is useful if your particleshave a handedness and may fall either face-up or face-down on the grid.
Use the fast version?: If set to *Yes*, a fast approach will be used to avoid
searching in the whole solutions space.             

For details see (and please cite): 
[[http://dx.doi.org/10.1093/bioinformatics/bti1140][Scheres et al., Bioinformatics, 2005]] 
Refine the normalization for each image?: This variant of the algorithm deals with normalization errors. 

For details see (and please cite): 
 [[http://dx.doi.org/10.1107/S0907444909012049][Scheres et al., Acta Crystallogr D Biol Crystallogr, 2009]] 
Maximum number of iterations: If the convergence has not been reached after this numberof iterations, the process will be stopped.
In-plane rotation sampling (degrees): In-plane rotation sampling interval (degrees).
Std for pixel noise: Expected standard deviation for pixel noise.
Std for origin offset: Expected standard deviation for origin offset (pixels).
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "apply 2d mask" can be found at the xmipp3 plugin.
Its help description is:
  Apply mask to a set of particles .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Mask source: Select which type of mask do you want to apply. 
 
Input mask: None
Mask type: None
Radius (px): Mask radius, if -1, the radius will be MaskSize/2
Box size: Mask box size, if -1, the box size will be MaskSize/2
Inner radius (px): Inner radius in pixels
Outer radius (px): Outer radius in pixels, if -1, the outer radius will be MaskSize/2
Sigma (px): Gaussian sigma in pixels. If -1, sigma will be MaskSize/6
Border decay (px): This is the fall-off of the two borders of the crown
Shift Center: Shift Mask Center to a new origin.
X center offset: New x center coordinate
Y center offset: New y center coordinate
Fill with : Select how are you going to fill the pixel values outside the mask. 
Fill value: Value to fill the pixel values outside the mask. 
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "apply 3d mask" can be found at the xmipp3 plugin.
Its help description is:
  Apply mask to a volume .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: Can be a density volume or a SetOfVolumes.
Mask source: Select which type of mask do you want to apply. 
 
Input mask: None
Mask type: None
Radius (px): Mask radius, if -1, the radius will be MaskSize/2
Shift center of the mask?: None
X: None
Y: None
Z: None
Box size: Mask box size, if -1, the box size will be MaskSize/2
Inner radius (px): Inner radius in pixels
Outer radius (px): Outer radius in pixels, if -1, the outer radius will be MaskSize/2
Height (px): Cylinder height in pixels. If -1, height will be MaskSize
Sigma (px): Gaussian sigma in pixels. If -1, sigma will be MaskSize/6
Border decay (px): This is the fall-off of the two borders of the crown
Fill with : Select how are you going to fill the pixel values outside the mask. 
Fill value: Value to fill the pixel values outside the mask. 
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "directional resolution MonoDir" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a map the protocol assigns local resolutions to each voxel of the map.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: Select a volume for determining its local resolution.
Binary Mask: The mask determines which points are specimen and which ones not
Significance: Relution is computed using hipothesis tests, this value determinesthe significance of that test
Resolution Step: The resolution will be sought in steps of this values, with step = 0.3, then 1A, 1.3A, 1.6A,...
Fast Computation: Fast computation is recommended for large volumes.
Is the original premasked?: Sometimes the original volume is masked inside a spherical mask. In this caseplease select yes
Spherical mask radius (px): When the original volume is originally premasked, the noise estimation oughtto be performed inside that premask, and out of the provieded mask asked in the previusbox. The radius value, determines the radius of the spherical premask. By defaultradius = -1 use the half of the volume size as radius
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "local MonoRes" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a map the protocol assigns local resolutions to each voxel of the map.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Would you like to use half volumes?: The noise estimation for determining the local resolution is performed via half volumes.
Are the half volumes stored with the input volume?: Usually, the half volumes are stored as properties of the input volume. If this is not the case, set this to False and specify the two halves you want to use.
Input Volume: Select a volume for determining its local resolution.
Input Half Maps: Select a volume for determining its local resolution.
Volume Half 1: Select the first half of a volume for determining its local resolution.
Volume Half 2: Select the second half of a volume for determining a local resolution.
Binary Mask: The mask determines which points are specimen and which are not
Exclude Area: The mask determines the area of the protein to beexcluded in the estimation of the local resolution
Significance: Resolution is computed using hypothesis tests, this value determines the significance of that test
Mask threshold: If the provided mask is not binary. Then, MonoReswill try to binarize it. Mask values below the thresholdwill be change to 0 and above the thresthol will be 1
Use noise inside protein?: (Yes recommended) the noise distribution will be estimated in the protein region (inside the mask) by means of the difference of both half maps.
Consider noise gaussian?: It assumes the noise in the map as gaussian. Note that this assumption might not be true, despite ,it is  in general.
High: None
Low: None
Step: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "movie dose analysis" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for the dose analysis .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select one or several movies. A dose analysis be calculated for each one of them.
Maximum percentage difference (%): By default, a difference of 5% against the median dose is used to assume that the dose has an incorrect value.
Samples to estimate the median dose: By default, 20 movies are used to compute the global median.
Window step (movies): By default, every 50 movies (window=50) we compute the percentage of incorrect dose analysis to check if there is any anomally in the dose.
Windows maximum faulty percentage (%): By default, if 30% of the movies are discardedit assume that the dose has an incorrect value that endures in time.

The protocol named "movie gain" can be found at the xmipp3 plugin.
Its help description is:
  Estimate the gain image of a camera, directly analyzing one of its movies.
    It can correct the orientation of an external gain image (by comparing it with the estimated).
    Finally, it estimates the residual gain (the gain of the movie after correcting with a gain).
    The gain used in the correction will be preferably the external gain, but can also be the estimated
    gain if the first is not found.
    The same criteria is used for assigning the gain to the output movies (external corrected > external > estimated)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select several movies. A gain image will be calculated for each one of them.
Estimate movies gain: Estimate the gain from a set of movies using the algorith from xmipp
Estimate external gain orientation: Estimate the relative orientation between the estimated and the existing gain
Estimate residual gain: If there is a gain image associated with input movies, you can decide to use it instead of estimating raw/residual gain image. Location of this gain image needs to be indicated in import movies protocol.
Normalize existing gain: Normalize the input gain so that it has a mean of 1
Estimate the sigma parameter: Estimate the sigma parameter for the gain image computation
Frame step: By default, every 5th frame is used to compute the movie gain. If you set this parameter to 2, 3, ..., then only every 2nd, 3rd, ... frame will be used.
Movie step: By default, every 250 movies (movieStep=250) is used to compute the movie gain. If you set this parameter to 2, 3, ..., then every 2nd, 3rd, ... movie will be used.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "movie maxshift" can be found at the xmipp3 plugin.
Its help description is:
 
    Protocol to make an automatic rejection of those movies whose
    frames move more than a given threshold.
        Rejection criteria:
            - *by frame*: Rejects movies with drifts between frames
                              bigger than a certain maximum.
            - *by whole movie*: Rejects movies with a total travel
                                         bigger than a certain maximum.
            - *by frame and movie*: Rejects movies if both conditions
                                                above are met.
            - *by frame or movie*: Rejects movies if one of the conditions
                                             above are met.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously aligned Movies.
Rejection type: Rejection criteria:
 - *by frame*: Rejects movies with drifts between frames bigger than a certain maximum.
 - *by whole movie*: Rejects movies with a total travel bigger than a certain maximmum.
 - *by frame and movie*: Rejects movies if both conditions above are met.
 - *by frame or movie*: Rejects movies if one of the conditions above are met.
Max. frame shift (A): Maximum drift between consecutive frames to evaluate the frame condition.
Max. movie shift (A): Maximum total travel to evaluate the whole movie condition.

The protocol named "movie resize" can be found at the xmipp3 plugin.
Its help description is:
 
    Resize a set of movies. Only downsampling is allowed.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of movies to be resized.
Resize option: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Dimensions_: Set the output dimensions. 
_Factor_: Set a resize factor to resize. 
 
Resize sampling rate (A/px): Set the new output sampling rate.
New image size (px): Size in pixels of the particle images <x> <y=x> <z=x>.
Downsampling factor: New size is the old one x resize factor.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "multireference alignability" can be found at the xmipp3 plugin.
Its help description is:
     
    Performs soft alignment validation of a set of particles confronting them
    against a given 3DEM map. This protocol produces particle alignment
    precision and accuracy parameters.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input volume: Select the input volume(s).
Input particles: Select the input projection images.
Symmetry group: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
Angular Sampling (degrees): Angular distance (in degrees) between neighboring projection points 
Number of Orientations for particle: Parameter to define the number of most similar volume 
    projected images for each projection image
Do not use the weights: Do not use the weights in the clustering calculation
Pseudo symmetry group: Add only in case the map is close to a symmetry different and more restrict than the one reported in the parameter Symmetry group.See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
Minimum allowed tilt angle: Tilts below this value will not be considered for the alignment
Maximum allowed tilt angle without mirror check: Tilts above this value will not be considered for the alignment without mirror check
CTF correction: Perform CTF correction by Wiener filtering.
Isotropic Correction: If true, Consider that there is not astigmatism and then it is performed an isotropic correction.
Padding factor: Padding factor for Wiener correction 
Wiener constant:  Wiener-filter constant (if < 0: use FREALIGN default)
Correct for CTF envelope:  Only in cases where the envelope is well estimated correct for it
Target resolution (A): Low pass filter the particles to this resolution. This usually helps a lot obtaining good alignment. You should have a good reason to modify this value outside the range  [8-10] A
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "multiple fscs" can be found at the xmipp3 plugin.
Its help description is:
 
    Compute the FSCs between a reference volume and a set of input volumes.
    A mask can be provided and the volumes are aligned by default.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Reference volume: The rest of volumes will be compared to this one
Volumes to compare: Set of volumes to compare to the reference volume
Mask: A mask may be provided and it is applied before comparing the different volumes
Align volumes?: Align volumes to reference before comparing. A local alignment is performed so the initial orientation of the volumes should be relatively similar
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "normalize strain" can be found at the xmipp3 plugin.
Its help description is:
 
    Normalize the local strain and rotations amongst several runs
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
input strain calculations: Select the runs of strain calculations to be normalized

The protocol named "optical alignment" can be found at the xmipp3 plugin.
Its help description is:
 
    Wrapper protocol to Xmipp Movie Alignment by Optical Flow
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
from: None
to: None
Use ALIGN frames range to SUM?: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Save aligned micrograph: None
Save movie: Save Aligned movie
: Set to true if you want the GPU implementation of Optical Flow
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Window size: Window size (shifts are assumed to be constant within this window).
Group Size: The number of frames in each group at the last step
Use previous movie alignment to SUM frames?: Input movies could have alignment information froma previous protocol. If you select *Yes*, the previous alignment will be taken into account.
Compute PSD (before/after)?: If Yes, the protocol will compute for each movie the PSD of the average micrograph (without OF alignement) and after that, to compare each PSDs
Keep images in RAM ?: If True, the protocol will increase the demand of RAM, decreasing disc access
Apply Dose filter: Apply a dose-dependent filter to frames before summing them. Pre-exposure and dose per frame should  be specified during movies import.
Save unweighted micrographs?: Yes by default, if you have selected to apply a dose-dependent filter to the frames
Apply Dose filter before alignment?: if *True*, you apply dose filter before perform the alignment; else will apply after alignment.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "manual-picking (step 1)" can be found at the xmipp3 plugin.
Its help description is:
  Picks particles in a set of micrographs
    either manually or in a supervised mode.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
Save discarded particles: Generates an output with the manually discarded particles.
Run in interactive mode: If YES, you can pick particles in differents sessions.
If NO, once an outputCoordinates is created, the protocol finishes. 
(the last can be useful when other protocol waits until this finish -internal scheduled-)

The protocol named "tilt pairs particle picking" can be found at the xmipp3 plugin.
Its help description is:
  Picks particles in a set of untilted-tilted pairs of micrographs. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Micrographs tilt pair: Select the MicrographsTiltPair 

The protocol named "phantom volume" can be found at the xmipp3 plugin.
Its help description is:
  Create phantom volume from a feature description file using xmipp_phantom_create .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Create phantom: create a phantom description: x y z backgroundValue geometry(cyl, sph...) +(superimpose) desnsityValue origin radius height rot tilt psi. See more information in https://web.archive.org/web/20180813105422/http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/FileFormats#Phantom_metadata_file
Sampling rate: None

The protocol named "pick noise" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to pick noise particles.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Set of true particle coordinates. Noise coordinates are chosen so that they are sufficiently far from particles
Number of noise particles: Number of noise particles to extract from each micrograph. Set to -1 for extracting the same amount of noise particles as the number true particles for that micrograph
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "remove duplicates" can be found at the xmipp3 plugin.
Its help description is:
 
    This protocol removes coordinates that are closer than a given threshold.
    The remaining coordinate is the average of the previous ones.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the set of coordinates to compare
Radius: All coordinates within this radius (in pixels) are presumed to correspond to the same particle

The protocol named "preprocess micrographs" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to preprocess a set of micrographs in the project.
    You can crop borders, remove bad pixels, etc. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: Select the SetOfMicrograph to be preprocessed.
Operations are performed in the order shown below: None
Crop borders?: Crop a given amount of pixels from each border.
Pixels to crop: Amount of pixels you want to crop from borders.
Take logarithm?: Depending on your acquisition system you may need to take the logarithm of the pixel values in order to have a linear relationship betweenthe gray values in the image and those in the volume. a - b ln(x+c) by default 4.431-0.4018*LN((P1+336.6)) is applied (right one for nikon coolscan 9000)
a: None
b: None
c: None
Remove bad pixels?: Values will be thresholded to this multiple of standard deviations. Typical values are about 5, i.e., pixel values beyond 5 times the standard deviation will be substituted by the local median. Set this option to -1 for not applying it.
Multiple of Stddev: Multiple of standard deviation.
Invert contrast?: Multiply by -1
Downsample micrographs?: Downsample micrographs by a given factor.
Downsampling factor: Non-integer downsample factors are possible. Must be larger than 1.
Denoising: Apply a denoising method
Max. number of iterations: Max. number of iterations. Higher number = better output but slower calculation. Must be larger than 1.
Gaussian filter: Apply a Gaussian filter in real space
Gaussian sigma (px): The larger this value, the more the effect will be noticed
Highpass filter: Apply a highpass filter in real space
Cutoff frequency: In normalized frequencies (<0.5). For example, if you want to remove patterns larger than 500 pixels, use 1/500=0.002
Transition bandwidth: In normalized frequencies (<0.5). For example, if you want to remove patterns larger than 1000 pixels, use 1/1000=0.001
Lowpass filter: Apply a lowpass filter in real space
Cutoff frequency: In normalized frequencies (<0.5). For example, if you want to remove the crystalline ice at a frequency of 4A and the pixel size is 0.5A, then the cutoff should be 0.5/4=0.125
Transition bandwidth: In normalized frequencies (<0.5). The number of pixels in Fourier will be approximately lowRaised*Xdim
Normalize micrograph?: Normalize micrographs to be zero mean and standard deviation one
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "preprocess particles" can be found at the xmipp3 plugin.
Its help description is:
  Preprocess a set of particles. You can remove dust, normalize, 
        apply threshold, etc .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Dust removal: Sets pixels with unusually large values torandom values from a Gaussian with zero-mean and unity-standard deviation.
Threshold for dust removal: Pixels with a signal higher or lower thanthis value times the standard deviation of the imagewill be affected. For cryo, 3.5 is a good value.For high-contrast negative stain, the signal itselfmay be affected so that a higher value may be preferable.
Randomize phases: Randomize phases beyond a certain frequency.
Maximum Resolution: Angstroms.
Normalize: It subtract a ramp in the gray values and normalizesso that in the background there is 0 mean andstandard deviation 1.
Normalization type: OldXmipp: mean(Image)=0, stddev(Image)=1
NewXmipp: mean(background)=0, stddev(background)=1
Ramp: subtract background + NewXmipp
Background radius: Pixels outside this circle are assumed to be noise andtheir stddev is set to 1. Radius for backgroundcircle definition (in pix.).If this value is 0, then half the box size is used.
Center images: None
Phase flip images: None
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Invert contrast: Invert the contrast if your particles are black overa white background.
Threshold: Remove voxels below a certain value.
Fill with : Select how are you going to fill the pixel valuesoutside the mask.
Threshold value: Grey value below which all voxels should be set to 0.
Substitute by: If you select: value: Selected are substitute by a desired value.            binarize: Selected are set to 0, non-selected to 1.                 avg: Average of non-selected.
Fill value:  Substitute selected pixels by this value.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "preprocess volumes" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for Xmipp-based preprocess for volumes .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: Can be a density volume or a SetOfVolumes.
Change hand: Change hand by applying a mirror along X.
Change icosahedral orientation: Change from one icosahedral standard orientation to another.
from: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] for a description of the symmetry groups format.
to: None
Randomize phases: Randomize phases beyond a certain frequency.
Maximum Resolution: Angstroms.
Symmetrize: Symmetrize the input model.
Symmetry group: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] for a description of the symmetry groups format.If no symmetry is present, set the Symmetrize field to not.
Aggregation mode: Symmetrized volumes can be averaged or summed.
Wrap: by default, the image/volume is wrapped
Apply Laplacian: Laplacian denoising
Mask volume: None
Adjust gray values: Adjust input gray values so that it is compatiblewith a set of projections.
Set of particles: Set of images to which the model should conform.The set of images should have the final pixel sizeand the final size of the model.
Symmetry group: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]]for a description of the symmetry groups format.If no symmetry is present, give c1.
Segment: Separate the molecule from its background.
Segmentation Type: Type of segmentation.
Molecule Mass: In automatic segmentation, set it to -1.
Normalize background: Set background to have zero mean and standard deviation 1.
Mask Radius: In pixels. Set to -1 for half of the size of the volume.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Invert contrast: Invert the contrast if your particles are black overa white background.
Threshold: Remove voxels below a certain value.
Fill with : Select how are you going to fill the pixel valuesoutside the mask.
Threshold value: Grey value below which all voxels should be set to 0.
Substitute by: If you select: value: Selected are substitute by a desired value.            binarize: Selected are set to 0, non-selected to 1.                 avg: Average of non-selected.
Fill value:  Substitute selected pixels by this value.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "projection matching" can be found at the xmipp3 plugin.
Its help description is:
  3D reconstruction and classification using multireference projection matching.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                   Select the one you want to use.
: Add a list of GPU devices that can be used
Input particles: Select the input particles. 
 If you want perform *CTF* correction the input particles 
 should have information about the CTF (hasCTF=True)
Use initial angles/shifts ? : Set to *Yes* if you want to use the projection assignment (angles/shifts) 
 associated with the input particles (hasProjectionAssigment=True)
Initial 3D reference volume: Input 3D reference reconstruction.
Clean up intermediate files?: Save disc space by cleaning up intermediate files. 
 Be careful, many options of the visualization protocol will not work anymore, 
 since all class averages, selfiles etc will be deleted. 
Perform CTF correction?: If set to true, a CTF (amplitude and phase) corrected map will be refined, 
 and the data will be processed in CTF groups. 

 _NOTE_: You cannot combine CTF-correction with re-alignment of the classes. 
 Remember that CTF information should be provided in the images input file. 
 
Make CTF groups automatically?: Make CTF groups based on a maximum differences at a given resolution limit. 
 _NOTE_: If this option is set to false, a docfile with the defocus values where to  

 split the images in distinct defocus group has to be provided (see expert option below) 
 
Maximum difference for grouping: If the difference between the CTF-values up to the resolution limit specified 
 below is larger than the value given here, two images will be placed in 
 distinct CTF groups.
Resolution limit (A) for grouping: Maximum resolution where to consider CTF-differences among different groups. 
 One should use somewhat higher resolutions than those aimed for in the refinement.
Set of defocus: Set with defocus values where to split into groups. 
 This field is compulsory if you do not want to make the CTF groups automatically. 

 _NOTE_: The requested docfile can be made initially with the *xmipp_ctf_group* program, 
 and then it can be edited manually to suit your needs.
Padding factor: Application of CTFs to reference projections and of Wiener filter 
 to class averages will be done using padded images. 
 Use values larger than one to pad the images.
Wiener constant: Term that will be added to the denominator of the Wiener filter. 
 In theory, this value is the inverse of the signal-to-noise ratio 
 If a negative value is taken, the program will use a default value as in FREALIGN 
 (i.e. 10% of average sum terms over entire space)  
 see Grigorieff JSB 157 (2006) pp117-125
Mask reference volumes: Masking the reference volume will increase the signal to noise ratio. 
 Do not provide a very tight mask. 
 
Radius of spherical mask (px): This is the radius (in pixels) of the spherical mask 
Mask Object: The mask file should have the same dimensions as your input particles. 
 The protein region should be 1 and the solvent should be 0.
Number of iterations: Number of iterations to perform.
Inner radius for rotational correlation::  In pixels from the image center
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "8 8 2 2 " 
    specifies 4 iterations, the first two set the value to 8 
    and the last two to 2. An alternative compact notation 
    is ("2x8 2x0", i.e.,
    2 iterations with value 8, and 2 with value 2).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Outer radius for rotational correlation:  In pixels from the image center. Use a negative number to use the entire image.
    *WARNING*: this radius will be use for masking before computing resolution
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "8 8 2 2 " 
    specifies 4 iterations, the first two set the value to 8 
    and the last two to 2. An alternative compact notation 
    is ("2x8 2x0", i.e.,
    2 iterations with value 8, and 2 with value 2).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Available memory to store all references (Gb):  This is only for the storage of the references. If your projections do not fit in memory, 
    the projection matching program will run MUCH slower. But, keep in mind that probably 
    some additional memory is needed for the operating system etc.
    Note that the memory per computing node needs to be given. That is, when using threads, 
    this value will be multiplied automatically by the number of (shared-memory) threads.
    
Angular sampling rate (deg):  Angular distance (in degrees) between neighboring projection  points
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "8 8 2 2 " 
    specifies 4 iterations, the first two set the value to 8 
    and the last two to 2. An alternative compact notation 
    is ("2x8 2x0", i.e.,
    2 iterations with value 8, and 2 with value 2).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Angular search range (deg):  Maximum change in rot & tilt  (in +/- degrees)
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1000 1000 10 10 " 
    specifies 4 iterations, the first two set the value to 1000 (no restriction)
    and the last two to 10degrees. An alternative compact notation 
    is ("2x1000 2x10", i.e.,
    2 iterations with value 1000, and 2 with value 10).
    <Note:> if there are less values than iterations the last value is reused
    <Note:> if there are more values than iterations the extra value are ignored
    
Perturb projection directions?:  If set to 1, this option will result to a Gaussian perturbation to the 
    evenly sampled projection directions of the reference library. 
    This may serve to decrease the effects of model bias.
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1 1 0" 
    specifies 3 iterations, the first two set the value to 1 
    and the last to 0. An alternative compact notation 
    is ("2x1 0", i.e.,
    2 iterations with value 1, and 1 with value 0).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Projection method: select projection method, by default Fourier with padding 1 and interpolation bspline
Padding factor for projection: Increase the padding factor will improve projection quality but 
    projection generation will be slower. In general padding 1 and spline is OK
    
Interpolation kernel for projection:  Interpolation kernel for the generation of projections.
    
Maximum change in origin offset:  Maximum shift allowed per iteration.
    You may specify this option for each iteration.
    This can be done by a sequence of numbers (for instance, "1000 10 5"
    specifies 3 iterations, the first two set the value to 1000
    (almost no restriction) and the last to 5.
    An alternative compact notation
    is ("2x1000 5", i.e.,
    2 iterations with value 1000, and 1 with value 5).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra values are ignored
    
Search range for 5D translational search:  Give search range from the image center for 5D searches (in +/- pixels).
    Values larger than 0 will results in 5D searches (which may be CPU-intensive)
    Give 0 for conventional 3D+2D searches. 
    Note that after the 5D search, for the optimal angles always 
    a 2D exhaustive search is performed anyway (making it ~5D+2D)
    Provide a sequence of numbers (for instance, "5 5 3 0" specifies 4 iterations,
    the first two set the value to 5, then one with 3, resp 0 pixels.
    An alternative compact notation is ("3x5 2x3 0", i.e.,
    3 iterations with value 5, and 2 with value 3 and the rest with 0).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
    
Step size for 5D translational search: " Provide a sequence of numbers (for instance, "2 2 1 1" specifies 4 iterations,
    the first two set the value to 2, then two with 1 pixel.
    An alternative compact notation is ("2x2 2x1", i.e.,
    2 iterations with value 2, and 2 with value 1).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Restrict tilt angle search?: Restrict tilt angle search 
 
Lower-value for restricted tilt angle search: Lower-value for restricted tilt angle search 
 
Higher-value for restricted tilt angle search: Higher-value for restricted tilt angle search 
 
Point group symmetry:  See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] for a description of the symmetry groups format.
If no symmetry is present, give c1. 
Symmetry group for Neighbourhood computations:  If you do not know what this is leave it blank.
    This symmetry will be using for compute neighboring points,
    but not for sampling or reconstruction
    See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]]
    for a description of the symmetry groups format
    If no symmetry is present, give c1
    
compute only closest neighbor: This option is only relevant if symmetryGroupNeighbourhood !=''
    If set to 1 only one neighbor will be computed per sampling point
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1 1 0" 
    specifies 3 iterations, the first two set the value to 1 
    and the last to 0. An alternative compact notation 
    is ("2x1 0", i.e.,
    2 iterations with value 1, and 1 with value 0).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Discard images?:  
    None : No images will be discarded.
    maxCC  : Minimum Cross Correlation, discard images with CC below a fixed value.
    percentage : Discard percentage of images with less CC.
    classPercentage: Discard percentage of images in each projection direction with less CC.
    Value of each option is set below.
    
discard image if CC below:  
    Discard images with cross-correlation (CC) below this value.
    Provide a sequence of numbers (for instance, "0.3 0.3 0.5 0.5" specifies 4 iterations,
    the first two set the value to 0.3, then two with 0.5.
    An alternative compact notation would be ("2x0.3 2x0.5").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
discard image percentage with less CC:  
    Discard this percentage of images with less cross-correlation (CC)
    Provide a sequence of numbers (for instance, "20 20 10 10" specifies 4 iterations,
    the first two set the value to 20%, then two with 10%
    An alternative compact notation would be ("2x20 2x10").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    Set to zero to prevent discarding any images
    
discard image percentage in class with less CC:  
    Discard this percentage of images in each class(projection direction)
    with less cross-correlation (CC)    
    Provide a sequence of numbers (for instance, "20 20 10 10" specifies 4 iterations,
    the first two set the value to 20%, then two with 10%
    An alternative compact notation would be ("2x20 2x10").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    Set to zero to prevent discarding any images
    
Perform scale search?:  If true perform scale refinement. (UNDER DEVELOPMENT!!!!) 
  
Step scale factors size: Scale step factor size (1 means 0.01 in/de-crements around 1).
    Provide a sequence of numbers (for instance, "1 1 .5 .5" specifies 4 iterations,
    the first two set the value to 1%, then two with .5%
    An alternative compact notation would be ("2x1 2x0.5").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    Set to zero to prevent discarding any images
Number of scale steps:  
    Number of scale steps.
    With default values (ScaleStep='1' and ScaleNumberOfSteps='3'): 1 +/-0.01 | +/-0.02 | +/-0.03.    
    With values ScaleStep='2' and ScaleNumberOfSteps='4' it performs a scale search over:
    1 +/-0.02 | +/-0.04 | +/-0.06 | +/-0.08.    
    In general scale correction should only be applied to the last iteration. Do not use it unless
    your data is fairly well aligned.
    
Additional options for Projection_Matching:  For details see:
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Projection_matching][projection matching]] and
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Mpi_projection_matching][mpi projection matching]]
    try -Ri xx -Ro yy for restricting angular search (xx and yy are
    the particle inner and outter radius)
    
Perform 2D re-alignment: None
Perform 2D re-alignment of classes?:  After performing a 3D projection matching iteration, each of the
    subsets of images assigned to one of the library projections is
    re-aligned using a 2D-alignment protocol.
    This may serve to remove model bias.
    For details see:
    [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Align2d][align 2d]]
    Note that you cannot combine this option with CTF-correction!
    You may specify this option for each iteration. 
    This can be done by a sequence of 0 or 1 numbers (for instance, "1 1 0 0" 
    specifies 4 iterations, the first two applied alig2d while the last 2
    dont. An alternative compact notation is 
    is ("2x1 2x0", i.e.,
    2 iterations with value 1, and 2 with value 0).
    *Note:*if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    *IMPORTANT:* if you set this variable to 0 the output  of the projection
    muching step will be copied as output of align2d
    
Number of align2d iterations::  Use at least 3 iterations
    The number of align iteration may change in each projection matching iteration
    Ffor instance, "4 4 3 3 " 
    specifies 4 alig2d iterations in the first projection matching iteration 
    and  two 3 alig2d iteration in the last 2 projection matching iterations.
    An alternative compact notation 
    is ("2x4 2x3", i.e.,
    2 iterations with value 4, and 2 with value 3).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Maximum change in origin offset (+/- pixels): Maximum change in shift  (+/- pixels)
    You must specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1000 1000 10 10 " 
    specifies 4 iterations, the first two set the value to 1000 (no restriction)
    and the last two to 10degrees. An alternative compact notation 
    is ("2x1000 2x10", i.e.,
    2 iterations with value 1000, and 2 with value 10).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Maximum change in rotation (+/- degrees): Maximum change in shift  (+/- pixels)
    You must specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1000 1000 10 10 " 
    specifies 4 iterations, the first two set the value to 1000 (no restriction)
    and the last two to 10degrees. An alternative compact notation 
    is ("2x1000 2x10", i.e.,
    2 iterations with value 1000, and 2 with value 10).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Reconstruction method:  Select what reconstruction method to use.
    fourier: Fourier space interpolation (with griding).
    art: Agebraic reconstruction technique
    wbp : Weight back project method.
    
Initial maximum frequency:  This number is only used in the first iteration. 
    From then on, it will be set to resolution computed in the resolution section
    
Additional parameters for fourier:  For details see:
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Fourier][fourier]]
    
Values of lambda for ART:  *IMPORTANT:* ou must specify a value of lambda for each iteration even
    if ART has not been selected.
    *IMPORTANT:* NOte that we are using the WLS version of ART that 
    uses geater lambdas than the plain art.
    See for details:
    [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Art][xmipp art]]
    You must specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, ".1 .1 .3 .3" 
    specifies 4 iterations, the first two set the value to 0.1 
    (no restriction)
    and the last  two to .3. An alternative compact notation 
    is ("2x.1 2x.3").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Additional parameters for ART:  For details see:
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Art][xmipp art]]
    
Additional parameters for WBP:  For details see:
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Wbp][xmipp wbp]]
    
Compute resolution?:  For details see:
    [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Resolution][xmipp resolution]].
    
Split references averages?: In theory each reference average should be splited
    in two when computing the resolution. In this way each
    projection direction will be represented in each of the
    subvolumes used to compute the resolution. A much faster
    but less accurate approach is to split the 
    proyection directions in two but not the averages. We
    recommend the first approach for small volumes and the second for
    large volumes (especially when using small angular
    sampling rates.
    *IMPORTANT:* the second option has ONLY been implemented for FOURIER
    reconstruction method. Other reconstruction methods require this
    flag to be set to True
    You may specify this option for each iteration. 
    This can be done by a sequence of 0 or 1 numbers (for instance, "1 1 0 0" 
    specifies 4 iterations, the first two split the images   while the last 2
    don't. an alternative compact notation is 
    is ("2x1 2x0", i.e.,
    2 iterations with value 1, and 2 with value 0).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more vapplications/scripts/protocols/new_protocol_projmatch.pyalues than iterations the extra value are ignored
    
Low-pass filter the reference?: None
Use estimated resolution for low-pass filtering?:  If set to true, the volume will be filtered at a frecuency equal to
   the  resolution computed with a FSC=0.5 threshold, possibly 
   plus a constant provided by the user in the next input box. 

   If set to false, then the filtration will be made at the constant 
   value provided by the user in the next box (in digital frequency, 
   i.e. pixel^-1: minimum 0, maximum 0.5)
    
Constant to be added to the estimated resolution:  The meaning of this field depends on the previous flag.
    If set to true, then the volume will be filtered at a frequency equal to
    the  resolution computed with resolution_fsc (FSC=0.5) plus the value 
    provided in this field 
    If set to false, the volume will be filtered at the resolution
    provided in this field 
    This value is in digital frequency, or pixel^-1: minimum 0, maximum 0.5
    
    If you detect correlation between noisy regions decrease this value 
    (even to negative values)
    
    You can specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, ".15 .15 .1 .1"
    specifies 4 iterations, the first two set the constant to .15
    and the last two to 0.1. An alternative compact notation 
    is ("2x.15 2x0.1", i.e.,
    4 iterations with value 0.15, and three with value .1).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Constant to be added to the reconstruction maximum frequency:  The meaning of this field depends on the <use FSC for filter> flag.
    If set to true, then the volume will be reconstructed up to the frequency equal to
    the resolution computed with resolution_fsc (FSC=0.5) plus the value 
    provided in this field 
    If set to false, the volume will be reconstructed up to the resolution
    provided in this field 
    This value is in digital frequency, or pixel^-1: minimum 0, maximum 0.5
    
    You can specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, ".15 .15 .1 .1" 
    specifies 4 iterations, the first two set the constant to .15
    and the last two to 0.1. An alternative compact notation 
    is ("2x.15 2x0.1", i.e.,
    4 iterations with value 0.15, and three with value .1).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
MPI job size: Minimum size of jobs in mpi processes.
    Set to 1 for large images (e.g. 500x500)
    and to 10 for small images (e.g. 100x100)
    
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "random conical tilt" can be found at the xmipp3 plugin.
Its help description is:
 Creates initial volumes by using a set of projections/classes
    from a tilted-pair picking process and using RCT algorithm. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles tilt pair: Select the input particles tilt pair file that will be used.  file. This file is used to associate each micrograph with its tilted equivalent.
Input classes: Select the input images or classes from the project.
Thin Object: If the object is thin, then the tilted projections can be stretched to match the untilted projections
Maximum allowed shift for tilted particles (pixels): Particles that shift more will be discarded. A value larger than the image size will not discard any particle.
Skip tilted translation alignment: If the tilted image quality is very low, then this alignment might result in poor estimates.
Additional reconstruction parameters: See: http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Reconstruct_art_v31
Filter reconstructed volumes?: Filtering may be useful to remove noise, especially when few particles contribute to the reconstruction.
Resolution of the low-pass filter (dig.freq): Resolution of the low-pass filter (dig.freq)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "ransac" can be found at the xmipp3 plugin.
Its help description is:
  
    Computes an initial 3d model from a set of projections/classes 
    using RANSAC algorithm.
    
    This method is based on an initial non-lineal dimensionality
    reduction approach which allows to select representative small 
    sets of class average images capturing the most of the structural 
    information of the particle under study. These reduced sets are 
    then used to generate volumes from random orientation assignments. 
    The best volume is determined from these guesses using a random 
    sample consensus (RANSAC) approach.    
     .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input averages: Select the input images from the project.It should be a SetOfClasses2D object
Symmetry group: See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format in Xmipp.
If no symmetry is present, use _c1_.
Angular sampling rate: In degrees. This sampling defines how fine the projection gallery from the volume is explored.
Number of RANSAC iterations: Number of initial volumes to test by RANSAC
Perform dimensionality reduction: The dimensionality reduction is performed using the Local Tangent SpaceAlignment. See http://www.stat.missouri.edu/~ys873/research/LTSA11.pdf
Number of grids per dimension: Number of squares to sample the classes
Number of random samples: Number of squares to sample the classes
Inliers threshold: Correlation value threshold to determine if an experimental projection is an inlier or outlier.
Number of best volumes to refine: Number of best volumes to refine using projection matching approach and the input classes
Number of iterations to refine the volumes: Number of iterations to refine the best volumes using projection matching approach and the input classes
Initial volume: You may provide a very rough initial volume as a way to constraint the angular search.For instance, when reconstructing a fiber, you may provide a cylinder so that side viewsare assigned to the correct tilt angle, although the rotational angle may be completely wrong
Max frequency of the initial volume:  Max frequency of the initial volume in Angstroms
Use all images to refine:  When refining a RANSAC volume, use all images to refine it instead of only inliers
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "reconstruct fourier" can be found at the xmipp3 plugin.
Its help description is:
     
    Reconstruct a volume using Xmipp_reconstruct_fourier from a given set of particles.
    The alignment parameters will be converted to a Xmipp xmd file
    and used as direction projections to reconstruct.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input particles: Select the input images from the project.
Symmetry group: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
Maximum resolution (A): Maximum resolution (in Angstrom) to consider 
in Fourier space (default Nyquist).
Param *--maxres* in Xmipp.
Projection: None
Volume: None
Legacy version: Use original CPU version of the algorithm. This should not be necessary, but it's present to ensure backward compatibility
Approximative version: If on, an approximation of the original algorithm will be used. This will result in faster processing times, but (slightly) less precise result
Extra parameters: : Extra parameters to *xmipp_(cuda_)reconstruct_fourier* program:

                      --iter () : Subtract projections of this map from the images used for reconstruction
                      
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "highres" can be found at the xmipp3 plugin.
Its help description is:
 This is a 3D refinement protocol whose main input is a volume and a set of particles.
       The set of particles has to be at full size (the finer sampling rate available), but
       the rest of inputs (reference volume and masks) can be at any downsampling factor.
       The protocol scales the input images and volumes to a reasonable size depending on
       the resolution of the previous iteration.
       
       The protocol works with any input volume, whichever its resolution, as long as it
       is a reasonable initial volume for the set of particles. The protocol does not
       resolve the heterogeneous problem (it assumes an homogeneous population),
       although it is somewhat tolerant through the use of particle weights in the
       reconstruction process.
       
       It is recommended to perform several global alignment iterations before entering
       into the local iterations. The switch from global to local should be performed when
       a substantial percentage of the particles do not move from one iteration to the next.
       
       The algorithm reports the cross correlation (global alignment) or cost (local) function
       per defocus group, so that we can see which was the percentile of each particle in its
       defocus group. You may want to perform iterations one by one, and remove from one
       iteration to the next, those particles that worse fit the model..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Continue from a previous run?: If you set to *Yes*, you should select a previousrun of type *XmippProtReconstructHighRes* class and some of the input parameterswill be taken from it.
Full-size Images: Select a set of images at full resolution
Initial volumes: Select a set of volumes with 2 volumes or a single volume. If the input particles have an angular assignment, then you may leave empty this field and a 3D reconstruction of the input images is performed using reconstruct_fourier.
Radius of particle (px): This is the radius (in pixels) of the spherical mask covering the particle in the input images
Select previous run: Select a previous run to continue from.
Symmetry group: If no symmetry is present, give c1
Remove intermediate files: None
Low pass filter?: Apply a low pass filter to the previous iteration whose maximum frequency is the current resolution(A) + resolutionOffset(A). If resolutionOffset>0, then fewer informationis used (meant to avoid overfitting). If resolutionOffset<0, then more information is allowed (meant for a greedy convergence).
FSC criterion: The resolution of the reconstruction is defined as the inverse of the frequency at which the FSC drops below this value. Typical values are 0.143 and 0.5
Resolution offset (A): None
Spherical mask?: Apply a spherical mask of the size of the particle. If the postprocessing indicates that it has helical symmetry,then a cylindrical mask is applied
Positivity?: Remove from the next reference all negative values
Mask: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
Dropout: This is the probability with which voxels are dropped (set to 0.0) inside the binary mask
Next reference command: A command template that is used to generate next reference. The following variables can be used %(sampling)s %(dim)s %(volume)s %(iterDir)s. The command should read Spider volumes and modify the input volume.the command should be accessible either from the PATH or provide the absolute path.
Examples: 
xmipp_transform_filter -i %(volume)s --fourier low_pass 15 --sampling %(sampling)s
/home/joe/myScript %(volume)s sampling=%(sampling)s dim=%(dim)s
Remove reference to save space?: Remove reference volumes once they are not needed any more.
: None
Multiresolution approach: In the multiresolution approach the sampling rate of the images is adapted to the current resolution
Max. shift (%): Maximum shift as a percentage of the image size
Min.: Side views are around 90 degrees, top views around 0
Max.: You may generate redudant galleries by setting this angle to 180, this may help if c1 symmetry is considered
Image alignment: None
Number of iterations: None
Random subset size: Stochastic alignment is performed by taking random subsets of images of this size
Step size: The update is performed as V(k+1)=(1-alpha)*V(k)+alpha*R(k+1), that is, the previous volume weights 1-alpha, while the new one weights alpha
Restrict reconstruction angles: You may reconstruct only with those images falling on a certain range. This is particularly useful for helices where you may want to use projections very close to 90 degrees
Min.: Perform an angular assignment and only use those images whose angles are within these limits
Max.: Perform an angular assignment and only use those images whose angles are within these limits
Max. Target Resolution: In Angstroms. The actual maximum resolution will be the maximum between this number of 0.5 * previousResolution, meaning thatin a single step you cannot increase the resolution more than 1/2
: The gallery of reprojections is randomly perturbed this number of times
: Significant alignment is allowed to replicate each image up to this number of times
Optimize shifts?: Optimize shifts within a limit
Max. shift variation: Percentage of the image size
Optimize scale?: Optimize scale within a limit
Max. scale variation: None
Optimize angles?: Optimize angles within a limit
Optimize gray values?: Optimize gray values. Do not perform this unless the reconstructed volume is gray-compatible with the projections, i.e., the volumes haven been produced from projections
Max. gray scale variation: None
Max. gray shift variation: As a factor of the image standard deviation
Optimize defocus?: None
Max. defocus variation: In Angstroms
Fourier padding factor: The volume is zero padded by this factor to produce projections
Weight by SSNR?: Weight input images by SSNR
Weight by Continuous cost?: Weight input images by angular assignment cost
Weight by angular stability?: Weight input images by angular stability between iterations
Weight by CC percentile?: Weight input images by their fitness (cross correlation) percentile in their defocus group
Minimum CC weight: Weights are between this value and 1. If most of the particles are good, this value should be high (e.g., 0.9)
Mask: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
Symmetrize volume within mask?: None
Mask symmetry: If no symmetry is present, give c1
Mask: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
Apply helical symmetry?: None
Radius: In Angstroms
Dihedral symmetry: None
Min. Rotation: In degrees
Max. Rotation: In degrees
Min. Z shift: In angstroms
Max. Z shift: In angstroms
Post-processing command: A command template that is used to post-process the reconstruction. The following variables can be used %(sampling)s %(dim)s %(volume)s %(iterDir)s. The command should read Spider volumes and modify the input volume.the command should be accessible either from the PATH or provide the absolute path.
Examples: 
xmipp_transform_filter -i %(volume)s --fourier low_pass 15 --sampling %(sampling)s
/home/joe/myScript %(volume)s sampling=%(sampling)s dim=%(dim)s
Significant denoising Real space: None
Significant denoising Fourier space: None
Laplacian denoising: It can only be used if there is a mask
Blind deconvolution: None
Attenuate undershooting: None
Attenuate undershooting (K): Values below avg-K*sigma are attenuated
Evaluate difference: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "reconstruct significant" can be found at the xmipp3 plugin.
Its help description is:
 
    This algorithm addresses the initial volume problem in SPA
    by setting it in a Weighted Least Squares framework and
    calculating the weights through a statistical approach based on
    the cumulative density function of different image similarity measures.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input classes: Select the input classes2D from the project.
It should be a SetOfClasses2D class with  class representative
Symmetry group: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]]for a description of the symmetry groups format. If no symmetry is present, give c1.
Is there a reference volume(s)?: You may use a reference volume to initialize  the calculations. For instance, this is very  useful to obtain asymmetric volumes from symmetric  references. The symmetric reference  is provided as starting point, choose no symmetry  group (c1), and reconstruct_significantwill tend to break the symmetry finding a suitable  volume. The reference volume can also be useful, for instance, when reconstructing a fiber.  Provide in this case a cylinder of a  suitable size.
Initial 3D reference volumes: None
Angular sampling: Angular sampling in degrees for generating the projection gallery.
Minimum tilt (deg): Use the minimum and maximum tilts to limit the  angular search. This can be useful, for instance, in the reconstruction of fibers from side views. 0 degrees is a top view, while 90 degrees is a  side view.
Maximum tilt (deg): Use the minimum and maximum tilts to limit the  angular search. This can be useful, for instance, in the reconstruction of fibers from side views. 0 degrees is a top view, while 90 degrees is a  side view.
Maximum shift (px):: Set to -1 for free shift search
Keep intermediate volumes: Keep all volumes and angular assignments along  iterations
Use new maximum resolution?: You may use a new maximum resolution to simplify the calculations keeping only low frequency information.
Target resolution: Target resolution (A).
Starting significance: 80 means 80% of significance. Use larger numbers to relax the starting significance and have a  smoother landscape of solutions
Number of iterations: Number of iterations to go from the initial  significance to the final one
Final significance: 99.5 means 99.5% of significance. Use smaller  numbers to be more strict and have a sharper  reconstruction. Be aware that if you are too strict, you may end with very few projections  and the reconstruction becomes verynoisy.
Use IMED: Use IMED for the weighting. IMED is an alternative to correlation that can discriminate better among very similar images
Strict direction: If the direction  is strict, then only the most  significant experimental images can contribute  to it. As a consequence, many experimental classes are lost and only the best contribute to the 3D reconstruction. Be aware that only the best can be very few depending on the cases.
Angular neighborhood: Images in an angular neighborhood also determines the weight of each image. It should be at least  twice the angular sampling
Do not apply Fisher: Images are preselected using Fisher's confidence interval on the correlation coefficient. Check this box if you do not want to make this preselection.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "swarm consensus" can be found at the xmipp3 plugin.
Its help description is:
 This is a 3D refinement protocol whose main input is a set of volumes and a set of particles.
       The set of particles has to be at full size (the finer sampling rate available), but
       the rest of inputs (reference volume and masks) can be at any downsampling factor.
       The protocol scales the input images and volumes to a size that depends on the target resolution.

       The input set of volumes is considered to be a swarm of volumes and they try to optimize
       the correlation between the volumes and the set of particles. This is an stochastic maximization
       and only a fraction of the particles are used to update the volumes and evaluate them.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Full-size Images: Select a set of images at full resolution
Initial volumes: Select a set of volumes with 2 volumes or a single volume
Radius of particle (px): This is the radius (in pixels) of the spherical mask covering the particle in the input images
Symmetry group: See http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups formatIf no symmetry is present, give c1
Mask: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
Number of iterations: None
Max. Target Resolution: In Angstroms.
Min. Angle: The angular search is limited by this parametr (in degrees).
# Images to update: None
# Images to evaluate: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "resolution 3D" can be found at the xmipp3 plugin.
Its help description is:
  Computes resolution by several methods .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Volume to compare: This volume will be compared to the reference volume.
Calculate FSC and DPR?: If set True calculate FSC and DPR.
Reference volume: Input volume will be compared to this volume.
Calculate B-factor?: If set True the so-called B-factor will be estimated.
The B-factor can be used to sharpen a volume.
The high-resolution features will enhanced, thereby
correcting the envelope functions of the microscope,
detector etc. This implementation follows the
automated mode based on methodology developed by Rosenthal2003

*Note*: after finished, you can apply the B-factor through
   the _Analyze Results_ GUI.

The protocol named "resolution alignment" can be found at the xmipp3 plugin.
Its help description is:
     
    Given two half maps the protocol estimates if the reconstruction presents angular
    alignment errors. To do that, a set of directional FSC along all possible directions
    are estimated. The result is a curve Resolution-radius. If this curve presents a slope
    then the map present angular assignment errors, but it the graph is flat (horizontal), the map
    is error free. Note that this protocol generates a plot, not a Scipion object. Its result
    can only be visualized.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Are the half volumes stored with the input volume?: Usually, the half volumes are stored as properties of the input volume. If this is not the case, set this to False and specify the two halves you want to use.
Input Half Maps: Select a half maps for determining its  resolution anisotropy and resolution.
Half Map 1: Select one map for determining the directional FSC resolution.
Half Map 2: Select the second map for determining the directional FSC resolution.
Mask: The mask determines which points are specimen and which are not
Is a the protein a helix: blablabla
Limit the protein radius: blablabla
use directional fsc: blablabla
Cone Angle: Angle between the axis of the cone and the generatrix. An angle of 17 degrees is the best angle (see publicationVilas 2021) to measuare directional FSCs
FSC Threshold: Threshold for the fsc. By default the standard 0.143. Other common thresholds are 0.5 and 0.3.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "rotate volume" can be found at the xmipp3 plugin.
Its help description is:
  Rotate a volume around x,y,z .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Volume : Specify a volume.
Rotation mode: : Align (x,y,z) with Z axis
Axis: : Align (x,y,z) with Z axis
Degrees: : degrees of rotation in selected axis

The protocol named "rotational symmetry" can be found at the xmipp3 plugin.
Its help description is:
 
    Estimate the orientation of a rotational axis and symmetrize.
    The user should know the order of the axis (two-fold, three-fold, ...)
    If this is unknown you may try several and see the most consistent results.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: None
Symmetry order: 3 for a three-fold symmetry axis, 4 for a four-fold symmetry axis, ...
Search mode: None
Initial rotational angle: In degrees
Initial tilt angle: In degrees. tilt=0 is a top axis while tilt=90 defines a side axis
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "deep consensus picking" can be found at the xmipp3 plugin.
Its help description is:
  Protocol to compute a smart consensus between different particle picking
        algorithms. The protocol takes several Sets of Coordinates calculated
        by different programs and/or different parameter settings. Let's say:
        we consider N independent pickings. Then, a neural network is trained
        using different subset of picked and not picked cooridantes. Finally,
        a coordinate is considered to be a correct particle according to the
        neural network predictions.
        In streaming, the network is trained and used to predict in batches.
        The network is trained until the number of particles set is reached,
        meanwhile, a preliminary output is generated. Once the threshold is reached,
        the final output is produced by batches.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Set to true if you want to use GPU implementation 
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Select model type: If you set to *New*, a new model randomly initialized will be employed. If you set to *Pretrained* a pretrained model will be used. If you set to *PreviousRun*, a model trained in a previous run, within this project, will be employed
Select previous run: Select a previous run to continue from.
Skip training and score directly with pretrained model?: If you set to *No*, you should provide training set. If set to *Yes* the coordinates will be directly scored using the pretrained/previous model
Input coordinates: Select the set of coordinates to compare
Relative Radius: All coordinates within this radius (as fraction of particle size) are presumed to correspond to the same particle
Tolerance threshold: The method attach a score between 0 and 1, where 0 if for _bad_ particles and 1 for _good_ ones. Introduce -1 to let pass all for posterior inspection.
How to extract particles from micrograph: Our method, internally, uses particles that are extracted from preprocess micrographs. Preprocess steps are:
1) mic donwsampling to the required size such that the particle box size become 128 px. 
   E.g. xmipp_transform_downsample -i in/100_movie_aligned.mrc -o out1/100_movie_aligned.mrc --step newSamplingRate --method fourier
2) mic normalization to 0 mean and 1 std and mic contrast inversion to have white particles.
   E.g.  xmipp_transform_normalize -i out1/101_movie_aligned.mrc -o out2/101_movie_aligned.mrc --method OldXmipp [ --invert ]
3) particles extraction.
   E.g. xmipp_micrograph_scissor  -i out2/101_movie_aligned.mrc --pos particles@Runs/101_movie_aligned.pos -o out3/105_movie_aligned_particles  --Xdim 128 --downsampling newSamplingRate --fillBorders  ( Correct your coordinates with newSamplingRate if needed)
4) OPTIONAL: phase flipping using CTF.
 xmipp_ctf_phase_flip  -i particles/105_movie_aligned_noDust.xmp -o particles/105_movie_aligned_flipped.xmp --ctf ctfPath/105_movie_aligned.ctfParam --sampling newSamplingRate
Did you invert the micrographs contrast (particles are bright now)?: If you invert the contrast, your particles will be white over a black background in the micrograph. We use white particles. Select *No* if you already have inverted the constrast in the micrograph so that we can extract white particles directly
Ignore CTF: Deep Consensus extracts particles. Do you want to ignore CTF for particle extraction
CTF estimation: Choose some CTF estimation related to input micrographs. 
CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
Number of epochs: Number of epochs for neural network training.
Learning rate: Learning rate for neural network training
Auto stop training when convergency is detected?: If you set to *Yes*, the program will automatically stop training if there is no improvement for consecutive 2 epochs, learning rate will be decreased by a factor 10. If learningRate_t < 0.01*learningrate_0 training will stop. Warning: Sometimes convergency seems to be reached, but after time, improvement can still happen. Not recommended for very small data sets (<100 true particles)
Training mean val_acc threshold: Stop training if at any training batch the selected threshold is achieved
Regularization strength: L2 regularization for neural network weights.Make it bigger if suffering overfitting (validation acc decreases but training acc increases)
Typical values range from 1e-1 to 1e-6
Number of models for ensemble: Number of models to fit in order to build an ensamble. Tipical values are 1 to 5. The more the better until a point where no gain is obtained. Each model increases running time linearly
Expected number of particles to use for training: Number of particles for training the CNN. Once surpassed, there will not be more training
Set to -1 to use all the particles found
It will determine the size of the CNNUsually, the bigger the better, but more training data is needed
Three CNN sizes: n < 1500 | 1500 <= n < 20000 | n >= 20000
Perform testing after training?: If you set to *Yes*, you should select a testing positive set and a testing negative set
Set of positive test particles: Select the set of ground true positive particles.
Set of negative test particles: Select the set of ground false positive particles.
Additional training data: If you set to *None*, only the AND and RANDOM will be used for training.
If you set to *Precompiled*, a precompiled additional training set will be added to to the AND and RANDOM sets for training.
If you set to *Custom*, you can provide your own data that will be added to the AND and RANDOM sets for training.

Additional training data: You can provide either particles or coordinates as additional training set.If you provide coordinantes, they have to be picked from the same micrographs that theinputs
 If you provide particles, they have to be processed in the same way that the protocoldoes (128x128 pixels and withe particles). Thus, what the protocol does is to perform the following steps:
1) mic donwsampling to the required size such that the particle box size become 128 px. 
   E.g. xmipp_transform_downsample -i in/100_movie_aligned.mrc -o out1/100_movie_aligned.mrc --step newSamplingRate --method fourier
2) mic normalization to 0 mean and 1 std and mic contrast inversion to have WHITE particles.
 E.g.  xmipp_transform_normalize -i out1/101_movie_aligned.mrc -o out2/101_movie_aligned.mrc --method OldXmipp [ --invert ]
3) particles extraction.
   E.g. xmipp_micrograph_scissor  -i out2/101_movie_aligned.mrc --pos particles@Runs/101_movie_aligned.pos -o out3/105_movie_aligned_particles  --Xdim 128 --downsampling newSamplingRate --fillBorders  ( Correct your coordinates with newSamplingRate if needed)
4) OPTIONAL: phase flipping using CTF.
 xmipp_ctf_phase_flip  -i particles/105_movie_aligned_noDust.xmp -o particles/105_movie_aligned_flipped.xmp --ctf ctfPath/105_movie_aligned.ctfParam --sampling newSamplingRate
Then, particles are extracted with no further alteration.
Please ensure that the additional particles have been preprocessed as indicated before.

Positive train particles 128px (optional): Select a set of true positive particles. Take care of the preprocessing (128x128 pixels, contrast inverted (white particles), possibly CTF corrected
Positive coordinates(optional): Select a set of true coordinates collected from the same microgaphs that the input
Weight of positive additional train data: Select the weigth for the additional train set of positive particles.The weight value indicates internal particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of internal particles
Negative train particles 128px (optional): Select a set of false positive particles. Take care of the preprocessing: 128x128 pixels, contrast inverted (white particles), possibly CTF corrected
Negative coordinates(optional): Select a set of incorrect coordinates collected from the same microgaphs that the input
Weight of negative additional train data: Select the weigth for the additional train set of negative particles. The weight value indicates the number of times each image may be included at most per epoch. Deep consensus internal particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of internal particles
Perform preliminar predictions with on training CNN: The protocol will make preliminar preedictions with the network before it is fully trained
These preliminar results will be stored in a different output set
Extraction batch size: Size of the extraction batches (in number of micrographs)
Training batch size: Size of the training batches (in number of micrographs).The CNN needs a minimum number of particles to train for each batch, if there are not enough particles, the batch size must be increased

The protocol named "screen deep learning" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for screening particles using deep learning. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Set to true if you want to use GPU implementation
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
Use previously trained model?: If you set to *Yes*, you should select a previous run of type *XmippProtScreenDeepLearning* class and some of the input parameters will be taken from it.
Select previous run: Select a previous run to continue from.
Continue training on previously trainedModel?: If you set to *Yes*, you should provide training set
True particles: Select a set of particles that contains mostly true particles
Number of different negative dataset: Data from all negative datasets will be used for training. Maximun number is 4.

Set of negative train particles 1: Select the set of negative particles for training.
Weight of negative train particles 1: Select the weigh for the negative set of particles. The weight value indicates the number of times each image may be included at most per epoch. Positive particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of positive particles
Set of negative train particles 2: Select the set of negative particles for training.
Weight of negative train particles 2: Select the weigh for the negative set of particles. The weight value indicates the number of times each image may be included at most per epoch. Positive particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of positive particles
Set of negative train particles 3: Select the set of negative particles for training.
Weight of negative train particles 3: Select the weigh for the negative set of particles. The weight value indicates the number of times each image may be included at most per epoch. Positive particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of positive particles
Set of negative train particles 4: Select the set of negative particles for training.
Weight of negative train particles 4: Select the weigh for the negative set of particles. The weight value indicates the number of times each image may be included at most per epoch. Positive particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of positive particles
Set of putative particles to score: Select the set of putative particles to classify as good (score close to 1.0) or bad (score close to 0.0).
Number of epochs: Number of epochs for neural network training.
Learning rate: Learning rate for neural network training
Auto stop training when convergence is detected?: If you set to *Yes*, the program will automatically stop training if there is no improvement for consecutive 2 epochs, learning rate will be decreased by a factor 10. If learningRate_t < 0.01*learningrate_0 training will stop. Warning: Sometimes convergence seems to be reached, but after time, improvement can still happen. Not recommended for very small data sets (<100 true particles)
Regularization strength: L2 regularization for neural network weights.Make it bigger if suffering overfitting. Typical values range from 1e-1 to 1e-6
Number of models for ensemble: Number of models to fit in order to build an ensemble. Tipical values are 1 to 5. The more the better until a point where no gain is obtained. Each model increases running time linearly
Perform testing after training?: If you set to *Yes*, you should select a testing positive set and a testing negative set
Set of positive test particles: Select the set of ground true positive particles.
Set of negative test particles: Select the set of ground false positive particles.

The protocol named "screen particles" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to attach different merit values to every particle metadata for subsequent pruning the set.
There are different merit values to be calculated:
    - zScore evaluates the similarity of a particles with an average (lower zScore -> higher similarity).
    - SSNR evaluates the signal/noise ration in the Fourier space.
    - Variance evaluates the varaince on the micrographs context where the particle was picked.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Automatic rejection by Zscore: zScore evaluates the similarity of a particles with an average. The rejection can be:
  None (no rejection)
  MaxZscore (reject a particle if its zScore is larger than this value).
   Percentage (reject a given percentage for this criteria).
zScore threshold: Maximum Zscore.
Percentage (%): The worse percentage of particles according to metadata labels: ZScoreShape1, ZScoreShape2, ZScoreSNR1, ZScoreSNR2, ZScoreHistogram are automatically disabled.
Automatic rejection by SSNR: SSNR evaluates the signal/noise ration in the Fourier space. The rejection can be:
  None (no rejection)
  Percentage (reject a given percentage of the lowest SSNRs).
Percentage (%): The worse percentage of particles according to SSNR are automatically disabled.
Automatic rejection by Variance: Variance evaluates the varaince on the micrographs context where the particle was picked. The rejection can be:
  None (no rejection)
  Variance (taking into account only the variance)
  Var. and Gini (taking into account also the Gini coeff.)
Add features: Add features used for the ranking to each one of the input particles
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "shift particles" can be found at the xmipp3 plugin.
Its help description is:
  This protocol shifts particles to center them into a point selected in a volume. To do so, it generates new
    shifted images and modify the transformation matrix according to the shift performed..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particles: Select the SetOfParticles with transformation matrix to be shifted.
Select position in volume?: Select the position where the particles will be shifted in a volume displayed in a wizard.
Volume: Volume to select the point (by clicking in the wizard for selecting the new center) that will be the new center of the particles.
x: Use the wizard to select the new center for the shifted particles by shift+click on the blue point a drag it to the desired location while pressing shift.
y: None
z: None
Volume mask: 3D mask to compute the center of mass, the particles will be shifted to the computed center of mass
Apply shift to particles?: Yes: The shift is applied to particle images and zero shift is stored in the metadata. No: The shift is stored in the transformation matrix in the metadata, but not applied to the particle image (i.e. the output images are the same of input images). This option takes less time and the shift could be applied later using protocol "xmipp3 - apply alignment 2d" or by re-extracting the particles.
Use original box size for the shifted particles?: Use input particles box size for the shifted particles.
Final box size: Box size for the shifted particles.
Inverse: Use inverse transformation matrix
Interpolation: Linear: Use bilinear/trilinear interpolation
Spline: Use spline interpolation

The protocol named "shift volume" can be found at the xmipp3 plugin.
Its help description is:
  This protocol shifts a volume according to the input shifts.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Volume: Volume to shift
Use the same shifts as for the particles?: Use output shifts of protocol "shift particles" which should be executed previously
Shift particles protocol: None
x: None
y: None
z: None
Use original box size for the shifted volume?: Use input volume box size for the shifted volume.
Final box size: Box size of the shifted volume.

The protocol named "simulate ctf" can be found at the xmipp3 plugin.
Its help description is:
 
    Simulate the effect of the CTF (no amplitude decay).
    A random defocus is chosen between the lower and upper defocus for each projection.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: None
Voltage (kV): None
Spherical aberration Cs (mm): None
Fraction inelastic scattering: Between 0 and 1
Lower defocus (A): Negative value is overfocus
Upper defocus (A): Negative value is overfocus
Simulate astigmatic CTF?: If yes, defocusU and defocusV will have different values with a difference determined by the user, and there will be a value for angle
Lower defocus angle (degrees): Between 0 and 90
Upper defocus angle (degrees): Between 0 and 90
Lower defocus difference between defocusU and defocusV (A): None
Upper defocus difference between defocusU and defocusV(A): None

The protocol named "solid angles" can be found at the xmipp3 plugin.
Its help description is:
     
    Construct image groups based on the angular assignment. All images assigned within a solid angle
    are assigned to a class. Classes are not exclusive and an image may be assigned to multiple classes
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input volume: Select the input volume.
Input particles: Select the input experimental images with an angular assignment.
Symmetry group: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] page for a description of the symmetries accepted by Xmipp
Angular sampling: In degrees
Angular distance: In degrees. An image belongs to a group if its distance is smaller than this value
Maximum shift: In pixels
Number of directional classes: By default only one class will be computed for each projection direction. More classes could becomputed and this is needed for protocols split-volume. 
Homogeneize groups: Set to -1 for no homogeneization. Set to 0 for homogeneizing to the minimum of class size. Set to any other number to homogeneize to that particular number
Target resolution (A): None
Refine angles: Refine the angles of the classes using a continuous angular assignment
Number of CL2D iterations: None
Split volume: If desired, the protocol can use the directional classes calculated in this protocol to divide the input volume into 2 distinct 3D classes as measured by PCA. If the PCA component is just noise, it means that the algorithm does not find a difference between the 2D classes
Mask: The mask values must be binary: 0 (remove these voxels) and 1 (let them pass).
Number of reconstructions: Number of random reconstructions to perform
Number of images/reconstruction: Number of images per reconstruction. Consider that reconstructions with symmetry c1 will be perfomed
Confidence level: This parameter is alpha. Two volumes, one at alpha/2 and another one at 1-alpha/2, will be generated
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "split frames" can be found at the xmipp3 plugin.
Its help description is:
 
    Wrapper protocol to Xmipp split Odd Even
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input movies: Select a set of movies to be split into two sets (odd and even).It means, the set of frames is split in two subsets.
Sum Frames: Set yes to get a set of micrograms, or no to get a set of movies.

The protocol named "split volume" can be found at the xmipp3 plugin.
Its help description is:
 Split volume in two.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Directional classes: Select a set of particles with angles. Preferrably the output of a run of directional classes
Symmetry group: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
Mask: The mask values must be binary: 0 (remove these voxels) and 1 (let them pass).
Number of reconstructions: Number of random reconstructions to perform
Number of images/reconstruction: Number of images per reconstruction. Consider that reconstructions with symmetry c1 will be perfomed
Confidence level: This parameter is alpha. Two volumes, one at alpha/2 and another one at 1-alpha/2, will be generated

The protocol named "gl2d streaming" can be found at the xmipp3 plugin.
Its help description is:
  2D alignment in full streaming using Xmipp GPU Correlation.
    The set of classes will be growing whilst new particle images are
    received..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
: Add a list of GPU devices that can be used
Maximum shift (%):: Maximum shift allowed during the alignment as percentage of the input set size
Number of best images:: Number of classes to assign every input image during the alignment
Number of iterations in split stage:: Maximum number of iterations in split stage
Number of iterations in classify stage:: Maximum number of iterations when the classification of the whole image set is carried out
Image size: The image size can be downsampled to accelerate the classification
Threshold to split: The threshold in the number of images assigned to one class to make a spliting of that class
Block size: The inputs will be processed in a block-by-block basis of this size
Maximum number of classes: Maximum number of classes to be generated
Use CL2D: If you set to *Yes*, you will use CL2D (CPU) to make the split process
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "gl2d static" can be found at the xmipp3 plugin.
Its help description is:
  2D alignment in semi streaming using Xmipp GPU Correlation.
    A previous set of classes must be provided to include the new images in the
    corresponding class although the representatives will be maintained..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
: Add a list of GPU devices that can be used
Set of references: Set of references that will serve as reference for the classification. This can be a set of classes or set of averages
Maximum shift (px):: Maximum shift allowed during the alignment as percentage of the input set size
Number of best images:: Number of the best images to keep for every class

The protocol named "struct map" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for structure mapping based on correlation distance. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume(s): Select one or more volumes (SetOfClasses3D)
for structure mapping.
Target resolution: In Angstroms, the images and the volume are rescaled so that this resolution is at 2/3 of the Fourier spectrum.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "struct map - Zernike3D" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for structure mapping based on Zernike3D. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                           Select the one you want to use.
: Add a list of GPU devices that can be used
Input volume(s): Select one or more volumes (Volume or SetOfVolumes)
for structure mapping.
Compare two sets?: Useful when two Sets are intended to be compared independently (e.g. comparing EMDBS and Maps coming from PDBs).
Second set of volumes: Select one or more volumes (Volume or SetOfVolumes)
to compare to the first set.
Target resolution: In Angstroms, the images and the volume are rescaled so that this resolution is at 2/3 of the Fourier spectrum.
Multiresolution: Perform the analysis comparing different filtered versions of the volumes. The values specified here will determine the cutoff frequency of the filter in normalized units (normalized to 1/2).
Sphere radius: Radius of the sphere where the spherical harmonics will be computed (in voxels).
Zernike Degree: Degree Zernike Polynomials of the deformation=1,2,3,...
Harmonical Degree: Degree Spherical Harmonics of the deformation=1,2,3,...
Regularization: Penalization to deformations (higher values penalize more the deformation).
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "subtract projection" can be found at the xmipp3 plugin.
Its help description is:
  This protocol computes the subtraction between particles and a reference volume, by computing its projections with the same angles that input particles have. Then, each particle and the correspondent projection of the reference volume are numerically adjusted and subtracted using a mask which denotes the region to keep. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particles : Specify a SetOfParticles
Reference volume : Specify a volume.
Circular mask radius: : Radius of the circular mask to avoid edge artifacts. If -1 it is half the X dimension of the input particles
Maximum resolution: : Maximum resolution (in A) of the data 
Ignore particles with negative beta0 or R2?: : Particles with negative beta0 or R2 will not appear in the output set as they are considered bad particles. Moreover, negative betas will not contribute to mean beta if "mean" option is selected
Limit frequency?: : Limit frequency in the adjustment process to the frequency correspondent to the resolution indicated in "Maximum resolution" field above
Decay of the filter (sigma): : Decay of the filter (sigma) to smooth the mask transition
Fourier padding factor: : The volume is zero padded by this factor to produce projections
Mask : Specify a 3D mask for the region of the input volume that you want to keep or subtract, avoiding masks with 1s in background. If no mask is given, the subtraction is performed in whole images.
Mask contains the part to : None
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tilt analysis" can be found at the xmipp3 plugin.
Its help description is:
  Estimate the tilt of a micrograph, by analyzing the PSD correlations of different segments of the image.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: Select the SetOfMicrograph to be preprocessed.
Window size: By default, the micrograph will be divided into windows of dimensions 512x512, the PSD its correlations will be computed in every segment.
Objective resolution: By default, micrographs PSD will be cropped into a central windows of dimensions (xdim*(sampling rate/objective resolution)) x (ydim*(sampling rate/objective resolution)).
Mean correlation threshold: By default, micrographs will be divided into an output set and a discarded set based on the mean and std threshold
STD correlation threshold: By default, micrographs will be divided into an output set and a discarded set based on the mean and std threshold.
: Save the micrograph segments, the PSD of those segments and the correlation statistics of those segments.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "trigger data" can be found at the xmipp3 plugin.
Its help description is:
 
    Waits until certain number of images is prepared and then
    send them to output.
    It can be done in 3 ways:
        - If "Send all items to output?" is _No_:
            Once the number of items is reached, a setOfImages is returned and
            the protocol finishes (ending the streaming from this point).
        - If "Send all items to output?" is _Yes_ and:
            - If "Split items to multiple sets?" is _Yes_:
                Multiple closed outputs will be returned as soon as
                the number of items is reached.
            - If "Split items to multiple sets?" is _No_:
                Only one output is returned and it is growing up in batches of
                a certain number of items (completely in streaming).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input images: None
Wait for signal to stop the stream?: If NO is selected, normal functionality.
If YES is selected it will wait for a signal to stop the stream.
 For this option, select send all items to output with a minimum size of 1
Minimum output size: How many particles need to be on input to create output set.
Send all items to output?: If NO is selected, only a closed subset of "Output size" items will be send to output.
If YES is selected it will still running in streaming.
Split items to multiple sets?: If YES is selected, multiple closed outputs of "Output size" are returned.
If NO is selected, only one open and growing output is returned
Send signal to stop a stream?: If NO is selected, normal functionality.
If YES is selected it will send a signal to a connected Trigger data protocol.
 For this option, select the option send all items to output.
Trigger data protocol: Select the trigger data protocol that you will send a signal to stop the stream.
Delay (sec): Delay in seconds before checking new output

The protocol named "validate fsc-q" can be found at the xmipp3 plugin.
Its help description is:
 
    The protocol assesses the quality of the fit.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: Select a volume.
Input PDB from file: : None
Refined PDB: : Specify the desired input structure.
PDB File path: : Specify a path to desired PDB structure.
Volume from PDB: : Volume created from the PDB. The volume should be aligned with the reconstruction map. If the volume is not entered, it is automatically created from the PDB.
Soft Mask: The mask determines which points are specimen and which are not. If the mask is not passed, the method creates an automatic mask from the PDB.
window size: Kernel size (slidding window) for determining local resolution (pixels/voxels).
Set origin of coordinates: Option YES:
A new volume will be created with the given ORIGIN of coordinates. 
x: offset along x axis
y: offset along y axis
z: offset along z axis
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "validate_nontilt" can be found at the xmipp3 plugin.
Its help description is:
     
    Ranks a set of volumes according to their alignment reliability obtained from a clusterability test.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input volumes: Select the input volumes.
Input particles: Select the input projection images .
Symmetry group: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
Image alignment: None
High: None
Low: None
Angular Sampling (degrees): Angular distance (in degrees) between neighboring projection points 
Number of orientations per particle: Number of possible orientations in which a particle can be 

Significance: Significance of the aligniability with respect to a a set of uniformly distributed random points 

Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "validate overfitting" can be found at the xmipp3 plugin.
Its help description is:
     
    Check how the resolution changes with the number of projections used for 
    3D reconstruction. 

    NOTE:
    Using the output plot, with the reconstruction of aligned gaussian noise,
    you can assess the validity of the reconstruction from your micrograph
    images. Practically, if the resolution of reconstruction based on your
    images is not considerably different from aligned gaussian noise one
    (for less number of particles),your images may not produce a valid
    reconstruction.

    This method has been proposed by:
    B. Heymann "Validation of 3D EM Reconstructions", 2015.
    (see References)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input particles: Select the input images from the project.
Resize input particles and volume?: If obtaining the best possible reconstruction is not your goal, you can resize your input particales and volume to reduce running time of the protocol
New size (px): Resizing input particles and volumeusing fourier method
Calculate the noise bound for resolution?: Select if you want to obtain the noise bound for resolution. This calculation will increase the computational time of this protocol.
Initial 3D reference volume: Input 3D reference reconstruction to align gaussian noise.
Symmetry group: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] pagefor a description of the symmetry formataccepted by Xmipp
Number of particles: Number of particles in each subset and consequently number of subsets (for instance, in default values,a number of 6 subsets with given values are chosen)
Note:
The number of particles in each subset should not be larger than 1/2 of the input set of particles. The protocol consider this issue automatically. It means that if the input set of particles are lower than 10,000, you could leave default values unchanged.
Number of times the randomization is performed: None
Maximum resolution (dig.freq): Nyquist is 0.5
Angular sampling rate: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "volumes adjust" can be found at the xmipp3 plugin.
Its help description is:
  This protocol scales a volume in order to assimilate it to another one.
    The volume with the best resolution should be the first one.
    The volumes should be aligned previously and they have to be equal in size.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Volume 1 : Specify a volume.
Mask volumes?: The masks are not mandatory but highly recommendable.
Mask for volume 1: Specify a mask for volume 1.
Filter at resolution: : Resolution (A) at which subtraction will be performed, filtering the input volumes.Value 0 implies no filtering.
Decay of the filter (sigma): : Decay of the filter (sigma parameter) to smooth the mask transition
Number of iterations: : None
Relaxation factor (lambda): : Relaxation factor for Fourier amplitude projector (POCS), it should be between 0 and 1, being 1 no relaxation and 0 no modification of volume 2 amplitudes
Match the rotationally averaged Fourier amplitudes?: Match the rotationally averaged Fourier amplitudes when adjusting the amplitudes instead of taking them directly from the reference volume. For subtraction and consensus it is recommended to set it to True but for sharpening it is recommended to set it to False
Compute energy?: Compute energy difference between the different adjustment steps and iterations to see if the method reaches convergence
Volume 2 : Specify a volume.
Mask for volume 2: Specify a mask for volume 1.

The protocol named "volume consensus" can be found at the xmipp3 plugin.
Its help description is:
  This protocol performs a fusion of all the input volumes, which should be preprocessed with protocol 'volume
    substraction' saving volume 2, in order to be as similar as possible before the fusion. The output of
    this protocol is the consensus volume and another volume which indicates the maximun difference between input
    volumes in each voxel..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Volumes: Select the volumes for the consensus.

The protocol named "volumes subtraction" can be found at the xmipp3 plugin.
Its help description is:
  This protocol scales a volume in order to adjust it to another one. Then, it can calculate the subtraction
    of the two volumes. Second input can be a pdb. The volumes should be aligned previously and they have to
    be equal in size.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Volume 1 : Specify a volume.
Mask volumes?: The masks are not mandatory but highly recommendable.
Mask for volume 1: Specify a mask for volume 1.
Filter at resolution: : Resolution (A) at which subtraction will be performed, filtering the input volumes.Value 0 implies no filtering.
Decay of the filter (sigma): : Decay of the filter (sigma parameter) to smooth the mask transition
Number of iterations: : None
Relaxation factor (lambda): : Relaxation factor for Fourier amplitude projector (POCS), it should be between 0 and 1, being 1 no relaxation and 0 no modification of volume 2 amplitudes
Match the rotationally averaged Fourier amplitudes?: Match the rotationally averaged Fourier amplitudes when adjusting the amplitudes instead of taking them directly from the reference volume. For subtraction and consensus it is recommended to set it to True but for sharpening it is recommended to set it to False
Compute energy?: Compute energy difference between the different adjustment steps and iterations to see if the method reaches convergence
Is the second input a PDB?: If yes, the protocol will generate and store in folder "extra" of this protocol a volume and a mask from the pdb. This is not the recommended option, as the automatic conversion of the PDB into a density map may not be successful due to origin mismatches. We recommend to convert previously the PDB, inspect the converted map and use the map as input. If not, a second volume has to be input and optionally (but highly recommendable), a mask for it.
Retrieve PDB from: Retrieve PDB data from server, use a pdb Object, or a local file
Input pdb : Specify a pdb object. This is not the recommended option, as the automatic conversion of the PDB into a density map may not be successful due to origin mismatches. We recommendto convert previously the PDB, inspect the converted map and use the map as input.
File path: Specify a path to desired PDB structure.
Volume 2 : Specify a volume.
Mask for volume 2: Specify a mask for volume 1.
Save intermediate files?: Save input volume 1 filtered and input volume 2 adjusted, whichare the volumes that are really subtracted.

The protocol named "volume deform - Zernike3D" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for volume deformation based on Zernike3D. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                           Select the one you want to use.
: Add a list of GPU devices that can be used
Volume 1: None
Volume 2: None
Multiresolution: Perform the analysys comparing different filtered versions of the volumes
Target resolution: In Angstroms, the images and the volume are rescaled so that this resolution is at 2/3 of the Fourier spectrum.
Sphere radius: Radius of the sphere where the spherical harmonics will be computed.
Zernike Degree: Degree Zernike Polynomials of the deformation=1,2,3,...
Harmonical Degree: Degree Spherical Harmonics of the deformation=1,2,3,...
Regularization: Penalization to deformations (higher values penalize more the deformation).
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "calculate strain" can be found at the xmipp3 plugin.
Its help description is:
 Compare two states of a volume to analyze the local strains and rotations.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Initial state: Initial state of the structure, it will be deformed to fit into the final state
Final state: Initial state of the structure, it will be deformed to fit into the final state
Mask for the final state: Binary mask that defines where the strains and rotations will be calculated
Symmetry group: See http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups formatIf no symmetry is present, give c1

The protocol named "local resolution/local bfactor" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a local resolution map and an atomic model, this protocols provides the matching between the
    local resolution with the local bfactor per residue.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Atomic model: Select an atomic model. The atom positions will be taken to estimate the local resolution around them and then, the  local resolution associated to each residue.
Normalize Resolution: The normalizedlocal resolution map is defined as(LR - FSC)/FSC, where LR is the local resolution of agiven voxel, and FSC is the FSC resolution in A. This map provides information about whether the local resolution isgreater or lesser than the FSC. The local resolution normalized map is used to carry out the matching with the localbfactor per residue. Yes means that the local resolution will benormalized by the algorithm. No means that the input local resolution map is already a normalized local resolution map.
Local Resolution Map: Select a local resolution map. Alternatively, the input. can be a normalized local resolution map, in this caseset the Normalize resolution to No
Normalized Local Resolution Map: Select a normalized local resolution map. The local resolution normalized map is defined as (LR - FSC)/FSC, where LR is the local resolution of agiven voxel, and FSC is the FSC resolution in A
FSC resolution (A): The global resolution of the map in A
Use median: The local resolution per residue can be estimated usingthe mean (by default - No) or the median (yes)
is the atomic centered: True if the atomic model centered in midle of the local resolution map
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "assign alignment" can be found at the pwem plugin.
Its help description is:
  Assign the alignment calculated for a set of particles to another set.
    This protocol will take into account the differences of pixel size (A/pix)
    between the two sets and multiply by the right factor the shifts.
    The particles with the alignment can also be a subset of the other images
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the particles that you want to update the new alignment.
Input alignments: Select the particles with alignment to be apply to the other particles.
Assign random subsets?: If yes, the random subset information from the assignment input will be transferred to the output particles.
Ignore fractional shifts: When extracting coordinates, the integer part of the shifts from the alignment can be transferred to the 2d coordinate. The remaining decimal part is stored as xFrac and yFrac in the particles. Leave this active if you want current alignment shifts to be used, IGNORING the decimal fraction that might be annotated in case this set comes from an "extract coordinates" and you chose to "Apply particle shifts?"
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "invert hand" can be found at the pwem plugin.
Its help description is:
  Modify the transformation matrix of a set of particles
    So that the handedness changes
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the particles that you want to update the new alignment.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "average frames" can be found at the pwem plugin.
Its help description is:
 
    Very simple protocol to align all the frames of a given data collection
    session. It can be used as a sanity check.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.

The protocol named "box size checkpoint" can be found at the pwem plugin.
Its help description is:
 
    Protocol to make a validation operations on particle picking boxsize.
    For sanity check all the generated outputs are even numbers.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particle box size reference (px): This is the reference size of the boxed particles (in pixels).
For sanity check if it is not, it will be transform to an even number.
Particle box size secondary reference (px): This is a secondary size of the boxed particles (in pixels).
For sanity check if it is not, it will be transform to an even number.
Maximum proportional difference: This proportion is calulated with the following formula:
Proportional diff = 1 - min(boxSize1, boxSize2)/max(boxSize1, boxSize2)
If disagreed stayed with the primary reference?: Select yes if you want to use the primary reference as output.
Average the particle boxsize?: Select yes if you want to use an average of the box sizes as output.
Use timer?: Select yes if you want to use a timer to take the decision.
Time to wait:: Time in seconds that the protocol will remain running. A correct format is an integer number in seconds or the following syntax: {days}d {hours}h {minutes}m {seconds}s separated by spaces e.g: 1d 2h 20m 15s,  10m 3s, 1h, 20s or 25.

The protocol named "box size related parameters" can be found at the pwem plugin.
Its help description is:
 
    Protocol to make mathematical operations on particle picking boxsize.
    For sanity check all the generated outputs are even numbers.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: Select the SetOfMicrographs from where we extract the sampling rate
Particle box size (px): This is size of the boxed particles (in pixels).
For sanity check if it is not, it will be transform to an even number.
Extract particles boxsize?: Select yes if you want to generate these parameters.
Factor to multiply the box size (px): Extraction box size (px) = picking box size (px) * *factor*
Calculate gautomatch picking parameters?: Select yes if you want to generate these parameters.
Factor to obtain the particle radius (A): Particle radius in Angstrom. Default will be equal to 75% of reference size (box size).
Particle radius (A) = picking box size (px) * sampling_rate (A/px) * *factor*
Factor to obtain the min inter-particle distance (A): Minimum distance between particles in Angstrom
 Use value of 0.9~1.1X diameter; can be 0.3~0.5X for filament-like particle.
Min inter-particle distnace (A) = picking box size (px) * sampling_rate (A/px) * *factor*
Factor to obtain the local sigma diameter (A): Diameter for estimation of local sigma, in Angstrom.
Usually this diameter could be 0.5-2x of your particle diameter according to several factors. When using bigger values, normally you should decrease *Local sigma cut-off*. For smaller and sharper high density contamination/ice/metal particles you could use a smaller diameter and larger *Local sigma cut-off*.
Local sigma diameter (A) = picking box size (px) * sampling_rate (A/px) * *factor*
Factor to obtain the local average diameter (A): Diameter for estimation of local average, in Angstrom. 1.5~2.0X particle diameter suggested.
However, if you have sharp/small ice or any dark/bright dots, using a smaller value will be much better to get rid of these areas.
Local average diameter (A) = picking box size (px) * sampling_rate (A/px) * *factor*
Calculate relion picking parameters?: Select yes if you want to generate these parameters.
Factor to obtain the Min diameter for LoG filter (A): This should correspond to the smallest size of your particles projections in Ångstroms.
Min diameter for LoG filter (A) = picking box size (px) * sampling_rate (A/px) * *factor*
Factor to obtain the Max diameter for LoG filter (A): This should correspond to the largest size of your particles projections in Ångstroms.
Max diameter for LoG filter (A) = picking box size (px) * sampling_rate (A/px) * *factor*
Calculate topaz picking parameters?: Select yes if you want to generate these parameters.
Factor to obtain the particle radius (px): Pixel radius around particle centers to consider.
Particle radius (px) = picking box size (px) * *factor*
Number of particles per image: Expected number of particles per micrograph.
 If -1 it will be estimated for you.
Calculate picking consensus parameters?: Select yes if you want to generate these parameters.
Factor to obtain the particle radius (px): Pixel radius around particle centers to consider.
Particle radius (px) = picking box size (px) * *factor*
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "assign ctf" can be found at the pwem plugin.
Its help description is:
  This protocol assigns a CTF estimation to a particular
    set of particles producing a new set. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input type:: Select the type of objects that you want to assign the CTF.
Input set: Select the images (micrographs or particles) that you want to update the CTF parameters.
Input CTF: Select the CTFs that will be used to update particles. It can be another set of particles
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "numeric classes extractor" can be found at the pwem plugin.
Its help description is:
  Extracts items from a SetOfClasses based on number of items assigned to the class
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input classes: Set of classes to extract items from.
Extract representative?: Set to true if you want to extract the image that represents the class otherwise all items supporting the class will be extracted.
Biggest N classes: Will take the N biggest classes. Those having most element supporting them.

The protocol named "create stream data" can be found at the pwem plugin.
Its help description is:
  create  setofXXXX in streaming mode.
        micrograph -> read a micrograph in memory and writes it nDim times
        movie      -> read a movie in memory and writes it nDim times
        randomMicrographs -> creates a micrograph with random values
        and applies a random CTF
        particles  -> read nDim particles in memory and writes it in streaming
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
set Of: create set of
movie: This movie will be copied "number of items" times
micrograph: This micrograph will be copied "number of items" times
xdim: X dim 
ydim: Y dim 
SetOfParticles: These particles will be written in streaming
SetOfCoordinates: These Coordinates will be written in streaming
groups: How many items will be created every iteration
number of items: setofXX size
samplingRate: Sampling rate
Create Object each (sec): create one object each creationInterval seconds
Extra random seconds interval: Each object will be generated in a random time uniformly picked from the interval defined by[baseInterval, baseInterval+extraInterval]
delay (sec): wait this seconds before creating stream data
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Crossed subset" can be found at the pwem plugin.
Its help description is:
 
    Create a subset of the main set based on a matching field in another set. e.g.: Use _micName field (in both fields)
    to select micrographs (main set) present in a set of coordinates (secondary set)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Main set: Set to be reduced
Main field: Field in the main set that contains the values in common with the secondary set. Use any of the metadata viewers to find the field name.
Secondary set: Set holding the matching field. e.g: Set of Coordinates hold the micName that can be used to filter a set of micrographs (main set)
Secondary field: Field in the secondary set that contains the values in common with the main set. Use any of the metadata viewers to find the field name.

The protocol named "export to emdb/pdb" can be found at the pwem plugin.
Its help description is:
  generates files for elements to submit structures to EMDB/PDB.
        Since mmcif/pdb is only partially supported by some software
        the protocol creates 4 versions of the atomic struct file with the hope that at least
        one of them will work.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Main EM map to export: This EM map is mandatory for EMDB and it will be exported using mrc format. If this map is associated to their respective half maps, they will be exported as well.
Additional maps to export?: Select YES if you want to add some more EM maps to export.
Additional EM maps to export: These additional EM maps will be also exported using mrc format.
FSC file to export: This FSCs will be exported using XML format
Masks to export?: Select YES if you want to add some  masks to export.
Masks to export: These mask will be exported using mrc format
Atomic structure to export: This atomic structure will be exported using mmCIF format
Image to export: This image is mandatory for EMDB
symmetry group: symmetry group of the map.
Symmetry Order: Order of cyclic symmetry.
Export to directory: Directory where the files will be generated.

The protocol named "extract coordinates" can be found at the pwem plugin.
Its help description is:
  
    Extract the coordinates information from a set of particles.
    
    This protocol is useful when we want to re-extract the particles
    (maybe resulting from classification and cleaning) with the 
    original dimensions. It can be also handy to visualize the resulting
    particles in their location on micrographs.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the particles from which you want
to extract the coordinates and micrographs.
Input micrographs: Select the micrographs to which you want to
associate the coordinates from the particles.
Apply particle shifts?: Apply particle shifts (ONLY INTEGER PART) from 2D alignment to recalculate new coordinates. This can be useful for re-centering particle coordinates.
IMPORTANT: Only the integer part of the shifts will be applied in order to avoid interpolation. If you are re-extracting particles and want to apply the remaining decimal part of the shifts, set to  "yes" the option "Were particle shifts applied?" in alignment assign protocol.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "import averages" can be found at the pwem plugin.
Its help description is:
 Protocol to import a set of averages to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: You can import particles directly from the binary files, or import from other packages formats. 
Currently, we can import from: emx, xmipp3, relion, scipion, frealign, eman, cryosparc 
Following are the expected import files for each one:
*emx*: particles.emx
*xmipp3*: images.xmd
*relion*: itXX_data.star
*scipion*: particles.sqlite
*eman*: particleSet.lst
*cryosparc*: particles.cs

Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input EMX file: Select the EMX file containing particles information.
 See more about 
[[http://i2pc.cnb.csic.es/emx][EMX format]]
Alignment Type: Is this a 2D alignment, a 3D alignment or a set of projections
Particles metadata file: Select the particles Xmipp metadata file.
It is usually a images.xmd file result
from Xmipp protocols execution.
Star file: Select a *_data.star file from a
previous Relion execution.To detect if the input particles contains alignment information, it is required to have the optimiser.star file corresponding to the data.star
Ignore ID column?: Set this option to True to regenerate 
the id's of the particles. By default 
it is read from metadata file.        
This option can be useful when merging
different metadatas and id's are not  
longer unique.
Particles sqlite file: Select the particles sqlite file.

For Frealign you need to import both stack and .par files.: None
Stack file: Select an stack file with the particles.
Param file: Select a Frealign .par file with the refinement information.
Lst file: Select a *.lst set file from EMAN2 project.
cs file: Select a .cs file.
It is usually a .cs file result from cryoSPARC job execution.
Pixel size (sampling rate) Å/px: None
Have data been phase-flipped?: Set this to Yes if the images have been ctf-phase corrected.
Use the wizard button to import acquisition.: Depending on the import Format, the wizard
will try to import the acquisition values.
If not found, required ones should be provided.
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "import ctf" can be found at the pwem plugin.
Its help description is:
 Common protocol to import a set of ctfs into the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input micrographs: Select the micrographs for which you want to update the CTF parameters.
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "import coordinates" can be found at the pwem plugin.
Its help description is:
  Protocol to import a set of coordinates .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input micrographs: Select the micrographs for which you want to import coordinates.
Box size: None
Scale: Factor to scale coordinates
Invert X: None
Invert Y: Invert Y for EMAN coordinates taken on dm3 or tif micrographs
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "import coordinate pairs" can be found at the pwem plugin.
Its help description is:
  Protocol to import a set of tilt pair coordinates .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
_Auto_ - detects coordinate file type by extension.
_Xmipp_ - provide *.pos files
_Eman_ - provide info/*.json files
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Micrograph .xmd file: Provide input_micrographs.xmd file that contains tilt angles information. This file is usually created alongside the coordinates.
Pattern untilted: Pattern (that can include wildcards) of the files to import.
For example:
  *data/particles/***.spi*
  *~/Micrographs/mic/***.mrc*
Pattern tilted: Pattern (that can include wildcards) of the files to import.
For example:
  *data/particles/***.spi*
  *~/Micrographs/mic/***.mrc*
Input tilt pair micrographs: Select the tilt pair micrographs for which you want to import coordinates.
Box size: None
Scale: Factor to scale coordinates
Invert X: None
Invert Y: None

The protocol named "import mask" can be found at the pwem plugin.
Its help description is:
  Class for import masks from existing files. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Mask path: Select the file path of the mask

Pixel size (sampling rate) Å/px: None

The protocol named "import micrographs" can be found at the pwem plugin.
Its help description is:
 Protocol to import a set of micrographs to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input EMX file: Select the EMX file containing micrographs information.
See more about [[http://i2pc.cnb.csic.es/emx][EMX format]]
Micrographs metadata file: Select the micrographs Xmipp metadata file.
It is usually a _micrograph.xmd_ file result
from import, preprocess or downsample protocols.
Micrographs sqlite file: Select the micrographs sqlite file.

Have data been phase-flipped?: Set this to Yes if the images have been ctf-phase corrected.
Use the wizard button to import acquisition.: Depending on the import Format, the wizard
will try to import the acquisition values.
If not found, required ones should be provided.
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Sampling rate mode: You can specify the sampling rate (pixel size) directly from the image
(A/pixel, Ts) or by specifying the magnification rate (M) and the scanner
pixel size (microns/pixel, Tm).

They are related by  Ts = Tm / M
Pixel size (sampling rate) Å/px: Pixel size
Scanned pixel size (microns/px): 
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 

Reject from Set: Files on this set will not be imported
Reject from: Files acquired after this date will not be imported. Must follow format: YYYY-mm-dd HH:MM:SS 
e.g: 2019-01-14 14:18:05
Reject before: Files acquired before this date will not be imported. Must follow format: YYYY-mm-dd HH:MM:SS 
e.g: 2019-01-14 14:18:05
Rejection file has RegExps: Choose Yes if the rejection file contains regular expressions. Set to No if the rejection file contains file names. Ignore if not using a rejection file
Blacklist File: Reject everything included in this file. If Use RegExps is True,lines will be interpreted as regular expressions. E.g: 
(.*)GRID_0[1-5](.*)
(.*)/GRID_10/Falcon_2019_01_14-16_(.*)
If Use RegExps is False, lines will be interpreted as file names. E.g.
/path/to/GRID_10/Falcon_2019_01_14-16_51_20_0_movie.mrcs
/path/to/GRID_10/Falcon_2019_01_14-16_55_40_0_movie.mrcs

The protocol named "import tilted micrographs" can be found at the pwem plugin.
Its help description is:
 Protocol to import untilted-tilted pairs of micrographs in the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Pattern untilted: Pattern (that can include wildcards) of the files to import.
For example:
  *data/particles/***.spi*
  *~/Micrographs/mic/***.mrc*
Pattern tilted: Pattern (that can include wildcards) of the files to import.
For example:
  *data/particles/***.spi*
  *~/Micrographs/mic/***.mrc*
Copy files?: None
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Sampling rate mode: You can specify the sampling rate (pixel size) directly from the image
(A/pixel, Ts) or by specifying the magnification rate (M) and the scanner
pixel size (microns/pixel, Tm).

They are related by  Ts = Tm / M
Pixel size (sampling rate) Å/px: Pixel size
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Scanned pixel size (microns/px): None

The protocol named "import movies" can be found at the pwem plugin.
Its help description is:
  Protocol to import a set of movies (from direct detector cameras)
    to the project.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Have data been phase-flipped?: Set this to Yes if the images have been ctf-phase corrected.
Use the wizard button to import acquisition.: Depending on the import Format, the wizard
will try to import the acquisition values.
If not found, required ones should be provided.
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Sampling rate mode: You can specify the sampling rate (pixel size) directly from the image
(A/pixel, Ts) or by specifying the magnification rate (M) and the scanner
pixel size (microns/pixel, Tm).

They are related by  Ts = Tm / M
Pixel size (sampling rate) Å/px: Pixel size
Scanned pixel size (microns/px): 
Initial: None
Per frame: None
Gain image: A gain reference related to a set of movies for gain correction
Dark image: A dark image related to a set of movies
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 

Reject from Set: Files on this set will not be imported
Reject from: Files acquired after this date will not be imported. Must follow format: YYYY-mm-dd HH:MM:SS 
e.g: 2019-01-14 14:18:05
Reject before: Files acquired before this date will not be imported. Must follow format: YYYY-mm-dd HH:MM:SS 
e.g: 2019-01-14 14:18:05
Rejection file has RegExps: Choose Yes if the rejection file contains regular expressions. Set to No if the rejection file contains file names. Ignore if not using a rejection file
Blacklist File: Reject everything included in this file. If Use RegExps is True,lines will be interpreted as regular expressions. E.g: 
(.*)GRID_0[1-5](.*)
(.*)/GRID_10/Falcon_2019_01_14-16_(.*)
If Use RegExps is False, lines will be interpreted as file names. E.g.
/path/to/GRID_10/Falcon_2019_01_14-16_51_20_0_movie.mrcs
/path/to/GRID_10/Falcon_2019_01_14-16_55_40_0_movie.mrcs
Input individual frames?: Select Yes if movies are acquired in individual frame files. 
Number of frames: Provide how many frames are per movie. 
Create movie stacks?: Select Yes if you want to create a new stack for each movies with its frames. 
Write stacks in the project folder?: If Yes, the created stack files will be written in the project folder. By default the movies will be written in the same place where input frames are.
Movie suffix: Suffix added to the output movie filename.Use the extension to select the format (e.g., .mrcs, .stk)
Delete frame files?: Select Yes if you want to remove the individual frame files after creating the movie stack. 
Previous movies to exclude: Select a setOfMovies that are already imported that you want to exclude for this import.

The protocol named "import particles" can be found at the pwem plugin.
Its help description is:
 Protocol to import a set of particles to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: You can import particles directly from the binary files, or import from other packages formats. 
Currently, we can import from: emx, xmipp3, relion, scipion, frealign, eman, cryosparc 
Following are the expected import files for each one:
*emx*: particles.emx
*xmipp3*: images.xmd
*relion*: itXX_data.star
*scipion*: particles.sqlite
*eman*: particleSet.lst
*cryosparc*: particles.cs

Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input EMX file: Select the EMX file containing particles information.
 See more about 
[[http://i2pc.cnb.csic.es/emx][EMX format]]
Alignment Type: Is this a 2D alignment, a 3D alignment or a set of projections
Particles metadata file: Select the particles Xmipp metadata file.
It is usually a images.xmd file result
from Xmipp protocols execution.
Star file: Select a *_data.star file from a
previous Relion execution.To detect if the input particles contains alignment information, it is required to have the optimiser.star file corresponding to the data.star
Ignore ID column?: Set this option to True to regenerate 
the id's of the particles. By default 
it is read from metadata file.        
This option can be useful when merging
different metadatas and id's are not  
longer unique.
Particles sqlite file: Select the particles sqlite file.

For Frealign you need to import both stack and .par files.: None
Stack file: Select an stack file with the particles.
Param file: Select a Frealign .par file with the refinement information.
Lst file: Select a *.lst set file from EMAN2 project.
cs file: Select a .cs file.
It is usually a .cs file result from cryoSPARC job execution.
Have data been phase-flipped?: Set this to Yes if the images have been ctf-phase corrected.
Use the wizard button to import acquisition.: Depending on the import Format, the wizard
will try to import the acquisition values.
If not found, required ones should be provided.
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Pixel size (sampling rate) Å/px: None
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "import atomic structure" can be found at the pwem plugin.
Its help description is:
  Protocol to import an atomic structure  to the project.
Format may be PDB or MMCIF.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import atomic structure from: Import mmCIF data from online server or local file
Atomic structure ID : Type a mmCIF ID (four alphanumeric characters).
File path: Specify a path to desired atomic structure.
Input Volume: Associate this volume to the mmCIF file.

The protocol named "import sequence" can be found at the pwem plugin.
Its help description is:
  Protocol to import an aminoacid/nucleotide sequence file to the
    project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Sequence ID: Write a sequence ID. Otherwise, if the sequence derives from GenBank/UniProt/PDB databases, the respective database ID will be selected as starting sequence ID; examples: if you select GenBank accession AJ520101, SCIPION will assign AJ520101 as sequence ID; if you select UniProt accession P12345, SCIPION will assign P12345 as sequence ID; if you select atomic structure 3lqd.cif, chain B, SCIPION will assign 3lqd_B as sequence ID. In the rest of cases, the Sequence name will be selected as starting Sequence ID.
Sequence name: Write a sequence name.
Sequence description: Write a description for your sequence. Otherwise, if the sequence derives from GenBank/UniProt/PDB databases, the respective database description will be selected as starting sequence description. In the rest of cases, no sequence description will be added.
Import sequence of : Select the type of sequence to import.
From : Select one of the four options: write the aminoacid sequence or import it from a previously loaded atomic structure, a local file or an online server.
IUPAC Protein alphabet: : Your raw sequence will be cleaned according a certain alphabet, i.e., only the letters contained in the alphabet will be maintained in the sequence. Select thus the type of protein alphabet in order to accomplish the cleaning:

Protein alphabet: IUPAC protein alphabet of the 20 standard amino acids; uppercase and single letter: *ACDEFGHIKLMNPQRSTVWY*.

Extended Protein alphabet: Extended uppercase IUPAC protein single letter alphabet including X etc.
In addition to the standard 20 single letter protein codes, this includes:
*B = Asx*; Aspartic acid (R) or Asparagine (N)
*X = Xxx*"; Unknown or other amino acid
*Z = Glx*; Glutamic acid (E) or Glutamine (Q)
*J = Xle*; Leucine (L) or Isoleucine (I), used in mass-spec (NMR)
*U = Sec*; Selenocysteine
*O = Pyl*; Pyrrolysine
This alphabet is not intended to be used with X for Selenocysteine (an ad-hoc standard prior to the IUPAC adoption of U instead).

UniProt name/ID : Write a UniProt ID (six or ten alphanumeric characters; examples: A2BC19, P12345, A0A022YWF9, DGAL_ECOLI).
 You can convert other database identifiers to UniProt accession codes by using the "ID Mapping" tab on https://www.uniprot.org/
From : Select one of the five options: write the nucleic acid sequence or import it from a local file or an online server.
IUPAC Nucleic acid alphabet: : Your raw sequence will be cleaned according a certain alphabet, i.e., only the letters contained in the alphabet will be maintained in the sequence. Select thus the type of nucleic acid alphabet in order to accomplish the cleaning:

 Ambiguous DNA alphabet: Uppercase IUPAC ambiguous DNA: *GATCRYWSMKHBVDN*.

Unambiguous DNA alphabet: Uppercase IUPAC unambiguous DNA (letters *GATC* only).

Extended DNA: Extended IUPAC DNA alphabet.
In addition to the standard letter codes GATC, this includes:
*B* = 5-bromouridine
*D* = 5,6-dihydrouridine
*S* = thiouridine
*W* = wyosine

Ambiguous RNA: Uppercase IUPAC ambiguous RNA; *GAUCRYWSMKHBVDN*

Unambigous RNA alphabet: Generic single letter RNA alphabet.


Write your sequence here:: Write the aminoacid or nucleotide raw sequence.

Atomic structure from: Import structure data from online server or local file
Atomic structure ID : Type a structure ID (four alphanumeric characters).
File path: Specify a path to desired atomic structure.
Chain : Select a particular chain of the atomic structure.
File path: Specify a path to desired aminoacid or nucleic acid sequence file.
If your file contains more than one sequence, only the first one will be considered.
GenBank accession : Write a GenBank accession.


The protocol named "import set of atomic structures" can be found at the pwem plugin.
Its help description is:
  Protocol to import a set of atomic structure  to the project.
    Format may be PDB or MMCIF.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import atomic structures from: Import mmCIF data from online server or local files
Atomic structure IDs : Type a mmCIF ID (four alphanumeric characters, comma-separated)
i.e: 5ni1, 1ake
Files directory path: : Specify a path to the directory where the files are stored.
The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: : Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.

You may create AtomStruct from PDB (.pdb) or CIF/mmCIF (.cif)

The protocol named "import volumes" can be found at the pwem plugin.
Its help description is:
 Protocol to import a set of volumes to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Import 3D map data from EMDB server or local file
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
EMDB map ID (integer): Type an EMDB ID (Integer). 
Set half maps: Option YES:
Assign two half maps to the imported map.
Path half map1: Select first half map
Path half map2: Select second half map
Pixel size (sampling rate) Å/px: None
Set origin of coordinates: Option YES:
A new volume will be created with the given ORIGIN of coordinates. This ORIGIN will be set in the map file header.
The ORIGIN of coordinates will be placed at the center of the whole volume if you select n(x)/2, n(y)/2, n(z)/2 as x, y, z coordinates (n(x), n(y), n(z) are the dimensions of the whole volume). However, selecting 0, 0, 0 as x, y, z coordinates, the volume will be placed at the upper right-hand corner.

Option NO:
The ORIGIN of coordinates will be placed at the center of the whole volume (coordinates n(x)/2, n(y)/2, n(z)/2 by default). This ORIGIN will NOT be set in the map file header.

WARNING: In case you want to process the volume with programs requiring a specific symmetry regarding the origin of coordinates, for example the protocol extract unit cell, check carefully that the coordinates of the origin preserve the symmetry of the whole volume. This is particularly relevant for loading fragments/subunits of the whole volume.

x: offset along x axis (Angstroms)
y: offset along y axis (Angstroms)
z: offset along z axis (Angstroms)
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "manual check point" can be found at the pwem plugin.
Its help description is:
 
    This protocol is kept running for a time determined by a parameter or until
    the user determines it is convenient. This protocol is useful if we want a
    given protocol to be launched at the time the user sees appropriate.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Time to wait:: Time in seconds that the protocol will remain running. A correct format is an integer number in seconds or the following syntax: {days}d {hours}h {minutes}m {seconds}s separated by spaces e.g: 1d 2h 20m 15s,  10m 3s, 1h, 20s or 25.

The protocol named "mathematical operator" can be found at the pwem plugin.
Its help description is:
 
    Protocol to make mathematical operations on different inputs
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input X1:: Write the value you want to consider as X1 or if it is a input pointer select from the list of available inputs.
Input X2:: Write the value you want to consider as X2 or if it is a input pointer select from the list of available inputs.
Formula: : Write the mathematical formula you want to calculate, e.g: (X1 + X2) * X1 * 0.9 
Please note that X1 and X2 would be replaced by the value you selected for each case. It is important to use upper cases when writing the expression.
Result type:: Choose the variable type you want your result to be, e.g: Integer

The protocol named "assign gain to movies" can be found at the pwem plugin.
Its help description is:
  Assign a gain image to a set of movies
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
Gain image: Select a gain image. The movie will be corrected as newMovie=Movie/gain

The protocol named "movie eraser" can be found at the pwem plugin.
Its help description is:
  
    Protocol for removing movies based on different conditions:
    - If the input is SetOfMicrographs, it removes movies already aligned into micrographs.
    - If the input is SetOfCoordinates, it removes movies with unselected particles.
    WARNING: There is no way back. Be sure you understand the consequences.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set: Select the SetOfMicrographs or Coordinates to drive the movie DELETION process.
Movies source: Select the SetOfMovies to locate the movie files. Match will be done by ids!.
Dry mode: None

The protocol named "assign Orig & Sampling" can be found at the pwem plugin.
Its help description is:
  Modify the origin and sampling values assigned to a 3D map
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: A new object volume will be created with the assigned sampling rate and origin. No new binary file will be created
Copy volume: Option Yes:
A new volume file will be copied otherwise a link to the input volume is made
NOTE: if the copy option is selected the new sampling/origin is stored in the header. Otherwise this information  is only stored in Scipion's database
Set sampling rate: Option Yes:
A new volume object will be created with the given SamplingRate. This sampling rate will NOT be set in the map file header.


Pixel size (sampling rate) Å/px: None
Set origin: Option Yes:
A new volume object will be created with the given ORIGIN of coordinates. This ORIGIN will NOT be set in the map file header.


x: offset along x axis (Å)
  y: offset along y axis (Å)
  z: offset along z axis (Å)

The protocol named "pdf report" can be found at the pwem plugin.
Its help description is:
  
    Produce a pdf report from the files in a given directory.
    Supported file formats: *.tex, *.txt, *.jpg, *.png, *.pdf
    Files in the directory are sorted by name alphabetically,
    so if you want them to have the right order a possibility is to name them as
    0010-myText.txt
    0020-aFigure.png
    0030-anotherFigure.jpg
    0040-aPaper.pdf
    0050-anotherText.tex
    ...
    when these files are sorted, they will be sorted by the number in front.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Files directory: Directory with the input files. 
Check protocol help for more details.

The protocol named "picking difference" can be found at the pwem plugin.
Its help description is:
 
    Protocol to compute the difference between a reference SetOfParticles and
    a another set (usually a negative reference).

    The output will be a SetOfCoordinates with the particles in the reference
    input that are not close to coordinates in the negative input.

    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the reference set of coordinates.
Negative coordinates: Negative coordinates that will help to exclude coordinates from the input set. 
Radius (px): Distance radius to consider that two coordinates close enough. If a particle in the input referenceset have any close particle in the negative set, it will not be included in the output set. 
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "edit projection" can be found at the pwem plugin.
Its help description is:
 
    This protocol edits the projection directions of all the items of a set of particles using
    a formula. This could be useful for applying geometrical transformation to a set of
    particles.

    Several predefined operation are offered such as
    * apply the rotation matrix define by an origin vector and a target vector
    * rotate the projection vector around a given vector by  A degrees
    * convert between icosahedral symmetries
    * convert between dihedral symmetries
    * convert between tetrahedral symmetries
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set of particles to edit: Set which items will be modified.Must be a set of particles with transformations.
Select operation: Select operation to be performed in the set.
 *rotate to vector* modifies the alignment matrix  so a reconstruction made from the images produces a  rotated reconstruction
 *convert between icosahedral symmetry* will modify  the alignment matrix so the reconstruction will have  the new symmetry provided
 *convert between dihedral symmetry* will modify  the alignment matrix so the reconstruction will have  the new symmetry provided
 *convert between tetrahedral symmetry* will modify  the alignment matrix so the reconstruction will have  the new symmetry provided

x: X Coordinate 
y: Y dim 
z: Z dim 
x: X Coordinate 
y: Y dim 
z: Z dim 
x: X coordinate 
y: Y coordinate 
z: Z coordinate
angle (degrees): rotation angle 
origin: Source symmetry. 
target: Target symmetry. 
origin: Source symmetry. 
target: Target symmetry. 
origin: Source symmetry. 
target: Target symmetry. 
Symmetry: Symmetry type to use.
Order: Order of the symmetry: 6 for C6, ...

The protocol named "data summary" can be found at the pwem plugin.
Its help description is:
  Aggregates any set data based on its fields.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Any set: Set with the dta to be aggregated
Summary operations: Summary operations to apply to all fields in Fields parameter. e.g: MIN MAX AVG. Possible values are MIN, MAX, COUNT, AVG, SUM, TOTAL, GROUP_CONCAT. For more technical information see: https://www.sqlite.org/lang_aggfunc.html
Fields: Fields to apply operations on. Fields can be found in the metadata viewers. The header of the columns are valid names. e.g: _samplingRate id. Fields listed here should support the operations specified: DO NOT add literal fields.
Group by: Fields to make the group. An empty value will summarize the whole dataset.

The protocol named "edit set" can be found at the pwem plugin.
Its help description is:
 
    Protocol to edit attributes of all the items of a set using a formula.
    This could be useful for editing some values in the set. Use this
    protocol with extreme care, you can easily produce a set that is
    not consistent.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set to edit: Set which items will be modified.
Formula: A python code compatible with eval, where item represents each of the elements of the set. E.g.: item._resolution.set(item._resolution.get() +1).You could also use modules like "import numpy;  item._resolution .... "

The protocol named "filter set" can be found at the pwem plugin.
Its help description is:
 
    Protocol to filter sets based on its attributes through an expression that
    should evaluate to true or false. Some predefined expresions are stored (i.e.
    distance to center, distance between coordinates)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set to filter: Set which items will be filtered.
Select operation: Select operation to be performed in the set.
 *distance to center* keep coordinates that are farther from the center than a given value.
 *distance-between-coordinates* if two coordinates 
 are closer than a given value then keep only one. *formula* will apply the formula to the chosen attribute (i.e, resolution less than 2 )
Passing formula: A python code compatible with eval that should evaluate to True or False, where item represents each of the elements of the set. E.g.: item._resolution.get() < 4).You could also use modules like "import numpy;  item._resolution .... "
distance (A): distance from coordinates to center or distance between coordinates 
keep first coordinate: If 2 or more coordinates are closer than distancekeep the first one or delete all
Threshold: : Number/proportion of items to keep:
	Number: n>=1 
	Proportion: 0<n<1
	Percentage: n%

Higher/lower values of the attribute: 
	Higher: positive number
	Lower: negative number

e.g: "-10%" == "-0.1" == 10% of the items with lower values
e.g: "5" == 5 items with higher values
Ranking field: : Attribute to sort the set by.

The protocol named "split sets" can be found at the pwem plugin.
Its help description is:
  Protocol to split a set in two or more subsets.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set: Select the set of elements (images, etc) that you want to split.
Number of subsets: Select how many subsets do you want to create.
Randomize elements: Put the elements at random in the different subsets.

The protocol named "stress" can be found at the pwem plugin.
Its help description is:
  stress  will  stress  test  a  computer system in various selectable
       ways. Several options require the program stress-ng.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
No. CPU stressors: start N workers spinning on sqrt(rand())
No. memory stressors: start N workers continuously calling mmap(2)/munmap(2) and writing to the allocated memory. It will use 100% per worker 
Memory per stressors (Mb): allocate N bytes per vm worker. each stressors will use 100% of a CPU
No IO stressors: start N workers spinning on sync() (Disk io)
TimeOut (sec): timeout after N seconds. Total execution time is timeout plus delay
delay (sec): wait this seconds before stressing the system seconds
Additional parameters: Additional parameters for stress-ng (http://kernel.ubuntu.com/~cking/stress-ng/)

The protocol named "subset" can be found at the pwem plugin.
Its help description is:
     
    Create a set with the elements of an original set that are also
    referenced in another set.
    
    Usually there is a bigger set with all the elements, and a smaller
    one obtained from classification, cleaning, etc. The desired result
    is a set with the elements from the original set that are also present
    somehow in the smaller set (in the smaller set they may be downsampled
    or processed in some other way).
    
    Both sets should be of the same kind (micrographs, particles, volumes)
    or related (micrographs and CTFs for example).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Full set of items: Even if the operation can be applied to two arbitrary sets,
the most common use-case is to retrieve a subset of
elements from an original full set.
*Note*: the elements of the resulting set will be the same
ones as this input set.
Make random subset: Choose elements randomly form the full set.
Number of elements: How many elements will be taken from the full set.
Make a subset from specific IDs: Choose specific elements form the full set.
IDs range or list: Select the IDs that will be the subset.
You have several ways to specify the IDs.
Example: 
"1,3,5-8,17-20" -> [1,3, 5, 6, 7, 8, 17, 18, 19, 20]

Other set: The elements present in this set will be used to pick 
elements from the input full set.     
This means that the output set will contain elements with 
exact the same information of input full set.

Set operation: if _intersection_ is used,
elements that are both in input and other set
will be included. If _difference_, elements that
are in input but not in other will picked.
Set operation: Set operation: if _intersection_ is used,
elements that are both in input and other set
will be included. If _difference_, elements that
are in input but not in other will picked.

The protocol named "particles subset by coordinates" can be found at the pwem plugin.
Its help description is:
 
    Create a subset of those particles that have a particular set of coordinates
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Set of particles from which the subset will be taken
Input coordinates: Only the particles with this set of coordinates will be output
Coordinate tolerance (px): Two coordinates are supposed to be the same if their X and Y distance is smaller or equal this value

The protocol named "particles subset by micrograph" can be found at the pwem plugin.
Its help description is:
 
    Create a subset of those particles that come from a particular set of micrographs
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Set of particles from which the subset will be taken
Input micrographs: Only the particles in this set of micrographs will be output

The protocol named "parallel test" can be found at the pwem plugin.
Its help description is:
  A parallel test protocol.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Number of iterations: Repeat the insertion of steps N times.
Number of parallel sleeps: How many sleep steps can be done at the same time.
Fail after: If you set an id, the next step should fail
Seconds to sleep: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "join sets" can be found at the pwem plugin.
Its help description is:
  Protocol to join two or more sets of images.
    This protocol allows to select two or more set of images
    and will produce another set joining all elements of the 
    selected sets. It will validate that all sets are of the
    same type of elements (Micrographs, Particles or Volumes) 
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input type:: Select the type of objects that you want to union.
Special case All will allow you to select any type.
Input set: Select two or more sets (of micrographs, particles, volumes, etc.) to be united. If you select 3 sets with 100, 200, 200 elements, the final set will contain a total of 500 elements.
Remove duplicates?: By default, duplicated items found (same ID) within the input sets, will cause renumbering of all the items ids in the output set. This is the case for example when doing several imports (which will cause ids overlapping) but we really want to insert as new items in the output. 
On the other hand, items originated in a previous common protocol (above in the workflow) might have identical items and you would like to remove them. Therefore, set this option to *Yes* to remove duplicates and keep only one copy of the item (the first occurrence).
Force new ids: Perform an automatic renumbering of ids to ensure all objects have unique ids. This will mean new objects will not be associated to the old ones.

The protocol named "wait" can be found at the pwem plugin.
Its help description is:
 
    Auxiliary protocol, it just waits "seconds" seconds and then exits
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
wait(seconds): Number of seconds the protocol waits untill it exits.

The protocol named "auto-picking" can be found at the relion plugin.
Its help description is:
  This protocol runs Relion autopicking (version > 3.0).

    This Relion protocol uses the 'relion_autopick' program to pick particles
    from micrographs, either using references (2D averages or 3D volumes)

    The wrapper implementation does not read/write any FOM maps compared to Relion
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: Select the input micrographs. If using the *Optimize* mode, just a subset of micrographs are used to compute the FOM maps. If in *Compute* mode, all micrographs will be auto-picked.
CTF estimation: Choose some CTF estimation related to the input micrographs.
References: The preferred way to autopick is by providing 2D references images that were obtained by 2D classification. 
The Gaussian blob references may be useful to kickstart a new data set.
Input references: Input references (SetOfAverages) for auto-pick. 

Note that the absolute greyscale needs to be correct, 
so only use images with proper normalization.
Input references: Input volume from which 2D references will be made by projection. Note that the absolute greyscale needs to be correct, so only use maps created by RELION itself from this data set.
Symmetry: Symmetry point group of the 3D reference. Only projections in the asymmetric part of the sphere will be generated.
3D angular sampling (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
For autopicking, 30 degrees is usually fine enough, but for highly symmetrical objects one may need to go finer to adequately sample the asymmetric part of the sphere.
Lowpass filter references (A): Lowpass filter that will be applied to the references before template matching. 
Do NOT use very high-resolution templates to search your micrographs. 
The signal will be too weak at high resolution anyway, and you may find Einstein from noise...
Highpass filter (A): Highpass filter that will be applied to the micrographs. This may be useful to get rid of background ramps due to uneven ice distributions. Give a negative value to skip the highpass filter.  Useful values are often in the range of 200-400 Angstroms.
Angular sampling (deg): Angular sampling in degrees for exhaustive searches of the in-plane rotations for all references.
References have inverted contrast?: Set to Yes to indicate that the reference have inverted contrast with respect to the particles in the micrographs.
Are References CTF corrected?: Set to Yes if the references were created with CTF-correction inside RELION.
If set to Yes, the input micrographs should contain the CTF information.
Ignore CTFs until first peak?: Set this to Yes, only if this option was also used to generate the references.
Picking threshold:: Use lower thresholds to pick more particles (and more junk probably)
Minimum inter-particle distance (A):: Particles closer together than this distance 
will be consider to be a single cluster. 
From each cluster, only one particle will be picked.
Maximum stddev noise:: This is useful to prevent picking in carbon areas, or areas with big contamination features. Peaks in areas where the background standard deviation in the normalized micrographs is higher than this value will be ignored. Useful values are probably in the range 1.0 to 1.2. Set to -1 to switch off the feature to eliminate peaks due to high background standard deviations.
Minimum avg noise:: This is useful to prevent picking in carbon areas, or areas with big contamination features. Peaks in areas where the background standard deviation in the normalized micrographs is higher than this value will be ignored. Useful values are probably in the range -0.5 to 0. Set to -999 to switch off the feature to eliminate peaks due to low average background densities.
Shrink factor: This is useful to speed up the calculations, and to make them less memory-intensive. The micrographs will be downscaled (shrunk) to calculate the cross-correlations, and peak searching will be done in the downscaled FOM maps. When set to 0, the micrographs will de downscaled to the lowpass filter of the references, a value between 0 and 1 will downscale the micrographs by that factor. Note that the results will not be exactly the same when you shrink micrographs!
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Additional arguments:: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "relion_autopick" will print a list of possible options.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "assign optics groups" can be found at the relion plugin.
Its help description is:
  Assign Optics Group name and related parameters to an input set.
     Input set can be: movies, micrographs or particles.

     Warning: all optics parameters from the input set itself are removed!
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set: Select the input set (Movies, Micrographs or Particles) to assign Optics Group parameters.
Input Optics Groups from: Select how to provide information about the optics groups. In the case of single group provide the parameters below, otherwise you need to provide a star file.
Optics group name: Relion-specific option. Name of this optics group. Each group of movies with different optics characteristics for CTF refinement should have a unique name.
MTF-curve file: User-provided STAR-file with the MTF-curve of the detector. Use the wizard to load one of the predefined ones provided at:
- [[https://www3.mrc-lmb.cam.ac.uk/relion/index.php/FAQs#Where_can_I_find_MTF_curves_for_typical_detectors.3F][Relion's Wiki FAQs]]
 - [[https://www.gatan.com/techniques/cryo-em#MTF][Gatan's website]]

Relion param: *--mtf*
X: None
Y: None
Gain reference: A gain reference file is required for gain correction
Gain rotation: Rotate the gain reference by this number times 90 degrees clockwise in relion_display. This is the same as -RotGain in MotionCor2. 
Note that MotionCor2 uses a different convention for rotation so it says 'counter-clockwise'.
Gain flip: Flip the gain reference after rotation. This is the same as -FlipGain in MotionCor2. 0 means do nothing, 1 means flip Y (upside down) and 2 means flip X (left to right).
Defects file: Location of a UCSF MotionCor2-style defect text file or a defect map that describe the defect pixels on the detector. Each line of a defect text file should contain four numbers specifying x, y, width and height of a defect region. A defect map is an image (MRC or TIFF), where 0 means good and 1 means bad pixels. The coordinate system is the same as the input movie before application of binning, rotation and/or flipping.

_Note that the format of the defect text is DIFFERENT from the defect text produced by SerialEM!_
 One can convert a SerialEM-style defect file into a defect map using IMOD utilities e.g.:
*clip defect -D defect.txt -f tif movie.tif defect_map.tif*
See explanations in the SerialEM manual.
Leave empty if you do not have any defects, or do not want to correct for defects on your detector.
Input Star file with optics groups: Provide input star file with Optics groups information. The input Star file should contain: 
- *data_optics* table with values for each group.
- *data_micrographs* table with two columns: 

	rlnMicrographName with the micName associated to the input set.
	rlnOpticsGroup with the group number associated to this micrograph.

If you provide rlnMicrographGainName in the optics table, it has to point to a transformed gain reference (rotated and flipped if necessary).

The protocol named "auto-picking LoG" can be found at the relion plugin.
Its help description is:
 
    This Relion protocol uses 'relion_autopick' program for the
    Laplacian of Gaussian (LoG) option.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: Select the input micrographs. If using the *Optimize* mode, just a subset of micrographs are used to compute the FOM maps. If in *Compute* mode, all micrographs will be auto-picked.
Box size (px): Box size in pixels.
Min diameter (A): None
Max diameter (A): None
Are the particles white?: Set this option to No if the particles are black, and to Yes if the particles are white.
Maximum resolution to consider (A): The Laplacian-of-Gaussian filter will be applied to downscaled micrographs with the corresponding size. Give a negative value to skip downscaling.
Adjust default threshold (stddev): Use this to pick more (negative number -> lower threshold) or less (positive number -> higher threshold) particles compared to the default setting.
Upper threshold (stddev): Use this to discard picks with LoG thresholds that are this many standard deviations above the average, e.g. to avoid high contrast contamination like ice and ethane droplets. Good values depend on the contrast of micrographs and need to be interactively explored; for low contrast micrographs, values of ~ 1.5 may be reasonable, but the same value will be too low for high-contrast micrographs.
Additional arguments:: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "relion_autopick" will print a list of possible options.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "bayesian polishing" can be found at the relion plugin.
Its help description is:
 
    Wrapper protocol for the Relion's Bayesian Polishing.

    As of release 3.0, Relion also implements a new Bayesian approach to beam
    induced motion correction. This approach aims to optimise a regularised
    likelihood, which allows us to associate with each hypothetical set of
    particle trajectories a prior likelihood that favors spatially coherent
    and temporally smooth motion without imposing any hard constraints.
    The smoothness prior term requires three parameters that describe the
    statistics of the observed motion. To estimate the prior that yields the
    best motion tracks for this particular dataset, we can first run the
    program in 'training mode'. Once the estimates have been obtained, one
    can then run the program again to fit tracks for the motion of all
    particles in the data set and to produce adequately weighted averages of
    the aligned movie frames.

    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input ALIGNED movies: Provide a set of movies that have at least global alignment information.
Input particles: Provide a set of particles from 3D auto-refine or CTF refinement.
Input Postprocess: Select a PostProcess job. The mask used for this postprocessing will be applied to the unfiltered half-maps and should encompass the entire complex. The resulting FSC curve will be used for weighting the different frequencies.
first: None
last: None
Extraction size (px in unbinned movie): Size of the extracted particles in the unbinned original movie (in pixels). This should be an even number.
Re-scaled size (px): The re-scaled value needs to be an even number.
Write output in float16?: Relion can write output images in float16 MRC (mode 12) format to save disk space. By default, float32 format is used.
Operation: If *train optimal parameters* , then relion_motion_refine will estimate optimal parameter values for the three sigma values above on a subset of the data (determined by the minimum number of particles to be used below).

If *perform particle polishing* then relion_motion_refine will be run to estimate per-particle motion-tracks using the parameters below, and polished particles will be generated. 
Fraction of Fourier pixels for testing: This fraction of Fourier pixels (at higher resolution) will be used for evaluation of the parameters (test set), whereas the rest (at lower resolution) will be used for parameter estimation itself (work set).
Use this many particles: Use at least this many particles for the meta-parameter optimisation. The more particles the more expensive in time and computer memory the calculation becomes, but the better the results may get.
Sigma for velocity (A/dose): Standard deviation for the velocity regularisation. Smaller values requires the tracks to be shorter.
Sigma for divergence (A): Standard deviation for the divergence of tracks across the micrograph. Smaller values requires the tracks to be spatially more uniform in a micrograph.
Sigma for acceleration (A/dose): Standard deviation for the acceleration regularisation. Smaller values requires the tracks to be straighter.
min: None
max: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "calculate fsc" can be found at the relion plugin.
Its help description is:
 
    Relion protocol to calculate various FSC curves using relion_image_handler.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Select FSC type to compute: 1) FSC overall - between two half-maps
2) FSC model-map - between atomic model and refined map
3) FSC work - model refined against half-map 1, compared to half-map 1
FSC free - model refined against half-map 1, compared to half-map 2
Input half map 1: None
Input half map 2: None
Final map: None
Final atomic model: None
Atomic model refined against half-map 1: None
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "center averages" can be found at the relion plugin.
Its help description is:
 
    Align class averages by their center of mass using *relion_image_handler*.
     (With *--shift_com* option)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input averages: Select the input averages to be centered.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "2D classification" can be found at the relion plugin.
Its help description is:
  This protocol runs Relion 2D classification..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: None
: None
Continue from a previous run?: If you set to *Yes*, you should select a previousrun of type *ProtRelionClassify2D* class and most of the input parameterswill be taken from it.
Input particles: Select the input images from the project.
Consider previous alignment?: If set to Yes, then alignment information from input particles will be considered.
Consider alignment as priors?: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
: None
Particle mask diameter (A): The experimental images will be masked with a soft circular mask with this <diameter>. Make sure this diameter is not set too small because that may mask away part of the signal! If set to a value larger than the image size no masking will be performed.

The same diameter will also be used for a spherical mask of the reference structures if no user-provided mask is specified.
Mask particles with zeros?: If set to <Yes>, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform. This will remove noise and therefore increase sensitivity in the alignment and classification. However, it will also introduce correlations between the Fourier components that are not modelled. When set to <No>, then the solvent area is filled with random noise, which prevents introducing correlations.High-resolution refinements (e.g. in 3D auto-refine) tend to work better when filling the solvent area with random noise, some classifications go better when using zeros.
Select previous run: Select a previous run to continue from.
Continue from iteration: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
Reference averages: This option is not recommended and should be used with care. The provided averages will be used as initial 2D references. If this option is used, the number of classes will be ignored. 
Reference mask (optional): User-provided mask for the references (default is to use spherical mask with particle_diameter)
CTF parameters are not available in continue mode: None
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Have data been phase-flipped?      (Don't answer, see help): The phase-flip status is recorded and managed by Scipion. 
 In other words, when you import or extract particles, 
Scipion will record whether or not phase flipping has been done.

Note that CTF-phase flipping is NOT a necessary pre-processing step 
for MAP-refinement in RELION, as this can be done inside the internal
CTF-correction. However, if the phases have been flipped, the program will handle it.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Do manual grouping ctfs?: Set this to Yes the CTFs will grouping manually.
Defocus range for group creation (in Angstroms): Particles will be grouped by defocus.This parameter is the bin for a histogram.All particles assigned to a bin form a group
minimum size for defocus group: If defocus group is smaller than this value, it will be expanded until number of particles per defocus group is reached
Number of classes:: The number of classes (K) for a multi-reference refinement. These classes will be made in an unsupervised manner from a single reference by division of the data into random subsets during the first iteration.
Regularisation parameter T: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D refinements, values of 1-2 for 2D refinements. Too small values yield too-low resolution structures; too high values result in over-estimated resolutions and overfitting.
Use VDAM algorithm?: If set to Yes, the faster VDAM algorithm will be used. This algorithm was introduced with Relion-4.0. If set to No, then the slower EM algorithm needs to be used.
Number of VDAM mini-batches: Number of mini-batches to be processed using the VDAM algorithm. Using 200 has given good results for many data sets. Using 100 will run faster, at the expense of some quality in the results.
Center class averages?: If set to Yes, every iteration the class average images will be centered on their center-of-mass. This will work only for positive signals, so the particles should be white.
Number of iterations: Number of iterations to be performed. Note that the current implementation does NOT comprise a convergence criterium. Therefore, the calculations will need to be stopped by the user if further iterations do not yield improvements in resolution or classes. If continue option is True, you going to do this number of new iterations (e.g. if *Continue from iteration* is set 3 and this param is set 25, the final iteration of the protocol will be the 28th.
Limit resolution E-step to (A): If set to a positive number, then the expectation step (i.e. the alignment) will be done only including the Fourier components up to this resolution (in Angstroms). This is useful to prevent overfitting, as the classification runs in RELION are not to be guaranteed to be 100% overfitting-free (unlike the _3D auto-refine_ with its gold-standard FSC). In particular for very difficult data sets, e.g. of very small or featureless particles, this has been shown to give much better class averages. In such cases, values in the range of 7-12 Angstroms have proven useful.
Perform image alignment?: If set to No, then rather than performing both alignment and classification, only classification will be performed. This allows the use of very focused masks. This requires that the optimal orientations of all particles are already calculated.
In-plane angular sampling (deg): The sampling rate for the in-plane rotation angle (psi) in degrees.
Using fine values will slow down the program. Recommended value for
most 2D refinements: 5 degrees. 

If auto-sampling is used, this will be the value for the first 
iteration(s) only, and the sampling rate will be increased 
automatically after that.
Initial offset range (pix): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
Initial offset step (pix): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid.
Allow coarser sampling?: If set to Yes, the program will use coarser angular and translational samplings if the estimated accuracies of the assignments is still low in the earlier iterations. This may speed up the calculations.
Use parallel disc I/O?: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
Number of pooled particles:: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Pre-read all particles into RAM?: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
Copy particles to scratch directory: : If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
Combine iterations through disc?: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Over-sampling: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--dont_combine_weights_via_disc
--verb 1
--pad 2

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "3D classification" can be found at the relion plugin.
Its help description is:
 
    Protocol to classify 3D using Relion Bayesian approach.
    Relion employs an empirical Bayesian approach to refinement of (multiple)
    3D reconstructions or 2D class averages in electron cryo-EM. Many
    parameters of a statistical model are learned from the data, which
    leads to objective and high-quality results.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: None
: None
Continue from a previous run?: If you set to *Yes*, you should select a previousrun of type *ProtRelionClassify3D* class and most of the input parameterswill be taken from it.
Input particles: Select the input images from the project.
Consider previous alignment?: If set to Yes, then alignment information from input particles will be considered.
Consider alignment as priors?: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
: None
Particle mask diameter (A): The experimental images will be masked with a soft circular mask with this <diameter>. Make sure this diameter is not set too small because that may mask away part of the signal! If set to a value larger than the image size no masking will be performed.

The same diameter will also be used for a spherical mask of the reference structures if no user-provided mask is specified.
Mask particles with zeros?: If set to <Yes>, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform. This will remove noise and therefore increase sensitivity in the alignment and classification. However, it will also introduce correlations between the Fourier components that are not modelled. When set to <No>, then the solvent area is filled with random noise, which prevents introducing correlations.High-resolution refinements (e.g. in 3D auto-refine) tend to work better when filling the solvent area with random noise, some classifications go better when using zeros.
Select previous run: Select a previous run to continue from.
Continue from iteration: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
Reference averages: This option is not recommended and should be used with care. The provided averages will be used as initial 2D references. If this option is used, the number of classes will be ignored. 
Input volume(s): Initial reference 3D map, it should have the same dimensions and the same pixel size as your input particles.
Reference mask (optional): A volume mask containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask. If no mask is given, a soft spherical mask based on the <radius> of the mask for the experimental images will be applied.

In some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. Check _Advaced_ level and select another volume mask
Second reference mask (optional): For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas.
Use solvent-flattened FSCs?: If set to Yes, then instead of using unmasked maps to calculate the gold-standard FSCs during refinement, masked half-maps are used and a post-processing-like correction of the FSC curves (with phase-randomisation) is performed every iteration. This only works when a reference mask is provided on the I/O tab. This may yield higher-resolution maps, especially when the mask contains only a relatively small volume inside the box.
Is initial 3D map on absolute greyscale?: The probabilities are based on squared differences, so that the absolute grey scale is important. 
Probabilities are calculated based on a Gaussian noise model, which contains a squared difference term between the reference and the experimental image. This has a consequence that the reference needs to be on the same absolute intensity grey-scale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity grey-scale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. Therefore: if the map was reconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No. If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent MAP refinement. Therefore, if in doubt it is recommended to set this option to No.
Symmetry: See [[https://relion.readthedocs.io/en/latest/Reference/Conventions.html#symmetry][Relion Symmetry]] page for a description of the symmetry format accepted by Relion
Initial low-pass filter (A): It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s).
CTF parameters are not available in continue mode: None
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Have data been phase-flipped?      (Don't answer, see help): The phase-flip status is recorded and managed by Scipion. 
 In other words, when you import or extract particles, 
Scipion will record whether or not phase flipping has been done.

Note that CTF-phase flipping is NOT a necessary pre-processing step 
for MAP-refinement in RELION, as this can be done inside the internal
CTF-correction. However, if the phases have been flipped, the program will handle it.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Do manual grouping ctfs?: Set this to Yes the CTFs will grouping manually.
Defocus range for group creation (in Angstroms): Particles will be grouped by defocus.This parameter is the bin for a histogram.All particles assigned to a bin form a group
minimum size for defocus group: If defocus group is smaller than this value, it will be expanded until number of particles per defocus group is reached
Number of classes:: The number of classes (K) for a multi-reference refinement. These classes will be made in an unsupervised manner from a single reference by division of the data into random subsets during the first iteration.
Regularisation parameter T: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D refinements, values of 1-2 for 2D refinements. Too small values yield too-low resolution structures; too high values result in over-estimated resolutions and overfitting.
Number of iterations: Number of iterations to be performed. Note that the current implementation does NOT comprise a convergence criterium. Therefore, the calculations will need to be stopped by the user if further iterations do not yield improvements in resolution or classes. If continue option is True, you going to do this number of new iterations (e.g. if *Continue from iteration* is set 3 and this param is set 25, the final iteration of the protocol will be the 28th.
Use fast subsets (for large data sets)?: If set to Yes, the first 5 iterations will be done with random subsets of only K*100 particles (K being the number of classes); the next 5 with K*300 particles, the next 5 with 30% of the data set; and the final ones with all data. This was inspired by a cisTEM implementation by Niko Grigorieff et al.
Use Blush regularisation?: If set to Yes, relion_refine will use a neural network to perform regularisation by denoising at every iteration, instead of the standard smoothness regularisation.
Limit resolution E-step to (A): If set to a positive number, then the expectation step (i.e. the alignment) will be done only including the Fourier components up to this resolution (in Angstroms). This is useful to prevent overfitting, as the classification runs in RELION are not to be guaranteed to be 100% overfitting-free (unlike the _3D auto-refine_ with its gold-standard FSC). In particular for very difficult data sets, e.g. of very small or featureless particles, this has been shown to give much better class averages. In such cases, values in the range of 7-12 Angstroms have proven useful.
Perform image alignment?: If set to No, then rather than performing both alignment and classification, only classification will be performed. This allows the use of very focused masks. This requires that the optimal orientations of all particles are already calculated.
Initial angular sampling (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
Initial offset range (pix): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
Initial offset step (pix): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid.
Perform local angular search?: If set to Yes, then rather than performing exhaustive angular searches, local searches within the range given below will be performed. A prior Gaussian distribution centered at the optimal orientation in the previous iteration and with a stddev of 1/3 of the range given below will be enforced.
Local angular search range: Local angular searches will be performed within +/- the given amount (in degrees) from the optimal orientation in the previous iteration. A Gaussian prior (also see previous option) will be applied, so that orientations closer to the optimal orientation in the previous iteration will get higher weights than those further away.
Relax symmetry: With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020.
Allow coarser sampling?: If set to Yes, the program will use coarser angular and translational samplings if the estimated accuracies of the assignments is still low in the earlier iterations. This may speed up the calculations.
Use parallel disc I/O?: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
Number of pooled particles:: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Skip padding: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
Pre-read all particles into RAM?: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
Copy particles to scratch directory: : If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
Combine iterations through disc?: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Over-sampling: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--dont_combine_weights_via_disc
--verb 1
--pad 2

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "clean project" can be found at the relion plugin.
Its help description is:
 
    Run Relion gentle clean procedure for the whole project.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Gentle clean procedure will move all intermediate files from finished Relion protocols to Trash folder. For iteration-based jobs, only the last iteration files are kept.: None

The protocol named "estimate gain reference" can be found at the relion plugin.
Its help description is:
 
    Using *relion_convert_to_tiff* to estimate the gain reference from a set of movies.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of movies to be used in the gain estimation.
Subset: Use a subset of the movies for the estimation. If 0, all input movies will be used. 
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "compress movies" can be found at the relion plugin.
Its help description is:
 
    Using *relion_convert_to_tiff* to compress a set of movies.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
Input gain estimation protocol (optional): Provide an estimate gain reference protocol from where the gain file will be taken.
Compression type: None
Deflate level: deflate level. 1 (fast) to 9 (slowest but best compression)
EER fractionation: The number of hardware frames to group into one fraction. This option is relevant only for Falcon4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
EER upsampling: EER upsampling (1 = 4K or 2 = 8K). 8K rendering is not recommended by Relion. See https://relion.readthedocs.io/en/latest/Reference/MovieCompression.html
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "create 3d mask" can be found at the relion plugin.
Its help description is:
  This protocols creates a 3D mask using Relion.
    The mask is created from a 3d volume or by comparing two input volumes.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: Select the volume that will be used to create the mask
Lowpass filter map by (A): Lowpass filter that will be applied to the input map, prior to binarization. To calculate solvent masks, a lowpass filter of 15-20A may work well.
Initial binarisation threshold: This threshold is used to make an initial binary mask from the average of the two unfiltered half-reconstructions. If you don't know what value to use, display one of the unfiltered half-maps in a 3D surface rendering viewer and find the lowest threshold that gives no noise peaks outside the reconstruction.
Compare with another volume to produce a mask?: Logical comparison of two input volumes to produce a mask
Input volume (second): Select the volume that will be compared to the first one
Operation: *AND*: Pixels in the initial mask will be one if the input AND the second volume are above the threshold value.
*OR*: Pixels in the initial mask will be one if the input OR the second volume are above the threshold value.
*AND_NOT*: pixels in the initial mask will be one if the input is above the threshold AND the second volume is below it.
*OR_NOT*: pixels in the initial mask will be one if the input is above the threshold OR the second volume is below it.
Extend binary mask by (px): The initial binary mask is extended this number of pixels in all directions.
Add a soft-edge (px): The extended binary mask is further extended with a raised-cosine soft edge of the specified width.
Invert final mask: Invert the final mask
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "ctf refinement" can be found at the relion plugin.
Its help description is:
  Wrapper protocol for the Relion's CTF refinement. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Provide a set of particles for local CTF refinement.
Input Postprocess: Select a PostProcess job. The mask used for this postprocessing will be applied to the unfiltered half-maps and should encompass the entire complex. The resulting FSC curve will be used for weighting the different frequencies.

Note that for helices it is common practice to use a mask only encompassing the central 30% or so of the box. This gives higher resolution estimates, as it disregards ill-defined regions near the box edges. However, for ctf_refine it is better to use a mask encompassing (almost) the entire box, as otherwise there may not be enough signal. 
Estimate (anisotropic) magnification?: If set to Yes, then relion_ctf_refine will also estimate the (anisotropic) magnification per optics group. This option cannot be done simultaneously with higher-order aberration estimation. It's probably best to estimate the one that is most off first, and the other one second. It might be worth repeating the estimation if both are off.
Perform CTF parameter fitting?: If set to Yes, then relion_ctf_refine will be used to estimate the selected parameters below.
Fit defocus?: If set to per-particle or per-micrograph, then relion_ctf_refine will estimate a defocus values.
Fit astigmatism? : If set to per-particle or per-micrograph, then relion_ctf_refine will estimate astigmatism.
Fit B-factor?: If set to per-particle or per-micrograph, then relion_ctf_refine will estimate B-factors that describe the signal falloff.
Fit phase-shift? : If set to per-particle or per-micrograph, then relion_ctf_refine will estimate astigmatism.
Estimate beamtilt?: If set to Yes, then relion_ctf_refine will also estimate the beamtilt per optics group. This option is only recommended for data sets that extend beyond 4.5 Angstrom resolution.
Also estimate trefoil?: If set to Yes, then relion_ctf_refine will also estimate the trefoil (3-fold astigmatism) per optics group. This option is only recommended for data sets that extend beyond 3.5 Angstrom resolution.
Estimate 4th order aberrations?: If set to Yes, then relion_ctf_refine will also estimate the Cs and the tetrafoil (4-fold astigmatism) per optics group. This option is only recommended for data sets that extend beyond 3 Angstrom resolution.
Minimum resolution for fits (A): The minimum spatial frequency (in Angstrom) used in the beam tilt fit.
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "expand symmetry" can be found at the relion plugin.
Its help description is:
  This protocols wraps relion_particle_symmetry_expand program.

    Given an input set of particles with angular assignment,
    expand the set by applying a pseudo-symmetry.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Symmetry group: See [[https://relion.readthedocs.io/en/latest/Reference/Conventions.html#symmetry][Relion Symmetry]] page for a description of the symmetry format accepted by Relion
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "export coordinates" can be found at the relion plugin.
Its help description is:
  Export coordinates from Relion to be used outside Scipion. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the SetOfCoordinates 

The protocol named "export ctf" can be found at the relion plugin.
Its help description is:
  Export a SetOfCTF to a Relion STAR file. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input CTF: Select set of CTF that you want to export.
Micrographs source: By default the micrograph used to create theexported STAR files are those used for the CTF estimation. You can selected *other* to use a different set of micrographs (e.g., dose weighted)
Input micrographs: Select the SetOfMicrographs from which to extract.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "export particles" can be found at the relion plugin.
Its help description is:
  Export particles from Relion to be used outside Scipion. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input images from the project.
Write alignment information?: If *Yes* the alignment information (2D or 3D) will be written to the resulting .star file if the particles contains such information.
Binary stack files: If *Don't write stacks* is chosen, only the star files will be written out. Alternatively, you can select to write images into a single stack file or several stacks (one per micrograph). 

The protocol named "particles extraction" can be found at the relion plugin.
Its help description is:
  Protocol to extract particles using a set of coordinates. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the SetOfCoordinates 
Micrographs source: By default the particles will be extracted from the micrographs used in the picking step ( _same as picking_ option ). 
If you select _other_ option, you must provide a different set of micrographs to extract from. 
*Note*: In the _other_ case, ensure that provided micrographs and coordinates are related by micName or by micId. Difference in pixel size will be handled automatically.
Input micrographs: Select the SetOfMicrographs from which to extract.
CTF estimation: Choose some CTF estimation related to input micrographs. 
 CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
Particle box size (px): This is size of the boxed particles (in pixels).
Rescale particles?: If set to Yes, particles will be re-scaled. Note that the re-scaled size below will be in the down-scaled images.
Re-scaled size (px): Final size in pixels of the extracted particles. The provided value should be an even number. 
Write output in float16?: Relion can write output images in float16 MRC (mode 12) format to save disk space. By default, float32 format is used.
Invert contrast?: Invert the contrast if your particles are black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background. Frealign (up to v9.07) requires black particles over a white background
Normalize particles?: If set to Yes, particles will be normalized in the way RELION prefers it.
Diameter background circle before scaling (px): Particles will be normalized to a mean value of zero and a standard-deviation of one for all pixels in the background area. The background area is defined as all pixels outside a circle with this given diameter in pixels (before rescaling). When specifying a negative value, a default value of 75% of the Particle box size will be used.
Stddev for white dust removal: : Remove very white pixels from the extracted particles. Pixels values higher than this many times the image stddev will be replaced with values from a Gaussian distribution. 
Use negative value to switch off dust removal.
Stddev for black dust removal: : Remove very black pixels from the extracted particles. Pixels values higher than this many times the image stddev will be replaced with values from a Gaussian distribution. 
Use negative value to switch off dust removal.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "import coordinates" can be found at the relion plugin.
Its help description is:
 
    Import coordinates from a particles star file.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input STAR file path with coordinates: None
Input micrographs: Select the micrographs for which you want to import coordinates.
Box size: None
Scale: Factor to scale coordinates
Invert X: None
Invert Y: Invert Y for EMAN coordinates taken on dm3 or tif micrographs

The protocol named "3D initial model" can be found at the relion plugin.
Its help description is:
  This protocols creates a 3D initial model using Relion.

    Generate a 3D initial model _de novo_ from 2D particles using
    Relion Stochastic Gradient Descent (SGD) algorithm.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Continue from a previous run?: If you set to *Yes*, you should select a previousrun of type *ProtRelionInitialModel* class and most of the input parameters will be taken from it.
Input particles: Select the input images from the project.
Particle mask diameter (A): The experimental images will be masked with a soft circular mask with this <diameter>. Make sure this diameter is not set too small because that may mask away part of the signal! If set to a value larger than the image size no masking will be performed.

The same diameter will also be used for a spherical mask of the reference structures if no user-provided mask is specified.
Select previous run: Select a previous run to continue from.
Continue from iteration: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
CTF parameters are not available in continue mode: None
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Have data been phase-flipped?      (Don't answer, see help): The phase-flip status is recorded and managed by Scipion. 
 In other words, when you import or extract particles, 
Scipion will record whether or not phase flipping has been done.

Note that CTF-phase flipping is NOT a necessary pre-processing step 
for MAP-refinement in RELION, as this can be done inside the internal
CTF-correction. However, if the phases have been flipped, the program will handle it.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Do manual grouping ctfs?: Set this to Yes the CTFs will grouping manually.
Defocus range for group creation (in Angstroms): Particles will be grouped by defocus.This parameter is the bin for a histogram.All particles assigned to a bin form a group
minimum size for defocus group: If defocus group is smaller than this value, it will be expanded until number of particles per defocus group is reached
Number of VDAM mini-batches: How many iterations (i.e. mini-batches) to perform with the VDAM algorithm?
Regularisation parameter T: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D initial model calculations.
Number of classes: The number of classes (K) for a multi-reference ab initio SGD refinement. These classes will be made in an unsupervised manner, starting from a single reference in the initial iterations of the SGD, and the references will become increasingly dissimilar during the in between iterations.
Flatten and enforce non-negative solvent?: If set to Yes, the job will apply a spherical mask and enforce all values in the reference to be non-negative.
Symmetry: The initial model is always generated in C1 and then aligned to and symmetrized with the specified point group. If the automatic alignment fails, please manually rotate run_itNNN_class001.mrc (NNN is the number of iterations) so that it conforms the symmetry convention.
Run in C1 and apply symmetry later?: If set to Yes, the gradient-driven optimisation is run in C1 and the symmetry orientation is searched and applied later. If set to No, the entire optimisation is run in the symmetry point group indicated above.
Use parallel disc I/O?: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
Number of pooled particles:: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Pre-read all particles into RAM?: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
Copy particles to scratch directory: : If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
Combine iterations through disc?: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--dont_combine_weights_via_disc
--verb 1
--pad 2

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "local resolution" can be found at the relion plugin.
Its help description is:
  This protocol does local resolution estimation using Relion.

    This program basically performs a series of post-processing operations
    with a small soft, spherical mask that is moved over the entire map,
    while using phase-randomisation to estimate the convolution effects
    of that mask.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Select a previous refinement protocol: Select any previous refinement protocol to get the 3D half maps. Note that it is recommended that the refinement protocol uses a gold-standard method.
User-provided solvent mask: Provide a mask with values between 0 and 1 around all domains of the complex. ResMap uses this mask for local resolution calculation. RELION does NOT use this mask for calculation, but makes a histogram of local resolution within this mask.
Calibrated pixel size (A): Provide the final, calibrated pixel size in Angstroms. If 0, the input pixel size will be used. This value may be different from the pixel-size used thus far, e.g. when you have recalibrated the pixel size using the fit to a PDB model. The X-axis of the output FSC plot will use this calibrated value.
Provide B-factor:: Probably, the overall B-factor as was estimated in the postprocess is a useful value for here. Use negative values for sharpening. Be careful: if you over-sharpen your map, you may end up interpreting noise for signal!
MTF of the detector: User-provided STAR-file with the MTF-curve of the detector.Relion param: <--mtf>
Original detector pixel size (A): This is the original pixel size (in Angstroms) in the raw (non-super-resolution!) micrographs
Select Advanced level if you want to adjust the parameters: None
Sampling rate (A): Sampling rate (in Angstroms) with which to sample the local-resolution map
Mask radius (A): Radius (in A) of spherical mask for local-resolution map (default = 0.5*sampling)
Edge width (A): Width of soft edge (in A) on masks for local-resolution map (default = sampling)
Randomize phases from (A): Randomize phases from this resolution (in A)
Lowest res limit (A): Lowest local resolution allowed (in A)
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "motion correction" can be found at the relion plugin.
Its help description is:
  Wrapper for the Relion's implementation of motioncor algorithm. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
from: None
to: None
Do dose-weighting?: If set to Yes, the averaged micrographs will be dose-weighted.
Save non-dose weighted as well?: Aligned but non-dose weighted images are sometimes useful in CTF estimation, although there is no difference in most cases. Whichever the choice, CTF refinement job is always done on dose-weighted particles.
Save sum of power spectra?: Sum of non-dose weighted power spectra provides better signal for CTF estimation. The power spectra can be used by CTFFIND4 but not by GCTF.
Sum power spectra every e/A2: McMullan et al. (Ultramicroscopy, 2015) suggests summing power spectra every 4.0 e/A2 gives optimal Thon rings.
Write output in float16?: Relion can write output images in float16 MRC (mode 12) format to save disk space. By default, float32 format is used.
Compute PSD?: If Yes, the protocol will compute for each aligned micrograph the PSD using EMAN2.
Compute micrograph thumbnail?: When using this option, we will compute a micrograph thumbnail with EMAN2 and keep it with the micrograph object for visualization purposes.
Additional arguments: Extra parameters for Relion motion correction. 
Bfactor: The B-factor that will be applied to the micrographs.
X: None
Y: None
Group frames: Average together this many frames before calculating the beam-induced shifts.
Binning factor: Bin the micrographs this much by a windowing operation in the Fourier Transform. Binning at this level is hard to un-do later on, but may be useful to down-scale super-resolution images. Float-values may be used. Do make sure though that the resulting micrograph size is even.
Gain rotation: Rotate the gain reference by this number times 90 degrees clockwise in relion_display. This is the same as -RotGain in MotionCor2. 
Note that MotionCor2 uses a different convention for rotation so it says 'counter-clockwise'.
Gain flip: Flip the gain reference after rotation. This is the same as -FlipGain in MotionCor2. 0 means do nothing, 1 means flip Y (upside down) and 2 means flip X (left to right).
Defects file: Location of a UCSF MotionCor2-style defect text file or a defect map that describe the defect pixels on the detector. Each line of a defect text file should contain four numbers specifying x, y, width and height of a defect region. A defect map is an image (MRC or TIFF), where 0 means good and 1 means bad pixels. The coordinate system is the same as the input movie before application of binning, rotation and/or flipping.

_Note that the format of the defect text is DIFFERENT from the defect text produced by SerialEM!_
 One can convert a SerialEM-style defect file into a defect map using IMOD utilities e.g.:
*clip defect -D defect.txt -f tif movie.tif defect_map.tif*
See explanations in the SerialEM manual.
Leave empty if you do not have any defects, or do not want to correct for defects on your detector.
EER fractionation: The number of hardware frames to group into one fraction. This option is relevant only for Falcon4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
EER upsampling: EER upsampling (1 = 4K or 2 = 8K). 8K rendering is not recommended by Relion. See https://relion.readthedocs.io/en/latest/Reference/MovieCompression.html
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "3D multi-body" can be found at the relion plugin.
Its help description is:
 
    Relion protocol for multi-body refinement.

    This approach models flexible complexes as a user-defined number of rigid
    bodies that move independently of each other.
    Using separate focused refinements with iteratively improved partial
    signal subtraction, improved reconstructions are generated for
    each of the defined bodies.

    Moreover, using PCA on the relative orientations of the bodies
    over all particle images in the data set, we generate movies that describe
    the most important motions in the data.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Continue from a previous run?: If you set to *Yes*, you should select a previous MultiBody protocol and most of the input parameters will be taken from it.
Consensus refinement protocol: Select any previous refinement protocol from where to run the multi-body refinement. The output volume will be used and some parameters from the optimiser.star file. 
Body STAR file: Provide the STAR file with all information about the bodies to be used in multi-body refinement. An example for a three-body refinement would look like this:

data_
loop_
_rlnBodyMaskName
_rlnBodyRotateRelativeTo
_rlnBodySigmaAngles
_rlnBodySigmaOffset
large_body_mask.mrc 2 10 2
small_body_mask.mrc 1 10 2
head_body_mask.mrc 2 10 2


 Where each data line represents a different body, and:
 - rlnBodyMaskName contains the name of a soft-edged mask with values in [0,1] that define the body; the mask name should be relative to the project folder;
 - rlnBodyRotateRelativeTo defines relative to which other body this body rotates (first body is number 1);
 - rlnBodySigmaAngles and _rlnBodySigmaOffset are the standard deviations (widths) of Gaussian priors on the consensus rotations and translations;

 Optionally, there can be a fifth column with _rlnBodyReferenceName. Entries can be 'None' (without the ''s) or the name of a MRC map with an initial reference for that body. In case the entry is None, the reference will be taken from the density in the consensus refinement.

Also note that larger bodies should be above smaller bodies in the STAR file. For more information, see the multi-body paper.
                           
Reconstruct subtracted bodies?: If set to Yes, then the reconstruction of each of the bodies will use the subtracted images. This may give useful insights about how well the subtraction worked. If set to No, the original particles are used for reconstruction (while the subtracted ones are still used for alignment). This will result in fuzzy densities for bodies outside the one used for refinement.
Use Blush regularisation?: If set to Yes, relion_refine will use a neural network to perform regularisation by denoising at every iteration, instead of the standard smoothness regularisation.
Select previous run: Select a previous run to continue from.
Continue from iteration: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
Initial angular sampling (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere. 

Note that this will only be the value for the first few iteration(s): the sampling rate will be increased automatically after that.
Initial offset range (pix): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration. 

Note that this will only be the value for the first few iteration(s): the sampling rate will be increased automatically after that.
Initial offset step (pix): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid. 

Note that this will only be the value for the first few iteration(s): the sampling rate will be increased automatically after that.
Run flexibility analysis?: If set to Yes, after the multi-body refinement has completed, a PCA analysis will be run on the orientations all all bodies in the data set. This can be set to No initially, and then the job can be continued afterwards to only perform this analysis.
Number of eigenvector movies:: Series of ten output maps will be generated along this many eigenvectors. These maps can be opened as a "Volume Series" in UCSF Chimera, and then displayed as a movie. They represent the principal motions in the particles.
Select particles based on eigenvalues?: If set to Yes, a particles.star file is written out with all particles that have the below indicated eigenvalue in the selected range.
Select on eigenvalue:: This is the number of the eigenvalue to be used in the particle subset selection (start counting at 1).
min: None
max: None
Use parallel disc I/O?: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
Number of pooled particles:: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Skip padding: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
Pre-read all particles into RAM?: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
Copy particles to scratch directory: : If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
Combine iterations through disc?: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. They will be appended to the relion_refine command.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "post-processing" can be found at the relion plugin.
Its help description is:
 
    Relion post-processing protocol for automated masking,
    overfitting estimation, MTF-correction and B-factor sharpening.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Start from Relion refinement?: Set to Yes if you wish to use as input a Relion protocol. Otherwise set it to No
Input half map 1: You might want to provide input half maps manually, in case you did not use 3D auto-refine or multi-body protocol that generates them automatically.
Input half map 2: You might want to provide input half maps manually, in case you did not use 3D auto-refine or multi-body protocol that generates them automatically.
Select a previous refinement protocol: Select any previous refinement protocol to get the 3D half maps. Note that it is recommended that the refinement protocol uses a gold-standard method.
Which body to process?: Only relevant if input protocol is 3D multi-body.
Solvent mask: Provide a soft mask where the protein is white (1) and the solvent is black (0). Often, the softer the mask the higher resolution estimates you will get. A soft edge of 5-10 pixels is often a good edge width.
Calibrated pixel size (A): Provide the final, calibrated pixel size in Angstroms. If 0, the input pixel size will be used. This value may be different from the pixel-size used thus far, e.g. when you have recalibrated the pixel size using the fit to a PDB model. The X-axis of the output FSC plot will use this calibrated value.
MTF of the detector: User-provided STAR-file with the MTF-curve of the detector. Use the wizard to load one of the predefined ones provided at:
- [[https://www3.mrc-lmb.cam.ac.uk/relion/index.php/FAQs#Where_can_I_find_MTF_curves_for_typical_detectors.3F][Relion's Wiki FAQs]]
 - [[https://www.gatan.com/techniques/cryo-em#MTF][Gatan's website]]

Relion param: *--mtf*
Original detector pixel size (A): This is the original pixel size (in Angstroms) in the raw (non-super-resolution!) micrographs
Estimate B-factor automatically?: If set to Yes, then the program will use the automated procedure described by Rosenthal and Henderson (2003, JMB) to estimate an overall B-factor for your map, and sharpen it accordingly.
low: None
high: None
Provide B-factor:: User-provided B-factor (in A^2) for map sharpening, e.g. -400. Use negative values for sharpening. Be careful: if you over-sharpen
your map, you may end up interpreting noise for signal!
Relion param: *--adhoc_bfac*
Skip FSC-weighting for sharpening?: If set to No (the default), then the output map will be low-pass filtered according to the mask-corrected, gold-standard FSC-curve. Sometimes, it is also useful to provide an ad-hoc low-pass filter (option below), as due to local resolution variations some parts of the map may be better and other parts may be worse than the overall resolution as measured by the FSC. In such  cases, set this option to Yes and provide an ad-hoc filter as described below.
Ad-hoc low-pass filter (A):: This option allows one to low-pass filter the map at a user-provided frequency (in Angstroms). When using a resolution that is higher than the gold-standard FSC-reported resolution, take care not to interpret noise in the map for signal.
Low-pass filter edge width:: Width of the raised cosine on the low-pass filter edge (in resolution shells)
Relion param: *--filter_edge_width*
Randomize phases threshold: Randomize phases from the resolution where FSC drops below this value
Relion param: *--randomize_at_fsc*
Force mask?: Use the mask even when the masked resolution is worse than the unmasked resolution.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "preprocess particles" can be found at the relion plugin.
Its help description is:
  This protocol wraps relion_preprocess program.

    It is used to perform normalisation, filtering or scaling of
    the particles.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input images from the project.
Normalize: If set to True, particles will be normalized in theway RELION prefers it. It is recommended to *always normalize your particles*, and use a reasonable radius for the circle around your particles outside of which the standard deviation and average values for the noise are calculated.
*Note*: if the particles are re-scaled, the radius for normalize will be taken over the new dimensions.
Background radius (px): Pixels outside this circle are assumed to be noise and their stddev is set to 1. Radius for background circle definition (in pixel).
Remove dust from particles: If there are white or black artifacts on the micrographs (e.g. caused by dust or hot/dead pixels), these may be removed by using a positive value for the dust removal options. All black/white pixels with values above the given parameter times the standard deviation of the noise are replaced by random values from aGaussian distribution. For cryo-EM data, valuesaround 3.5-5 are often useful. Make sure you do not erase part of the true signal.
White: None
Black: None
Invert contrast: Invert the contrast if your particles are black over a white background.
Scale particles?: Re-scale the particles to this size (in pixels).
Scale size (px): New particle size in pixels.
Window particles?: Re-window the particles to this size (in pixels).
Window size (px): New particles windows size (in pixels).
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "reconstruct" can be found at the relion plugin.
Its help description is:
  This protocol reconstructs a volume using Relion.

    Reconstruct a volume from a given set of particles.
    The alignment parameters will be converted to a Relion star file
    and used as direction projections to reconstruct.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input images from the project.
Symmetry group: See [[https://relion.readthedocs.io/en/latest/Reference/Conventions.html#symmetry][Relion Symmetry]] page for a description of the symmetry format accepted by Relion
Maximum resolution (A): Maximum resolution (in Angstrom) to consider 
in Fourier space (default Nyquist).
Padding factor: None
Subset to reconstruct: Subset of images to consider.
Use only this class: Consider only this class (-1: use all classes)
Extra parameters: : Extra parameters to *relion_reconstruct* program. Address to Relion to see full list of options.
Apply CTF correction?: None
Leave CTFs intact until first peak?: None
Correct for Ewald-sphere curvature?: None
Skip masking?: Do not apply real space mask during Ewald sphere correction.
Mask diameter (A): Diameter (in A) of mask for Ewald-sphere curvature correction
Add a soft-edge (px): Width (in pixels) of the soft edge on the mask.
Reverse curvature?: None
New box size (px): Box size of reconstruction after Ewald sphere correction.
Number of sectors: Number of sectors for Ewald sphere correction.
Skip weighting?: Do not apply weighting during during Ewald sphere correction.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "3D auto-refine" can be found at the relion plugin.
Its help description is:
  Protocol to refine a 3D map using Relion.

Relion employs an empirical Bayesian approach to refinement
of (multiple) 3D reconstructions
or 2D class averages in electron cryo-microscopy (cryo-EM). Many
parameters of a statistical model are learned from the data,which
leads to objective and high-quality results.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: None
: None
Continue from a previous run?: If you set to *Yes*, you should select a previousrun of type *ProtRelionRefine3D* class and most of the input parameterswill be taken from it.
Input particles: Select the input images from the project.
Consider previous alignment?: If set to Yes, then alignment information from input particles will be considered.
Consider alignment as priors?: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
: None
Particle mask diameter (A): The experimental images will be masked with a soft circular mask with this <diameter>. Make sure this diameter is not set too small because that may mask away part of the signal! If set to a value larger than the image size no masking will be performed.

The same diameter will also be used for a spherical mask of the reference structures if no user-provided mask is specified.
Mask particles with zeros?: If set to <Yes>, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform. This will remove noise and therefore increase sensitivity in the alignment and classification. However, it will also introduce correlations between the Fourier components that are not modelled. When set to <No>, then the solvent area is filled with random noise, which prevents introducing correlations.High-resolution refinements (e.g. in 3D auto-refine) tend to work better when filling the solvent area with random noise, some classifications go better when using zeros.
Select previous run: Select a previous run to continue from.
Continue from iteration: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
Reference averages: This option is not recommended and should be used with care. The provided averages will be used as initial 2D references. If this option is used, the number of classes will be ignored. 
Input volume: Initial reference 3D map, it should have the same dimensions and the same pixel size as your input particles.
Reference mask (optional): A volume mask containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask. If no mask is given, a soft spherical mask based on the <radius> of the mask for the experimental images will be applied.

In some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. Check _Advaced_ level and select another volume mask
Second reference mask (optional): For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas.
Use solvent-flattened FSCs?: If set to Yes, then instead of using unmasked maps to calculate the gold-standard FSCs during refinement, masked half-maps are used and a post-processing-like correction of the FSC curves (with phase-randomisation) is performed every iteration. This only works when a reference mask is provided on the I/O tab. This may yield higher-resolution maps, especially when the mask contains only a relatively small volume inside the box.
Is initial 3D map on absolute greyscale?: The probabilities are based on squared differences, so that the absolute grey scale is important. 
Probabilities are calculated based on a Gaussian noise model, which contains a squared difference term between the reference and the experimental image. This has a consequence that the reference needs to be on the same absolute intensity grey-scale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity grey-scale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. Therefore: if the map was reconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No. If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent MAP refinement. Therefore, if in doubt it is recommended to set this option to No.
Symmetry: See [[https://relion.readthedocs.io/en/latest/Reference/Conventions.html#symmetry][Relion Symmetry]] page for a description of the symmetry format accepted by Relion
Initial low-pass filter (A): It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s).
CTF parameters are not available in continue mode: None
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Have data been phase-flipped?      (Don't answer, see help): The phase-flip status is recorded and managed by Scipion. 
 In other words, when you import or extract particles, 
Scipion will record whether or not phase flipping has been done.

Note that CTF-phase flipping is NOT a necessary pre-processing step 
for MAP-refinement in RELION, as this can be done inside the internal
CTF-correction. However, if the phases have been flipped, the program will handle it.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Do manual grouping ctfs?: Set this to Yes the CTFs will grouping manually.
Defocus range for group creation (in Angstroms): Particles will be grouped by defocus.This parameter is the bin for a histogram.All particles assigned to a bin form a group
minimum size for defocus group: If defocus group is smaller than this value, it will be expanded until number of particles per defocus group is reached
Perform image alignment?: If set to No, then rather than performing both alignment and classification, only classification will be performed. This allows the use of very focused masks. This requires that the optimal orientations of all particles are already calculated.
Initial angular sampling (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
Initial offset range (pix): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
Initial offset step (pix): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid.
Local search from auto-sampling (deg): In the automated procedure to increase the angular samplings, local angular searches of -6/+6 times the sampling rate will be used from this angular sampling rate onwards.
Relax symmetry: With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020.
Use finer angular sampling faster?: If set to Yes, then let auto-refinement proceed faster with finer angular samplings. Two additional command-line options will be passed to the refine program:

	--auto_ignore_angles lets angular sampling go down despite changes still happening in the angles
	--auto_resol_angles lets angular sampling go down if the current resolution already requires that sampling at the edge of the particle.

This option will make the computation faster, but has not been tested for many cases for potential loss in reconstruction quality upon convergence.
Use Blush regularisation?: If set to Yes, relion_refine will use a neural network to perform regularisation by denoising at every iteration, instead of the standard smoothness regularisation.
Use parallel disc I/O?: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
Number of pooled particles:: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Skip padding: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
Pre-read all particles into RAM?: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
Copy particles to scratch directory: : If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
Combine iterations through disc?: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Over-sampling: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--dont_combine_weights_via_disc
--verb 1
--pad 2
--low_resol_join_halves 40 (only not continue mode)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "remove preferential views" can be found at the relion plugin.
Its help description is:
  Protocol to remove preferential views from a particle set.

    Inspired by https://github.com/leschzinerlab/Relion

    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Provide a set of particles.
Number of particles to remove: Number of particles to remove WITHIN the limits below.
min: None
max: None
min: None
max: None
Remove views with specific in-plane rotation?: Particle orientation on Euler sphere is defined by rot and tilt angles. Psi is for in-plane rotation only. Select *Yes* if you want to provide psi limits.
min: None
max: None

The protocol named "crop/resize volumes" can be found at the relion plugin.
Its help description is:
  This protocol rescales/resizes 3D volumes using relion_image_handler. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: Can be a Volume or a SetOfVolumes.
Rescale volumes?: None
New sampling rate (Å/px): None
Resize volumes to a new box?: None
New box size (px): Provide even box size.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "2D class ranker" can be found at the relion plugin.
Its help description is:
 
    Relion protocol to auto-select 2D class averages.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Relion 2D classification: None
Min. threshold for auto-selection: Only classes with a predicted threshold above this value will be selected.
Select at least this many particles: Even if they have scores below the minimum threshold, select at least this many particles with the best scores.
OR: Select at least this many classes: Even if they have scores below the minimum threshold, select at least this many classes with the best scores.

The protocol named "subtract projection" can be found at the relion plugin.
Its help description is:
  Signal subtraction protocol of Relion.

    Subtract volume projections from the experimental particles.
    The particles must have projection alignment in order to
    properly generate volume projections.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Start from Relion protocol?: Set to Yes if you wish to use as input a Relion protocol. Otherwise set it to No
Input Relion protocol: Select the 3D refinement/classification or multi-body run which you want to use for subtraction. It will use the maps from this run for the subtraction.
Input map to be projected: Provide the input volume that will be used to calculate projections, which will be subtracted from the experimental particles. Make sure this map was calculated by RELION from the same particles as above, and preferably with those orientations, as it is crucial that the absolute greyscale is the same as in the experimental particles.
Use all particles from input protocol?: If No, then you need to provide a subset of particles below.
Input particles subset: Select the particles which are a SUBSET of the input protocol provided above.
Input particles: Select the input particles.
Mask of the signal to keep: Provide a soft mask where the protein density you wish to subtract from the experimental particles is black (0) and the density you wish to keep is white (1).
That is: *the mask should INCLUDE the part of the volume that you wish to KEEP.*
Write output in float16?: Relion can write output images in float16 MRC (mode 12) format to save disk space. By default, float32 format is used.
This section is only used if starting from Relion input.: None
Do center subtracted images on mask?: If set to Yes, the subtracted particles will be centered on projections of the center-of-mass of the input mask.
Do center on my coordinates?: If set to Yes, the subtracted particles will be centered on projections of the x,y,z coordinates below. The unit is pixel, not angstrom. The origin is at the center of the box, not at the corner.
X: None
Y: None
Z: None
New box size: Provide a non-negative value to re-window the subtracted particles in a smaller box size.
This section is only used if NOT starting from Relion protocol.: None
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "symmetrize volume" can be found at the relion plugin.
Its help description is:
 
    Symmetrize a volume using Relion programs:
        *relion_align_symmetry* and *relion_image_handler*.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: Select the input volume to be symmetrized. 
Symmetry: Select which symmetry do you want to apply. 
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "2D particles to subtomograms" can be found at the tomo plugin.
Its help description is:
  Protocol to create a set of subtomograms from a selected 2D particles.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set of subtomograms: Select the set of subtomograms 
Input set: Select the 2D classes or a set of particles

The protocol named "2d coordinates to 3d coordinates" can be found at the tomo plugin.
Its help description is:
  Turns 2d coordinates into set of 3d coordinates. Works in coordination with 'tomograms to micrographs' protocol.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomograms: Select the tomograms to be associated to the 3D coordinates
2D Coordinates: Set of 2d coordinates picked on tomogram slices.

The protocol named "assign alignment" can be found at the tomo plugin.
Its help description is:
  Assign the alignment stored in a set of Subtomograms/Coordinates3D
    to another set.
    Both sets should have same pixel size (A/px).
    The Subtomograms/Coordinates3D with the alignment can also be a subset of a bigger set.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input: Select the Subtomograms/Coordinates3D that you want to update the new alignment.
Alignments: Select the Subtomograms/Coordinates3D with alignment to be apply to the other object.

The protocol named "assign tomos to subtomos" can be found at the tomo plugin.
Its help description is:
  This protocol assign tomograms to subtomograms that have been imported before without tomograms.
    Subtomograms should contain the name of the original tomogram in their own file name.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Subtomograms: Select the subtomograms that you want to update with original tomograms as precedents.The subtomograms should contain the original tomogram name in their own filename.
Tomograms: Select the tomograms to be assigned to the subtomograms.

The protocol named "assign tomograms to tomo masks (segmentations)" can be found at the tomo plugin.
Its help description is:
  This protocol assign tomograms to tomomasks (segmentations)..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomo masks (segmentations): Select the tomo masks desired to be referred to the introduced tomograms. The match between both sets is carried out firstly by tsId and if not possible, then it will try to do it by filename.
Tomograms: Select the tomograms to be assigned to the input tomo masks.

The protocol named "Tilt-series assign alignment" can be found at the tomo plugin.
Its help description is:
 
    Assign the transformation matrices from an input set of tilt-series to a target one.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tilt-series from which to take the alignment: Set of tilt-series from which transformation matrices will be obtained.
Tilt-series to assign the alignment to: Set of tilt-series on which transformation matrices will be assigned.
Combine alignments: If this option is selected and the the tilt-series to assign the alignment has a previous alignment, both precious and new alignment are combined.

The protocol named "ctf consensus tomo" can be found at the tomo plugin.
Its help description is:
 
     Validate a set of CTF tomo series and separate into two sets (good and
     bad tomo series )
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input ctf tomo series: None
Input secondary ctf tomo series: CTF tomo series to be compared with reference CTF
Validation type: Global mode: the series with at least one image that does not satisfy the criteria are rejected 
Per tilt mode: the series containing a certain number of images that does not satisfy the criteria are rejected
Number of images to rejected: Number of images taking into account to rejected a ctf series
Defocus tolerance: Validate the defocus deviation taking into account a threshold(tolerance) respect to a defocus expected value.
Tolerance value defocus: Defocus tolerance value calculates as: 
asb(error)/mean_defocus
Astigmatism: Validate the astigmatism taking into account a tolerance value.
Tolerance value astigmatism: Astigmatism tolerance value calculated as: 
asb(error)/mean_astigmatism
Resolution: Validate the resolution taking into account a expected resolution.
Minimum consensus resolution (A): Minimum value for the consensus resolution in Angstroms.
If there are noticeable discrepancies between the two estimations below this resolution, it will be discarded. 'Option for calculating consensus resolution. The algorithm assumes that two CTF are consistent if the phase (wave aberration function) of the two CTFs are closer than 90 degrees.
The reported consensusResolution is the resolution at which the two CTF phases differ in 90 degrees.'
Average equivalent metadata?: If *Yes*, making an average of those metadata present in both CTF estimations (defocus, astigmatism angle...)
 If *No*, the primary estimation metadata will persist.
Include all secondary metadata?: If *Yes*, all metadata in the *Secondary CTF* will be included in the resulting CTF.
 If *No*, only the primary metadata (plus consensus scores) will be in the resulting CTF.

The protocol named "ctf validate" can be found at the tomo plugin.
Its help description is:
 
     Validate a set of CTF tomo series and separate into two sets (good and
     bad tomo series )
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input ctf tomo series: None
Validation type: Global mode: the series with at least one image that does not satisfy the criteria are rejected 
Per tilt mode: the series containing a certain number of images that does not satisfy the criteria are rejected
Number of images to rejected: Number of images taking into account to rejected a ctf series
Defocus tolerance: Validate the defocus deviation taking into account a threshold(tolerance) respect to a defocus expected value.
Expected value (Å): Defocus expected value in Å
Tolerance value (Å): Defocus tolerance value in Å
Astigmatism: Validate the astigmatism taking into account a tolerance value.
Tolerance value: Astigmatism tolerance value
Resolution: Validate the resolution taking into account a expected resolution.
Expected value: Expected resolution value

The protocol named "Compose Tilt Series" can be found at the tomo plugin.
Its help description is:
  Compose in streaming a set of tilt series based on a set of micrographs and mdoc files.
    Two time parameters are available for the streaming behaviour:
    Time to next tilt and time to next tilt series
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: Select the SetOfMicrographs to import
Path with the *.mdoc files for each tilt series: Root directory of the tilt-series. Use of * will work for multiple characters or ? for a single one. Also [] can specify ranges.
Mdoc pattern: Pattern that should match for mdoc files.Use of * will work for multiple characters or ? for a single one. Also [] can specify ranges.
Exclusion words: Space separated words that will be used to exclude mdoc files that could be listed with the above parameters.
mdoc bug Correction: Setting True, the mdoc generated by SerialEM will be read considering the bug
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Time for next Tilt (secs): Delay (in seconds) until the next tilt is registered in the mdoc file. After timeout, if there is no new tilt, the tilt series is considered as completed.Minimum time recommended 20 secs
Time for next tilt series (secs): Interval of time (in seconds) after which, if no new tilt series is detected, the protocol will end. The default value is  high (30 min) to avoid the protocol finishes during the acq of the microscope. You can also stop it from right click and press STOP_STREAMING.

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Tilt-series consensus alignment" can be found at the tomo plugin.
Its help description is:
 
    Perform a consensus of a set of alignments for the same tilt series. Returns the average alignment matrix of the
    consensus alignments and its standard deviation of shift and angle.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tilt series: Select several sets of tilt-series where to evaluate the consensus in their alignment. Output set will bring the information from the first selected set.
Shift tolerance (A): Maximum shift difference between alignments to consider them as equal. it is measured in Angstroms.
Angle tolerance (degrees): Maximum angle difference between alignments to consider them as equal. It is measured in degrees
Consensus: Criteria for consensus alignment. If local, consensus will be performed to the tilt-images individually (different consensus applied individually) and if there is no consensus in some image the series will be discarded. If global, consensus will be performed at the level o tilt-series (the whole pair of alignments must agree).

The protocol named "consensus classes subtomo" can be found at the tomo plugin.
Its help description is:
  Compare several SetOfClassesSubTomograms.
        Return the intersection of the input classes.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Classes: Select several sets of classes where to evaluate the intersections.

The protocol named "import coordinates 3D" can be found at the tomo plugin.
Its help description is:
 Protocol to import a set of tomograms to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Coordinates sampling rate [Å/pix] (opt.): If empty, the coordinates' sampling rate will be considered to be the same as the tomograms'.
*IMPORTANT*: If a value is provided, the ratio of both tomograms and coordinates sampling rate will be used to scale the coordinates properly to the tomograms introduced.
Box Size [pix]: It will be re-scaled to the tomogram size considering the coordinates and tomograms ratio between their corresponding sampling rates.
Input tomograms: Select the tomograms to which the coordinates should be referred to.
The file names of the tomogram and coordinate files must be the same.

The protocol named "import 3D coordinates from scipion" can be found at the tomo plugin.
Its help description is:
 Protocol to import a set of 3d coordinates from Scipion sqlite file.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Scipion sqlite file: None
Input tomograms: Select the tomograms to which the coordinates should be referred to. The matching between coordinates and tomograms is made checking the tsId/tomoId attribute. If no matches are found, then it tries to do it comparing the filenames. *IMPORTANT*: the coordinates will be assumed to be at the same sampling rate as the introduced tomograms.
Box Size [pix]: None

The protocol named "import subtomograms" can be found at the tomo plugin.
Its help description is:
 Protocol to import a set of tomograms to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Pixel size (sampling rate) Å/px: None
Import from: Select the type of import.
Acquisition parameters file: File with the acquisition parameters for each tomogram or subtomogram to import. File must be in plain format. The file must contain a row per file to be imported and have the following parameters in order: 

'File_name AcquisitionAngleMin AcquisitionAngleMax Step TiltAxisAngle' 

An example would be:
subtomo1.em -40 40 3 85
subtomo2.em -45 50 2 85

Acquisition angle max: Enter the positive limit of the acquisition angle
Acquisition angle min: Enter the negative limit of the acquisition angle
Step: Enter the step size for the import
Tilt axis angle (deg.): The rotation angle is the angle from the vertical to the axis of tilting, where counterclockwise is positive.
 See https://bio3d.colorado.edu/imod/doc/tomoguide.html#UnknownAxisAngle
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.

The protocol named "import tilt-series coordinates" can be found at the tomo plugin.
Its help description is:
 Protocol to import a set of tilt-series coordinates 3D.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input set of tilt-series: None

The protocol named "import tomograms" can be found at the tomo plugin.
Its help description is:
 Protocol to import a set of tomograms to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Pixel size (sampling rate) Å/px: None
Import from: Select the type of import.
Acquisition parameters file: File with the acquisition parameters for each tomogram or subtomogram to import. File must be in plain format. The file must contain a row per file to be imported and have the following parameters in order: 

'File_name AcquisitionAngleMin AcquisitionAngleMax Step TiltAxisAngle' 

An example would be:
subtomo1.em -40 40 3 85
subtomo2.em -45 50 2 85

Acquisition angle max: Enter the positive limit of the acquisition angle
Acquisition angle min: Enter the negative limit of the acquisition angle
Step: Enter the step size for the import
Tilt axis angle (deg.): The rotation angle is the angle from the vertical to the axis of tilting, where counterclockwise is positive.
 See https://bio3d.colorado.edu/imod/doc/tomoguide.html#UnknownAxisAngle
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Set origin of coordinates: Option YES:
A new volume will be created with the given ORIGIN of coordinates. This ORIGIN will be set in the map file header.
The ORIGIN of coordinates will be placed at the center of the whole volume if you select n(x)/2, n(y)/2, n(z)/2 as x, y, z coordinates (n(x), n(y), n(z) are the dimensions of the whole volume). However, selecting 0, 0, 0 as x, y, z coordinates, the volume will be placed at the upper right-hand corner.

Option NO:
The ORIGIN of coordinates will be placed at the center of the whole volume (coordinates n(x)/2, n(y)/2, n(z)/2 by default). This ORIGIN will NOT be set in the map file header.

WARNING: In case you want to process the volume with programs requiring a specific symmetry regarding the origin of coordinates, for example the protocol extract unit cell, check carefully that the coordinates of the origin preserve the symmetry of the whole volume. This is particularly relevant for loading fragments/subunits of the whole volume.

From mrc header: Use origin information in mrc headers of the tomograms.
x: offset along x axis (Angstroms)
y: offset along y axis (Angstroms)
z: offset along z axis (Angstroms)

The protocol named "import tomomasks (segmentations)" can be found at the tomo plugin.
Its help description is:
 Protocol to import a set of tomomasks (segmentations) to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Tomograms: Select the tomograms to be assigned to the input tomo masks.

The protocol named "import tilt-series" can be found at the tomo plugin.
Its help description is:
 Protocol to import tilt series..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Files directory: Root directory of the tilt-series (or movies) files.
Pattern: This determines if the tilt series / movies are going to be imported using the mdoc files or the tilt series files. To import from the mdoc files, the word '.mdoc' must appear in the pattern, if not, a tilt series pattern is expected. In the first case, the angular and acquisition data are read from the corresponding mdoc files, while in the second case they are read from the name of the matching files.

*IMPORTING WITH MDOC FILES*

For *tilt series movies*, ONE mdoc per tilt series is expected. The movie files must be located in the same folder as the mdocs. The filenames will be fetched from the _SubFramePath_ value in mdoc. 
Example pattern: _TS*.mdoc_

For *tilt series*, ONE _mrcs_ stack should match ONE mdoc file per each tilt series. To import unstacked images use the filename pattern (see below) instead of mdoc.

*IMPORTING WITH A FILENAME PATTERN (tilt series and movies)*

The pattern can contain wildcards such as *, ?, etc. It should also contain the following special tags:

   *{TS}*: tilt series identifier, which can be any UNIQUE part of the path. This must be an alpha-numeric sequence (avoid dash (-) symbol) and can not start with a number.
   *{TO}*: acquisition order, an integer value (important for dose information).
   *{TA}*: tilt angle, a positive or negative float value.

Example:

To import a set of images (tilt-series or tilt-series movies) like: 
TiltSeries_a_001_0.0.mrc
TiltSeries_a_002_3.0.mrc
TiltSeries_a_003_-3.0.mrc
...
TiltSeries_b_001_0.0.mrc
TiltSeries_b_002_3.0.mrc
TiltSeries_b_003_-3.0.mrc
...
Use pattern TiltSeries_{TS}_{TO}_{TA}.mrc, which will identify:
{TS} as a, b, ...
{TO} as 001, 002, 003, ...
{TA} as 0.0, 3.0, -3.0, ...

Tomo5 mdoc?: If these mdocs were generated by the Tomography 5 software, check this box to ensure that the tilt axis angle is converted properly: -1 * TiltAxisAngle - 90
Exclusion words:: List of words separated by a space that the path should not have
Acquisition values provided below will override the corresponding mdoc values: None
Import angles from: Choose how the tilt angles will be inferred. They can be taken from a range (Min, Max, Step) or from the image header, or from anmdoc or tlt file (should have the SAME filename but with the .mdoc or .tlt or .rawtlt extension at the end). If a tlt or rawtlt file is used, it is optional to pass the accumulated dose as second column beside each angle separated by space
min: None
max: None
step: None
Have images been CTF corrected?: Select Yes if images have been CTF corrected
Have images been aligned?: Select Yes if images have been rotated/interpolated using alignment information.
Import action on files: This parameters determine how the project will deal with imported files. It can be: 
*Copy files*: Input files will be copied into your project. (this will duplicate the raw data).*Absolute symlink*: Create symbolic links to the absolute path of the files.*Relative symlink*: Create symbolic links as relative path from the protocol run folder. 
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Pixel size (sampling rate) Å/px: Pixel size
Tilt axis angle (deg.): The rotation angle is the angle from the vertical to the axis of tilting, where counterclockwise is positive.
 See https://bio3d.colorado.edu/imod/doc/tomoguide.html#UnknownAxisAngle
Initial dose: None
Dose per tilt image: None

The protocol named "import tomo CTFs" can be found at the tomo plugin.
Its help description is:
 Common protocol to import CTF estimation of a tilt-series. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Exclusion words:: List of words separated by a space that the path should not have
Input tilt-series: Select the corresponding tilt-series for which you want to update the CTF parameters.

The protocol named "import tilt-series movies" can be found at the tomo plugin.
Its help description is:
 Protocol to import tilt series movies..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Files directory: Root directory of the tilt-series (or movies) files.
Pattern: This determines if the tilt series / movies are going to be imported using the mdoc files or the tilt series files. To import from the mdoc files, the word '.mdoc' must appear in the pattern, if not, a tilt series pattern is expected. In the first case, the angular and acquisition data are read from the corresponding mdoc files, while in the second case they are read from the name of the matching files.

*IMPORTING WITH MDOC FILES*

For *tilt series movies*, ONE mdoc per tilt series is expected. The movie files must be located in the same folder as the mdocs. The filenames will be fetched from the _SubFramePath_ value in mdoc. 
Example pattern: _TS*.mdoc_

For *tilt series*, ONE _mrcs_ stack should match ONE mdoc file per each tilt series. To import unstacked images use the filename pattern (see below) instead of mdoc.

*IMPORTING WITH A FILENAME PATTERN (tilt series and movies)*

The pattern can contain wildcards such as *, ?, etc. It should also contain the following special tags:

   *{TS}*: tilt series identifier, which can be any UNIQUE part of the path. This must be an alpha-numeric sequence (avoid dash (-) symbol) and can not start with a number.
   *{TO}*: acquisition order, an integer value (important for dose information).
   *{TA}*: tilt angle, a positive or negative float value.

Example:

To import a set of images (tilt-series or tilt-series movies) like: 
TiltSeries_a_001_0.0.mrc
TiltSeries_a_002_3.0.mrc
TiltSeries_a_003_-3.0.mrc
...
TiltSeries_b_001_0.0.mrc
TiltSeries_b_002_3.0.mrc
TiltSeries_b_003_-3.0.mrc
...
Use pattern TiltSeries_{TS}_{TO}_{TA}.mrc, which will identify:
{TS} as a, b, ...
{TO} as 001, 002, 003, ...
{TA} as 0.0, 3.0, -3.0, ...

Tomo5 mdoc?: If these mdocs were generated by the Tomography 5 software, check this box to ensure that the tilt axis angle is converted properly: -1 * TiltAxisAngle - 90
Exclusion words:: List of words separated by a space that the path should not have
Acquisition values provided below will override the corresponding mdoc values: None
: Angles will be parsed from the filename pattern.The special token {TA} should be specified as  part of the pattern.
Import action on files: This parameters determine how the project will deal with imported files. It can be: 
*Copy files*: Input files will be copied into your project. (this will duplicate the raw data).*Absolute symlink*: Create symbolic links to the absolute path of the files.*Relative symlink*: Create symbolic links as relative path from the protocol run folder. 
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Pixel size (sampling rate) Å/px: Pixel size
Tilt axis angle (deg.): The rotation angle is the angle from the vertical to the axis of tilting, where counterclockwise is positive.
 See https://bio3d.colorado.edu/imod/doc/tomoguide.html#UnknownAxisAngle
Initial dose: None
Dose per tilt image: None
Gain image: A gain reference related to a set of movies for gain correction
Dark image: A dark image related to a set of movies

The protocol named "meshes from tomoMask" can be found at the tomo plugin.
Its help description is:
 
    Creates meshes based on segmentations (TomoMasks) voxels values.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomo Masks: Set of tomo mask from which the meshes will be created
Lowest: None
Highest: None
Percentage of density : This parameter goes from 0 - 100 and defines the percentage of voxel of the tomoMask thatwill be considered as points of the mesh.

The protocol named "Astigmatism rotation" can be found at the tomo plugin.
Its help description is:
 
    Rotate the astigmatism of a set of ctf tilt-series estimation given a set of transformation matrices coming from
    a set of tilt series.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set of tilt-series from which get transform: Set of tilt-series from which transformation matrices will be obtained.
input tilt-series CTF estimation: Select the CTF estimation whose astigmatism estimation will be rotated.

The protocol named "split even/odd tomos/subtomos" can be found at the tomo plugin.
Its help description is:
  Protocol to split set of tomograms or subtomograms in even/odd sets by element id.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set to split: Select the set of tomograms or subtomograms that you want to split in even/odd sets.

The protocol named "extract 3D coordinates" can be found at the tomo plugin.
Its help description is:
 
    Extract the coordinates information from a set of subtomograms.

    This protocol is useful when we want to re-extract the subtomograms
    (maybe resulting from classification) with the
    original dimensions. It can be also handy to visualize the resulting
    subtomograms in their location on the tomograms.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Subtomograms or 3D coordinates: Select the subtomograms from which you want
to extract the coordinates. The coordinate belonging to each subtomogram should be already associated to an initial tomogram.
Tomograms: Select the tomograms to which you want to
associate the coordinates from the subtomograms.
Box Size: Determine the box size of the extracted coordinates. By default, the program assigns the box size directly from the coordinates associated to the subtomograms.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "Landmarks to 2D coordinates" can be found at the tomo plugin.
Its help description is:
  Converts a set of landmark models into SPA 2d objects. Landmarks will become
    a SetOfCoordinates2D and the tilt series associated will become a micrograph set associated
    to the coordinates. Since SPA methods will not handle micrograph in stacks, tilt series files will
    be unstacked..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Landmarks: Set of Landmarks to convert

The protocol named "misalign tilt-series " can be found at the tomo plugin.
Its help description is:
 
    Introduce misalignment in the transformation matrix of a tilt-series.
    NOTE: The Interpolated tilt series in this case resembles a not aligned tilt series
    or an aligned one in case you want to apply the inverse of the misalignment
    transformation matrix.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Introduce misalignment in shift X?: Introduce noise in the shift alignment value in the X axis. Characterize the noise behaviour through the parameters in the following formula:

dx = a0 + a1 * i + a2 * sin((i + a3) / S * pi) + a4 * sin((i + a5) / S * 2 * pi) + N(0,a6)

Being i the index position of the image inside the tilt-series, S the size of it and N a normal distribution.These parameters characterize the following behaviours:
- Constant (a0): an offset error (a0) is introduced in every image of the tilt-series.
- Incremental (a1): a constant incremental error (a1) is propagated through the tilt-series.
- Sine lobe (a2, a3): the introduced error presents a half sine shape, characterized by the error amplitude (a2) and the phase to displace the error function a given number of images inside the tilt-series (a3).
- Sine cycle (a4, a5): the introduced error presents a full sine cycle shape, characterized by the error amplitude (a4) and the phase to displace the error function a given number of images inside the tilt-series (a5).
- Random (a6): a random error is introduced in every image of the tilt-series given a sigma value (a6).

Offset error (a0): Offset shift error introduced in the X axis for every image of the tilt-series.
Incremental error (a1): Incremental shift error introduced in the X axis for every image of the tilt-series.
Sine lobe error amplitude (a2): Maximum amplitude of the sine lobe error function introduced in the X axis.
Sine lobe error phase (a3): Phase (displacement) of the sine lobe error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
Sine error amplitude (a4): Maximum amplitude of the sine error function introduced in the X axis.
Sine error phase (a5): Phase (displacement) of the sine error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
Random error sigma (a6): Sigma value for the random error introduced in the shift X.
Introduce misalignment in shift Y?: Introduce noise in the shift alignment value in the Y axis. Characterize the noise behaviour through the parameters in the following formula:

dY = b0 + b1 * i + b2 * sin((i + b3) / S * pi) + b4 * sin((i + b5) / S * 2 * pi) + N(0,b6)

Being i the index position of the image inside the tilt-series, S the size of it and N a normal distribution.These parameters characterize the following behaviours:
- Constant (b0): an offset error (b0) is introduced in every image of the tilt-series.
- Incremental (b1): a constant incremental error (b1) is propagated through the tilt-series.
- Sine lobe (b2, b3): the introduced error presents a half sine shape, characterized by the error amplitude (b2) and the phase to displace the error function a given number of images inside the tilt-series (b3).
- Sine cycle (b4, b5): the introduced error presents a full sine cycle shape, characterized by the error amplitude (b4) and the phase to displace the error function a given number of images inside the tilt-series (b5).
- Random (b6): a random error is introduced in every image of the tilt-series given a sigma value (b6).

Offset error (b0): Offset shift error introduced in the Y axis for every image of the tilt-series.
Incremental error (b1): Incremental shift error introduced in the Y axis for every image of the tilt-series.
Sine lobe error amplitude (b2): Maximum amplitude of the sine lobe error function introduced in the Y axis.
Sine lobe error phase (b3): Phase (displacement) of the sine lobe error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
Sine error amplitude (b4): Maximum amplitude of the sine error function introduced in the Y axis.
Sine error phase (b5): Phase (displacement) of the sine error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
Random error sigma (b6): Sigma value for the random error introduced in the shift Y.
Introduce misalignment in angle?: Introduce noise in the angle alignment value. Characterize the noise behaviour through the parameters in the following formula:

dA = c0 + c1 * i + c2 * sin((i + c3) / S * pi) + c4 * sin((i + c5) / S * 2 * pi) + N(0,c6)

Being i the index position of the image inside the tilt-series, S the size of it and N a normal distribution.These parameters characterize the following behaviours:
- Constant (c0): an offset error (c0) is introduced in every image of the tilt-series.
- Incremental (c1): a constant incremental error (c1) is propagated through the tilt-series.
- Sine lobe (c2, c3): the introduced error presents a half sine shape, characterized by the error amplitude (c2) and the phase to displace the error function a given number of images inside the tilt-series (c3).
- Sine cycle (c4, c5): the introduced error presents a full sine cycle shape, characterized by the error amplitude (c4) and the phase to displace the error function a given number of images inside the tilt-series (c5).
- Random (c6): a random error is introduced in every image of the tilt-series given a sigma value (c6).

Offset error (c0): Constant angle error to add for every image of the tilt-series. Angles are measured in degrees.
Incremental error (c1): Initial angle error value for the first image (lowest angle) of the tilt-series. Angles are measured in degrees.
Sine lobe error amplitude (c2): Maximum amplitude of the sine lobe error function introduced in the angle. Angles are measured in degrees.
Sine lobe error phase (c3): Phase (displacement) of the sine lobe error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
Sine error amplitude (c4): Maximum amplitude of the sine error function introduced in the angle. Angles are measured in degrees.
Sine error phase (c5): Phase (displacement) of the sine error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
Random error sigma (c6): Sigma value for random error introduced in the angle. Angles are measured in degrees.
Generate interpolated tilt-series: Generate tilt-series applying theobtained misalignment transformation matrix.
With inverted matrix: Save the inverse of the misalignment transformation matrix in the interpolated set.

The protocol named "tomograms to micrographs" can be found at the tomo plugin.
Its help description is:
  Turns tomograms into set of micrographs to apply SPA picking methods..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomograms: Select the tomograms to be turned into micrographs
Slices gap: Number of slices to skip when turning tomogram slices into micrographs.
No. slices to sum: For each slice corresponding to the slices gap introduced, the introduced number of adjacent slices will be considered to sum. For example, if the number is 5, the slices considered for each sum will be the corresponding to the slice gap indices plus 2 slices above and 2 slices below. If set to 1, no sum will be performed.

The protocol named "average tilt-series movies" can be found at the tomo plugin.
Its help description is:
 
    Simple protocol to average TiltSeries movies as basic
    motion correction. It is used mainly for testing purposes.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tilt-Series (movies): Select input tilt-series movies that you wantto correct for beam-induced motion. 
from: None
to: None
Use ALIGN frames range to SUM?: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Tilt-series convert coords3D" can be found at the tomo plugin.
Its help description is:
 
    Scipion protocol to convert a set of tilt-series coordinates 3d to a set of coordinates 3d associated to a set of
    tomograms.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of coordinates 3D: Set of 3D coordinates indicating the position in space of the fiducials. This set should be obtained from the previous alignment step of the tilt-series.
Input set of tomograms: None

The protocol named "fit vesicles" can be found at the tomo plugin.
Its help description is:
  This protocol adjust a SetOfSubtomograms with coordinates assigned or a SetOfCoordinates3D, to a vesicle
    (ellipsoid), defining regions of interest (SetOfMeshes) for each vesicle as output..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Subtomograms/Coordinates3D: Subtomograms or coordinates3D picked in vesicles. If there are more than one vesicle per tomogram, input subtomograms or coordinates should have assigned groupId.

The protocol named "align transformations" can be found at the xmipptomo plugin.
Its help description is:
 Protocol to rotate a series of alignments to a common reference defined by a
    Subtomogram Average.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Reference Subtomogram Average: None
Moving Subtomogram Average: None
Moving Subtomograms: None

The protocol named "apply alignment subtomo" can be found at the xmipptomo plugin.
Its help description is:
  Apply alignment matrix and produce a new setOfSubtomograms, with each subtomogram aligned to its reference. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set of subtomograms: Set of subtomograms to be alignment

The protocol named "apply alignment tilt-series" can be found at the xmipptomo plugin.
Its help description is:
 
    Compute the interpolated tilt-series from its transform matrix.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None

The protocol named "connected components to ROIs" can be found at the xmipptomo plugin.
Its help description is:
  This protocol adjust a SetOfCoordinates (which usually will come from a
    connected componnent) to a ROI (region of interest) previously defined.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Connected components: Select the Connected components (SetOfCoordinates3D).
ROIs: Select the ROIs (Regions Of Interest) they are SetOfMeshes
Selection: Selection options:
*Connected component*: It takes the whole connected component (cc) if a percentage of the points (introduced in the next field) in the cc belongs to the ROI. 
*Points*: It takes just the points of the cc which belongs to the roi
Percentage of coordinates in ROI: Percentage of coordinates from a connected component that should be inside the ROI to consider that connected component.
Distance: Maximum euclidean distance (in pixels) between ROI vertex and a coordinate to consider that it belongs to the ROI.

The protocol named "cltomo" can be found at the xmipptomo plugin.
Its help description is:
  Averages a set of subtomograms taking into account the missing edge. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set of volumes: Set of volumes to align
Number of references: How many references are computed at the end of the process
Number of iterations: How many iterations at each of the Clustering levels
Generate aligned subvolumes: If set to true, it will be created a new set of volumes with all of them aligned
Align: Do not align if volumes are already aligned, only classify
Generate initial volume: Let CLTomo to automatically generate the initial references
Number of initial references: How many initial volumes. If set to 1, all subvolumes are aligned to a single reference, and then they are classified
Randomize orientation: Use this option if all the input volumes have the same missing wedge or if they have not been previously aligned.
Set of initial volumes: Set of initial volumes
Symmetry group: See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format.If no symmetry is present, give c1
Spatial mask: None
Maximum resolution (pixels^-1): The maximum (Nyquist) resolution is 0.5. Use smaller values, e.g. 0.45, to prevent high-resolution artifacts.
Sparsity in Fourier space: A value of 90 drops 90% of the smallest Fourier coefficients
Sparsity in wavelet space: A value of 95 drops 95% of the smallest wavelet coefficients
Maximum rotational angle: In degrees
Maximum tilt angle: In degrees
Maximum in-plane angle: In degrees
Maximum shift X: In voxels
Maximum shift Y: In voxels
Maximum shift Z: In voxels
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "local confidence maps" can be found at the xmipptomo plugin.
Its help description is:
 
    This protocol can be used with tilt series or with tomograms
    Tilt series: The algorithm estimates the local probabilities of each signal
    Tomograms:
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Has odd-even associated?: (True) The odd-even SetOfTiltSeries or the SetOfTomograms are internally associatedto the input SetOfTiltSeries or SetOfTomograms. (False) The user have to provide in the input the odd and even sets.
Input TiltSeres/Tomograms: Select the odd tomogram for estimating the confidence tomogram.
Odd tilt series/tomogram: Select the odd tilt series/tomogram for estimating the confidence tomogram.
Even tilt series/tomogram: Select the even tilt series/tomogram for estimating the  confidence map.
median filter: The mask determines which points are specimen and which are not.
Locality: Edge of the square local windows where local distribution of noise will be measured.
sigma: The mask determines which points are specimen and which are not.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "connected components" can be found at the xmipptomo plugin.
Its help description is:
  This protocol takes a set of coordinates and identifies connected
    components among the picked particles..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates: Select the SetOfCoordinates3D.
Distance: Maximum radial distance (in voxels) between particles to consider that they are in the same connected component. Wizard returns three times the box size of the input coordinates.

The protocol named "crop tomograms" can be found at the xmipptomo plugin.
Its help description is:
 
    Protocol to crop tomograms using xmipp_transform_window.
    The protocol allows to change the size of a tomogram/s, by removing the
    borders defined by the users
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tomograms: Select a set of tomograms to be cropped.
from: None
to: None
from: None
to: None
from: None
to: None

The protocol named "detect misalignment from fiducials" can be found at the xmipptomo plugin.
Its help description is:
 
    Wrapper protocol to Xmipp xmipp_deep_misalignment_detection for misalignment detection
    in tomographic reconstructions based on artifacted landmarks
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Fiducial 3D coordinates: 3D coordinates indicating the location of the fiducials (gold beads) in the tomogram. These fiducails will be the ones used to study misalignment artifacts over them. The coordinate denotes the center of the subtomogram
Tomogram source: By default the subtomograms will be extracted from the tomogram used in the picking step ( _same as picking_ option ). 
If you select _other_ option, you must provide a different tomogram to extract from. 
*Note*: In the _other_ case, ensure that provided tomogram and coordinates are related 
Input tomograms: Tomograms from which extract the fiducials (gold beads) at the specified coordinates locations.
Use misalignment threshold?: Threshold to settle if a tomogram presents weak or strong misalignment. If this value is not provided two output set of tomograms are generated, those discarded which present strong misalignment and those which do not. If this value is provided the second group of tomograms is splitted into two, using this threshold to settle if the tomograms presentor not a weak misalignment.
Misalignment threshold: Threshold value to settle if a tomogram presents weak or strong misalignment. Value ranged between (0, 1).
Model for weak misalignment estimation: Choose model for weak misalignment estimation. By default, strict model is picked in order to avoid false positives. In case loose model is chosen, less good aligned tomograms are lost. As a tradeoff, the number of false positives will increase.
Misalignment criteria: Criteria used for making a decision on the presence of misalignment on the tomogram based on the individual scores of each subtomogram. By default the mean of this scores is calculated. The other option is to implement a voting system based on if each subtomo score is closer to 0 o 1.

The protocol named "Dose filter" can be found at the xmipptomo plugin.
Its help description is:
 
    Tilt-series' dose filtering based on  T. Grant, N. Grigorieff, eLife 2015
    More info:
        https://doi.org/10.7554/eLife.06980
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series to be filtered.: None
Initial dose (e/sq A): Dose applied before any of the images in the input file were taken; this value will be added to all the prior dose values, however they were obtained.

The protocol named "extract particle stacks" can be found at the xmipptomo plugin.
Its help description is:
 
    Extract a set of particle stacks from a set of tilt series given a set of coordinates in the tomogram.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates: 3D coordinates to use in the extraction process.The coordinate denotes the center of the particle stack (subtomogram position)
Tilt Series: The particle stacks will be extracted from this set.
Box size: The particle stack are extracted as squares. The box size defines the edge of the square
Invert Contrast: Normally, tilt series has the contrast inverted with respect to standard for tilt series particles. It means, in the tomograms/recosntructions the structure is black and the noise is white. Generally, thetilt series particles are white with a black background. This means that the tilt series particles have the contrast inverted with respect to the tilt series. Put this flag as True if the contrastneed to be inverted.
Extract as SPA particles: False for a pure tilt series particles averaging treatment of the problem. True if the extractted particles will be used ina single Particle Analysis workflow.

The protocol named "extract subtomos" can be found at the xmipptomo plugin.
Its help description is:
 
    Extract a set of subtomograms from a set of tomograms given a set of coordinates.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates: 3D coordinates to use in the extraction process.The coordinate denotes the center of the subtomogram
Tomograms (Optional): The subtomograms will be extracted from this set.
Box size: The subtomograms are extracted as a cube. The box size defines the edge of the cube. This is the final size of the boxsize if downsampling is applied. The wizard selects same box size as picking
Dowsampling factor: The subtomograms are extracted as a cube. The box size defines the edge of the cubeThe wizard selects same box size as picking
Invert Contrast: Normally, tomograms has the contrast inverted with respect to standard for subtomograms. It means, in the tomograms the structure is black and the noise is white. Generally, thesubtomograms are white with a black background. This means that the subtomograms has the contrast inverted with respect to the tomograms. Put this flag as True if the contrastneed to be inverted.

The protocol named "Filter coordinates by map" can be found at the xmipptomo plugin.
Its help description is:
 Filter coordinate by map both given a mask or a resolucion map from a tomogram.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input 3D coordinates: Select the set of 3D coordinates to be filtered
Input Tomogram: Select the Set Of Tomograms to be used. The coordinatesmake references to their corresponding tomograms, then, thestatistics of the the enviroment of each coordinates willbe calculated. Thus it is possible to associate a mean, anda standard deviation to each coordinate.
Radius: Radius of the ball with center at the coordinate
Filter option: Select an option to filter the coordinates: 
 _Average_: Filter by Average value. 
_StandardDeviation_: Filter by Standard deviation value.
Average: Average value as threshold
std: std value as threshold
keep greater than the threshold: Set true if you want to keep values greater than the threshold. And set falseif the values lesser than the threshold will be discarded

The protocol named "half maps" can be found at the xmipptomo plugin.
Its help description is:
  Create half maps from a SetOfSubtomograms and its alignment .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set of subtomograms: Set of subtomograms to be split into even and odd stacks

The protocol named "local Resolution MonoTomo" can be found at the xmipptomo plugin.
Its help description is:
 
    Given a tomogram the protocol assigns local resolutions to each voxel of the tomogram.
    To do that, thje protocol makes use of two half tomograms, called odd and even.
    These tomograms are reconstructed with the same alignment parameter but using the
    half of the data. For instance, the odd/even-images of the tilt series, or much
    better usign the odd/even frames of the movies (recommended). The result is a
    tomogram with the values of local resolution.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Odd tomogram: Select the odd tomogram for determining the local resolution tomogram.
Even Tomogram: Select the even tomogram for determining the  local resolution tomogram.
Use mask?: The mask determines which points are specimen and which are not.
Binary Mask: The mask determines which points are specimen and which are not
Significance: Relution is computed using hypothesis tests, this value determines the significance of that test
High: None
Low: None
Step: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "peak high contrast" can be found at the xmipptomo plugin.
Its help description is:
 
    Wrapper protocol to Xmipp image peak high contrast applied to any volume
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tomograms: Select a set of volumes to peak high contrast regions.
Fiducial size (nm): Size of the fiducial markers (or any other object) to be peaked in nanometers.
Box size: Size of the box containing the high contrast feature in pixels.
Run in relaxed mode?: If this option is selected coordinates are kept when none of them pass the mirror correlation filter. If not, and empty output is possible. This second case might happen if the tomogram does not present any gold bead or if it presents misalignment
Relaxed mode threshold: Minimum number of surviving coordinates to enter in relaxed mode.
Number of sampling slices: Number of slices used as a sample to calculate the threshold pixel value, for posterior high contrast regions detection.
Threshold for initial coordinates (SD): Number of standard deviations (SD) that a coordinate value must be over the mean in other to consider it a member of a high contrast feature.
Number of coordinates threshold: Number of coordinates that must be attracted by a center of mass to consider it a plausible high contrast feature.
Minimum mirror correlation: Minimum correlation between a feature and its mirror to consider it a fiducial.
Mahalanobis distance threshold: Maximum Mahalanobis distance of the radial average of the gold bead between all the peaked coordinates.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "phantom create subtomo" can be found at the xmipptomo plugin.
Its help description is:
  Create subtomogram phantoms .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
 : Import a volume or create 'base' phantom manually
Input volume: Volume used as 'base' phantom
Phantom description: create a phantom description: x y z backgroundValue geometry(cyl, sph...) +(superimpose) density value origin radius height rot tilt psi. More info at https://web.archive.org/web/20180813105422/http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/FileFormats#Phantom_metadata_file
Simulating tilt series: None
Sampling rate (A/px): None
Number of subtomograms: How many phantom subtomograms
Apply missing wedge?: Apply a filter to simulate the missing wedge along Y axis.
Missing wedge angle: Missing wedge (along y) for data between +- this angle.
Force a randomization seed: Activate to force same random results (useful for tests).
Apply rotation?: Apply a random rotation to the generated subtomograms. The subtomograms will present a randomorientation.
Randomly distributed?: Apply a random rotation to the generated subtomograms. The subtomograms will present a randomorientation.
Introduce random error with std: It introduces angular assignment errors with standard deviation given by the introduced valueIt is assumed that the errors are Gaussian.
std: It introduces angular assignment errors with standard deviation given by the introduced valueIt is assumed that the errors are Gaussian.
Min: None
Max: None
Min: None
Max: None
Min: None
Max: None
Apply random shift?: Apply a random shit to the generated subtomograms. The subtomograms will present a randomdisplacement from the center of the box.
Min (px): None
Max (px): None
Min (px): None
Max (px): None
Min (px): None
Max (px): None
Assign random coordinates?: Create random x, y, z coordinates for each subtomogram.
Tomograms: Tomograms to get dimension for random creation of coordinates
Add gaussian noise to subtomograms?: Select true to generate noisy subtomograms, and False to obtain clean subtomograms.
Add variable gaussian noise to subtomograms?: (False) Each subtomogram will follow a different noise distribution. All distribution are Gaussian, the noise of twodifferent subtomograms will follow two different Gaussian distributions. It means, given two subtomogramsA and B, the noise of the subtomogram A will follow a Gaussian distribution with mean mu_A, and std s_A,in contrast, the subtomograms B will follow also a Gaussian distribution but with different mean, mu_B, and different standard deviation s_B. If True, the noise of both subtomograms will follow the same Gaussiandistribution
Min: None
Max: None
mean: None
std: None

The protocol named "phantom tomograms" can be found at the xmipptomo plugin.
Its help description is:
  Create phantom tomograms with phantom particles and its coordinates with the right Scipion transformation matrix .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomogram dimensions: Tomogram dimensions: X, Y, Z
Sampling rate: None
Number of particles: How many particles in each tomogram
Number of tomograms: How many tomograms
Missing wedge angle: Missing wedge (along y) for data between +- this angle.
Add noise to the tomogram.: Add noise using xmipp_transform.
2 particles?: Add 2 different particles to allow for 3d classification
Min rot angle: Minimum and maximum range for each Euler angle in degrees
Max rot angle: None
Min tilt angle: None
Max tilt angle: None
Min psi angle: None
Max psi angle: None

The protocol named "project subtomograms" can be found at the xmipptomo plugin.
Its help description is:
 Extracts proyections from subtomograms.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Set of subtomograms: Set of subtomograms whose projections will be generated.
Clean temporary files: : Clean temporary files after finishing the execution.
This is useful to reduce unnecessary disk usage.
Transform method: : Select the algorithm that will be used to obtain the projections.
Tilt range start:: The initial value of the range of angles the projection will be produced on.
Defaults to -60º.
Tilt range end:: The final value of the range of angles the projection will be produced on.
Defaults to 60º.
Type of sample generation: : Select either the number of samples to be taken or the separation in degrees between each sample.
Number of samples:: Number of samples to be produced.
It has to be 1 or greater.
Step:: Number of degrees each sample will be separated from the next.
It has to be greater than 0.

The protocol named "reconstruct tomogram" can be found at the xmipptomo plugin.
Its help description is:
 
    Given a set of Tilt series with the corresponding alignment parameters. This protocol
    will reconstruct the tomograms associated to the tilt series..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tilt Series: Select the Set of Tilt Series that will be used to reconstruct the tomograms.
Reconstruction Algorithm: Select an option to reconstruct tomograms: 
 _ART_: Arithmetic reconstruction technique. 
_SIRT_: (only with MPI) Simultaneous Iterative Reconstruction Technique. 
 
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "resize tilt-series" can be found at the xmipptomo plugin.
Its help description is:
 
    Wrapper protocol to Xmipp image resize applied on tilt-series
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: Select a set of tilt-series to be resized.
Resize option: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Factor_: Set a resize factor to resize. 
 _Pyramid_: Use positive level value to expand and negative to reduce. 
Pyramid uses spline pyramids for the interpolation. All the rest uses normally 
interpolation (cubic B-spline or bilinear interpolation).
Resize sampling rate (Å/px): Set the new output sampling rate.
Resize factor: New size is the old one x resize factor.
Pyramid level: Use positive value to expand and negative to reduce.
Huge file: If the file is huge, very likely you may have problems doing the antialiasing filter (because there is no memory for the input and its Fourier transform). This option removes the antialiasing filter (meaning you will get aliased results), and performs a bilinear interpolation (to avoid having to produce the B-spline coefficients).

The protocol named "resize tomograms" can be found at the xmipptomo plugin.
Its help description is:
 
    Protocol to to resize tomograms using xmipp_image_resize.
    The protocol allows to change the size of a tomogram/s by means
    of different methods
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tomograms: Select a set of tomograms to be resized.
Resize option: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Factor_: Set a resize factor to resize. 
 _Pyramid_: Use positive level value to expand and negative to reduce. 
Pyramid uses spline pyramids for the interpolation. All the rest uses normally 
interpolation (cubic B-spline or bilinear interpolation).
Resize sampling rate (Å/px): Set the new output sampling rate.
Resize factor: New size is the old one x resize factor.
Pyramid level: Use positive value to expand and negative to reduce.
Huge file: If the file is huge, very likely you may have problems doing the antialiasing filter (because there is no memory for the input and its Fourier transform). This option removes the antialiasing filter (meaning you will get aliased results), and performs a bilinear interpolation (to avoid having to produce the B-spline coefficients).

The protocol named "imagej roi" can be found at the xmipptomo plugin.
Its help description is:
  Tomogram ROI selection in IJ .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select tomograms.

The protocol named "score/filter coordinates" can be found at the xmipptomo plugin.
Its help description is:
 Scoring and (optional) filtering of coordinates based on different scoring
    functions (carbon distance, neighbour distance).
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input 3D coordinates: Select the set of 3D coordinates to compare
Operation mode: Determine whether to retrieve all the coordinates scored or to filter out unwanted coordinates based on a threshold
Score outluiers?: None
Outliers distance threshold: Z-Score value from 0 to infinite. Only coordinates with a Z-Score smaller than or equal to the threshold will be kept in the output
Score carbon closeness?: None
Carbon distance threshold: Score value between 0 and 1. Only coordinates with a score larger than or equal to the threshold will be kept in the output

The protocol named "subtomo alignment consensus" can be found at the xmipptomo plugin.
Its help description is:
 Protocol to score a series of alignments stored in a SetOfSubtomograms by
    quaternion distance analysis.

    xmipp_alignmentDistance ranges from 0º to 180º. Therefore, a 0º distance is the best and means alignment is the same.
    The lower the score the more similar is the alignment.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
First Subtomograms to compare: None
Second Subtomograms to compare: None

The protocol named "split tilt-series" can be found at the xmipptomo plugin.
Its help description is:
 
    Wrapper protocol to Xmipp split Odd Even on tilt-series
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: Select a set of tilt-series to be split into two sets (odd and even).It means, the set of tilt-series is split in two subsets.

The protocol named "map back subtomos" can be found at the xmipptomo plugin.
Its help description is:
  This protocol takes a tomogram, a reference subtomogram and a metadata with geometrical parameters
   (x,y,z) and places the reference subtomogram on the tomogram at the designated locations (map back).
   It has different representation options..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Select input type: Class: input is a class generated previously in Scipion.
Subtomograms: input is a set of subtomograms previously aligned.
Class: Subtomogram class from which the coordinates of the subtomograms and the reference will be used. It should be a SetOfClassesSubTomograms with just 1 item.
Subtomograms/coordinates: Subtomograms to be mapped back, they should have alignment and coordinates.
Reference: Subtomogram reference, average, representative or initial model of the subtomograms.
Original tomograms: Original tomograms from which the subtomograms were extracted
Invert reference contrast: Invert the contrast if the reference is black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background. 
Painting mode: The program has several painting options:
*Copy*: Copying the reference onto the tomogram.
*Average*: Setting the region occupied by the reference in the tomogram to the average value of that region.
*Highlight*: Add the reference multiplied by a constant to the location specified.
*Binarize*: Copy a binarized version of the reference onto the tomogram.
Remove background: Set tomogram to 0
Threshold: threshold applied to tomogram
Multiplier: constant to multiply the reference
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "subtomo projection" can be found at the xmipptomo plugin.
Its help description is:
 
    Project a set of volumes or subtomograms to obtain their X, Y or Z projection of the desired range of slices.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: This protocol can *not* work with .em files *if* the input is a set of tomograms or a set of volumes, 
Compute radial average?: Compute the radial average with respect to Z of the input volumes and from them, it computes their projections in the desired direction
Projection direction: None
Range of slices: Range of slices used to compute the projection, where 0 is the central slice.
Slices: Crop this amount of voxels in each side of the selected direction.
Ignore orientations: Activate to ignore particle orientation information.

The protocol named "subtomo subtraction" can be found at the xmipptomo plugin.
Its help description is:
  This protocol subtracts a subtomogram average to a SetOfSubtomograms, which are internally aligned and
    numerically adjusted in order to obtain reliable results. The adjustment and subtraction is perfomed by
    xmipp_volume_subtraction program. A mask can be provided if the user wants to perform the subtraction in a
    determined region..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Subtomograms : Select the SetOfSubTomograms with transform matrix which will be subtracted.
Average subtomogram : Select an average subtomogram to be subtracted.
Mask subtomograms?: The mask are not mandatory but highly recommendable.
Average mask: Specify a mask for the average.
Subtraction mask: Optional, specify a mask for the region of subtraction
Filter at resolution: : Resolution (A) at which subtraction will be performed, filtering the input volumes.Value 0 implies no filtering.
Decay of the filter (sigma): : Decay of the filter (sigma parameter) to smooth the mask transition
Number of iterations: : None
Relaxation factor (lambda): : Relaxation factor for Fourier amplitude projector (POCS), it should be between 0 and 1, being 1 no relaxation and 0 no modification of volume 2 amplitudes
Save intermediate files?: Save input volume 1 (first subtomogram of the set) filtered and input volume 2 (average) adjusted, which are the volumes that are really subtracted.

The protocol named "tiltseries FlexAlign" can be found at the xmipptomo plugin.
Its help description is:
 
    Simple protocol to average TiltSeries movies as basic
    motion correction. It is used mainly for testing purposes.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tilt-Series (movies): Select input tilt-series movies that you wantto correct for beam-induced motion. 
from: None
to: None
Use ALIGN frames range to SUM?: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Save aligned micrograph: None
Save movie: Save Aligned movie
Split & sum odd/even frames?: Generate odd and even sums using odd and even frames respectively when this option is enabled.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Maximum resolution (A): Maximum resolution in A that will be preserved during correlation.
Compute PSD?: If Yes, the protocol will compute PSD for each movie before and after the alignment
Maximum shift (A): Maximum allowed distance (in A) that each frame can be shifted with respect to the next.
Compute local alignment?: If Yes, the protocol will try to determine local shifts, similarly to MotionCor2.
Auto control points: If on, protocol will automatically determine necessary number of control points.
X: None
Y: None
t: None
Auto patches: If on, protocol will automatically determine necessary number of patches.
X: None
Y: None
Min size of the patch (A): How many A should contain each patch?
Group N frames: Group every specified number of frames by adding them together.                         The alignment is then performed on the summed frames.
Rotate gain reference:: Rotate gain reference counter-clockwise.
Flip gain reference:: Flip gain reference after rotation. For tiff movies, gain is automatically upside-down flipped

The protocol named "Apply transformation" can be found at the imod plugin.
Its help description is:
 
    Compute the interpolated tilt-series from its transform matrix.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/newstack.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Binning: Binning to be applied to the interpolated tilt-series in IMOD convention. Images will be binned by the given factor. Must be an integer bigger than 1
Apply to odd/even: If True, the full tilt series and the associated odd/even tilt series will be processed. The transformations applied to the odd/even tilt series will be exactly the same.

The protocol named "CTF estimation (auto)" can be found at the imod plugin.
Its help description is:
 
    CTF estimation of a set of input tilt-series using the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/ctfplotter.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: This should be a *raw stack*, not an aligned stack, because the interpolation used to make an aligned stack attenuates high frequencies and the noise power spectra would no longer match.
Defocus tolerance (nm): Defocus tolerance in nanometers defining the center strips. The center strips are taken from the central region of a view that has defocus difference less than this tolerance. These kind of center strips from all views within AngleRange are considered to have a constant defocus and are used to compute the initial CTF after being further tessellated into tiles.
Input expected defocus as:: None
Expected defocus value (nm): This value will be applied as the expected defocus in nanometers for every tilt-series from the set.
Expected defocus file: File containing the expected defocus in nanometers for each tilt-series belonging to the set.

The format of the text file must be two columns, the first one being the tilt series ID and the second the defocus value.

An example of this file comes as follows:
TS_01 4000
TS_02 1500
...
Left defocus tolerance (nm): Defocus tolerance in nanometers for strips to the left of the center strip.
Right defocus tolerance (nm): Defocus tolerance in nanometers for strips to the right of the center strip.
Tile size (px): The tile size each strip will be tessellated into. The size is in pixels and the tiles are square. Each view is first divided into strips that are considered to have constant defocus.
Angle step: Step size between ranges. A value of zero for the step will make it fit to each single image separately, regardless of the value for the range.
Angle range: Size of the angle range for which the CTF is estimated.
Start: Starting frequency (X1 starts)
End: Ending frequency (X2 ends)
Extra zeros to fit: By default, the ending frequency of the fitting range is set to the expected location of the second zero. With this entry, the range will be extended by the given multiple of the interval between first and seconds zeros. For example, entries of 1 and 2 will fit approximately to the third and fourth zeros, respectively. An entry of more than 0.5 will trigger fitting to two exponentials, which is important for fitting multiple peaks between zeros.
Skip astigmatic phase views?: Skip or break views only when finding astigmatism or phase shift
Search astigmatism?: Search for astigmatism when fitting.
Maximum astigmatism (um): Maximum astigmatism, in microns. During the fitting to wedge spectra, the defocus is allowed to vary from the global value by more than half of this amount.
Number of sectors: Number of sectors for astigmatism analysis.  A power spectrum is stored separately for each sector; spectra can then be computed fairly quickly for wedges of any size that is a multiple of the sector size. The default is 36, giving 5 degree sectors.
Minimum views astigmatism: Minimum number of views for finding astigmatism.
Search phase shift?: Search for phase shift when fitting.
Minimum views phase shift: Minimum number of views for finding phase shift.
Search cut-on frequency?: Search for cut-on frequency when finding phase shift.
Maximum astigmatism (1/nm): Maximum frequency to test when searching for cut-on frequency, in reciprocal nanometers.  The default is the frequency of the first zero at the expected defocus and phase shift. To use the default value set box to -1.

The protocol named "CTF correction" can be found at the imod plugin.
Its help description is:
 
    CTF correction of a set of input tilt-series using the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/ctfphaseflip.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tilt-series: Select the set of tilt-series to be CTF corrected. Usually this will be the tilt-series with alignment information.
Input CTF estimation: Select the CTF estimation for the set of tilt-series.
Defocus tolerance (nm): The value introduced must be the same used for CTF estimation with IMOD.

Defocus tolerance in nanometers defining the center strips. The center strips are taken from the central region of a view that has defocus difference less than this tolerance. These kind of center strips from all views within AngleRange are considered to have a constant defocus and are used to compute the initial CTF after being further tessellated into tiles.
Interpolation width (px): The distance in pixels between the center lines of two consecutive strips. A pixel inside the region between those two center lines resides in both strips. As the two strips are corrected separately, that pixel will have 2 corrected values. The final value for that pixel is a linear interpolation of the 2 corrected values. If a value of 1 is entered, there is no such interpolation. For a value greater than one, the entered value will be used whenever the strip width is less than 256 (i.e., at high tilt), and the value will be scaled proportional to the strip width for widths above 256.  This scaling keeps the computational time down and is reasonable because the defocus difference between adjacent wide strips at wider intervals is still less than that between the narrower strips at high tilt. However, strips at constant spacing can still be obtained by entering the negative of the desired spacing, which disables the scaling of the spacing.
: This protocol has both CPU and GPU implementation.Select the one you want to use.
: GPU ID. To pick the best available one set 0. For a specific GPU set its number ID (starting from 1).
Correct odd/even: If True, the full tilt series and the associated odd/even tilt series will be processed. The CTF correction applied to the odd/even tilt series will be exactly the same.

The protocol named "Dose filter" can be found at the imod plugin.
Its help description is:
 
    Tilt-series dose filtering based on the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/mtffilter.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Initial dose (e/sq. Å): Dose applied before any of the images in the input file were taken; this value will be added to all the dose values.
Input dose source: Where to find the dose information:
- Scipion import: use the dose provided during import of the tilt-series
- Fixed dose: manually input fixed dose for each image of the input file, in electrons/square Ångstrom.
Fixed dose (e/sq Å): Fixed dose for each image of the input file, in electrons/square Ångstrom.
Filter odd/even: If True, the full tilt series and the associated odd/even tilt series will be processed. The applied dose for the odd/even tilt series will be exactly the same.

The protocol named "Etomo interactive" can be found at the imod plugin.
Its help description is:
 
    Simple wrapper around etomo to manually reconstruct a Tomogram.

    More info:
        https://bio3d.colorado.edu/imod/doc/etomoTutorial.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: Input set of tilt-series to be processed with eTomo.
Fiducial markers diameter (nm): Diameter of gold beads in nanometers.
Apply transformation matrix?: Apply the transformation matrix if inputtilt series have it.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Exclude views" can be found at the imod plugin.
Its help description is:
 
    excludeviews - Reversibly remove views from a tilt series stack

    By default, the protocol will remove disabled tilt images from the input TS.
    Alternatively, you can provide a text file with a list of tilts to exclude.

    If you use this protocol, make sure this output tilt series is use for everything else
    CTF estimation, per particle per tilt, tomogram reconstruction....
    More info:
        https://bio3d.colorado.edu/imod/doc/man/excludeviews.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Exclude views file: File containing the views to be excluded for each tilt-series belonging to the set.

The format of the text file must be two columns, the first one being the tilt series ID of the series from which the views will be excluded and the second the views to exclude, numbered from 1. The syntax for this exclude list is a comma separated list of ranges with no spaces between them (e.g., 1,4-5,60-70). 

An example of this file comes as follows:
TS_01 1,4-6,8,44-47
TS_02 3,10-12,24
...

The protocol named "Fiducial alignment" can be found at the imod plugin.
Its help description is:
 
    Construction of a fiducial model and alignment of tilt-series based
    on the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/tiltalign.html
        https://bio3d.colorado.edu/imod/doc/man/model2point.html
        https://bio3d.colorado.edu/imod/doc/man/imodtrans.html
        https://bio3d.colorado.edu/imod/doc/man/newstack.html
        https://bio3d.colorado.edu/imod/doc/man/ccderaser.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of fiducial models.: None
Find beads on two surfaces?: Track fiducials differentiating in which side of the sample are located.
IMPORTANT: It is highly recommended to match the option selected in the generation of the fiducial models. In case they do not match, it is not intended to fail but could be missing the whole potential of the algorithm. In case the algorithm used fot he calculationof the fiducial models does not consider this option it is algo recomended to set this option to 'No'.
Generate interpolated tilt-series?: Generate and save the interpolated tilt-series applying the obtained transformation matrices.
Binning: Binning to be applied to the interpolated tilt-series in IMOD convention. Images will be binned by the given factor. Must be an integer bigger than 1
Rotation solution type: Type of rotation solution.
Group size: Size of the rotation group
Magnification solution type: Type of magnification solution.
Group size: Size of the magnification group
Tilt angle solution type: Type of tilt angle solution.
Group size: Size of the tilt angle group
Distortion solution type: Type of distortion solution.
X stretch group size: Basic grouping size for X stretch
Skew group size: Size of the skew group
Erase gold beads: Remove the gold beads detected during fiducial alignment with *ccderaser* program. This option will generate an interpolated tilt series with the gold beads erased and interpolated with the calculated transformation matrices form the alignment.
Bead diameter (px): For circle objects, this entry specifies a radius to use for points without an individual point size instead of the object's default sphere radius. This entry is floating point and can be used to overcome the limitations of having an integer default sphere radius. If there are multiple circle objects, enter one value to apply to all objects or a value for each object.

The protocol named "Generate fiducial model" can be found at the imod plugin.
Its help description is:
 
    Construction of a fiducial model and alignment of tilt-series based
    on the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/autofidseed.html
        https://bio3d.colorado.edu/imod/doc/man/beadtrack.html
        https://bio3d.colorado.edu/imod/doc/man/model2point.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Fiducial diameter (nm): Fiducials diameter to be tracked for alignment.
Find beads on two surfaces?: Track fiducials differentiating in which side of the sample are located.
Number of fiducials: Number of fiducials to be tracked for alignment.
Track with fiducial model as seed: Turn the tracked model into new seed and repeat tracking.
Shifts near zero fraction: Fraction of the tracking box size above which to supply shifts near zero tilt to Beadtrack. The dominant net shifts in the bead positions between views are found as described above, and if one of the shifts is larger than this fraction of the -BoxSizeXandY entry to Beadtrack, then the shifts are provided when running Beadtrack on the initial seed models. Also, a command file will be written with modified parameters, named as the root name of the input command file followed by '_adjusted' and its extension. Enter 0 or a large value to disable this analysis.
Refine center with Sobel filter?: Use edge-detecting Sobel filter to refine the bead positions.
Sobel sigma relative to bead size: Sigma for gaussian kernel filtering of single beads before Sobel filtering, as fraction of bead diameter. The default sigma is 0.5 pixels regardless of bead size. A value of around 0.12 diameters is needed for higher noise (eg. cryo) data.

The protocol named "Gold bead picker 3D" can be found at the imod plugin.
Its help description is:
 
    3-dimensional gold bead picker using the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/findbeads3d.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tomograms: Input set of tomograms from which gold beads will be picked. A tomogram needs to be thicker than normal because the program cannot find beads too close to the surfaces of a tomogram.
Fiducials diameter (px): Diameter of beads in pixels.
Bead contrast: Contrast of the gold beads:
-Dark: beads are dark on light background.
-Light: beads are light on dark background.
Minimum relative strength: Minimum relative peak strength for keeping a peak in the analysis.  The square root of the specified value is used for comparing with the square root of peak strength, for compatibility with existing command files. The default is 0.05, which corresponds to a relative square root peak strength of 0.22. Too many weak peaks can prevent a dip from showing up in the smoothed histogram of strengths.  If the program fails to find a histogram dip, one strategy is to try raising this value.
Minimum spacing: Minimum spacing between peaks as a fraction of the bead size. When two peaks are closer than this distance apart, the weaker one is eliminated unless the -both option is entered. The default is 0.9. A value less than 1 is helpful for picking both beads in a pair.

The protocol named "Import transformation matrix" can be found at the imod plugin.
Its help description is:
 
    Import the transformation matrices assigned to an input set of tilt-series
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Exclusion words:: List of words separated by a space that the path should not have
Input set of tilt-series: Set of tilt-series on which transformation matrices will be assigned.
Transformation matrix binning: Binning of the tilt series at which the transformation matrices were calculated.
Tilt-series binning: Binning of the tilt-series.

The protocol named "CTF estimation (manual)" can be found at the imod plugin.
Its help description is:
 
    CTF estimation of a set of input tilt-series using the IMOD procedure.
    Runs the protocol through the interactive GUI. The resulting defocus values
    MUST BE SAVED manually by the user.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/ctfplotter.html

    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: This should be a *raw stack*, not an aligned stack, because the interpolation used to make an aligned stack attenuates high frequencies and the noise power spectra would no longer match.
Defocus tolerance (nm): Defocus tolerance in nanometers defining the center strips. The center strips are taken from the central region of a view that has defocus difference less than this tolerance. These kind of center strips from all views within AngleRange are considered to have a constant defocus and are used to compute the initial CTF after being further tessellated into tiles.
Input expected defocus as:: None
Expected defocus value (nm): This value will be applied as the expected defocus in nanometers for every tilt-series from the set.
Expected defocus file: File containing the expected defocus in nanometers for each tilt-series belonging to the set.

The format of the text file must be two columns, the first one being the tilt series ID and the second the defocus value.

An example of this file comes as follows:
TS_01 4000
TS_02 1500
...
Left defocus tolerance (nm): Defocus tolerance in nanometers for strips to the left of the center strip.
Right defocus tolerance (nm): Defocus tolerance in nanometers for strips to the right of the center strip.
Tile size (px): The tile size each strip will be tessellated into. The size is in pixels and the tiles are square. Each view is first divided into strips that are considered to have constant defocus.

The protocol named "Tilt-series preprocess" can be found at the imod plugin.
Its help description is:
 
    Normalize input tilt-series and change its storing formatting.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/newstack.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Binning: Binning to be applied to the normalized tilt-series in IMOD convention. Images will be binned by the given factor. Must be an integer bigger than 1
Apply transformation matrix: Apply the tilt series transformation matrix if tilt series have them
Adjust densities mode: Adjust densities of sections individually:
-Default: no adjustment performed
-Mode 1: sections fill the data range
-Mode 2: sections scaled to common mean and standard deviation.
-Mode 3: sections shifted to a common mean without scaling
-Mode 4: sections shifted to a common mean and then rescale the resulting minimum and maximum densities to the Min and Max values specified
Storage data type: Apply one density scaling to all sections to map current min and max to the given Min and Max. The storage mode of the output file. The default is the mode of the first input file, except for a 4-bit input file, where the default is to output as bytes
Set scaling range values?: This option will rescale the densities of all sections by the same factors so that the original minimum and maximum density will be mapped to the Min and Max values that are entered
Max.: Maximum value for the rescaling
Min.: Minimum value for the rescaling
Antialias method:: Type of antialiasing filter to use when reducing images.
The available types of filters are:

None
Blackman - fast but not as good at antialiasing as slower filters
Triangle - fast but smooths more than Blackman
Mitchell - good at antialiasing, smooths a bit
Lanczos 2 lobes - good at antialiasing, less smoothing than Mitchell
Lanczos 3 lobes - slower, even less smoothing but more risk of ringing
The default is Lanczos 3 as of IMOD 4.7. Although many people consider Lanczos 2 the best compromise among the various factors, that sentiment may be based on images of natural scenes where there are sharp edges.
Set mean and SD?: Set mean and SD values
Mean: Mean value for the rescaling
SD: Standard deviation value for the rescaling
Max.: Maximum value for the rescaling
Min.: Minimum value for the rescaling
Apply to odd/even: If True, the full tilt series and the associated odd/even tilt series will be processed. The transformations applied to the odd/even tilt series will be exactly the same.

The protocol named "Tomo preprocess" can be found at the imod plugin.
Its help description is:
 
    Normalize input tomogram and change its storing formatting.
    More info:
        https://bio3D.colorado.edu/imod/doc/newstack.html
        https://bio3D.colorado.edu/imod/doc/binvol.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tomograms: None
Binning: Binning to be applied to the normalized tomograms in IMOD convention. Volumes will be binned by the given factor. Must be an integer bigger than 1
Adjust densities mode: Adjust densities of sections individually:
-Default: no adjustment performed
-Mode 1: sections fill the data range
-Mode 2: sections scaled to common mean and standard deviation.
-Mode 3: sections shifted to a common mean without scaling
-Mode 4: sections shifted to a common mean and then rescale the resulting minimum and maximum densities to the Min and Max values specified
Storage data type: Apply one density scaling to all sections to map current min and max to the given Min and Max. The storage mode of the output file. The default is the mode of the first input file, except for a 4-bit input file, where the default is to output as bytes
Set scaling range values?: This option will rescale the densities of all sections by the same factors so that the original minimum and maximum density will be mapped to the Min and Max values that are entered
Max.: Maximum value for the rescaling
Min.: Minimum value for the rescaling
Antialias method:: Type of antialiasing filter to use when reducing images.
The available types of filters are:

None
Blackman - fast but not as good at antialiasing as slower filters
Triangle - fast but smooths more than Blackman
Mitchell - good at antialiasing, smooths a bit
Lanczos 2 lobes - good at antialiasing, less smoothing than Mitchell
Lanczos 3 lobes - slower, even less smoothing but more risk of ringing
The default is Lanczos 3 as of IMOD 4.7. Although many people consider Lanczos 2 the best compromise among the various factors, that sentiment may be based on images of natural scenes where there are sharp edges.
Set mean and SD?: Set mean and SD values
Mean: Mean value for the rescaling
SD: Standard deviation value for the rescaling
Max.: Maximum value for the rescaling
Min.: Minimum value for the rescaling
Process odd/even?: If True, the full tilt series and the associated odd/even tilt series will be processed. The transformations applied to the odd/even tilt series will be exactly the same.

The protocol named "Tomo projection" can be found at the imod plugin.
Its help description is:
 
    Re-project a tomogram given a geometric description (axis and angles).
    More info:
        https://bio3d.colorado.edu/imod/doc/man/xyzproj.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tomograms: None
Minimum angle of rotation: Minimum angle of the projection range
Maximum angle of rotation: Maximum angle of the projection range
Step angle: Step angle of the projection range
Rotation axis for projection: Axis to tilt around (X, Y, or Z). Y axis usually corresponds to the typical rotation axis acquisition.

The protocol named "Tomo reconstruction" can be found at the imod plugin.
Its help description is:
 
    Tomogram reconstruction procedure based on the IMOD procedure.

    More info:
        https://bio3d.colorado.edu/imod/doc/man/tilt.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Tomogram thickness (voxels): Size in voxels of the tomogram in the z axis (beam direction).
Tomogram shift in X: This entry allows one to shift the reconstructed slice in X before it is output.  If the X shift is positive, the slice will be shifted to the right, and the output will contain the left part of the whole potentially reconstructable area.
Tomogram width (voxels): Number of pixels to cut out in X, centered on the middle in X. Leave 0 for default X.
Tomogram shift in Z: This entry allows one to shift the reconstructed slice in Z before it is output. If the Z shift is positive, the slice is shifted upward. The Z entry is optional and defaults to 0 when omitted.
Angle offset: Apply an angle offset in degrees to all tilt angles. This offset positively rotates the reconstructed sections anticlockwise.
Tilt axis offset: Apply an offset to the tilt axis in a stack of full-sized projection images, cutting the X-axis at  NX/2. + offset instead of NX/2. The DELXX entry is optional and defaults to 0 when omitted.
Super-sampling factor: Compute slices in pixels smaller by this factor to reduce artifacts.
Iterations of a SIRT-like equivalent filter: Modify the radial filter to produce a reconstruction equivalent to the one produced by the given number of iterations of SIRT. The Gaussian filter is applied at the high-frequency end of the filter. The functioning of this filter is described in: 
	https://bio3d.colorado.edu/imod/doc/man/tilt.html
First parameter: Linear region value
Second parameter: Gaussian fall-off parameter
: This protocol has both CPU and GPU implementation. Select the one you want to use.
: GPU ID. To pick the best available one set 0. For a specific GPU set its number ID (starting from 1).
Reconstruct odd/even?: If True, the full tilt series and the associated odd/even tilt series will be reconstructed. The alignment applied to the odd/even tilt series will be exactly the same.

The protocol named "Coarse prealignment" can be found at the imod plugin.
Its help description is:
 
    Tilt-series cross correlation alignment based on the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/tiltxcorr.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Use cumulative correlation?: With this option, the program will take the image at zero tilt as the firstreference, and correlate it with the image at the next most negative tilt.It will then add the aligned image to the first reference to make the reference for the next tilt.  At each tilt, the reference will be the sum of images that have already been aligned. When the most negative tilt angle is reached, the procedure is repeated from the zero-tilt view to more positive tilt angles.
Generate interpolated tilt-series?: Generate and save the interpolated tilt-series applying the obtained transformation matrices.
Binning for the interpolated: Binning to be applied to the interpolated tilt-series in IMOD convention. Images will be binned by the given factor. Must be an integer bigger than 1
Tilt axis angle detected from import. In case another value is desired please adjust the number below: None
Tilt axis angle (degrees): The tilt axis angle is the tilt axis rotation relative to the Y axis of the image.If it was not properly set in the import of the tilt series, or the importedinformation is not correct you have the chance to correct at in this point.Usually, it will be 90 degrees less than the RotationAngle in a system with no axis inversions
left: None
right: None
top: None
botton: None
Filter radius 1: None
Filter sigma 1: None
Filter radius 2: None
Filter sigma 2: None

The protocol named "X-rays eraser" can be found at the imod plugin.
Its help description is:
 
    Erase X-rays from aligned tilt-series based on the IMOD procedure.
    More info:
            https://bio3d.colorado.edu/imod/doc/man/ccderaser.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Peak criterion: Criterion # of SDs above local mean for erasing peak based on intensity (the default is 8 SDs)
Difference criterion: Criterion # of SDs above mean pixel-to-pixel difference for erasing a peak based on differences (the default is 6 SDs).
Maximum radius (px): Maximum radius of peak area to erase (the default is 4.2 pixels).
Big difference criterion: An extra-large peak will be erased only if the value for the maximum difference between adjacent pixels, averaged over the most extreme one-fourth of the pixels in the patch, exceeds this criterion, evaluated as the number of SDs above the mean absolute difference between adjacent pixels in the scan area. The default is 19.  This high a value is needed to prevent gold erasure on low-noise data sets with small gold particles, and a lower value may be needed to make extra-large peak removal useful.
Apply to odd/even: If True, the full tilt series and the associated odd/even tilt series will be processed. The filter applied to the odd/even tilt series will be exactly the same.

The protocol named "import 3D coordinates" can be found at the reliontomo plugin.
Its help description is:
 Protocol to import a 3D coordinates from a relion star file as the one provided in the tutorial.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Star file: None
Tomograms: Tomograms to which the coordinates will be referred.
Coordinates sampling rate [Å/pix] (opt.): If empty, the protocol will try to read it from the label "_rrlnDetectorPixelSize" if it is present in the introduced star file. If not find, it will be considered to be the same as the tomograms. The ratio of both tomograms and coordinates sampling rate will be used to scale the coordinates properly to the tomograms introduced if they are different
Box Size [pix]: None

The protocol named "import subtomograms from a star file" can be found at the reliontomo plugin.
Its help description is:
 Protocol to import a set of subtomograms from a star file.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Star file: None
Tomograms: Tomograms to which the coordinates will be referred.
Coordinates sampling rate [Å/pix] (opt.): If empty, the protocol will try to read it from the label "_rrlnDetectorPixelSize" if it is present in the introduced star file. If not find, it will be considered to be the same as the tomograms. The ratio of both tomograms and coordinates sampling rate will be used to scale the coordinates properly to the tomograms introduced if they are different
Box Size [pix]: None

The protocol named "3D Classification of subtomograms" can be found at the reliontomo plugin.
Its help description is:
 3D Classification of subtomograms..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Reference volume: Initial reference 3D map, it should have the same dimensions and the same pixel size as your input particles.
Reference mask (optional): A volume mask containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask. If no mask is given, a soft spherical mask based on the <radius> of the mask for the experimental images will be applied.

In some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. Check _Advaced_ parameters to select another volume mask.
Second reference mask (optional): For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas.
Is initial 3D map on absolute greyscale?: Perform CC-calculation in the first iteration (use this if references are not on the absolute intensity scale). See detailed explanation below:

 Probabilities are calculated based on a Gaussian noise model,which contains a squared difference term between the reference and the experimental image.

 This has a consequence that the reference needs to be on the same absolute intensity greyscale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity greyscale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. But, if the map wasreconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No.

If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent map refinement. Therefore, if in doubt it is recommended to set this option to No.
Initial low-pass filter (A): It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s).
Symmetry group: Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Number of classes to be defined: None
Regularisation parameter T: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. If it's set to 0, no regularisation will be applied. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D initial model calculations.
Number of iterations: Number of iterations to be performed. Note that the current implementation of 2D class averaging and 3D classification does NOT comprise a convergence criterium. Therefore, the calculations will need to be stopped by the user if further iterations do not yield improvements in resolution or classes.
Use fast subsets (for large data sets)?: If set to Yes, the first 5 iterations will be done with random subsets of only K*1500 particles (K being the number of classes); the next 5 with K*4500 particles, the next 5 with 30% of the data set; and the final ones with all data. This was inspired by a cisTEM implementation by Niko Grigorieff et al.
Circular mask diameter (Å): Diameter of the circular mask that will be applied to the experimental images (in Angstroms)
Mask individual particles with zeros?: If set to Yes, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform.

This will remove noise and therefore increase sensitivity in the alignment and classification.

However, it will also introduce correlations between the Fourier components that are not modelled. When set to No, then the solvent area is filled with random noise, which prevents introducing correlations.

High-resolution refinements (e.g. ribosomes or other large complexes in 3D auto-refine) tend to work better when filling the solvent area with random noise (i.e. setting this option to No), refinements of smaller complexes and most classifications go better when using zeros (i.e. setting this option to Yes).
Limit resolution E-step to (Å): If set to a positive number, then the expectation step (i.e. the alignment) will be done only including the Fourier components up to this resolution (in Angstroms).

This is useful to prevent overfitting, as the classification runs in RELION are not guaranteed to be 100% overfitting-free (unlike the 3D auto-refine with its gold-standard FSC). In particular for very difficult data sets, e.g. of very small or featureless particles, this has been shown to give much better class averages. 

In such cases, values in the range of 7-12 Angstroms have proven useful.
Perform image alignment?: If set to No, then rather than performing both alignment and classification, only classification will be performed. This allows the use of very focused masks. It requires that the optimal orientations of all particles are already stored in the input STAR file.
Initial angular sampling interval (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
Initial offset range (pix.): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
Initial offset step (pix.): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluatedon a 2x coarser grid.
Perform local angular searches?: If set to Yes, then rather than performing exhaustive angular searches, local searches within the range given below will be performed.

A prior Gaussian distribution centered at the optimal orientation in the previous iteration and with a stddev of 1/3 of the range given below will be enforced.
Local angular search range (deg.): Local angular searches will be performed within +/- the given amount (in degrees) from the optimal orientation in the previous iteration.

A Gaussian prior (also see previous option) will be applied, so that orientations closer to the optimal orientation in the previous iteration will get higher weights than those further away.
Symmetry to be relaxed: With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020 cited in the About dialog.

Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
Allow coarser sampling?: If set to Yes, the program will use coarser angular and translational samplings if the estimated accuracies of the assignments are still low in the earlier iterations. This may speed up the calculations.
Use parallel disc I/O?: If set to Yes, all MPI followers will read their own images from disc. Otherwise, only the leader will read images and send them through the network to the followers. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many followers reading in parallel. If your datasets contain particles with different box sizes, you have to say Yes.
Number of pooled particles: Particles are processed in individual batches by MPI followers. During each batch, a stack of particle images is only opened and closed once to improve disk access times.

All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. This parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together.

This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Skip griding?: Skip gridding in the Maximization step in the Expectation-Maximization algorithm. If this option is set to Yes, more memory will be consumed during the protocol execution, but it will be faster.
Pre-read all particles into RAM?: If set to Yes, the leader process read all particles into memory. Be careful you have enough RAM for large data sets!
Combine iterations through disc?: If set to Yes, the large arrays of summed weights will be sent through the MPI network instead of writing large files to disc.
Copy particles to scratch directory: If provided, particle stacks will be copied to this local scratch disk prior for refinement.
Skip padding?: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
Use GPU acceleration?: If set to Yes, it will use available gpu resources for some calculations.
GPUs to use:: It can be used to provide a list of which GPUs (e. g. "0:1:2:3") to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Keep only files from last iteration?: If Yes is chosen, only the files which correspond to the last iteration will be saved in the protocol's extra directory. Otherwise, files corresponding to each iteration will be kept.
Over-sampling: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
Consider alignment as priors?: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--verb 1
--pad 2

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Tomo CTF refine" can be found at the reliontomo plugin.
Its help description is:
 Tomo CTF refine.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Volume to get the halves: None
Input reference mask: None
Box size for estimation (pix): Box size to be used for the estimation. Note that this can be larger than the box size of the reference map. A sufficiently large box size allows more of the high-frequency signal to be captured that has been delocalized by the CTF.
Refine defocus?: If set to Yes, then estimate the defoci of the individual tilt images.
Defocus search range (Å): None
Do defocus regularisation?: Apply defocus regularisation.

High-tilt images do not offer enough signal to recover the defocus value precisely. The regularisation forces the estimated defoci to assume similar values within a given tilt series, which prevents those high-tilt images from overfitting.
Defocus regularisation scale: None
Refine contrast scale?: If set to Yes, then estimate the signal scale or ice thickness.
Refine scale per frame?: If set to Yes, then estimate the signal-scale parameter independently for each tilt. If not specified, the ice thickness, beam luminance and surface normal are estimated instead. Those three parameters then imply the signal intensity for each frame. Due to the smaller number of parameters, the ice thickness model is more robust to noise. By default, the ice thickness and surface normal will be estimated per tilt-series, and the beam luminance globally.
Refine scale per tomogram?: If set to Yes, then the beam luminance will be estimated separately for each tilt series. This is not recommended.
Refine even aberrations?: If set to Yes, then even higher-order aberrations will be estimated.
Max order of even aberrations: None
Refine odd aberrations?: If set to Yes, then odd higher-order aberrations will be estimated.
Max order of odd aberrations: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "De novo 3D initial model" can be found at the reliontomo plugin.
Its help description is:
 Generate a de novo 3D initial model from the pseudo-subtomograms..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Number of VDAM mini-batches: How many iterations (i.e. mini-batches) to perform with the VDAM ((variable metric gradient descent with adaptive moments) algorithm. Using 200 (default) has given good results for many data sets. Using 100 will run faster, at the expense of some quality in the results.
Regularisation parameter T: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. If it's set to 0, no regularisation will be applied. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D initial model calculations.
Number of classes to be defined: None
Circular mask diameter (Å): Diameter of the circular mask that will be applied to the experimental images (in Angstroms)
Flatten and enforce non-negative solvent?: If set to Yes, the job will apply a spherical mask and enforce all values in the reference to be non-negative.
Symmetry group: Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
Run in C1 and apply symmetry later?: If set to Yes, the gradient-driven optimisation is run in C1 and the symmetry orientation is searched and applied later. If set to No, the entire optimisation is run in the symmetry point group indicated above.
Initial angular sampling interval (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
Initial offset range (pix.): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
Initial offset step (pix.): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluatedon a 2x coarser grid.
Use parallel disc I/O?: If set to Yes, all MPI followers will read their own images from disc. Otherwise, only the leader will read images and send them through the network to the followers. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many followers reading in parallel. If your datasets contain particles with different box sizes, you have to say Yes.
Number of pooled particles: Particles are processed in individual batches by MPI followers. During each batch, a stack of particle images is only opened and closed once to improve disk access times.

All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. This parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together.

This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Skip griding?: Skip gridding in the Maximization step in the Expectation-Maximization algorithm. If this option is set to Yes, more memory will be consumed during the protocol execution, but it will be faster.
Pre-read all particles into RAM?: If set to Yes, the leader process read all particles into memory. Be careful you have enough RAM for large data sets!
Combine iterations through disc?: If set to Yes, the large arrays of summed weights will be sent through the MPI network instead of writing large files to disc.
Copy particles to scratch directory: If provided, particle stacks will be copied to this local scratch disk prior for refinement.
Use GPU acceleration?: If set to Yes, it will use available gpu resources for some calculations.
GPUs to use:: It can be used to provide a list of which GPUs (e. g. "0:1:2:3") to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Keep only files from last iteration?: If Yes is chosen, only the files which correspond to the last iteration will be saved in the protocol's extra directory. Otherwise, files corresponding to each iteration will be kept.
Over-sampling: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
Consider alignment as priors?: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--verb 1
--pad 2

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Apply operation to Relion particles" can be found at the reliontomo plugin.
Its help description is:
 Operate on the particles star file.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Perform centering of particles: Perform centering of particles according to a position in the reference.
Average of subtomogram (optional): None
Reference mask (optional): None
X (pix.): X-coordinate in the reference to center particles on (in pix)
Y (pix.): Y-coordinate in the reference to center particles on (in pix)
Z (pix.): Z-coordinate in the reference to center particles on (in pix)
Choose operation: None
Value to operate the selected labels: None
Operate with: None
X (pix.): None
Y (pix.): None
Z (pix.): None
Shift X (pix.): None
Shift Y (pix.): None
Shift Z (pix.): None
Rot (deg.): None
Tilt (deg.): None
Psi (deg.): None

The protocol named "Make pseudo-subtomograms" can be found at the reliontomo plugin.
Its help description is:
 Make pseudo-subtomograms.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Box size (pix.): Box size, in pixels,  of the reconstruction. Note that this is independent of the box size used to refine the particle. This allows the user to construct a 3D map of arbitrary size to gain an overview of the structure surrounding the particle. A sufficiently large box size also allows more of the high-frequency signal to be captured that has been delocalized by the CTF.
Cropped box size (pix.): Cropped box size in pixels. If set, the program will output an additional set of maps that have been cropped to this size. This is useful if a map is desired that is smaller than the box size required to retrieve the CTF-delocalized signal.
Binning factor: Downsampling (binning) factor. Note that this does not alter the box size. The reconstructed region instead becomes larger.
Apply cone weight?: Down weight a cone in Fourier space along the Z axis (as defined by the coordinate system of the particle). This is useful for particles embedded in a membrane, as it can prevent the alignment from being driven by the membrane signal (the signal of a planar membrane is localised within one line in 3D Fourier space). Note that the coordinate system of a particle is given by both the subtomogram orientation (if defined) and the particle orientation. This allows the user to first obtain a membrane-driven alignment, and to then specifically suppress the signal in that direction.
Cone angle (deg.): It is the (full) opening angle of the cone to be suppressed, given in degrees. This angle should  include both the uncertainty about the membrane orientation and its variation across the region represented in the subtomogram.
Write output in float16?: If set to Yes, this program will write output images in float16 MRC format. This will save a factor of two in disk space compared to the default of writing in float32. Note that RELION and CCPEM will read float16 images, but other programs may not (yet) do so.

The protocol named "postprocessing" can be found at the reliontomo plugin.
Its help description is:
 Sharpen a 3D reference map and estimate the gold-standard FSC curves for subtomogram averaging.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Use halves from this refined volume: It will provide the two unfiltered half-reconstructions that were output upon convergence of a 3D auto-refine run.
Solvent mask: Provide a soft mask where the protein is white (1) and the solvent is black (0). Often, the softer the mask the higher resolution estimates you will get. A soft edge of 5-10 pixels is often a good edge width.
Calibrated pixel size (Å/pix): Provide the final, calibrated pixel size in Angstroms. This value may be different from the pixel-size used thus far, e.g. when you have recalibrated the pixel size using the fit to a PDB model. The X-axis of the output FSC plot will use this calibrated value.
Estimate B-factor automatically?: If set to Yes, then the program will use the automated procedure described by Rosenthal and Henderson (2003, JMB) to estimate an overall B-factor for your map, and sharpen it accordingly. Note that your map must extend well beyond the lowest resolution included in the procedure below, which should not be set to resolutions much lower than 10 Angstroms. 
Lowest resolution for auto-B fit: This is the lowest frequency (in Angstroms) that will be included in the linear fit of the Guinier plot as described in Rosenthal and Henderson (2003, JMB). Dont use values much lower or higher than 10 Angstroms. If your map does not extend beyond 10 Angstroms, then instead of the automated procedure use your own B-factor.
Use your own B-factor?: Instead of using the automated B-factor estimation, provide your own value. Use negative values for sharpening the map. This option is useful if your map does not extend beyond the 10A needed for the automated procedure, or when the automated procedure does not give a suitable value (e.g. in more disordered parts of the map).
User-provided B-factor: Use negative values for sharpening. Be careful: if you over-sharpen your map, you may end up interpreting noise for signal!
Skip FSC-weighting?: If set to No, then the output map will be low-pass filtered according to the mask-corrected, gold-standard FSC-curve. Sometimes, it is also useful to provide an ad-hoc low-pass filter, as due to local resolution variations some parts of the map may be better and other parts may be worse than the overall resolution as measured by the FSC. In such cases, set this option to Yes and provide an ad-hoc filter as described below.
Ad-hoc low-pass filter (Å): This option allows one to low-pass filter the map at a user-provided frequency (in Angstroms). When using a resolution that is higher than the gold-standard FSC-reported resolution, take care not to interpret noise in the map for signal.
MTF of the detector: User-provided STAR-file with the MTF-curve of the detector. Use the wizard to load one of the predefined ones provided at:
- [[https://www3.mrc-lmb.cam.ac.uk/relion/index.php/FAQs#Where_can_I_find_MTF_curves_for_typical_detectors.3F][Relion's Wiki FAQs]]
 - [[https://www.gatan.com/techniques/cryo-em#MTF][Gatan's website]]

Relion param: *--mtf*
Original detector pixel size ((Å)/pix): This is the original pixel size (in Angstroms) in the raw (non-super-resolution!) micrographs.

The protocol named "Prepare data for Relion 4" can be found at the reliontomo plugin.
Its help description is:
 Prepare data for Relion 4
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input CTF tomo series: None
Does focus decrease with Z distance?: It is the handedness of the tilt geometry and it is used to describe whether the focus increases or decreases as a function of Z distance.
Input coordinates: None
Input tilt series: Tilt series with alignment (non interpolated) used in the tomograms reconstruction.
Flip Z coordinate?: This option is generally False if your coordinates are displayed correctly in Scipion. You may want to check this to True only if you see that the extracted subtomograms are wrong.
Has tomogram been flipped along Y and Z?: This option is generally True if the slices of your tomogram are displayed on slice Z in Imod. Usually, a tomogram is flipped along Y and Z (i.e. rotated around X with 90 degrees) after the reconstruction and before the particles have been picked. This will tell Relion to apply the same transformation to the coordinate system.
Has the Z axis been flipped?: This option is generally True when you apply reconstrucion in Imod. This is usually used together with the flipYZ option.
Swap X with Y dimensions of the tilt series: This may be a trial and error parameter. Depending of the reconstruction path of your tomograms we you may need to deactivate this option to get good results. This option will be deprecated in the future

The protocol named "Average from tilt series" can be found at the reliontomo plugin.
Its help description is:
 Reconstructs/averages from the tilt series projected particles.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Box size (pix.): Box size, in pixels,  of the reconstruction. Note that this is independent of the box size used to refine the particle. This allows the user to construct a 3D map of arbitrary size to gain an overview of the structure surrounding the particle. A sufficiently large box size also allows more of the high-frequency signal to be captured that has been delocalized by the CTF.
Cropped box size (pix.): Cropped box size in pixels. If set, the program will output an additional set of maps that have been cropped to this size. This is useful if a map is desired that is smaller than the box size required to retrieve the CTF-delocalized signal.
Binning factor: Downsampling (binning) factor. Note that this does not alter the box size. The reconstructed region instead becomes larger.
Symmetry group: Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
FSC solvent mask (opt.): Provide a soft mask to automatically estimate the postprocess FSC.
Apply a Wiener filter with this SNR: If set to a positive value, apply a Wiener filter with this signal-to-noise ratio. If omitted, the reconstruction will use a heuristic to prevent divisions by excessively small numbers. Please note that using a low (even though realistic) SNR might wash out the higher frequencies, which could make the map unsuitable to be used for further refinement.

The protocol named "Auto-refinement of subtomograms" can be found at the reliontomo plugin.
Its help description is:
 Auto-refinement of subtomograms..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Reference volume: Initial reference 3D map, it should have the same dimensions and the same pixel size as your input particles.
Reference mask (optional): A volume mask containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask. If no mask is given, a soft spherical mask based on the <radius> of the mask for the experimental images will be applied.

In some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. Check _Advaced_ parameters to select another volume mask.
Second reference mask (optional): For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas.
Is initial 3D map on absolute greyscale?: Perform CC-calculation in the first iteration (use this if references are not on the absolute intensity scale). See detailed explanation below:

 Probabilities are calculated based on a Gaussian noise model,which contains a squared difference term between the reference and the experimental image.

 This has a consequence that the reference needs to be on the same absolute intensity greyscale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity greyscale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. But, if the map wasreconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No.

If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent map refinement. Therefore, if in doubt it is recommended to set this option to No.
Initial low-pass filter (A): It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s).
Symmetry group: Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Circular mask diameter (Å): Diameter of the circular mask that will be applied to the experimental images (in Angstroms)
Mask individual particles with zeros?: If set to Yes, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform.

This will remove noise and therefore increase sensitivity in the alignment and classification.

However, it will also introduce correlations between the Fourier components that are not modelled. When set to No, then the solvent area is filled with random noise, which prevents introducing correlations.

High-resolution refinements (e.g. ribosomes or other large complexes in 3D auto-refine) tend to work better when filling the solvent area with random noise (i.e. setting this option to No), refinements of smaller complexes and most classifications go better when using zeros (i.e. setting this option to Yes).
Use solvent-flattened FSCs?: If set to Yes, then instead of using unmasked maps to calculate the gold-standard FSCs during refinement, masked half-maps are used and a post-processing-like correction of the FSC curves (with phase-randomisation) is performed every iteration.

This only works when a reference mask is provided. This may yield higher-resolution maps, especially when the mask contains only a relatively small volume inside the box.
Initial angular sampling interval (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
Initial offset range (pix.): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
Initial offset step (pix.): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluatedon a 2x coarser grid.
Local searches from auto-sampling: Minimum healpix order (before oversampling) from which autosampling procedure will use local searches.

In the automated procedure to increase the angular samplings, local angular searches of -6/+6 times the sampling rate will be used from this angular sampling rate onwards. For most lower-symmetric particles a value of 1.8 degrees will be sufficient. Perhaps icosahedral symmetries may benefit from a smaller value such as 0.9 degrees.
Symmetry to be relaxed: With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020 cited in the About dialog.

Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
Use finer angular sampling faster?: If set to Yes, then let auto-refinement proceed faster with finer angular samplings. Two additional conditions will be considered:

 	-Angular sampling will go down despite changes still happening in the angles.
	-Angular sampling will go down if the current resolution already requires that sampling
	 at the edge of the particle.

This option will make the computation faster, but hasn't been tested for many cases for potential loss in reconstruction quality upon convergence.
Use parallel disc I/O?: If set to Yes, all MPI followers will read their own images from disc. Otherwise, only the leader will read images and send them through the network to the followers. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many followers reading in parallel. If your datasets contain particles with different box sizes, you have to say Yes.
Number of pooled particles: Particles are processed in individual batches by MPI followers. During each batch, a stack of particle images is only opened and closed once to improve disk access times.

All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. This parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together.

This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Skip griding?: Skip gridding in the Maximization step in the Expectation-Maximization algorithm. If this option is set to Yes, more memory will be consumed during the protocol execution, but it will be faster.
Pre-read all particles into RAM?: If set to Yes, the leader process read all particles into memory. Be careful you have enough RAM for large data sets!
Combine iterations through disc?: If set to Yes, the large arrays of summed weights will be sent through the MPI network instead of writing large files to disc.
Copy particles to scratch directory: If provided, particle stacks will be copied to this local scratch disk prior for refinement.
Skip padding?: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
Use GPU acceleration?: If set to Yes, it will use available gpu resources for some calculations.
GPUs to use:: It can be used to provide a list of which GPUs (e. g. "0:1:2:3") to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Keep only files from last iteration?: If Yes is chosen, only the files which correspond to the last iteration will be saved in the protocol's extra directory. Otherwise, files corresponding to each iteration will be kept.
Over-sampling: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
Consider alignment as priors?: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--verb 1
--pad 2

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Average from subtomograms" can be found at the reliontomo plugin.
Its help description is:
  This protocol reconstructs a volume using Relion.
    Reconstruct a volume from a given set of subtomograms.
    The alignment parameters will be converted to a Relion star file
    and used as direction projections to reconstruct.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input subtomograms: Select the input subtomograms from the project.
Symmetry group: See [[Relion Symmetry][http://www2.mrc-lmb.cam.ac.uk/relion/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Relion
Maximum resolution (A): Maximum resolution (in Angstrom) to consider 
in Fourier space (default Nyquist).
Padding factor: None
Subset to reconstruct: Subset of images to consider.
Use only this class: Consider only this class (-1: use all classes)
Extra parameters: : Extra parameters to *relion_reconstruct* program. Address to Relion to see full list of options.
Apply CTF correction?: None
Leave CTFs intact until first peak?: None
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Tomo frame align" can be found at the reliontomo plugin.
Its help description is:
 Tomo frame align.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Volume to get the halves: None
Input reference mask: None
Box size for estimation (pix): Box size to be used for the estimation. Note that this can be larger than the box size of the reference map. A sufficiently large box size allows more of the high-frequency signal to be captured that has been delocalized by the CTF.
Max position error (pix): Maximal assumed error in the initial 2D particle-positions (distances between the projected 3D positions and their true positions in the images), given in pixels.
Align by shift only?: If set to Yes, tilt series projection shifts are refined based on cross-correlation. Useful for very badly aligned frames. No iterative optimisation.
Alignment model: If set to "Only particles", it estimates rigid shift by aligning only the particles instead of by predicting entire micrographs. In this case, only misalignments smaller than half the box size of the particle can be corrected.
Fit per particle motion?: If set to Yes, then the subtomogram version of Bayesian polishing will be used to fit per-particle (3D) motion tracks, besides the rigid part of the motion in the tilt series.
Sigma for velocity (Å/dose): The expected amount of motion (i.e. the std. deviation of particle positions in Angstroms after 1 electron per A^2 of radiation).
Sigma for divergence (Å): The expected spatial smoothness of the particle trajectories in angstroms (a greater value means spatially smoother motion.
Use Gaussian decay?: If set to Yes, then it is assumed that the correlation of the velocities of two particles decays as a Gaussian over their distance, instead of as an exponential. This will produce spatially smoother motion and result in a shorter program runtime.
Estimate 2D deformations?: If set to Yes, then the subtomogram version of Bayesian polishing will be used to fit per-particle (3D) motion tracks, besides the rigid part of the motion in the tilt series.
Horizontal sampling points: Number of horizontal sampling points for the deformation grid.
Vertical sampling points: Number of vertical sampling points for the deformation grid.
Alignment model: Type of model to use (linear, spline or Fourier).
Deformation regularisation scale: None
Refine deformations per frame?: If set to Yes, it models deformations per tilt frame instead of per tilt series.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Reconstruct tomograms from prepare data prot" can be found at the reliontomo plugin.
Its help description is:
  This protocol reconstructs a single tomogram using Relion. It is very useful
    to check if the protocol "Prepare data" has been applied correctly (in terms of flip
    options, for example).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Prepare Data protocol: It is very usefulto check if the protocol "Prepare data" has been applied correctly (in terms of flip options, for example)
Choose a reconstruction option: None
Tomogram to be reconstructed: None
Binning factor: The binning will be applied concerning the size of the tomograms used for the picking.
Width: If -1, the width considered will be of the original tilt series after having applied the introduced binning factor.
Height: If -1, the height considered will be of the original tilt series after having applied the introduced binning factor.
Thickness: If -1, the thickness considered will be of the original tilt series after having applied the introduced binning factor.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Matching coordinates" can be found at the reliontomo plugin.
Its help description is:
 
    Protocol to generate a set of pseudosubtomograms taking into account the
    intersection of  a set of 3D coordinates and a set of pseudosubtomograms
    as input.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input pseudoubtomograms: Select the input pseudosubtomograms from the project.
Subtomograms or 3D coordinates: Select the subtomograms or 3D coordinates that we want to match with the pseudosubtomogram

The protocol named "ctf estimation" can be found at the emantomo plugin.
Its help description is:
 
    Protocol for CTF estimation from tilt series using e2spt_tomoctf.py
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tilt Series: None
min: None
max: None
Step: None
Do phase shift search?: None
min: None
max: None
Step: None
Size of tile to calculate FFT: None
Number of references: Using N tilt images near the center tilt to estimate the range of defocus for all images.
Step in X direction: Number of tiles to generate on x-axis (different defocus)
Step in Y direction: Number of tiles to generate on y-axis (same defocus)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Multi-reference classification pppt" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_refinemulti_new.py* EMAN2 program.
    Multi-reference classification for the new (2021) SPT refinement protocol.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Aligned particles: None
Mask the references prior to to classif. (opt.): None
Max. resolution (Å): Maximum resolution (the smaller number) to consider in alignment (in Å).
Since gold-standard validation is not used here, setting this parameter is mandatory.
Min. resolution (Å): Minimum resolution (the larger number) to consider in alignment (in Å).
Number of classes: None
Reference volume (opt.): None
No. iterations: None
Sym. to apply to the average: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Break specified symmetry: If empty, no symmetry will be broken.
Do alignment?: If set to No (default), it will skip the alignment entirely when aligned particles are provided. Otherwise a local orientation search will still be performed.
Apply mask to the 3D alignment ref. in each iter. (opt.): Not applied to the average, which will follow normal EMAN's masking routine.
Maximum angular diff. (deg.): maximum angle difference for local alignment (in degrees)
Maximum shift (px): If set to -1, it will be estimated as maxShift=boxSize/6.
Threads for post-processing: None
Do make3d in threading mode with shared memory?: Safer for large boxes.
Extra params: Here you can add any extra parameters to run Eman's  new subtomogram refinement. Parameters should be written in Eman's command line format (--param val)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "average subtomograms" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_average.py* EMAN2 program.
    Computes the average a selected subset of a SetOfSubtomograms in the predetermined orientation
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input SubTomograms: Select the set of subtomograms to perform the reconstruction.
Symmetry: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Missing wedge threshold: Threshold for identifying missing data in Fourier space in terms of standard deviation of each Fourier shell. Default 3.0. If set to 0.0, missing wedge correction will be skipped
Skip post process steps (fsc, mask and filters): None
Keep hdf files?: If set to Yes, the generated files will be saved in both HDF and MRC formats. They are generated in HDF and then converted into MRC. The HDF files are deleted by default to save storage.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Extraction from TS" can be found at the emantomo plugin.
Its help description is:
 Extract 2D subtilt particles from the tilt series, and reconstruct 3D subvolumes..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates or 3D particles: The corresponding tomograms data will be accessed from the provided coordinates or the coordinates associated to the 3D particles.
CTF tomo series: Estimated CTF for the tilt series associates to the tomograms used to pick the input coordinates. The corresponding tilt series data will be also accessed through them.
Tilt series: Tilt series with alignment (non interpolated) used in the tomograms reconstruction.
Flip Z axis in tomogram?: If the reconstruction was carried out with EMAN, it would be set to No.
Box size unbinned (px): The subtomograms are extracted as a cubic box of this size.
Particles binning factor: For example, if the unbinned box size is 160 pix and the particles binning factor introduced is 4, the 2D tilt particles will be cropped on the tilt series with a box of 160 x 160 pix, and then shrink to 160 / 4 = 40 pix. Thus, both resulting 2D and 3D sets of particles will be of size 40 pix.
Max tilt: None
Tilt fraction to keep: Keep a fraction of tilt images with good score determined from tomogram reconstruction
Contrast threshold for 2D particle removal: Remove 2d particles with high contrast object beyond N sigma at 100Å. Note that this may result in generating fewer particles than selected. Default is -1 (include all particles). 0.5 might be a good choice for removing gold beads.
Padding factor: If set to 0, no padding will be considered. If your particles are deeply buried in other densities, using a bigger padtwod may help, but doing so may significantly increase the memory usage and slow down the process.
Minimum distance between particles (Å): None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Template matching picking" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_tempmatch.py* EMAN2 program.
    It is a reference-based picking (template matching).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomograms: Specify tomograms containing reference-like particles to be exctracted. These should be "dark contrast".
Reference volume: This should be 'light contrast'.
Maximum no. particles picked among the tomograms: If a higher number of particles is detected, the program will take the best N, being N the value of the current parameter.
Anglular sampling to rotate the reference (deg.: The lower value, the higher number of orientations that will be checked.
Distance threshold (Å): Particles closer than the value introduced will be removed. If default =-1, it will be considered as half of the box size of the reference.
Template matching threshold (n sigma): Particles with score lower than the introduced value will be removed. Admitted values are [1, 10], where 1 means very insensitive picking (pick a lot of particles with a high probability of having a a high number of false positives) and 10 means very sensitive picking (strict picking, with less particles picked and very low presence of false positives, but with high probability of some or even a lot of particles not to be picked.
Minimum peak volume: If default=-1, this filter is not applied.
Maximum peak volume: If default=-1, this filter is not applied.
Symmetry of the reference: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Remove particles on the edge?: None
Remove particles near gold fiducials?: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Manual picking" can be found at the emantomo plugin.
Its help description is:
  Manual picker for Tomo. Uses EMAN2 e2spt_boxer.py.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select the Tomogram to be used during picking.
Modify previous coordinates?: This option allows to add and/or remove coordinates to a previous SetOfCoordinates
Input Coordinates: Select the previous SetOfCoordinates you want to modify

The protocol named "clip tomograms" can be found at the emantomo plugin.
Its help description is:
 Make the output have this size by padding/clipping and re-centered using e2proc3d.py. Both
    new center and new dimensions are referred to the original position and dimensions, respectively..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tomograms: None
cx: None
cy: None
cz: None
dx: None
dy: None
dz: None

The protocol named "Subtomograms extraction from tomogram" can be found at the emantomo plugin.
Its help description is:
  Extraction for Tomo. Uses EMAN2 e2spt_boxer_old.py..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates/Subtomograms: Choose coordinates or subtomograms derived from 3d coordinates.
Tomogram source: By default the subtomograms will be extracted from the tomogram used in the picking step ( _same as picking_ option ). 
If you select _other_ option, you must provide a different tomogram to extract from. 
*Note*: In the _other_ case, ensure that provided tomogram and coordinates are related 
Input tomogram: Select the tomogram from which to extract.
Box size: The subtomograms are extracted as a cubic box of this size. The wizard will select the box size considering the sampling rate ratio between the introduced coordinates and the tomograms that will br used for the extraction.
Invert contrast?: Invert the contrast if your tomogram is black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background. Frealign (up to v9.07) requires black particles over a white background
Normalize subtomogram?: Normalization processor applied to subtomograms before extraction.
Normalize method: Use normalize.edgemean if the particles have a clear solvent background (i.e., they are not part of a larger complex or embeded in a membrane)

The protocol named "Initial model" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_sgd.py* EMAN2 program.

    It will take a set of subtomograms (particles) and a subtomogram(reference)
    and build a subtomogram suitable for use as initial models in tomography.
    It also builds a set of subtomograms that contains the original particles
    plus the score, coverage and align matrix per subtomogram .
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particles: Select the set of subtomograms to build an initial model
Reference volume: Specify a 3D volume
Mask: Select a 3D Mask to be applied to the initial model
Symmetry: Specify the symmetry.
Choices are: c(n), d(n), h(n), tet, oct, icos.
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry
for a detailed description of symmetry in Eman.
Filterto: Filter map to frequency after each iteration. Default is 0.02
Fourier: Gradient descent in fourier space
Batch Size: SGD batch size. Increasing batchsize will use more cores (if you have more than 12), and may cause it to converge to the correct answer in fewer iterations, but each iteration will not become faster.
Learn Rate: Learning Rate. Default is 0.1
Number of iterations to perform: The total number of refinement iterations to perform.
Number of batches: Number of batches per iteration
Shrink factor: Using a box-size >64 is not optimal for making initial models. Suggest using this option to shrink the input particles by an integer amount prior to reconstruction. Default = 1, no shrinking
Apply Symmetry: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.

The protocol named "Initial model pppt" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_sgd_new.py* EMAN2 program.
    It generates an initial model from subtomograms using stochastic gradient descent.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particles: Select the set of subtomograms to build an initial model
Reference volume (opt.): None
Binning factor: This option can be used to shrink the input particles by an integer amount prior to reconstruction, making them smaller. Default = 1 means no shrinking
No. iterations: None
No. classes: None
Symmetry: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Target resolution (Å): None
Batch Size: SGD batch size. Increasing batch size will use more cores (if you have more than 12), and may cause it to converge to the correct answer in fewer iterations, but each iteration will not become faster.
Fraction of particles to keep: It will actually align more particles and use the number of particles specified by the batch size parameter. Default = 1 means that all the particles are kept.
Learning Rate: In the context of stochastic gradient descent (SGD), the learning rate is a hyperparameter that determines the step size at each iteration when updating the model's parameters.

In other words, the learning rate controls how much the parameters are adjusted in the direction of the gradient, which is the direction of steepest descent of the loss function. A higher learning rate leads to larger updates and faster convergence, but it may also cause the algorithm to overshoot the optimal solution and fail to converge. On the other hand, a lower learning rate leads to smaller updates and slower convergence, but it may also help the algorithm avoid overshooting and find a more precise optimum.

Choosing an appropriate learning rate is important for achieving good performance in SGD. It typically involves a trade-off between convergence speed and accuracy, and may require tuning through trial and error or more advanced optimization techniques such as adaptive learning rate methods.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "subtomogram refinement" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_refine.py* EMAN2 program.

    Protocol to performs a conventional iterative subtomogram averaging
    using the full set of particles.
    It will take a set of subtomograms (particles) and a subtomogram(reference,
    potentially coming from the initial model protocol)
    and 3D reconstruct a subtomogram.
    It also builds a set of subtomograms that contains the original particles
    plus the score, coverage and align matrix per subtomogram .
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input SubTomograms: Select the set of subtomograms to perform the reconstruction.
Input Ref SubTomogram: 3D reference for initial model generation.No reference is used by default.
Number of iterations: The number of iterations to perform.
Mass:: Mass normalization. Default=-1 Ignores mass
Particle keep:: Fraction of particles to keep
Gold standard:: initial resolution for gold standard refinement
Gold continue: continue from an existing gold standard refinement
Mask file: Mask file to be applied to initial model
Structure factor: Select the structure factor
Symmetry: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Local filter: use tophat local
maxtilt: Explicitly zeroes data beyond specified tilt angle.Assumes tilt axis exactly on Y and zero tilt in X-Yplane. Default 90 (no limit).
Use previous alignments?: None
Maximum angular change: Maximum anglular difference in refine mode (in degrees)
Extra params: Here you can add any extra parameters to run Eman subtomogram refinement. Parameters should be written in Eman command line format (--param=val)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "subtomogram refinement pppt" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_refine_new.py* EMAN2 program.
    This refinement protocol performs subtomogram, subtilt and defocus refinement. The 2D subtilt particles are used
    instead of 3D subvolumes in the subtomogram refinement step. Moreover, this program now can model the localized 2D
    particle motion by considering the motion trajectory of each particle along with its neighbor.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particles: None
Reference volume (opt.): None
Refinement initial resolution (Å): This will be the maximum resolution considered for the first iteration. In later iterations, the maximum resolution is calculated from the FSC of the previous iteration (unless the parameter max. resolution is specified).
Iteration information: Input types of refinement separated by comma:

	- *p*: 3d particle translation-rotation.
	- *t*: subtilt translation.
	- *r*: subtilt translation-rotation.
	- *d*: subtilt defocus.

Default is p,p,p,t,p,p,t,r,d. Character followed by number is also acceptable. p3 = p,p,p.
Symmetry: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Particle keep: Fraction of particles to keep. Note that this is controlled at three separate steps.
When default = 0.95, it removes:

	- The worst 5% 3D particles.
	- The 5% 2D subtilt with the worst score.
	- The 5% of subtilt with the largest drift.

Also accept comma separated values 0.9,0.5,0.5 to set different keep thresholds for the three removal operations described before.
3D map filtering: Options to filter the 3D maps:

	- wiener: wiener filter based on FSC curve. default mode in most programs.
	- global: tophat filter across the map at the resolution cutoff 0.143 from fsc_masked_xx.txt.
	- localwiener: wiener filter based on the fsc curve of local regions from the even/odd maps.
	- local: tophat filter based on local resolution calculated from the even/odd maps at 0.143 cutoff.
Max. resolution in alignment (Å): The program will determine maximum resolution each round from the FSC of the previous round by default.
Min. resolution in alignment (Å): None
Do local refine? (only for p iterations): Perform only local search around the solution from the previous alignment.
Maximum angular diff. (deg.): maximum angle difference from starting point for local refine (in degrees)
Maximum shift (px): If set to -1, it will be estimated as maxShift= boxSize/6.
Smooth motion factor: Controls how many of its neighbors are considered to model the local motion. Smoother local motion with larger numbers.
No. neighboring particles used for smoothing: Used to control how many of its neighbors are considered to model the local motion.
Threads for post-processing: None
Do make3d in threading mode with shared memory?: Safer for large boxes.
Extra params: Here you can add any extra parameters to run Eman's  new subtomogram refinement. Parameters should be written in Eman's command line format (--param val)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Alignment and reconstruction" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2tomogram.py* EMAN2 program.

    Tilt series alignment and tomogram reconstruction.
    Tomograms are not normally reconstructed at full resolution, generally limited to 1k x 1k or 2k x 2k,
    but the tilt-series are aligned at full resolution. For high resolution subtomogram averaging, the raw
    tilt-series data is used, based on coordinates from particle picking in the downsampled tomograms.
    On a typical workstation reconstruction takes about 4-5 minutes per tomogram.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tilt Series: Select the set of tilt series to be aligned and/or to reconstruct the corresponding tomograms.
Bit compression: Number of bits of precision in outputs with lossless compression. Value -1 means uncompressed float
Keep hdf files?: If set to Yes, the generated files will be saved in both HDF and MRC formats. They are generated in HDF and then converted into MRC. The HDF files are deleted by default to save storage.
Align the tilt series?: None
Generated the interpolated tilt series?: If set to Yes, an additional set of tilt series with the transformation matrix applied will be generated. It can be used to check if the alignment was correctly calculated.

*NOTE*: Depending on the combination of parameters "Align the tilt series" and "Reconstruct the tomogram", the interpolated tilt series generated may be different in terms of size and sampling rate.
The interpolated tilt series generated when the tomogram is requested to be reconstructed is different from the one generated if only align TS is selected (It is part of the reconstruction functionality in the first case, and a temp file part of the alignment step in the second case).
No. landmarks to use: None
Fraction of landmarks to keep in the tracking: None
No. patch tracking iterations: use patch tracking before landmark based alignment. input 0/1/2 as the number of patch tracking iterations.
Box size of the particles for tracking (px): It may be helpful to use a larger one for fiducial-less cases.
Should Eman estimate the tilt angles?: If set to No, a .tlt file will be generated containing the tilt angles read from Scipion imported tilt series metadata and passed to Eman. Default=True will let Eman to estimate the tilt angles, following the Eman original default behavior.
Index of the center tilt: If set -1, it will be estimated by EMAN.
Tilt axis angle: If not provided, it will be read from the tilt series metadata. If it is not contained in the metadata, it will be estimated by EMAN.
Write intermediate results?: They will be generated always the interpolated tilt series are requested.
Reconstruct the tomograms?: None
Size of the output tomograms: None
No. iterations for 500, 1K, 2K, and 8K images: None
Thickness (px): Z thickness of the final tomogram output. default is -1, (5/16 of tomogram length).
Fraction of tilts to keep in the reconstruction: None
Make final tomogram by tiles?: None
Sample more tiles during rec.?: If set to Yes, the processing time will be greater, but it can be useful to reduce the boundary artifacts when the sample is thick.
Correct rotation: Correct for global rotation and position sample flat in tomogram.
Correct drifting along the X axis?: None
Filter final tomogram to target resolution (Å): None
Density value threshold for removing beads: "Density value threshold (of sigma) for removing beads. High contrast objects beyond this value will be removed. Default is -1 for not removing.
Extra pad: Use extra padding for tilted reconstruction. It is slower and costs more memory, but reduces the boundary artifacts when the sample is thick.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "boxer auto" can be found at the eman2 plugin.
Its help description is:
  Automated particle picker for SPA. Uses EMAN2 (versions 2.2+) e2boxer.py
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
: Set to Yes if you want to run Neural Net boxer on GPU. Default is CPU.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Eman boxer can use only one GPU.
Box size (px): Box size in pixels. See http://eman2.org/BoxSize
Particle size (px): Longest axis of particle in pixels (diameter, not radius).
Autopicker mode:: Choose autopicker mode:

 _local search_ - Reference based search by downsampling and 2-D alignment to references.
 _by ref_ - simple reference-based cross-correlation picker with exhaustive rotational search.
 _neural net_ - convolutional neural network boxer.
 _gauss_ - simple reference-free picker.
Threshold: None
Threshold2: None
Threshold low: None
Threshold high: None
Gaussian width: None
Previous e2boxer protocol: Provide previously executed e2boxer protocol that has all 3 types of references and pre-trained neural network.
Good references: Good particle references.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "boxer" can be found at the eman2 plugin.
Its help description is:
  Semi-automated particle picker for SPA. Uses EMAN2 e2boxer.py.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
Box size (px): Box size in pixels.
Particle size (px): Longest axis of particle in pixels (diameter, not radius).
Device: For Convnet training only.
Pick a device to use. Choose from cpu, gpu, or gpuX (X=0,1,...) when multiple gpus are available. Default is cpu.
Invert Y coordinates: In some cases, using dm3 or tiff Y coordinates must be flipped. Check output and activate this if needed.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "ctf auto" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2ctf_auto.py* EMAN2 program.
    It automates the CTF fitting and structure factor
    generation process.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
type: Performs CTF processing targeting different resolution:
*hires* - 2-6 Angstrom
*midres* - 7-15 Angstrom
*lores* - 15-30 Angstrom
Min: None
Max: None
Fit from scratch: Force refitting of CTF from scratch, ignoring any previous fits.
Estimate astigmatism: Includes astigmatism in automatic fitting.
Estimate phase shift: Include phase/amplitude contrast in CTF estimation. For use with hole-less phase plates.
Extra padding: If particles were boxed more tightly than EMAN requires, this will add some extra padding.
Invariant type: Which type of invariants to generate
High density : If particles are very close together, this will interfere with SSNR estimation. If set uses an alternative strategy, but may over-estimate SSNR.
Invert contrast: Invert the contrast of the particles in output files (default false)
Constant B-factor: Set B-factor to a fixed value, negative value enables autofitting.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "initial model" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2initialmodel.py* EMAN2 program.

    It will take a set of class-averages/projections and build a set
    of 3-D models suitable for use as initial models in single
    particle reconstruction. The output set is theoretically sorted
    in order of quality (best one is numbered 1), though it's best
    to look at the other answers as well.

    See more details in:
    http://blake.bcm.edu/emanwiki/EMAN2/Programs/e2initialmodel
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input averages: Select the your class averages to build your 3D model.
You can select SetOfAverages or SetOfClasses2D as input.
Symmetry group: Specify the symmetry.
Choices are: c(n), d(n), h(n), tet, oct, icos.
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry
for a detailed description of symmetry in Eman.
Number of iterations to perform: The total number of refinement to perform.
Number of different initial models: The number of different initial models to generate in search of a good one.
Shrink factor: Using a box-size >64 is not optimal for making initial models. Suggest using this option to shrink the input particles by an integer amount prior to reconstruction. Default = 1, no shrinking
Use random orientations?: Instead of seeding with a random volume, seeds by randomizing input orientations
Automask expand (px): Number of voxels of post-threshold expansion in the mask, for use when peripheral features are truncated (default=shrunk boxsize/20)
Additional arguments:: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "e2initialmodel.py -h" will print a list of possible options.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "initial model SGD" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2initialmodel_sgd.py* EMAN2 program.

    This program makes initial models using a (kind of) stochastic gradient
    descent approach. It is recommended that the box size of
    particles is around 100.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Select input type: You can choose either class averages or particles as input.
Input averages: Select the class averages to build your 3D model.
You can select SetOfAverages or SetOfClasses2D as input.
Input particles: Select the particles to build your 3D model.
Symmetry group: Specify the symmetry.
Choices are: c(n), d(n), h(n), tet, oct, icos.
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry
for a detailed description of symmetry in Eman.
Batch size: Batch size of stochastic gradient descent. N particles are randomly selected to generate an initial model at each step.
Number of iterations to perform: The total number of refinement to perform.
Number of different initial models: The number of different initial models to generate in search of a good one.
Target resolution (A): Target resolution in A of the model.
Shrink factor: Using a box-size >64 is not optimal for making initial models. Suggest using this option to shrink the input particles by an integer amount prior to reconstruction. Default = 1, no shrinking
Learning rate: Learning rate is how much the initial model changes toward the gradient direction in each iteration. Ranges from 0.0 to 1.0. Default is 0.3
Learning decay: Learning rate multiplier after each iteration.
Add noise: Add noise on particles at each iteration. Stablize convergence for some reason.
Full coverage: Assume the input particles covers most of the orientation of the model. This gives better performance when the model is relatively featureless, but is more likely to fail when there are incorrect particles in the input.
Write tmp output?: Write output for each iteration.
Additional arguments:: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "e2initialmodel_sgd.py -h" will print a list of possible options.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "reconstruct" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2make3d.py* EMAN2 program.

    Reconstructs 3D volumes using a set of 2D images.
    Euler angles are extracted from the 2D image headers
    and symmetry is imposed. Several reconstruction methods
    are available. The fourier method is the default and
    recommended reconstructor.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input images from the project.
Skip ctf estimation?: Use this if you want to skip running e2ctf.py. It is not recommended to skip this step unless CTF estimation was already done with EMAN2.
Use old e2make3d?: Use the traditional e2make3d program instead of the new e2make3dpar program.
Number of iterations:: Set the number of iterations. Iterative reconstruction improves the overall normalization of the 2D images as they are inserted into the reconstructed volume, and allows for the exclusion of the poorer quality images.
Symmetry group: Set the symmetry; if no value is given then the model is assumed to have no symmetry. 
Choices are: *i, c, d, tet, icos, or oct* 
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry 
for a detailed description of symmetry in Eman.
X : None
Y : None
X: None
Y: None
Z: None
X: None
Y: None
Z: None
Reconstruction Method:: Reconstructor to use. See e2help.py reconstructors -v 9. Default is fourier:mode=gauss_2.
Mode to Fourier method:: Fourier pixel insertion mode. See e2help.py reconstructors fourier -v 9. Default mode is gauss_2.
Sense of keep:: If *percentage* is selected, *keep* parameter will be interpreted as a percentage. It is the default option.
If *standard deviation* is selected, *keep* parameter will be interpreted as a standard deviation coefficient instead of as a percentage.
If *absolute quality* is selected, *keep* parameter will refer to the absolute quality of the class-average, not a local quality relative to other similar sized classes.
Fraction of slices to keep: The fraction of slices to keep, in fraction, based on quality scores (1.0 = use all slices).
Disable automatic weighting?: This argument turns automatic weighting off causing all images to be weighted by 1. If this argument is False images inserted into the reconstructed volume are weighted by the number of particles that contributed to them (i.e. as in class averages), which is extracted from the image header.
Additional parameters: In this box command-line arguments may be provided that are not generated by the GUI. See e2make3dpar.py -h.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "refine easy" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2refine_easy.py* EMAN2 program.

This is the primary single particle refinement program in EMAN2.1+.
It replaces earlier programs such as e2refine.py and e2refine_evenodd.py.

Major features of this program:

 * While a range of command-line options still exist. You should not
 normally specify more than a few basic requirements. The rest will
 be auto-selected for you.
 * This program will split your data in half and automatically
 refine the halves independently to produce a gold standard resolution
 curve for every step in the refinement.
 * An HTML report file will be generated as this program runs,
 telling you exactly what it decided to do and why, as well as giving
 information about runtime, etc while the job is still running.
 * The gold standard FSC also permits us to automatically filter the
 structure at each refinement step. The resolution you specify is
 a target, NOT the filter resolution.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Continue from a previous run?: If you set to *Yes*, you should select a previous run of type *EmanProtRefine* class and most of the input parameters will be taken from it.
Select previous run: Select a previous run to continue from.
Input particles: Select the input particles.
Initial 3D reference volume: Input 3D reference reconstruction.
Skip ctf estimation?: Use this if you want to skip running e2ctf.py. It is not recommended to skip this step unless CTF estimation was already done with EMAN2.
Number of iterations: The total number of refinement iterations to perform.
Tophat filter?: Instead of imposing a final Wiener filter (tophat = none)), use a tophat filter (global similar to Relion). local determines local resolution and filters. Danger of feature exaggeration.
Symmetry group: Set the symmetry; if no value is given then the model is assumed to have no symmetry. 
Choices are: c(n), d(n), tet, icos, or oct.
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Break symmetry?: If set True, reconstruction will be asymmetric with *Symmetry group* parameter specifying a known pseudosymmetry, not an imposed symmetry.
Target resolution (A): Target resolution in A of this refinement run. Usually works best in at least two steps (low/medium) resolution, then final resolution) when starting with a poor starting model. Usually 3-4 iterations is sufficient.
Molecular mass (kDa): Approximate molecular mass of the particle, in kDa. This is used to run normalize.bymass. Due to resolution effects, not always the true mass.
Use old e2make3d?: Use the traditional e2make3d program instead of the new e2make3dpar program.
Expand mask by (px): Default=boxsize/20. Specify number of voxels to expand mask before soft edge. Use this if low density peripheral features are cut off by the mask.
Supress phase randomization: Suppress independent phase randomization of input map. Only appropriate if input map has been preprocessed in some suitable fashion.
Speed: Balances speed vs precision. Larger values sacrifice a bit of potential resolution for significant speed increases. Set to 1 when really pushing resolution. Set to 7 for initial refinements.
Fraction of particles to use in final average: The fraction of particles to keep in each class,based on the similarity score.
Fraction of class-averages to use in 3-D map: The fraction of slices to keep in reconstruction.
Use bispectra? (experimental): Will use bispectra for orientation determination (EXPERIMENTAL).
Use the setsfref option in class averaging?: This matches the filtration of the class-averages to the projections for easier comparison. May also improve convergence. Disabled when ampcorrect=flatten is used.
Do automask to the class-average?: This will apply an automask to the class-average during iterative alignment for better accuracy. The final class averages are unmasked.
Apply threshold before project the volume?: Applies a threshold to the volume just before generating projections. A sort of aggressive solvent flattening for the reference.
Postprocess parameters: <name>:<parm>=<value>:...  An arbitrary processor (e2help.py processors -v2) to apply to the 3-D map after each iteration. Default=none
Amplitude correction:: Will perform amplitude correction via the specified method. 'flatten' requires a target resolution better than 8 angstroms (experimental). 'none' will disable amplitude correction (experimental).
Additional parameters: In this box command-line arguments may be provided that are not generated by the GUI. See e2refine_easy.py -h.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "refine 2D" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2refine2d.py* EMAN2 program.

    This program is used to produce reference-free class averages
    from a population of mixed, unaligned particle images. These averages
    can be used to generate initial models or assess the structural
    variability of the data. They are not normally themselves used as part
    of the single particle reconstruction refinement process, which
    uses the raw particles in a reference-based classification
    approach. However, with a good structure, projections of the
    final 3-D model should be consistent with the results of
    this reference-free analysis.

    This program uses a fully automated iterative alignment/MSA approach.
    You should normally target a minimum of 10-20 particles per
    class-average, though more is fine.

    Default parameters should give a good start, but are likely not
    optimal for any given system.

    Note that it does have the --parallel option, but a few steps of the
    iterative process are not parallellised, so don't be surprised if
    multiple cores are not always active.
.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Continue from a previous run?: If you set to *Yes*, you should select a previous run of type *EmanProtRefine2D* class. The refinement will resume after the last completed iteration. It is ok to alter other parameters.
Select previous run: Select a previous run to continue from.
Input particles: Select the input particles.
Input class averages: Select starting class averages. If not provided, they will be generated automatically.
Skip ctf estimation?: Use this if you want to skip running e2ctf.py. It is not recommended to skip this step unless CTF estimation was already done with EMAN2.
Number of class-averages: Number of class-averages to generate. Normally you would want a minimum of ~10-20 particles per class on average, but it is fine to have 100-200 for a large data set. If you plan on making a large number (>100) of classes, you should use the *Fast seed* option. Note that these averages are not used for final 3-D refinement, so generating a very large number is not useful in most situations.
Number of iterations: Number of iterations of the overall 2-D refinement process to run. For high contrast data, 4-5 iterations may be more than enough, but for low contrast data it could take 10-12 iterations to converge well.
If running in Continue mode, provide here a number of additional iterations to run.
Number of MSA vectors to use: Number of MSa basis vectors to use when classifying particles.
Number of alignment references: The number of alignment references to use in each iteration. You can look at this as the number of different highly distinct views your particle has. With something like GroEL with mostly side views and top views, 3-4 is sufficient. With something like a ribosome something more like 10-15 would be appropriate.
Normalize projected vectors?: Normalizes each projected vector into the MSA subspace. Note that this is different from normalizing the input images since the subspace is not expected to fully span the image
Use fast seed?: Will seed the k-means loop quickly, but may produce less consistent results. Always use this when generating >~ 100 classes.
Automask class-averages?: This will perform a 2-D automask on class-averages to help with centering. May be useful for negative stain data particularly.
: None
params: None
Additional arguments:: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "e2refine2d.py -h" will print a list of possible options.
These parameters are for advanced users only!
: For help please address to EMAN2 [[http://blake.bcm.edu/emanwiki/EMAN2][Wiki]] or run:
*scipion run e2help.py cmp -v 2* or
*scipion run e2help.py aligners -v 2*
Shrink particles: Optionally shrink the input particles by an integer amount prior to computing similarity scores. For speed purposes.
: None
params: None
: None
params: None
: None
params: None
: None
params: None
: None
params: None
These parameters are for advanced users only!
: For help please address to EMAN2 [[http://blake.bcm.edu/emanwiki/EMAN2][Wiki]] or run:
*scipion run e2help.py cmp -v 2* or
*scipion run e2help.py averagers -v 2*
Number of iterations for class-averages: Number of iterations to use when making class-averages (default=5)
Fraction of particles to keep: The fraction of particles to keep in each class, based on the similarity score generated by cmp (default=0.85)
Keep particles based on sigma?: Change the *keep* criterion from fraction-based to sigma-based
Filter class-averages?: Use setsfref option in class averaging to produce better class averages
Class averager: : The averager used to generated class-averages
: None
params: None
: None
params: The name of a cmp to be used in class averaging (default=ccc)
: None
params: None
: None
params: None
: None
params: None
: None
params: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "refine 2D bispec" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2refine2d_bispec.py* EMAN2 program.

    This program is used to produce reference-free class averages
    from a population of mixed, unaligned particle images. These averages
    can be used to generate initial models or assess the structural
    variability of the data. They are not normally themselves used as part
    of the single particle reconstruction refinement process, which
    uses the raw particles in a reference-based classification
    approach. However, with a good structure, projections of the
    final 3-D model should be consistent with the results of
    this reference-free analysis.

    This variant of the program uses rotational/translational
    invariants derived from the bispectrum of each particle.
.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Choose e2ctf auto protocol: Select EMAN CTF auto protocol that has generated bispectra.
Number of class-averages: Number of class-averages to generate. Normally you would want a minimum of ~10-20 particles per class on average, but it is fine to have 100-200 for a large data set. If you plan on making a large number (>100) of classes, you should use the *Fast seed* option. Note that these averages are not used for final 3-D refinement, so generating a very large number is not useful in most situations.
Number of MSA vectors to use: Number of MSa basis vectors to use when classifying particles.
Normalize projected vectors?: Normalizes each projected vector into the MSA subspace. Note that this is different from normalizing the input images since the subspace is not expected to fully span the image
Align and sort?: This will align and sort the final class-averages based on mutual similarity.
: None
params: None
Additional arguments:: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "e2refine2d_bispec.py -h" will print a list of possible options.
These parameters are for advanced users only!
: For help please address to EMAN2 [[http://blake.bcm.edu/emanwiki/EMAN2][Wiki]] or run:
*scipion run e2help.py cmp -v 2* or
*scipion run e2help.py averagers -v 2*
Number of iterations for class-averages: Number of iterations to use when making class-averages (default=5)
Fraction of particles to keep: The fraction of particles to keep in each class, based on the similarity score generated by cmp (default=0.8)
Keep particles based on sigma?: Change the *keep* criterion from fraction-based to sigma-based
Class averager: : The averager used to generated class-averages
: None
params: None
: None
params: The name of a cmp to be used in class averaging (default=ccc)
: None
params: None
: None
params: None
: None
params: None
: None
params: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tilt validate" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps the *e2tiltvalidate.py* EMAN2 program.
    It performs tilt validation using
    the method described in Rosenthal and Henderson, JMB (2003).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: Select the input volume that will be validated.
Input tilt pair particles: Select the input set of tilt pair particles.
Symmetry group: Set the symmetry; if no value is given then the model is assumed to have no symmetry. 
Choices are: *i, c, d, tet, icos, or oct* 
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry
for a detailed description of symmetry in Eman.
Max tilt angle: Maximum tilt angle permitted when finding tilt distances.
Use quaternions: Use quaternions for tilt distance computation
Projection step (deg.): Angular step size for alignment
Shrink particles: Optionally shrink the input particles by an integer amount prior to computing similarity scores. For speed purposes.
Do contour plot?: Also make a contour plot similar to fig. 6 in Henderson paper
Tilt range: The angular tilt range to search
Verbose level: Verbose level from 0 to 9. 
These parameters are for advanced users only!
: For help please address to EMAN2 [[http://blake.bcm.edu/emanwiki/EMAN2][Wiki]] or run:
*e2help.py cmp -v 2* or
*e2help.py aligners -v 2*
type: None
params: None
type: None
params: None
type: None
params: None
type: None
params: None
type: None
params: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "bin tomograms" can be found at the dynamo plugin.
Its help description is:
 Reduce the size of a SetOfTomograms by a binning factor.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: None
Binning Factor: A Binning Factor of 1 means that no binning will be carried out.
Number of slices kept in memory: Maximum number of Z slices that are kept simultaneously in the memory during the binning process. This parameter might be important for larger size tomograms, making possible to process them in vertical slabs of thickness = value introduced in the  current parameter. This procedure can be accelerated using the multiple threads to engage several cores in parallel. However, this will only make sense if the total memory occupied by all the slabs simultaneously in memory in a given time fits in the RAM of the machine.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "vectorial picking" can be found at the dynamo plugin.
Its help description is:
 Manual vectorial picker from Dynamo. After choosing the Tomogram to be picked, the tomo slicer from Dynamo will
     be direclty loaded with all the models previously saved in the disk (if any).
     This picking will save the "user points" defined in a set of models and generate a set of meshes with them. In case
     the user carries out the workflow model for each of the models from the Dynamo GUI, a set of coordinates will be
     also created, containing all the interpolated coordinates, and the calculated orientation. It is possible to
     create several models at once in a given tomogram. Once the coordinates are defined, the models are automatically
     saved in the catalogue and registered..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select the Tomogram to be used during picking.
Box Size: None
Remove the .m files generated after the execution?: It can be useful for developers to check exactly what was .m files were generated by Scipion and executed by Dynamo.

The protocol named "subtomogram extraction" can be found at the dynamo plugin.
Its help description is:
 Extraction of subtomograms using Dynamo.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Coordinates: None
Tomogram source: By default the subtomograms will be extracted from the tomogram used in the picking step ( _same as picking_ option ).
If you select _other_ option, you must provide a different tomogram to extract from.
*Note*: In the _other_ case, ensure that provided tomogram and coordinates are related 
Input tomogram: Select the tomogram from which to extract.
Box size: The subtomograms are extracted as a cubic box of this size. The wizard will select the box size considering the sampling rate ratio between the introduced coordinates and the tomograms that will br used for the extraction.
Invert contrast?: Invert the contrast if your tomogram is black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "import subtomograms from tbl files" can be found at the dynamo plugin.
Its help description is:
  This protocol imports subtomograms with metadata generated from Dynamo tables.
    The subtomograms files are generated in the same directory as the .tbl file, one for each tomogram..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Tomograms (opt.): If not provided, the subtomograms won't be referred to any tomogram. If provided, the sampling rate value will be read from them.
Sampling rate [Å/px] (opt.): None

The protocol named "model workflow" can be found at the dynamo plugin.
Its help description is:
 
    Apply a model workflow to a SetOfMeshes generated by Dynamo Boxing protocol.
    This workflow will use the models created by the user to create the
    corresponding cropping meshes needed to extract the crop points.
    Considerations:
        1. The geometry will be automatically approximated from the clicked points.
        2. The meshes for the general models will be calculated treating them as surface models.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Meshes: Input Meshes that will be used to create the cropping geometry and to extract the crop points
Box size: None
Mesh parameter: Intended mesh parameter for the "mesh" that supports the depiction of the model. It governs the number or triangles.
Maximun number of triangles: Maximum number of triangles allowed during generation of a depiction mesh
Refine mesh?: If set to Yes, it will refine both the mesh and the cropped mesh, which means that the depiction grid will be subdivided (each triangle will generate four children). Hence, a higher number of points will be generated, but the computation time will be significantly increased.
Subdivision iterations: Specify the number of times the Mesh geometry will be subdivided. This will increase the number of triangles in the mesh, making it smoother. However, it will also increase the number of cropping points
Cropping parameter: Intended mesh parameter for the "crop_mesh" that defined a cropping geometry on a surface

The protocol named "Average subtomograms" can be found at the dynamo plugin.
Its help description is:
 None.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Subtomograms: None
Do implicit rotation masking? (opt.): If set to Yes, in the rotated particles, the material outside a spherical mask will not be computed. The particles will de facto appear with a spherical mask.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Subtomogram alignment" can be found at the dynamo plugin.
Its help description is:
 This protocol will align subtomograms using Dynamo.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation. Select the one you want to use.
: Add a list of GPU devices that can be used
Set of subtomograms: Set of subtomograms to align with dynamo
Template: The size of the template should be equal or smaller than the size of the particles.
Iterations (R): Number of iterations per round (R). Used to identify the number of rounds desired to be carried out.
Particle dimensions (R): If only one round, leave 0 to use the size of your particle. If working with multiple rounds, the size of the particles for each round is expected to be explicitly specified. If not, the size of the input particles will be used for all the rounds. This option can be used, for example, to reduce the particles size for a particular round and increase the speed. E.g.: 64 128 128.
Launch dynamo GUI: Launches Dynamo's alignment project GUI. Do not 'Run' the project, Scipion will do it for you.
Alignment mask (opt): This is the MOST important mask from the different types that can be used by Dynamo. It is used for the local correlation. The template is rotated and shifted (virtually, through fourier acceleration). At each posible combination of rotation angles and shift, the mask is also rotated and shifted, defining a moving region inside the template. The rotated and shifted template is compared to the data particle only inside this moving region. See more details in https://wiki.dynamo.biozentrum.unibas.ch/w/index.php/Alignment_mask.
Fourier mask on template (opt): Used in very few special cases. The Fourier Mask that you define on a template during an alignment project describes the Fourier content of the template, not the one of the data particles. It does not reflect directly the missing wedge of the tomogram. See more details in https://wiki.dynamo.biozentrum.unibas.ch/w/index.php/Fourier_mask_on_template.
Fourier Shell Correlation mask (opt): Used in the context of adaptive bandpass filtering. This procedure needs an automatic evaluation of the attained resolution at each iteration step. This is performed through and FSC computation of the averages computed independently in the different channels of the odd/even computation. See more details in https://wiki.dynamo.biozentrum.unibas.ch/w/index.php/Smoothing_mask
Cone aperture (R): The ‘cone_’ parameters define a set of orientations that will be sampled around a previously determined old orientation. Here we speak of orientations of the vertical axis of the template, not full unconstrained rotations. Allowing this axis to move inside a cone involves only two Euler angles (tdrot and tilt).

‘cone_range’, is the extent of this cone in degrees (360 being the full possible range of axis orientations).
Cone sampling (R): The ‘cone_’ parameters define a set of orientations that will be sampled around a previously determined old orientation. Here we speak of orientations of the vertical axis of the template, not full unconstrained rotations. Allowing this axis to move inside a cone involves only two Euler angles (tdrot and tilt).

’cone_sampling’ is the step inside the cone defined by ´cone_range´, also in degrees. The orientations are generated so as to provide an uniform coverage.
Cone flip (R): Generates a mirrored scanning geometry: the "cone" of directions is complemented with the diametrally oposed cone.
This is useful when averaging elongated particles in the case in which the direction of each one is not certain, i.e., the initial table catches the overall orientation of each particle, but it is not certain on which end is the "head" and which is the "tail", so that the refinement should allow "flippling" the particles (but still produce a scanning set of angles concentrated along the axis of the particle). Values:

	* 0:  No inversion of the cone (default!)
	* 1:  The cone is inverted only for the coarsest level of the multigrid refinement
	* 2:  The cone is inverted for all refinement levels
Azimuth rotation range (R): The ‘inplane_’ parameters complete the set of scanned Euler triplets. After each of the axis reorentations defined by the ‘cone_’ parameters, the template will be rotated about the new orientation of its axis. This involves only the ‘narot’ angle.

‘inplane_range’ defines the angular interval to be scanned around the old value of narot.
Azimuth rotation sampling (R): The ‘inplane_’ parameters complete the set of scanned Euler triplets. After each of the axis reorentations defined by the ‘cone_’ parameters, the template will be rotated about the new orientation of its axis. This involves only the ‘narot’ angle.

The project parameter ‘inplane_range’ defines the angular interval to be scanned around the old value of narot, and ‘inplane_sampling’ defines the interval.
Azimuth flip (R): Flips the set of inplane rotations.
The set of inplane rotations to scan will be the original set plus the flipped orientations.
This is useful when the particles have a directionality, but it is not very well defined. For instance, if you have decorations on a microtubule, you might expect that most of them will have similar orientations along the direction of the tube. However, this direction might not be obvious: if you have particles coming from two different tubes, reducing the span of azimuthal rotations to a narrow set along the estimated direction of the tube might be dangerous, as the particles from the two tubes might be oriented in different directions.Values:

	* 0  :  no flip (default).
	* 1  :  flips the coarsest level  in the multilevel grid.
	* 2  :  flips the full set (all levels).
Refine iterations per particle (R): How many refinement iterations are carried out on each single particle. This refinement when comparing rotations of the reference against the data, takes the best orientation and looks again with a finer sampling. The sampling in the refined search will be half of the sampling used in the original one.  The range of the refined search encompasses all the orientations that neighobur the best orientation found in the original search.
Refine factor (R): Controls the size of the angular neighborhood during the local refinement of the angular grid.
Shift limits (R): Restricts the search area to an sphere of the given radius centered and oriented in the last found position (Ellipsoid will be implemented soon).
Shift limiting way (R): States how exactly the shifts (area search) will be interpreted:

	* 0:  no limitations (can easily produce artifacts if the initial reference is bad).
	* 1:  limits are understood from the center of the particle cube.
	* 2:  limits are understood from the previous estimation on the particle position (i.e., the shifts available) With this option, the origin of the shifts changes at every iteration.
	* 3:  limis are understood from the estimation provided for the first iteration of the round. The origin of the shifts will change at each round.
	* 4:  limis are understood from the estimation provided for the first iteration of the project. The origin of the shifts is thus defined for the full project, and stays static all during the full computation.

Note that options 3 and 4 are useful to avoid particles gradually shifting away from the initially user-entered locations.
Separation in tomogram [pix.] (R): When tuned to  positive number, it will check the relative positions (positions in the tomogram+shifts) of all the particles in each tomogram separately. Whenever two particles are closer together than "separation_in_tomogram", only the particle with the higher correlation will stay.
Threshold parameter (R): Different thresholding policies can be used in order to select which particles are averaged in view of their CC (cross correlation value) . The value of the thresholding parameter defined here  will be interpreted differently depending on the "threshold_modus"
Threshold modus (R): Specify which particles contribute to the average at the end of each iteration. Different thresholding policies can be used to select particles according to their CC value. Thus value of the "threshold" parameter you input  (denoted as THRESHOLD below) will be interpreted differently depending on the "threshold_modus" defined here.

Possible values of the thresholding policy "threshold_modus":

	* 0: no thresholding policy
	* 1: THRESHOLD is an absolute threshold (only particles with CC above this value are selected).
	* 2: effective threshold = mean(CC) * THRESHOLD.
	* 3: effective threshold = mean(CC) + std(CC) * THRESHOLD.
	* 4: THRESHOLD is the total number of particles (ordered by CC ).
	* 5: THRESHOLD ranges between 0 and 1  and sets the fraction of particles.
Second threshold parameter (R): Thresholding II is operated against the average produced by the particles that survivedthe first thresholding.
Second threshold modus (R): Thresholding II is operated against the average produced by the particles that survived the first thresholding. It uses the same syntax as Threshold I
High pass (R): Cut off frequency for high pass filtering. The units are pixels in the Fourier space of the particle (if your template is smaller than the data, the bandpass parameters will be rescaled). The bandpass works with a soft mask, allowing a smoothing window of two pixels around the cut frequency.
Low frequency (R): Cut off frequency for low pass filtering. The units are pixels in the Fourier space of the particle (if your template is smaller than the data, the bandpass parameters will be rescaled). The bandpass works with a soft mask, allowing a smothing window of two pixels around the cut frequency.
Symmetry group (R): Symmetrization is applied at the beginning of the round to the input reference. It is also used during the computation of the [eo_fsc] or the iteration.
First chars in string indicate thetype of symmetry operator:

	* 'c'  rotational symmetry around z.
	* 'h'  helical symmetry around z  (parameters: dpsi; dz).
	* 'ico'  icosahedral symmetry.
	* 'cbo' for cuboctahedral symmetry.
The rest of the string contains the respective parameters. Examples: 'c1', 'h60,5' ,'h[60,5]','h[-60,5]'
Cross-correlation matrix batch: Number of particles to be kept in memory simultaneously during the computation of the ccmatrix. The larger this number, the more efficient the algorithm performance, as more computations can be kept for reuse.However, trying to keep all the particles in memory can lead to saturate it,blocking the CPU. Additionally, a small batch allows to divide the matrix in more blocks. This might be useful in parallel computations.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "ctffind4" can be found at the cistem plugin.
Its help description is:
  Estimate CTF for a set of micrographs with ctffind4.
    
    To find more information about ctffind4 visit:
    https://grigoriefflab.umassmed.edu/ctffind4
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Do recalculate ctf?: None
Input previous run: None
: None
: None
Input micrographs: None
Input movies: None
No. movie frames to average: When estimating parameters from movie frames, enter how many frames should be included in the sub-averages used to calculate the amplitude spectra.
Use power spectra?: If set to Yes, the CTF estimation will be done using power spectra calculated during Relion motion correction.
FFT box size (px): The dimensions (in pixels) of the amplitude spectrum CTFfind will compute. Smaller box sizes make the fitting process significantly faster, but sometimes at the expense of fitting accuracy. If you see warnings regarding CTF aliasing, consider increasing this parameter.
Min: None
Max: None
Min: None
Max: None
Defocus step (A): Step size for the defocus search.
Slower, more exhaustive search?: Select this option if CTF determination fails on images that show clear Thon rings and should therefore yield good CTF parameters, or if you expect noticeably elliptical Thon rings and high noise.
Restrain astigmatism?: Should the amount of astigmatism be restrained during the parameter search and refinement? This option should be selected when astigmatism is expected to be small to produce more reliable fits. Disable this option if you expect large astigmatism.
Tolerated astigmatism (A): When restraining astigmatism, astigmatism values much larger than this will be penalized. Set to negative to remove this restraint. In cases where the amplitude spectrum is very noisy, such a restraint can help achieve more accurate results.
Find additional phase shift?: Was the data recorded using a phase plate with variable phase shift that must be determined together with the defocus parameters?
Minimum phase shift (deg): If finding an additional phase shift, this value sets the lower bound for the search.
Maximum phase shift (deg): If finding an additional phase shift, this value sets the upper bound for the search.
Phase shift search step (deg): If finding an additional phase shift, this value sets the step size for the search.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.

The protocol named "find particles" can be found at the cistem plugin.
Its help description is:
  Protocol to pick particles (ab-initio or reference-based) using cisTEM. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
CTF estimation: Choose some CTF estimation related to the input micrographs.
Picking algorithm: None
Input references: Provide a set of 2D templates to use in the search.
Max particle radius (A): In Angstroms, the maximum radius of the particles to be found. This also determines the minimum distance between picks.
Characteristic particle radius (A): In Angstroms, the radius within which most of the density is enclosed. The template for picking is a soft-edge disc, where the edge is 5 pixels wide and this parameter defines the radius at which the cosine-edge template reaches 0.5.
Threshold peak height: Particle coordinates will be defined as the coordinates of any peak in the search function which exceeds this threshold. In numbers of standard deviations above expected noise variations in the scoring function. See Sigworth (2004) for definition.
Avoid high variance areas: Avoid areas with abnormally high local variance. This can be effective in avoiding edges of support films or contamination.
Particles are white on a dark background?: None
Highest resolution used in picking (A): The template and micrograph will be resampled (by Fourier cropping) to a pixel size of half the resolution given here. Note that the information in the corners of the Fourier transforms (beyond the Nyquist frequency) remains intact, so that there is some small risk of bias beyond this resolution.
Minimum distance from edges (px): No particle shall be picked closer than this distance from the edges of the micrograph. In pixels.
Use radial averages of templates: Say yes if the templates should be rotationally averaged
Rotate each template this many times: If > 0, each template image will be rotated this number of times and the micrograph will be searched for the rotated template.
Avoid areas with abnormal local mean: Avoid areas with abnormally low or high local mean. This can be effective to avoid picking from, e.g., contaminating ice crystals, support film.
Number of background boxes: Number of background areas to use in estimating the background spectrum. The larger the number of boxes, the more accurate the estimate should be, provided that none of the background boxes contain any particles to be picked.
Algorithm to find background areas: Testing so far suggests that areas of lowest variance in experimental micrographs should be used to estimate the background spectrum. However, when using synthetic micrographs this can lead to bias in the spectrum estimation and the alternative (areas with local variances near the mean of the distribution of local variances) seems to perform better
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "classify 2D" can be found at the cistem plugin.
Its help description is:
  Protocol to run 2D classification in cisTEM. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Continue from a previous run?: If you set to *Yes*, you should select a previous run of type *CistemProtRefine2D* class. The refinement will resume after the last completed iteration. It is ok to alter other parameters.
Select previous run: Select a previous run to continue from.
Continue from iteration: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
Input particles: Select the input particles.
Input class averages: Select starting class averages. If not provided, they will be generated automatically.
Are the particles black?: cisTEM requires particles to be black on white.
Number of classes: The number of classes that should be generated. This input is only available when starting a fresh classification run.
Number of cycles ro run: The number of refinement cycles to run. If the option "Auto Percent Used" is selected, 20 cycles are usually sufficient to generate good class averages. If the user decides to set parameters manually, 5 to 10 cycles are usually sufficient for a particular set of parameters. Several of these shorter runs should be used to obtain final class averages, updating parameters as needed (e.g. Percent Used, see example above).
Low resolution limit (A): The data used for classification is usually bandpass-limited to exclude spurious low-resolution features in the particle background. It is therefore good practice to set the low-resolution limit to 2.5x the approximate particle mask radius.
start: None
finish: None
Mask radius (A): The radius of the circular mask applied to the input class averages before classification starts. This mask should be sufficiently large to include the largest dimension of the particle. The mask helps remove noise outside the area of the particle.
Angular search step (deg): The angular step used to generate the search grid when marginalizing over the in-plane rotational alignment parameter. The smaller the value, the finer the search grid and the slower the search. It is often sufficient to set the step to 15deg as the algorithm varies the starting point of the grid in each refinement cycle, thereby covering intermediate in-plane alignment angles. However, users can try to reduce the step to 5deg (smaller is probably not helpful) to see if class averages can be improved further once no further improvement is seen at 15deg.
X: None
Y: None
Smoothing factor [0-1]: A factor that reduces the range of likelihoods used during classification. A reduced range can help prevent the appearance of "empty" classes (no members) early in the classification. Smoothing may also suppress some high-resolution noise. The user should try values between 0.1 and 1 if classification suffers from the disappearance of small classes or noisy class averages.
Exclude blank edges?: Should particle boxes with blank edges be excluded from classification? Blank edges can be the result of particles selected close to the edges of micrographs. Blank edges can lead to errors in the calculation of the likelihood function, which depends on the noise statistics.
Auto percent used?: Should the percent of included particles be adjusted automatically? A classification scheme using initially 300 particles/class, then 30% and then 100% is often sufficient to obtain good classes and this scheme will be used when this option is selected.
Percent used: The fraction of the dataset used for classification. Especially in the beginning, classification proceeds more rapidly when only a small number of particles are used per class, e.g. 300 (see example above). Later runs that refine the class averages should use a higher percentage and the final run(s) should use all the data. This option is only available when "Auto Percent Used" is not selected.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "resample tomogram" can be found at the cistem plugin.
Its help description is:
 
    Resample tomograms by Fourier cropping/padding using cisTEM. This is equivalent to binning/unbinning operations but free of aliasing artifacts.

    More info:
        https://cistem.org
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tomograms: None
New X-Size: Volume will be rescaled to this size in X dimension (voxels)
New Y-Size: Volume will be rescaled to this size in Y dimension (voxels)
New Z-Size: Volume will be rescaled to this size in Z dimension (voxels)

The protocol named "tilt-series ctffind4" can be found at the cistem plugin.
Its help description is:
  CTF estimation on a set of tilt series using CTFFIND4. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tilt series: None
: None
: None
: None
: None
FFT box size (px): The dimensions (in pixels) of the amplitude spectrum CTFfind will compute. Smaller box sizes make the fitting process significantly faster, but sometimes at the expense of fitting accuracy. If you see warnings regarding CTF aliasing, consider increasing this parameter.
Min: None
Max: None
Min: None
Max: None
Defocus step (A): Step size for the defocus search.
Slower, more exhaustive search?: Select this option if CTF determination fails on images that show clear Thon rings and should therefore yield good CTF parameters, or if you expect noticeably elliptical Thon rings and high noise.
Restrain astigmatism?: Should the amount of astigmatism be restrained during the parameter search and refinement? This option should be selected when astigmatism is expected to be small to produce more reliable fits. Disable this option if you expect large astigmatism.
Tolerated astigmatism (A): When restraining astigmatism, astigmatism values much larger than this will be penalized. Set to negative to remove this restraint. In cases where the amplitude spectrum is very noisy, such a restraint can help achieve more accurate results.
Find additional phase shift?: Was the data recorded using a phase plate with variable phase shift that must be determined together with the defocus parameters?
Minimum phase shift (deg): If finding an additional phase shift, this value sets the lower bound for the search.
Maximum phase shift (deg): If finding an additional phase shift, this value sets the upper bound for the search.
Phase shift search step (deg): If finding an additional phase shift, this value sets the step size for the search.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "resample tilt series" can be found at the cistem plugin.
Its help description is:
 
    Resample tilt series by Fourier cropping/padding using cisTEM. This is equivalent to binning/unbinning operations but free of aliasing artifacts.

    More info:
        https://cistem.org
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tilt series: None
New X-Size: Volume will be rescaled to this size in X dimension (voxels)
New Y-Size: Volume will be rescaled to this size in Y dimension (voxels)

The protocol named "unblur" can be found at the cistem plugin.
Its help description is:
  This protocol wraps unblur movie alignment program. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
: None
: None
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
Compute PSD?: If Yes, the protocol will compute for each aligned micrograph the PSD using EMAN2.
Compute micrograph thumbnail?: When using this option, we will compute a micrograph thumbnail with EMAN2 and keep it with the micrograph object for visualization purposes. 
Additional protocol parameters: Here you can provide some extra parameters for the protocol, not the underlying unblur program.You can provide many options separated by space. 

*Options:* 

--use_worker_thread 
 Use an extra thread to compute PSD and thumbnail. This will allow requires an extra CPU. 
Min shift: None
Max shift: None
Exposure filter sums?: If selected the resulting aligned movie sums will be calculated using the exposure filter as described in Grant and Grigorieff (2015). Pre-exposure and dose per frame should  be specified during movies import.
Restore power? : If selected, and the exposure filter is used to calculate the sum then the sum will be high pass filtered to restore the noise power. This is essentially the denominator of Eq. 9 in Grant and Grigorieff (2015).
Termination threshold (A): The frames will be iteratively aligned until either the maximum number of iterations is reached, or if after an alignment round every frame was shifted by less than this threshold.
Max iterations: The maximum number of iterations that can be run for the movie alignment. If reached, the alignment will stop and the current best values will be taken.
B-factor (A^2): This B-Factor is applied to the reference sum prior to alignment. It is intended to low-pass filter the images in order to prevent alignment to spurious noise peaks and detector artifacts.
Horiz. mask (px): None
Vert. mask (px): None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "cryolo tomo picking (manual)" can be found at the sphire plugin.
Its help description is:
  Picks particles or filaments in a set of tomograms using napari_boxmanager. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select the Tomogram to be used during picking.

The protocol named "cryolo picking" can be found at the sphire plugin.
Its help description is:
  Picks particles in a set of micrographs with crYOLO.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
Picking model: : You might use a general network model that consists of
	-cryo: real, simulated, particle free datasets on various grids with contamination
	-negative stain: trained withnegative stain images
and skip training completely,
or,
if you would like to improve the results you can use the model from a previous training step or an imported one.
Input model: Select an existing crYOLO trained model.
Confidence threshold: If you want to pick less conservatively or more conservatively you might want to change the threshold from the default of 0.3 to a less conservative value like 0.2 or more conservative value like 0.4.
Low-pass filter: CrYOLO works on original micrographs but the results will be probably improved by the application of a reasonable low-pass filter.
Cut-off frequency: Specifies the absolute cut-off frequency for the low-pass filter.
Number of CPUs: *Important!* This is different from number of threads above as threads are used for GPU parallelization. Provide here the number of CPU cores for each cryolo process.
Input size: This is the size to which the input is rescaled before passed through the network.For example the default value would be 1024x1024.
Box Size (optional): Box size in pixels. It should be the size of the minimum particle enclosing square in pixel. If introduced value is zero, it is estimated.
Maximum box per image: Maximum number of particles in the image. Only for the memory handling. Keep the default value of 700.
: Set to True if you want to use GPU implementation.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. crYOLO can use multiple GPUs - in that case set to i.e. *0 1 2*.
Adjust estimated box size by: Value to multiply crYOLO estimated box size to be registered with the SetOfCoordinates. It is usually very tight.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.

The protocol named "cryolo tomo picking" can be found at the sphire plugin.
Its help description is:
  Picks particles in a set of tomograms. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select the Tomogram to be used during picking.
Picking model: : You might use a general network model that consists of
	-cryo: real, simulated, particle free datasets on various grids with contamination
	-negative stain: trained withnegative stain images
and skip training completely,
or,
if you would like to improve the results you can use the model from a previous training step or an imported one.
Input model: Select an existing crYOLO trained model.
Confidence threshold: If you want to pick less conservatively or more conservatively you might want to change the threshold from the default of 0.3 to a less conservative value like 0.2 or more conservative value like 0.4.
Low-pass filter: CrYOLO works on original micrographs but the results will be probably improved by the application of a reasonable low-pass filter.
Cut-off frequency: Specifies the absolute cut-off frequency for the low-pass filter.
Number of CPUs: *Important!* This is different from number of threads above as threads are used for GPU parallelization. Provide here the number of CPU cores for each cryolo process.
Input size: This is the size to which the input is rescaled before passed through the network.For example the default value would be 1024x1024.
Box Size (optional): Box size in pixels. It should be the size of the minimum particle enclosing square in pixel. If introduced value is zero, it is estimated.
Maximum box per image: Maximum number of particles in the image. Only for the memory handling. Keep the default value of 700.
: Set to True if you want to use GPU implementation.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. crYOLO can use multiple GPUs - in that case set to i.e. *0 1 2*.
Search range (px): Search range in pixel. On default it will choose 25 percent of the box size (default: -1).
Minimum length: The minimum number of boxes in one trace to be considered as valid particle (default: 5).
Tracing memory: The maximum number of frames during which a particle can vanish, then reappear nearby, and be considered the same particle (default: 0).
Activate filament mode?: None
Box distance (px): Distance in pixels between two boxes
Minimum number of boxes: Minimum number of boxes per filament
Straightness method: Method to measure the straightness of a line.
LINE_STRAIGHTNESS divides the length from start to end by accumulated length between adjacent boxes.
RMSD calculates the root means squared deviation of the line points to line given by start and the endpoint of the filament. Adjust the straightness_method accordingly!
Straightness threshold: Threshold value for the straightness method. The default value works good for LINE_STRAIGHTNESS. Lines with a LINE_STRAIGHTNESS lower than this threshold get split. For RMSD, lines with a RMSD higher than this threshold will be split. A good value for RMSD is 20 percent of your filament width
Search range factor: The search range for connecting boxes is the box size times this factor
Angle delta: Angle delta in degree. This value is good more or less straight filament. More curvy filament might require values around 20
Directional method: Directional method
Filament width (px): None
Mask width: Mask width in pixel. A gaussian filter mask is usedto estimate the direction of the filaments. This parameter defines how elongated the mask is. The default value typically don't has to be changed
Do not merge filaments?: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "cryolo tomo training" can be found at the sphire plugin.
Its help description is:
  Train crYOLO picker using a set of 3D coordinates. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tomograms: Select the SetOfTomograms to be used during picking.
Input coordinates 3D: Please select a set of coordinates 3D, obtained from a previous picking run.
Fine-tune previous model?: Since crYOLO 1.3 you can train a model for your data by fine-tuning the general model.The general model was trained on a lot of particles with a variety of shapes and therefore learned a very good set of generic features.
Use previous model: : You might use a general network model that consists of real, simulated, particle free datasets on various grids with contamination and skip training completely or if you would like to improve the results you can use the model from a previous training step or an imported one.
Input model: Select an existing crYOLO trained model.
Confidence threshold: If you want to pick less conservatively or more conservatively you might want to change the threshold from the default of 0.3 to a less conservative value like 0.2 or more conservative value like 0.4.
Low-pass filter: CrYOLO works on original micrographs but the results will be probably improved by the application of a reasonable low-pass filter.
Cut-off frequency: Specifies the absolute cut-off frequency for the low-pass filter.
Number of CPUs: *Important!* This is different from number of threads above as threads are used for GPU parallelization. Provide here the number of CPU cores for each cryolo process.
Input size: This is the size to which the input is rescaled before passed through the network.For example the default value would be 1024x1024.
Box Size (optional): Box size in pixels. It should be the size of the minimum particle enclosing square in pixel. If introduced value is zero, it is estimated.
Maximum box per image: Maximum number of particles in the image. Only for the memory handling. Keep the default value of 700.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. crYOLO can use multiple GPUs - in that case set to i.e. *0 1 2*.
Early stop patience: The training stops when the 'loss' metric on the validation data does not improve 10 times in a row. This is typically enough. In case want to give the training more time to find the best model you might increase this parameters to a higher value (e.g 15).
Maximum number of iterations: Maximum number of epochs the network will train. Basically never reach this number, as crYOLO stops training if it recognize that the validation loss is not improving anymore.
Learning rates: If the number is too small convergence can be slow.
Batch size: The number of images crYOLO process in parallel during training.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "cryolo training" can be found at the sphire plugin.
Its help description is:
  Train crYOLO picker using a set of coordinates. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
Input coordinates: Please select a set of coordinates, obtained from a previous picking run. Typically the coordinates from ~ 10 micrographs is a good start.
Fine-tune previous model?: Since crYOLO 1.3 you can train a model for your data by fine-tuning the general model.The general model was trained on a lot of particles with a variety of shapes and therefore learned a very good set of generic features.
Use previous model: : You might use a general network model that consists of real, simulated, particle free datasets on various grids with contamination and skip training completely or if you would like to improve the results you can use the model from a previous training step or an imported one.
Input model: Select an existing crYOLO trained model.
Confidence threshold: If you want to pick less conservatively or more conservatively you might want to change the threshold from the default of 0.3 to a less conservative value like 0.2 or more conservative value like 0.4.
Low-pass filter: CrYOLO works on original micrographs but the results will be probably improved by the application of a reasonable low-pass filter.
Cut-off frequency: Specifies the absolute cut-off frequency for the low-pass filter.
Number of CPUs: *Important!* This is different from number of threads above as threads are used for GPU parallelization. Provide here the number of CPU cores for each cryolo process.
Input size: This is the size to which the input is rescaled before passed through the network.For example the default value would be 1024x1024.
Box Size (optional): Box size in pixels. It should be the size of the minimum particle enclosing square in pixel. If introduced value is zero, it is estimated.
Maximum box per image: Maximum number of particles in the image. Only for the memory handling. Keep the default value of 700.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. crYOLO can use multiple GPUs - in that case set to i.e. *0 1 2*.
Early stop patience: The training stops when the 'loss' metric on the validation data does not improve 10 times in a row. This is typically enough. In case want to give the training more time to find the best model you might increase this parameters to a higher value (e.g 15).
Maximum number of iterations: Maximum number of epochs the network will train. Basically never reach this number, as crYOLO stops training if it recognize that the validation loss is not improving anymore.
Learning rates: If the number is too small convergence can be slow.
Batch size: The number of images crYOLO process in parallel during training.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "cryolo import" can be found at the sphire plugin.
Its help description is:
  Protocol to import an existing crYOLO training model.
    The model will be registered as an output of this protocol and
    can be used later for further training or picking.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Training model path: Provide the path of a previous crYOLO training model.

The protocol named "janni denoising" can be found at the sphire plugin.
Its help description is:
  Protocol to denoise a set of micrographs. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: JANNI works on a single GPU.
Input micrographs: None

The protocol named "annotate particles" can be found at the deepfinder plugin.
Its help description is:
 This protocol allows you to annotate macromolecules in your tomograms, using a visual tool..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select the Tomogram to be used during picking.
Box size: Default box size for the output.

The protocol named "cluster" can be found at the deepfinder plugin.
Its help description is:
 This protocol analyses segmentation maps and outputs particle coordinates and class..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Segmentation maps: Please select the segmentation maps you would like to analyze.
Clustering radius: Should correspond to average radius of target objects (in voxels)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "generate sphere targets" can be found at the deepfinder plugin.
Its help description is:
  This protocol generates segmentation maps from annotations. These segmentation maps will be used as targets
     to train DeepFinder .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: 1 coordinate set per class. A set may contain coordinates from different tomograms.
Sphere radius [pix.]: Sphere radius, in voxels, per class. Should be separated by coma as follows: Rclass1,Rclass2, ...
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "segment" can be found at the deepfinder plugin.
Its help description is:
 This protocol segments tomograms, using a trained neural network..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select the Tomogram to be used during picking.
Neural network model: Select a trained DeepFinder neural network.
Patch size: It must be a multiple of 4, due to the network architecture.
: GPU ID, normally it is 0.

The protocol named "train" can be found at the deepfinder plugin.
Its help description is:
  This protocol launches the training procedure .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Training TomoMasks: Training dataset. Please select here your TomoMasks. The corresponding tomograms will be loaded automatically.
Use specific set for Validation?: Recommended value as false. The default value (False) will atuomatically split the set of tomo masks according to the "Validation data fraction". If this parameter  is true, the user can provide a certain set of tomoMask for validating the training.
Validation TomoMasks: (Only available when "Use specific set for Validation" is True.) This is the validation set of tomo Masks to ensure that the network learns properly.
Validation data fraction: Fraction of the "Training Tomomasks" that will be used as validation dataset. The admitted values are [0.1, 0.5], which means from 10% to 50% of the introduced training tomo masks. Only applies if "Validation TomoMasks" is empty.
Coordinates: Select coordinate set.
Patch size: Size of patches loaded into memory for training.
Batch size: Number of patches used to compute average loss.
Number of epochs: At the end of each epoch, evaluation on validation set is performed (useful to check if network overfits).
Steps per epoch: Number of batches trained on per epoch.
Steps per validation: Number of batches used for validation.
Bootstrap: Can remain checked. Useful when in presence of unbalanced classes.
Random shift: (in voxels) Applied to positions in object list when sampling patches. Enhances network robustness. Make sure that objects are still contained in patches when applying shift.
: GPU ID, normally it is 0.

The protocol named "import DeepFinder coordinates" can be found at the deepfinder plugin.
Its help description is:
 Protocol to import a DeepFinder object list as a set of 3D coordinates in Scipion.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input tomograms: Select the tomograms/tomogram for which you want to import coordinates. The file names of the tomogram and coordinate files must be the same.
Box size: Default box size for the output.

The protocol named "Load Training Model" can be found at the deepfinder plugin.
Its help description is:
 Use two data-independent reconstructed tomograms to train a 3D cryo-CARE network..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Model weights file: File which contains the weights for the neural network (.h5 file).
Number of classes: Number of classes corresponding to this model.

The protocol named "alphafold prediction" can be found at the chimerax plugin.
Its help description is:
  Protocol to import atomic structures generated by alphafold.

    If you choose the "Execute alphafold Locally" option you will need 
    a local alphafold NO docker instalation as
    described here: https://github.com/kalininalab/alphafold_non_docker
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Source to retrieve the AlphaFold2 model:: Retrieve the AlphaFold2 model from:
 * EBI database (identical sequence) in case your sequence is already included in the EBI database of AlphaFold2. This database covers the complete human proteome (including fragments for long proteins) and the proteomes of more than 40 other key organisms, as well as the majority of manually curated UniProt entries. Since this database is continuously updating, check the contents in https://alphafold.ebi.ac.uk/.
  If the structure of your sequence is already included in the EBI database you can retrieve it writing the UniProt ID.
 * EBI Database (homologous sequence): In case the structure prediction of your sequence has not been included in the EBI database yet, a Blast will be launched against that database. According to the Blast searching parameters, which you can modify, some homologous sequences of your sequence will be retrieved and you can select one of them as close prediction of your sequence initial model.
* Executing AlphaFold2 in Google-Colab taking advantage of ChimeraX or Phenix notebooks.
* Executing AlphaFold2 Locally (multimer supported)

UniProt name/ID : Write a UniProt ID (six or ten alphanumeric characters; examples: A2BC19, P12345, A0A022YWF9, DGAL_ECOLI).
 You can convert other database identifiers to UniProt accession codes by using the "ID Mapping" tab on https://www.uniprot.org/
Colab Notebook : Execute alphafold in Google-colab.
  Two notebooks are available from
 ChimeraX and Phenix, respectively
 TEST option is for debuging, do not use it
Reference sequence: Input the aminoacid sequence to blast or send to Google-Colab
similarity-matrix: The matrix option indicates which amino acid similarity-matrix to use for scoring the hits: BLOSUM45, BLOSUM50, BLOSUM62 (default), BLOSUM80, BLOSUM90, PAM30, PAM70, PAM250, or IDENTITY
cutoff: The cutoff evalue is the maximum or least significantexpectation value needed to qualify as a hit (default 1e-3).
Use this template: Fill if you want to supply a PDB template to Google-Colab
Skip Amber relaxation: This option allows skipping energy-minimization of the result from alphafold predict, for faster job completion and/or to avoid failures during minimization.
Use templates from PDB: Use this numbers of templates from PDB. If set to -1 no templates are used
Reference sequences: Include here one or more sequences to get the AlphaFold2 prediction of a monomer (one sequence) or a multimer (several sequences). 
Use Template until: Maximum template release date to consider (YYYY-MM-DD)
Is prokaryote?: Optional for multimer system, not used by the single chain system. A boolean specifying true where the target complex is from a prokaryote, and false where it is not, or where the origin is unknown. This value determine the pairing method for the MSA (default: 'None')
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use.
Extra flags: # -n <openmm_threads>   OpenMM threads (default: all available cores) -c <db_preset>        Choose preset MSA database configuration - smaller genetic database config (reduced_dbs) or full genetic database config (full_dbs) (default: 'full_dbs')
Extra commands for alphafold: Add extra commands in cmd file. Use for testing
Hide help popup window: If set to Yes no help message will be shown in chimera at start up.
Show results in ChimeraX: Show results in ChimeraX.

The protocol named "model from template" can be found at the chimerax plugin.
Its help description is:
 Protocol to model three-dimensional structures of proteins using Modeller.
        Execute command *scipionwrite #n [prefix stringAddedToFilename] from command line in order
        to transfer the selected
        pdb to scipion. Default value is model=#0,
        model refers to the pdb file..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Do you already have a template?: "Yes": Option by default. Select this option in case you already have a template to model your target sequence.
"No": Select this option if you want to search for a template with which model your target sequence. Generation of multimeric models is not allowed selecting this option.

Atomic structure used as template: PDBx/mmCIF file template used as basic atomic structure to model your specific sequence.
Chain : Select a particular chain of the atomic structure.
Target sequence: Input the aminoacid sequence to align with the structure template sequence.
Protein sequence database:: Select a protein sequence database to search for templates:
PDB: Experimentally determined structures in the Protein Data Bank.
NR: NCBI 'non-redundant'database. It contains GenBank translation proteins, PDB sequences, SwissProt proteins + PIR + PRF. Since NR is much larger than PDB, it takes longer to search.

Similarity matrix:: Select a similarity matrix to use for alignment scoring.

cutoff evalue:: Least significant expectation value needed to qualify the retrieved element as a hit.

Maximum number of sequences:: Maximum number of sequences to retrieve from the database.

Options to improve the alignment:: None: Option by default. Only the template and the target sequences will be included in the alignment. This option is recommendable when these two sequences are very similar. Otherwise, select any of the two additional options:
Additional sequences to align: Select this option if you want to add some more sequences to accomplish the alignment.
Provide your own sequence alignment: Your alignmentshould include both the target and the template sequences.

Sequence alignment input: Input your own sequence alignment.
ChimeraX allowed formats accessible here: https://www.cgl.ucsf.edu/chimerax/docs/user/commands/open.html#sequence 
Other sequences to align: In case you need to load more sequences to align, you can load them here.
Alignment tool for two sequences:: Select a program to accomplish the sequencealignment:

Biophyton module Bio.pairwise2 (http://biopython.org/DIST/docs/api/Bio.pairwise2-module.html). Built-in program to align two sequences. The global alignment algorithm from the EMBOSS suite has been implemented with match/mismatch scores of 3/-1 and gap penalties (open/extend) of 3/2.

Clustal Omega program (http://www.clustal.org/omega/, https://doi.org/10.1038/msb.2011.75): Multiple sequence alignment tool. Install clustalo if you choose this option for the first time by 'sudo apt-get install clustalo'.

MUSCLE program stands for MUltiple Sequence Comparison by Log- Expectation(http://www.drive5.com/muscle/muscle.html, https://doi.org/10.1093/nar/gkh340). Install muscle if you choose this option for the first time by 'sudo apt install muscle'.
Multiple alignment tool:: Select a program to accomplish the sequencealignment:

Clustal Omega program (http://www.clustal.org/omega/, https://doi.org/10.1038/msb.2011.75): Multiple sequence alignment tool. Install clustalo if you choose this option for the first time by 'sudo apt-get install clustalo'.

MUSCLE program stands for MUltiple Sequence Comparison by Log- Expectation(http://www.drive5.com/muscle/muscle.html, https://doi.org/10.1093/nar/gkh340). Install muscle if you choose this option for the first time by 'sudo apt install muscle'.
Additional target sequence to include?: Select YES if you want to add an additional target sequence to model according a different chain of the structure template. This option is recommendable when you want to model the two interacting elements of a particular complex at the same time.
Chain : Select a particular chain of the atomic structure.
Target sequence: Input the aminoacid sequence to align with the structure template sequence.
Options to improve the alignment:: None: Option by default. Only the template and the target sequences will be included in the alignment. This option is recommendable when these two sequences are very similar. Otherwise, select any of the two additional options:
Additional sequences to align: Select this option if you want to add some more sequences to accomplish the alignment.
Provide your own sequence alignment: Your alignmentshould include both the target and the template sequences.

Sequence alignment input: Input your own sequence alignment.
ChimeraX allowed formats accessible here: https://www.cgl.ucsf.edu/chimerax/docs/user/commands/open.html#sequence 
Other sequences to align: In case you need to load more sequences to align, you can load them here.
Alignment tool for two sequences:: Select a program to accomplish the sequencealignment:

Biophyton module Bio.pairwise2 (http://biopython.org/DIST/docs/api/Bio.pairwise2-module.html). Built-in program to align two sequences. The global alignment algorithm from the EMBOSS suite has been implemented with match/mismatch scores of 3/-1 and gap penalties (open/extend) of 3/2.

Clustal Omega program (http://www.clustal.org/omega/, https://doi.org/10.1038/msb.2011.75): Multiple sequence alignment tool. Install clustalo if you choose this option for the first time by 'sudo apt-get install clustalo'.

MUSCLE program stands for MUltiple Sequence Comparison by Log- Expectation(http://www.drive5.com/muscle/muscle.html, https://doi.org/10.1093/nar/gkh340). Install muscle if you choose this option for the first time by 'sudo apt install muscle'.
Multiple alignment tool:: Select a program to accomplish the sequencealignment:

Clustal Omega program (http://www.clustal.org/omega/, https://doi.org/10.1038/msb.2011.75): Multiple sequence alignment tool. Install clustalo if you choose this option for the first time by 'sudo apt-get install clustalo'.

MUSCLE program stands for MUltiple Sequence Comparison by Log- Expectation(http://www.drive5.com/muscle/muscle.html, https://doi.org/10.1093/nar/gkh340). Install muscle if you choose this option for the first time by 'sudo apt install muscle'.
Extra commands for chimera viewer: Add extra commands in cmd file. Use for testing

The protocol named "contacts" can be found at the chimerax plugin.
Its help description is:
 Identifies interatomic clashes and contacts based on van der Waals radii
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Atomic Structure:: Input atomic structure.
Chain Labeling: Dictionary that maps chains to labels.
Example: {'A':'h1', 'B':'h1', 'E':'h2'}
Contacts are calculated between two chains with distinct labels. Two chains with the same label are considered as a group. Contacts will be computed between any chain included in this group and any other group/chain. However, no contacts among members of the group will be calculated.
Apply symmetry:: 'Symmetry = Yes' indicates that symmetry will be applied, and then contacts will be computed between any two chains of the atomic structure (the unit cell) and between a chain of the unit cell and another chain of a neigbour unit cell. Output results will show only non redundant contatcs, i.e., contacts than you can infer by symmetry will not be shown.
'Symmetry = No' indicates that symmetry will not be applied, and then  contacts will only be calculated between chains within the atomic structure. Output results will show all contacts between any couple of interacting chains.

Symmetry: https://scipion-em.github.io/docs/release-2.0.0/docs/developer/symmetries.html?highlight=symmetrySymmetry for a description of the symmetry groups format in CHIMERA.
If no symmetry is present, use _c1_.More information: 
https://www.cgl.ucsf.edu/chimera/current/docs/UsersGuide/midas/sym.html
Symmetry Order: Select the order of cyclic or dihedral symmetry.
cutoff (Angstroms): : Large positive cutoff identifies the more severe clashes, whereas negative cutoff indicates favorable contacts:
default contact rule: -0.4 (from 0.0 to -1.0)
default clash rule: 0.6 (from 0.4 to 1.0)
More information: 
https://www.cgl.ucsf.edu/chimerax/docs/user/commands/clashes.html#top
allowance (Angstroms): : default contact rule: 0.0
default clash rule: 0.4
More information: 
https://www.cgl.ucsf.edu/chimerax/docs/user/commands/clashes.html#top

The protocol named "operate" can be found at the chimerax plugin.
Its help description is:
 This protocol provides access to Chimera and allows to save the result in Scipion framework.
            Execute command *scipionwrite #n [prefix stringAddedToFilename]
            model refers to the pdb file.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: Volume to process
Input additional Volumes: Other Volumes
Atomic structure: PDBx/mmCIF file that you can save after operating with it.
Other atomic structures: In case you need to load more PDBx/mmCIF files, you can load them here and save them after operating with them.
Extra commands for chimera viewer: Add extra commands in cmd file. Use for testing

The protocol named "restore session" can be found at the chimerax plugin.
Its help description is:
 This protocol opens Chimera and restores a session
      that has been stored each time a 3Dmap or an atomic structure 
      by using `scipionwrite` or `scipionss` commad.
      Execute command *scipionwrite #n [prefix stringAddedToFilename]
      model refers to the pdb file.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input protocols: protocol to be reloaded
Extra commands for chimera viewer: Add extra commands in cmd file. Use for testing

The protocol named "rigid fit" can be found at the chimerax plugin.
Its help description is:
 Protocol to perform rigid fit using Chimera.
            Execute command *scipionwrite #n [prefix stringAddedToFilename]
            model refers to the pdb file.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: Volume to process
Input additional Volumes: Other Volumes
Atomic structure to be fitted: PDBx/mmCIF file to be fitted. 
Other reference atomic structures: Other PDBx/mmCIF files used as reference.
Extra commands for chimera viewer: Add extra commands in cmd file. Use for testing

The protocol named "map subtraction" can be found at the chimerax plugin.
Its help description is:
 Protocol to subtract two volumes.
        One of these volumes can be derived from an atomic structure.
        Execute command *scipionwrite #n [prefix stringAddedToFilename]*
        from command line in order to transfer the generated maps and models to scipion.
        In addition to maps and models that the protocol saves by default,
        the user can generate and save some others.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input 3D Map: Difference 3D map = minuend − subtrahend.
Input here the minuend of the subtraction.
Select the operation to perform: You can select "Subtract" to get the result minuend − subtrahend, or "Mask" to mask the minuend.
This mask is created with all those points that belong to the subtrahend and are greater than the level (0 level is not supplied).
Contour level (subtrahend): Difference 3D map = minuend − subtrahend.
"Calculation are made for those voxels inside a region created by this contour level
Empty value -> chimera computes the level.
Subtraction/Mask of: Difference 3D map = minuend − subtrahend.
Subtrahend 3D map may be provided by the user (choose '3D map') or created from an atomic coordinates file (choose 'atomic structure').
 If 3D Map is chosen, the sampling rate of the minuend should be equal to the sampling rate of the subtrahend.
Map to subtract (subtrahend): Map that has to be subtracted from the minuend 3D map.
Map resolution (A)::  The atomic structure file wil be used to create a 3D map.  Each atom is described as a 3D Gaussian distribution of  width proportional to the resolution and amplitude proportional  to the atomic number. We recommend half the value of the resolution obtained by FSC
Atomic structure: Atomic structure to derive a 3D map that will be subtracted from the minuend map.
Select a specific chain?: Select 'Yes' if you want to generate the map from a specific chain of the atomic structure.

Chain of the atomic structure: Select a particular chain of the atomic structure.
Remove residues from the atomic structure?: Select 'Yes' to remove a certain number of residues of one of the chains of the atomic structure. These removed residues might help you to establish a control of appropriate levels of map density.
In order to better visualize the area of removed residues, 10 residues will be highligthed before and after the first and the last residues selected, respectively.

Chain : Select a particular chain of the atomic structure.
Residues to remove : Select the first and last residues of the selected atomic structure chain that you want to remove. 
(Use Ctrl for multiple selection)
Apply symmetry to the atomic structure:: 'Symmetry = Yes' indicates that symmetry will be applied. This option is recommended if the atomic structure corresponds to the asymmetrical unit and you want to regenerate the structure of the whole map.
'Symmetry = No' indicates that symmetry will not be applied, and then  the map derived from the atomic structure involves only the atomic structure provided as input.

Symmetry: https://scipion-em.github.io/docs/docs/developer/symmetries
Symmetry for a description of the symmetry groups format in CHIMERA.
If no symmetry is present, use _c1_.More information: 
https://www.cgl.ucsf.edu/chimerax/docs/user/commands/sym.html
Symmetry Order: Select the order of cyclic or dihedral symmetry.
Range of distance: This value allows to generate copies with centers within a certain range of distance of the center of the original molecule model. A models's center is defined as the center of its bounding box.
Other atomic structures: In case you need to load more PDBx/mmCIF files, you can load them here. These structures will NOT be used to create the subtrahend.
Map fraction around the atomic structure?: Select 'Yes' if you want to limit the map to a certain radius around the atomic structure.

Atom radius (A): Set the radius (Angstroms) to select values of grid points farther than that radius from any atom.
Filter to apply to the differential map: Choose the filter to clean the background noise of the differential map.
Gaussian filter width: Set the width of the Gaussian filter.
Extra commands for chimera viewer: Add extra commands in cmd file. Use for testing

The protocol named "2d streamer" can be found at the emfacilities plugin.
Its help description is:
  This protocol will monitor an input set of particles
    (usually in streaming) and will run/schedule many copies
     of a given 2D classification protocol but using subsets
     of the input particles as the 2D classification input.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input 2D protocol: This protocol will serve as the template runthat will be repeated with subsets of the input particles. 
Input particles: Input particles that will be used to executemany 2D classification runs based on the 2D protocol template selected. 
Batch size: How many particles (approximately) you want to group to make the new batch and launch a new 2dclassification job. 
Starting number: Specify a value greater than 0 if you want to skip this amount of particles from the classification batches (e.g, if you have classified them for the initial 2D classification template. 
Update interval (min): After how many minutes the protocol should look for new input data and schedule more 2D classificationjobs if necessary. 

The protocol named "ctf monitor" can be found at the emfacilities plugin.
Its help description is:
  check CPU, mem and IO usage.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input protocols: this protocol will be monitorized
Sampling Interval (sec): Take one sample each SamplinInteval seconds
Raise Alarm if maximum defocus (A) >: Raise alarm if defocus is greater than given value
Raise Alarm if minimum defocus (A) <: Raise alarm if defocus is smaller than given value
Raise Alarm if astigmatism (A) >: Raise alarm if astigmatism is greater than given value
Total Logging time (min): Log during this interval
Enable Email notification?: Allow monitors to notify via email.
From: Provide the sender address for notifications.
To: Provide the destination address for notifications.
SMTP Mail server: Provide the address of SMTP mail server.

The protocol named "movie gain monitor" can be found at the emfacilities plugin.
Its help description is:
  check CPU, mem and IO usage.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input protocol: This protocol will be monitorized
Raise Alarm if residual gain standard deviation >: Raise alarm if residual gain standard deviation is greater than given value
Raise Alarm if the ratio between the 97.5 and 2.5 percentiles >: Raise alarm if the ratio between the 97.5 and 2.5 percentiles is greater than given value
Raise Alarm if the ratio between the maximum gain value and the 97.5 percentile >: Raise alarm if the ratio between the maximum gain value and the 97.5 percentile is greater than given value
Total Logging time (min): Log during this interval
Sampling Interval (sec): Take one sample each SamplinInteval seconds
Enable Email notification?: Allow monitors to notify via email.
From: Provide the sender address for notifications.
To: Provide the destination address for notifications.
SMTP Mail server: Provide the address of SMTP mail server.

The protocol named "monitor summary" can be found at the emfacilities plugin.
Its help description is:
  Provide some summary of the basic steps of the Scipion-Box:
    - Import movies
    - Align movies (global and/or local)
    - CTF estimation
    - Movie gain estimation.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input protocols: this protocol/s will be monitorized
Sampling Interval (sec): Take one sample each *samplingInterval* seconds
Total Logging time (min): Log during this interval. 21 days by default
Raise Alarm if residual gain standard deviation >: Raise alarm if residual gain standard deviation is greater than given value
Raise Alarm if the ratio between the 97.5 and 2.5 percentiles >: Raise alarm if the ratio between the 97.5 and 2.5 percentiles is greater than given value
Raise Alarm if the ratio between the maximum gain value and the 97.5 percentile >: Raise alarm if the ratio between the maximum gain value and the 97.5 percentile is greater than given value
Raise Alarm if maximum defocus (A) >: Raise alarm if defocus is greater than given value
Raise Alarm if minimum defocus (A) <: Raise alarm if defocus is smaller than given value
Raise Alarm if astigmatism >: Raise alarm if astigmatism (defocusU-defocusV)is greater than given value
Raise Alarm if CPU > XX%: Raise alarm if memory allocated is greater than given percentage
Raise Alarm if Memory > XX%: Raise alarm if cpu allocated is greater than given percentage
Raise Alarm if Swap > XX%: Raise alarm if swap allocated is greater than given percentage
Check GPU: Set to true if you want to monitor the GPU
Which GPUs to use:: Provide a list of GPUs (e.g. "0 1 2 3"). Default is to monitor GPU 0 only
Check Network: Set to true if you want to monitor the Network
Interface: Name of the network interface to be checked
Check Disk IO: Set to true if you want to monitor the Disk Acces
Enable Email notification?: Allow monitors to notify via email.
From: Provide the sender address for notifications.
To: Provide the destination address for notifications.
SMTP Mail server: Provide the address of SMTP mail server.
use grafana/influx: Use grafana+influx vs apache for reports
Publish command: Specify a command to publish the template. You can use the special token %(REPORT_FOLDER)s that will be replaced with the report folder. For example: 
rsync -avL %(REPORT_FOLDER)s scipion@webserver:public_html/

The protocol named "system_monitor" can be found at the emfacilities plugin.
Its help description is:
  check CPU, mem and IO usage.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input protocols: this protocol/s will be monitorized
Sampling Interval (sec): Take one sample each *samplingInterval* seconds
Total Logging time (min): Log during this interval
Raise Alarm if CPU > XX%: Raise alarm if memory allocated is greater than given percentage
Raise Alarm if Memory > XX%: Raise alarm if cpu allocated is greater than given percentage
Raise Alarm if Swap > XX%: Raise alarm if swap allocated is greater than given percentage
Enable Email notification?: Allow monitors to notify via email.
From: Provide the sender address for notifications.
To: Provide the destination address for notifications.
SMTP Mail server: Provide the address of SMTP mail server.
Check GPU: Set to true if you want to monitor the GPU
Which GPUs to use:: Providing a list of which GPUs (0,1,2,3, etc). Default is monitor GPU 0 only
Check Network: Set to true if you want to monitor the Network
Interface: Name of the network interface to be checked
Check Disk IO: Set to true if you want to monitor the Disk Access

The protocol named "Track used items" can be found at the emfacilities plugin.
Its help description is:
 
  This protocol will track the items (micrographs, classes2D,...) that has been used in a scipion protocol to
  generate a final volume. If the ids have been maintained, it will also track the not used items.
  .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volumes: Select the sets of volumes to track their used items
Save images as JPG: Save micrographs and particles as jpg
Track used particles?: The particles used in the final volume reconstruction will be tracked
Original Particles: Set of Particles containing the complete set of original particles, including the used and filtered particles. If None, the set of particles with same sampling rate and furthest to the used particles will be used.
Track used micrographs?: The micrographs with picked particles used in the final volume reconstruction will be tracked and scored according to the number of used particles in them
Original micrographs: Set of micrographs containing the complete set of original mics, including the used and filtered mics. If None, the first protocol with output micrographs will be used. Each of these micrographs will be scored depending on the number of used particles in them
Track used CTFs?: The CTFs from micrographs with picked particles used in the final volume reconstruction will be tracked and scored according to the number of used particles in them
Track used coordinates?: The coordinates used in the final volume reconstruction will be tracked
Original Coordinates: Set of Coordinates where to get the coordinates parameters. If None, the first protocol with output Coordinates will be used
Pick negative coordinates: Picks noise from the micrographs as negative particle examples
Number of noise particles: Number of noise particles to extract from each micrograph. Set to -1 for extracting the same amount of noise particles as the number true particles for that micrograph
Track used Classes2D?: The Classes2D used in the final volume reconstruction will be tracked
Used Classes2D: Set of Classes2D where to track the used items. If None, the newer protocolwith output Classes2D will be used
Track used Classes3D?: The Classes3D used in the final volume reconstruction will be tracked
Used Classes3D: Set of Classes3D where to track the used items. If None, the newer protocolwith output Classes3D will be used
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "fils" can be found at the pyseg plugin.
Its help description is:
 filter a MbGraphMCF (Mean Cumulative Function) object by extracting a filament network.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Graphs: Pointer to graphs protocol.
Filament area: Source or destination (depending if you are in the Sources or Targets tab) area for the filament calculation.
Min: None
Max: None
range: None
Min: None
Max: None
range: None
Min: None
Max: None
range: None
Min: None
Max: None
range: None
Filament area: Source or destination (depending if you are in the Sources or Targets tab) area for the filament calculation.
Min: None
Max: None
range: None
Min: None
Max: None
range: None
Min: None
Max: None
range: None
Min: None
Max: None
range: None
Orientation with respect to the membrane/filament: None
Euclidean distance (STRAIGHT) range of vertices source-target (nm): None
Geodesic distance (CURVED) range of vertices source-target (nm): None
Filament sinuosity range (FLEXIBILITY, normally the ratio geoLen / eucLen): None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "graphs" can be found at the pyseg plugin.
Its help description is:
 analyze a GraphMCF (Mean Cumulative Function) from a segmented membrane.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Pre segmentation: Pointer to preseg protocol.
Vesicles packaging size: The input set of particles will be split into packages of N vesicles. Each package will be processed as a different step, allowing to continue the execution from the last step in case of the protocol fails. On the other hand, more packages implies more calls to PySeg, which can affect to performance.
Keep only required files?: If set to No, all the intermediate Disperse program resulting directories will be kept in the extra folder.
Sigma for gaussian filtering: Sigma for Gaussian foltering input tomograms. It allows to smooth small and irrelevant features and increases teh signal noise ratio (SNR). Higher values will provide less dense graphs (lower execution time), so they should be used when picking large particles, like ribosomes.
Vertex density within membranes (nm³): Vertex density within membranes. It allows to adjust simplification adaptively for every tomogram.
Avg ratio vertex/edge of graph within membrane: Averaged ratio vertex/edge in the graph within membrane.
Maximum distance to membrane (Å): Maximum euclidean distance to membrane in Å.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "picking" can be found at the pyseg plugin.
Its help description is:
 extract particles from a filament network of a oriented single membrane graph.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Fils protocol: Pointer to fils protocol.
Tomograms to refer the coordinates: Tomograms to which the coordinates should be referred to. If empty, it is assumed that the tomograms are the same from were the vesicles were segmented (pre-seg).
Box size (pixels): None
Segmentation area for picking: Area in which the cutting point or cutting point + projections of the filament will be considered for the picking coordinates.
Find on two surfaces: Track fiducials differentiating in which side of the sample are located.
Percentile of points to discard by their density level.: None
Min distance between selected points (nm).: Scale suppression in nm, two selected points cannot be closer than this distance.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "2D classification" can be found at the pyseg plugin.
Its help description is:
 Unsupervised and deterministic classification of membrane-bound particles.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input subtomograms: Select the input subtomograms desired to be classified.
Mask: Mask used for the post processing
Clustering algorithm: None
Filter size (voxels): A value of n means that the voxels will be grouped in groups of size n.
Do 3D radial compensation?: If "No" is selected, the normalized cross correlation (NCC) is made in 2D, otherwise radial average is compensated for doing a NCC in 3D.
Cross correlation metric: Metric used when computing the cross correlation matrix among the 2D particles. Considerations:
	- Mask normalized similarity is referred to negative squared Euclidean distance.
	- Full cross-correlation (slower than ross-correlation within the mask but allows small disalignments between particles).
PCA components for dim. reduction: Number of components (moments) after the reductions.
If 0 or None, then they will be automatically estimated considering the size ob the input subtomograms.
Number of clusters to find: None
Affinity propagation preference (-inf, inf): Preference parameter (-inf, inf).
The smaller value the higher number of potential classes.
If None, the median of the affinity class is considered.
Dumping [0.5, 1): Dumping parameter [0.5, 1), it controls convergence speed.
Maximum number of iterations: None
Iterations for fitting the convergence criteria: None
Reference 2D image used for classes: None
Minimum number of particles per class: Purge classes with less than the specified number of particles. If 0, this filter will not be applied.
Cross-correlation against AP reference filter: Purge classes with the cross correlation against the reference lower than the specified value. If 0, this filter will not be applied.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "posrec" can be found at the pyseg plugin.
Its help description is:
 post-process already reconstructed particles: rot angle randomization and membrane suppression.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input subtomograms: Select the input subtomograms from the project.
Mask: Mask used for the post processing
Mask for membrane supression: None
Membrane suppression factor [0, 1]: Value 0 suppress the area corresponding to the suppression mask, while higher values up to 1 attenuate it.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "preseg membranes" can be found at the pyseg plugin.
Its help description is:
 Segment membranes into membranes, inner surroundings and outer surroundings.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomomasks (segmentations): Pointer to segmented and annotated tomograms within Scipion.
Offset voxels: Margin to ensure that the desired entities, e. g. membranes, proteins, are included.
Density threshold: All the voxels with density equal to or higher than the threshold are set to 1. The remaining voxels are set to 0.
Size threshold (voxels): It sets the minimal size for a component to be considered as membrane.
Segmented membrane thickness (Å): Value introduced will be divided by 2 internally, because it is expected like that by PySeg.
Segmented membrane neighbours (Å): Thickness around the membrane to represent the in-membrane and out-membrane surroundings desired to be included in the analysis.

The protocol named "picking consensus" can be found at the tomoviz plugin.
Its help description is:
 
    Protocol to estimate the agreement between different particle picking
    algorithms. The protocol takes several Sets of Coordinates calculated
    by different programs and/or different parameter settings. Let's say:
    we consider N independent pickings. Then, a coordinate is considered
    to be a correct particle if M pickers have selected the same particle
    (within a radius in pixels specified in the form).

    If you want to be very strict, then set M=N; that is, a coordinate
    represents a particle if it has been selected by all particles (this
    is the default behaviour). Then you may relax this condition by setting
    M=N-1, N-2, ...

    If you want to be very flexible, set M=1, in this way it suffices that
    1 picker has selected the coordinate to be considered as a particle. Note
    that in this way, the cleaning of the dataset has to be performed by other
    means (screen particles, 2D and 3D classification, ...).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input 3D coordinates: Select the set of 3D coordinates to compare
Radius: All coordinates within this radius (in pixels) are presumed to correspond to the same particle
Consensus: This parameter can take values from 1 to total number of inputs (being -1 a special case).
*Set to -1* to indicate that it needs to be selected by all algorithms: *AND* operation.
*Set to 1* to indicate that it suffices that only 1 algorithm selects the particle: *OR* operation.
Any other value will determine how many times need a particle to be selected to be considered as a consensus particle.
Consensus mode: If the number of votes to progress to the output must be either (=) strictly speaking equals to the consensus number or (>=) at least equals.

The protocol named "remove duplicates" can be found at the tomoviz plugin.
Its help description is:
 
    This protocol removes coordinates that are closer than a given threshold.
    The remaining coordinate is the average of the previous ones.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the set of 3D coordinates to compare
Radius: All coordinates within this radius (in pixels) are presumed to correspond to the same particle

The protocol named "filter by normal" can be found at the tomoviz plugin.
Its help description is:
  This protocol takes surfaces or ROIs (SetOfMeshes) and a SetOfSubtomograms or SetOfCoordinates3D with
    transformation matrix and filters them by different criteria related with the normal direction..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Subtomograms/Coordinates: Coordinates to filter.
Vesicles: Select the vesicles in which the subtomograms/coordinates are.
Filter by tilt angle: Remove items depending on their tilt angle.
Maximum allowed tilt: Remove the items that have a tilt angle bigger than the one specified in here, considering tilt angle between 0 and 180 degrees.
Minimum allowed tilt: Remove the items that have a tilt angle smaller than the one specified in here, considering tilt angle between 0 and 180 degrees.
Filter by normal: Remove the items that have a normal direction not equal to the normal direction of the vesicle in the coordinate of the particle.
Tolerance in degrees: Tolerance (in degrees) when comparing between subtomogram/coordinate and mesh normal directions.

The protocol named "movie alignment" can be found at the motioncorr plugin.
Its help description is:
  This protocol wraps motioncor movie alignment program developed at UCSF.

    Motioncor performs anisotropic drift correction and dose weighting
        (written by Shawn Zheng @ David Agard lab)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
: None
: None
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Split & sum odd/even frames?: Generate odd and even sums using odd and even frames respectively when this option is enabled.
Save aligned movie?: None
Compute PSD?: If Yes, the protocol will compute for each aligned micrograph the PSD using EMAN2.
Compute micrograph thumbnail?: When using this option, we will compute a micrograph thumbnail with EMAN2 and keep it with the micrograph object for visualization purposes. 
Additional protocol parameters: Here you can provide some extra parameters for the protocol, not the underlying motioncor program.You can provide many options separated by space. 

*Options:* 

--dont_use_worker_thread 
 Now by default we use a separate thread to compute PSD and thumbnail (if is required). This allows  more effective use of the GPU card, but requires  an extra CPU. Use this option (NOT RECOMMENDED) if  you want to prevent this behaviour
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. Motioncor can use multiple GPUs - in that case set to i.e. *0 1 2*.
Apply dose filter: Apply a dose-dependent filter to frames before summing them. Pre-exposure and dose per frame should be specified during movies import.
X: None
Y: None
Patches overlap (%): Specify the overlapping between patches. 
For example, overlap=20 means that each patch will have a 20% overlapping 
with its neighboring patches in each dimension.
global align: None
local align: None
Tolerance (px): Tolerance for iterative alignment, default *0.2px*.
Save unweighted images?: Aligned but non-dose weighted images are sometimes useful in CTF estimation, although there is no difference in most cases.
Additional parameters: Extra command line parameters. See MotionCor help.
Rotate gain reference:: Rotate gain reference counter-clockwise.
Flip gain reference:: Flip gain reference after rotation.
Camera defects file: Defect file that stores entries of defects on camera.
Each entry corresponds to a rectangular region in image. The pixels in such a region are replaced by neighboring good pixel values. Each entry contains 4 integers x, y, w, h representing the x, y coordinates, width, and height, respectively.
Camera defects map: 1. Defect map is a binary (0 or 1) map where defective  pixels are assigned value of 1 and good pixels have value of 0.
2. The defective pixels are corrected with a random pick of good pixels in its neighborhood. 
3. This is map must have the same dimension and orientation as the input movie frame.
4. This map can be provided as either MRC or TIFF file that has MRC mode of 0 or 5 (unsigned 8 bit).
These options are ignored for non-EER movies.: None
EER fractionation: The number of hardware frames to group into one fraction. This option is relevant only for Falcon 4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
EER upsampling: EER upsampling (1x = 4K, 2x = 8K, 3x=16K)
Correct anisotropic magnification?: Correct anisotropic magnification by stretching image along the major axis, the axis where the lower magnification is detected.
Major scale factor: None
Minor scale factor: None
Distortion angle (deg): None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tasks" can be found at the motioncorr plugin.
Its help description is:
  This protocol wraps motioncor movie alignment program developed at UCSF.

    Motioncor performs anisotropic drift correction and dose weighting
        (written by Shawn Zheng @ David Agard lab)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
: None
: None
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Split & sum odd/even frames?: Generate odd and even sums using odd and even frames respectively when this option is enabled.
Save aligned movie?: None
Compute PSD?: If Yes, the protocol will compute for each aligned micrograph the PSD using EMAN2.
Compute micrograph thumbnail?: When using this option, we will compute a micrograph thumbnail with EMAN2 and keep it with the micrograph object for visualization purposes. 
Additional protocol parameters: Here you can provide some extra parameters for the protocol, not the underlying motioncor program.You can provide many options separated by space. 

*Options:* 

--dont_use_worker_thread 
 Now by default we use a separate thread to compute PSD and thumbnail (if is required). This allows  more effective use of the GPU card, but requires  an extra CPU. Use this option (NOT RECOMMENDED) if  you want to prevent this behaviour
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. Motioncor can use multiple GPUs - in that case set to i.e. *0 1 2*.
Apply dose filter: Apply a dose-dependent filter to frames before summing them. Pre-exposure and dose per frame should be specified during movies import.
X: None
Y: None
Patches overlap (%): Specify the overlapping between patches. 
For example, overlap=20 means that each patch will have a 20% overlapping 
with its neighboring patches in each dimension.
global align: None
local align: None
Tolerance (px): Tolerance for iterative alignment, default *0.2px*.
Save unweighted images?: Aligned but non-dose weighted images are sometimes useful in CTF estimation, although there is no difference in most cases.
Additional parameters: Extra command line parameters. See MotionCor help.
Rotate gain reference:: Rotate gain reference counter-clockwise.
Flip gain reference:: Flip gain reference after rotation.
Camera defects file: Defect file that stores entries of defects on camera.
Each entry corresponds to a rectangular region in image. The pixels in such a region are replaced by neighboring good pixel values. Each entry contains 4 integers x, y, w, h representing the x, y coordinates, width, and height, respectively.
Camera defects map: 1. Defect map is a binary (0 or 1) map where defective  pixels are assigned value of 1 and good pixels have value of 0.
2. The defective pixels are corrected with a random pick of good pixels in its neighborhood. 
3. This is map must have the same dimension and orientation as the input movie frame.
4. This map can be provided as either MRC or TIFF file that has MRC mode of 0 or 5 (unsigned 8 bit).
These options are ignored for non-EER movies.: None
EER fractionation: The number of hardware frames to group into one fraction. This option is relevant only for Falcon 4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
EER upsampling: EER upsampling (1x = 4K, 2x = 8K, 3x=16K)
Correct anisotropic magnification?: Correct anisotropic magnification by stretching image along the major axis, the axis where the lower magnification is detected.
Major scale factor: None
Minor scale factor: None
Distortion angle (deg): None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.

The protocol named "align tilt-series movies" can be found at the motioncorr plugin.
Its help description is:
  This protocol wraps motioncor movie alignment program developed at UCSF.

    Motioncor performs anisotropic drift correction
        (written by Shawn Zheng @ David Agard lab)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tilt-Series (movies): Select input tilt-series movies that you wantto correct for beam-induced motion. 
from: None
to: None
Use ALIGN frames range to SUM?: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Split & sum odd/even frames?: (Used for denoising data preparation). If set to Yes, 2 additional movies/tilt series will be generated, one generated from the even frames and the other from the odd ones using the same alignment for the whole stack of frames.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. Motioncor can use multiple GPUs - in that case set to i.e. *0 1 2*.
X: None
Y: None
Patches overlap (%): Specify the overlapping between patches. 
For example, overlap=20 means that each patch will have a 20% overlapping 
with its neighboring patches in each dimension.
global align: None
local align: None
Tolerance (px): Tolerance for iterative alignment, default *0.2px*.
Additional parameters: Extra command line parameters. See MotionCor help.
Rotate gain reference:: Rotate gain reference counter-clockwise.
Flip gain reference:: Flip gain reference after rotation.
Camera defects file: Defect file that stores entries of defects on camera.
Each entry corresponds to a rectangular region in image. The pixels in such a region are replaced by neighboring good pixel values. Each entry contains 4 integers x, y, w, h representing the x, y coordinates, width, and height, respectively.
Camera defects map: 1. Defect map is a binary (0 or 1) map where defective  pixels are assigned value of 1 and good pixels have value of 0.
2. The defective pixels are corrected with a random pick of good pixels in its neighborhood. 
3. This is map must have the same dimension and orientation as the input movie frame.
4. This map can be provided as either MRC or TIFF file that has MRC mode of 0 or 5 (unsigned 8 bit).
These options are ignored for non-EER movies.: None
EER fractionation: The number of hardware frames to group into one fraction. This option is relevant only for Falcon 4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
EER upsampling: EER upsampling (1x = 4K, 2x = 8K, 3x=16K)
Correct anisotropic magnification?: Correct anisotropic magnification by stretching image along the major axis, the axis where the lower magnification is detected.
Major scale factor: None
Minor scale factor: None
Distortion angle (deg): None

The protocol named "annotate segmented membranes" can be found at the tomosegmemtv plugin.
Its help description is:
  Manual annotation tool for segmented membranes
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomo Masks: Select the Tomogram Masks (segmented tomograms) for the membrane annotation.

The protocol named "Resize segmented or annotated volume" can be found at the tomosegmemtv plugin.
Its help description is:
 Resize segmented volumes or annotated (TomoMasks)..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input segmentations (TomoMasks): None
Input tomograms: These tomograms will be used to be the ones to which the resized TomoMasks will be referred to. Thus, the resized segmentations will be of the same size of those tomograms.

The protocol named "tomogram segmentation" can be found at the tomosegmemtv plugin.
Its help description is:
 Segment membranes in tomograms.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tomograms: None
Membrane thickness (voxels): It basically represents the standard deviation of a Gaussian filtering. In general, any value in a range around that thickness works well. Too low values may make spurious details produce false positives at the local membrane detector while too high values may excessively smear out the membranes, which in turn may produce discontinuities in the segmentation results.
Membrane scale factor (voxels): This defines the effective neighborhood involved in the voting process. Depending on the thickness of the membranes in the tomogram, lower (for thinner membranes) or higher values (for thicker ones) may be more appropriate.
Is black over white?: None
Membrane-strength threshold: Allow the user tune the amount of output membrane points and remove false positives. Only voxels with values of membrane-strength threshold higher than this value will be considered as potential membrane points, and planarity descriptors will be calculated for them. Higher values will generate less membrane points, at the risk of producing gaps in the membranes. Lower values will provide more membrane points, at the risk of generating false positives.
Sigma for the initial gaussian filtering: The input tomogram is subjected to an initial Gaussian filtering aiming at reducing the noise so as to determine the derivatives more robustly. By default, a standard deviation of 1.0 voxel is considered. This option allows fine-tuning of this parameter. If the membranes are very thin or are very close to each other, use lower values (e.g. 0.5)
Sigma for the post-processing gaussian filtering: This option refers to the post-processing Gaussian filtering that is applied to the output tomogram. If sigma is set to 0, no such filtering will be applied and the program will produce 1-voxel-thick membranes. If the filter is desired to be applied, use lower values (e.g 0.5) for membranes that are very thin or are very close to each other.
Keep all the generated files?: If set to Yes, a file will be kept for each step carried out in the protocol. If set to No, only the file corresponding to the last step will be kept. Steps followed and the corresponding generated files are listed below:

   - Scale-space --> *filename_s2.mrc*
   - First tensor voting --> *filename_tv.mrc*
   - Surfaceness --> *filename_surf.mrc*
   - Second tensor voting --> *filename_tv2.mrc*
   - Saliency --> *filename_flt.mrc*
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "compute defocus array" can be found at the novactf plugin.
Its help description is:
 
    Compute defocus array for each tilt-image with novaCTF.

    More info:
            https://github.com/turonova/novaCTF
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Input tilt-series CTF estimation: Select the CTF estimation for the input tilt-series.
Tomogram thickness (voxels): Size of the tomogram in voxels in the Z direction.
Tomogram shift (voxels): Shift of the tomogram in voxels in the Z direction. The shift should be set to zero even if for reconstruction we want to shift the tomogram in z! We assume the defocus to be estimated at the center of mass which should correspond to the shifted tomogram and thus here the shift should be zero.
Defocus step (nm): The space between min and max in Z is sliced by defocus step. 15 nm is default step size. See Fig. 2 in Turonova et al., 2017 for optimal number.
Correction type: CTF correction type to be applied for the tilt-series.
Correct astigmatism: Correct for astigmatism in reconstruction.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "3D CTF correction and reconstruction" can be found at the novactf plugin.
Its help description is:
 
    Tomogram reconstruction with 3D CTF correction by novaCTF.

    More info:
            https://github.com/turonova/novaCTF
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
NovaCTF compute defocus run: None
Apply tilt-series alignment?: None
Erase gold beads: Remove the gold beads from the tilt-series.
Input set of fiducial models: Set of fid. models with no gaps after alignment
Bead diameter (px): For circle objects, this entry specifies a radius to use for points without an individual point size instead of the object's default sphere radius. This entry is floating point and can be used to overcome the limitations of having an integer default sphere radius. If there are multiple circle objects, enter one value to apply to all objects or a value for each object.
Linear region: None
Gaussian fall-off: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "auto-picking" can be found at the gautomatch plugin.
Its help description is:
  Automated particle picker for SPA.

    Gautomatch is a GPU accelerated program for accurate, fast, flexible and
    fully automatic particle picking from cryo-EM micrographs with or without
    templates.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
Input References: Template images (2D class averages or reprojections from a reference volume) to be used in picking.
 If not provided, references will be auto-generated. This is fine for *spherical particles* like virus or ribosome.
References have inverted contrast: Set to Yes to indicate that the reference have inverted contrast with respect to the particles in the micrographs.
Keep in mind that auto-generated templates will be WHITE.
Angular step size: Angular step size for picking, in degrees
Micrographs for wizard: Select which micrographs will be used for optimizing the parameters in the wizard. By default, ALL micrograph are used. You can select to use a subset based on defocus values (where micrographs will be taken from different defocus). 
Micrographs for optimization:: Select the number of micrographs that you want to be used for the parameters optimization. 
CTF estimation: Choose some CTF estimation related to the input micrographs to create the subset by defocus values.
Threshold: Particles with CCC above the threshold will be picked
Particle radius (A): Particle radius in Angstrom. Default -1 means it will be equal to 75% of references size if they were provided, otherwise 250 A.
: None
Guess advanced parameters?: By default, the program will optimize advanced parameters by itself, however if you want to modify them, select No
Box size (pix): Box size, in pixels; a suggested value will be automatically calculated using pixel size and particle size
Min inter-particle distance (A): Minimum distance between particles in Angstrom
 Use value of 0.9~1.1X diameter; can be 0.3~0.5X for filament-like particle
Speed: Speed level {0,1,2,3,4}. The bigger the faster, but less accurate.
Suggested values: 2 for >1 MDa complex, 1 for <500 kD complex, 1 or 2 for 500~1000 kD.
0 is not suggested, because the accuracy is simply fitting noise, unless for special noise-free micrographs. Use 3 for huge viruses, but 2 is still preferred. Probably do not use 4 at all, it is not accurate in general.
To adjust these parameters, select "No" for the "Guess advanced parameters?" on the Advanced tab.: None
Local sigma cut-off: Local sigma cut-off (relative value), 1.2~1.5 should be a good range
Normally a value >1.2 will be ice, protein aggregation or contamination.
This option is designed to get rid of sharp carbon/ice edges or sharp metal particles.
Local sigma diameter (A): Diameter for estimation of local sigma, in Angstrom.
Usually this diameter could be 0.5-2x of your particle diameter according to several factors. When using bigger values, normally you should decrease *Local sigma cut-off*. For smaller and sharper high density contamination/ice/metal particles you could use a smaller diameter and larger *Local sigma cut-off*
Min: None
Max: None
Local average diameter (A): Diameter for estimation of local average, in Angstrom. 1.5~2.0X particle diameter suggested.
However, if you have sharp/small ice or any dark/bright dots, using a smaller value will be much better to get rid of these areas
Min: None
Max: None
Pre-filter micrographs?: This band-pass pre-filter is normally not suggested, because it can affect ice/carbon detection. Use it only if you have a severe ice gradient.
Min: None
Max: None
Detect ice/aggregates/carbon?: None
Template normalization type: Template normalization: 1, 2 or 3 allowed.
Do band-pass?: Choose No to skip band-pass filtering.
Exclusive picking?: Exclude user-provided areas. This can be useful in the following cases:

(a) Another cycle of auto-picking after 2D classification: in this case, usually you are pretty sure that some of the particles are completely rubbish, it will be much better to exclude them during picking.
(b) Picking for partial structure: sometimes, you might have two/multiple domain complex, one is severely dominant and affect picking of the other (the rest). If you want to focus on another domain, it might be quite helpful to exclude such good particles from 2D classification.
(c) Strong orientation preference: if your templates were severely biased and mainly picked the preferred views, then it might be nice to exclude the preferred views and focused on rare views.
Coordinates to be excluded: Coordinates can be imported beforehand or generated from particles using scipion - extract coordinates protocol.
Detector defects coordinates: Occasionally you might have detector defects, e.g. a black/white stripe. This will help to get rid of these bad areas.
Write CC files?: Specify to write out cross-correlation files in MRC stack
Write pre-filtered micrographs?: Specify to write out pre-filted micrographs
Write estimated background?: Specify to write out estimated background of the micrographs
Write background-subtracted micrographs?: Specify to write out background-subtracted micrographs
Write local sigma?: Specify to write out local sigma micrographs
Write detected mask?: Specify to write out the auto-detected mask (ice, contamination, aggregation, carbon edges etc.)
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tomo reconstruction" can be found at the isonet plugin.
Its help description is:
 
     Isotropic Reconstruction of Electron Tomograms with Deep Learning
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomograms: Select the input tomogram for restoring the missing wedge.
CTF tomo series: Select the CTF estimation for the set of tilt-series.
Acceleration voltage: Acceleration voltage in kV
Spherical aberration: Spherical aberration in mm.
SNR fall rate: SNR fall rate with the frequency. High values means losing more high frequency.If this value is not set, the program will look for the parameter in the star file.If this value is not set and not found in star file, the default value 1.0 will be used.
Strength of the deconvolution: SNR fall rate with the frequency. High values means losing more high frequency.If this value is not set, the program will look for the parameter in the star file.If this value is not set and not found in star file, the default value 1.0 will be used.
Highpass filter: Highpass filter for at very low frequency. We suggest to keep this default value.
The overlapping rate: The overlapping rate for adjecent chunks.
Highpass filter: Highpass filter for at very low frequency. We suggest to keep this default value.
Pixel size (Å): Pixel size in Anstroms. Usually you want to bin your tomograms to about 10Å pixel size.Too large or too small pixel sizes are not recommanded, since the target resolution on Z-axis of corrected tomograms should be about 30Å.
Generate mask?: Generate a mask that include sample area and exclude "empty" area of the tomogram. The masks do not need to be precise. In general, the number of subtomograms (a value in star file) should be lesser if you masked out larger area.
Patch size:  The size of the box from which the max-filter and std-filter are calculated.
Density percentage: The approximate percentage of pixels to keep based on their local pixel density.If this value is not set, the program will look for the parameter in the star file.If this value is not set and not found in star file, the default value 50 will be used.
Std percentage: The approximate percentage of pixels to keep based on their local standard deviation.If this value is not set, the program will look for the parameter in the star file.If this value is not set and not found in star file, the default value 50 will be used.
Z_crop: If exclude the top and bottom regions of tomograms along z axis. For example, "0.2" will mask out the top 20% and bottom 20% region along z axis.
Tomo index:  If this value is set, process only the tomograms listed in this index. e.g. 1,2,4 or 5-10,15,16
Number of subtomograms to be extracted per tomogram: Number of subtomograms to be extracted
Size of cubes: Size of cubes for training, should be divisible by 8, eg. 32, 64. The actual sizes of extracted subtomograms are this value adds 16.This is the size of the cubic volumes used for training. This values should be smaller than the size of subtomogram. And the cube_size should be divisible by 8. If this value isnt set, cube_size is automatically determined as int(subtomo_size / 1.5 + 1)//16 * 16
Crop size: The size of subtomogram, should be larger than the cube_size The default value should be 16+cube_size.
Training model path: A trained neural network model in ".h5" format to start with.
Number of training iterations: Number of training iterations
Number of epoch: Number of epoch for each iteraction
Batch size: Size of the minibatch.If None, batch_size will be the max(2 * number_of_gpu,4). batch_size should be divisible by the number of gpu.
Steps per epoch: Step per epoch. If not defined, the default value will be min(num_of_subtomograms * 6 / batch_size , 200
Level of noise: Level of noise STD(added noise)/STD(data) after the iteration defined in noise_start_iter.
Noise start iter: Iteration that start to add noise of corresponding noise level.
Filter names: Filter names when generating noise volumes, can be 'ramp', 'hamming' and 'noFilter'
Drop out rate: Drop out rate to reduce overfitting
Learning rate: Learning rate for network training.
Number of convolution layer: Number of convolution layer for each depth
Depth of UNet: Depth of UNet.
Kernel for convolution: Kernel for convolution
Filter base: The base number of channels after convolution.
Use batch normalization layer?: Use Batch Normalization layer
Use pooling layer?: Use pooling layer instead of stride convolution layer
Normalize percentile?: Normalize the 5 percent and 95 percent pixel intensity to 0 and 1 respectively. If this is set to False, normalize the input to 0 mean and 1 standard deviation.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Choose GPU IDs:: This argument is necessary. By default, the protocol will attempt to launch on GPU 0. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. GPU are separated by ",". For example: "0,1,5"

The protocol named "tilt-series align and reconstruct" can be found at the aretomo plugin.
Its help description is:
  Protocol for fiducial-free tilt series alignment, tomogram reconstruction and CTF estimation all in one..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of Tilt-Series: If you choose to skip alignment, the input tilt-series are expected to be already aligned.
Skip alignment?: You can skip alignment if you just want to reconstruct a tomogram from already aligned tilt-series.
Reconstruct the tomograms?: You can skip tomogram reconstruction, so that input tilt-series will be only aligned.
Save interpolated aligned TS?: Choose No to discard aligned stacks.
Use alignment from previous AreTomo run?: None
Previous AreTomo run: Use alignment from a previous AreTomo run. The match is made using *tsId*. This option is useful when working with odd/even tilt-series sets. All other input alignment parameters will be ignored.
Binning: Binning for aligned output tilt-series / volume.
Volume height for alignment (voxels): Specifies Z height (*unbinned*) of the temporary volume reconstructed for projection matching as part of the alignment process. This value plays an important role in alignment accuracy. This Z height should be always smaller than tomogram thickness and should be close to the sample thickness.
Tomogram thickness unbinned (voxels): Z height of the reconstructed volume in *unbinned* voxels.
Refine tilt angles?: You have three options:
a) Disable measure and correction
b) Measure only (default). Correction is done during alignment but not for final reconstruction
c) Measure and correct

Occasionally, the measurement is erroneous and can impair the alignment accuracy. Please note that the orientation of the missing wedge will be changed as a result of the correction of tilt offset. For subtomogram averaging, tomograms reconstructed from tilt series collected within the same tilt range may have different orientations of missing wedges.
Refine tilt axis angle?: Tilt axis determination is a two-step processing in AreTomo. A single tilt axis is first calculated followed by the determination of how tilt axis varies over the entire tilt range. The initial value lets users enter their estimate and AreTomo refines the estimate in [-3º, 3º] range.
Generate extra IMOD output?: 0 - No
1 - generate IMOD files for Relion 4
2 - generate IMOD files for Warp
3 - generate global and local-aligned tilt series stack. High frequencies are enhanced to alleviate the attenuation due to interpolation.
Estimate the CTF?: Activate to make aretomo estimate the CTF.
Do phase shift estimation?: None
min: None
max: None
Do dose-weighting?: None
Reconstruction method: Choose either SART or weighted back projection (WBP).
iterations: None
projections per subset: None
Flip intensity?: By default, the reconstructed volume and the input tilt series use the same grayscale that makes dense structures dark.
Flip volume?: Set to Yes when making a tomogram and No when making a tilt-series. This way the output orientation will be similar to IMOD.
ROI for focused alignment: By default AreTomo assumes the region of interest at the center of 0º projection image. A circular mask is employed to down-weight the area outside ROI during the alignment. When the structures of interest are far away from the tilt axis, the angular error in the determination of tilt axis will significantly amplify the translational error. ROI function can effectively improve the alignment accuracy for the distant structures.
Here you can provide *a pair of x and y coordinates*, representing the center of the region of interest.
The region of interest should be selected from 0º projection image with the origin at the lower left corner. IMOD's Pixel View is a good tool to select the center of region of interest.
Sample type: AreTomo provides two means to correct the local motion, one for isolated sample and the other for well distributed across the field of view.
Coordinate file: A list of x and y coordinates should be put into a two-column text file, one column for x and the other for y. Each pair defines a region of interest (ROI). The origin of the coordinate system is at the image's lower left corner.
X: None
Y: None
Dark tolerance: Set tolerance for removing dark images. The range is in (0, 1). The default value is 0.7. The higher value is more restrictive.
Additional parameters: Extra command line parameters. See AreTomo help.
: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tomo blik" can be found at the blik plugin.
Its help description is:
 
    Tool for visualising and interacting with cryo-ET and subtomogram averaging
    data using napari viewer
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomograms: Select the input tomograms

The protocol named "tomogram membrane segmentation" can be found at the membrain plugin.
Its help description is:
 
    Segment membranes in tomograms using MemBrain-seg.

    More info:
        https://github.com/teamtomo/membrain-seg
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tomograms: None
Threshold for segmentation: Threshold for the membrane segmentation. Only voxels with a membrane score higher than this threshold will be segmented.
Sliding window size: Sliding window size used for inference. Smaller values than 160 consume less GPU, but also lead to worse segmentation results!
Label connected components?: Segmentation will be stored as labelled connected components (automatic annotation).
Threshold for connected components: Components smaller than this size (in voxels) will be removed from the segmentation. A negative value disables this parameter.
Do test-time augmentation?: Use 8-fold test-time augmentation? This improves segmentation quality, but also increases runtime.
Output probability maps?: Stores probability maps obtained from 8-fold test-time augmentation in addition to the segmentations.
: GPU device to be used. If no GPU is found, MemBrain-seg will run on CPU using the number of threads specified (much slower)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "OFM Corrector" can be found at the ofmcorrection plugin.
Its help description is:
 
    Corrects optical fluorecence microscopy images/channels based on calibration images
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Beads file pattern: Pattern of the beads file name. Must contain this text.
OFM Root folder: Path to the OFM sample images
File finished after: File will be considered finished if it has not been modified for this time. Duration format example: 1d 20h 30m 30s --> 1 day 20 hours 30 minutes and 30 seconds
Scanning waiting time: Time to wait for the next folder scan. Duration format example: 1d 20h 30m 30s --> 1 day 20 hours 30 minutes and 30 seconds
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "AI training" can be found at the tomonet plugin.
Its help description is:
 
    Trains an AI model using a set of Coordinates. Producing a AI model that
    can be used in a later TomoNet tomogram picking step.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates: Coordinates to be used in the training
Epochs: Number of "iterations" to run over the training data.

The protocol named "test output" can be found at the pyworkflowtests plugin.
Its help description is:
  Protocol to test scalar output and input linking.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input box size as Integer: None
Nullable Integer: None
Scipion v3.4.0 - Eugenius

The protocol named "optical alignment" can be found in the xmipp3 plugin.
"optical alignment" protocol help is as follows:
 
    Wrapper protocol to Xmipp Movie Alignment by Optical Flow
    .
Scipion v3.4.0 - Eugenius

The protocol named "optical alignment" can be found in the xmipp3 plugin.
"optical alignment" protocol help is as follows:
 
    Wrapper protocol to Xmipp Movie Alignment by Optical Flow
    .
"optical alignment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"optical alignment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"optical alignment" has a "Input Movies" parameter that is explained as: Select a set of previously imported movies.
"optical alignment" has a "from" parameter that is explained as: None
"optical alignment" has a "to" parameter that is explained as: None
"optical alignment" has a "Use ALIGN frames range to SUM?" parameter that is explained as: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
"optical alignment" has a "from" parameter that is explained as: None
"optical alignment" has a "to" parameter that is explained as: None
"optical alignment" has a "Binning factor" parameter that is explained as: 1x or 2x. Bin stack before processing.
"optical alignment" has a "X" parameter that is explained as: None
"optical alignment" has a "Y" parameter that is explained as: None
"optical alignment" has a "X" parameter that is explained as: None
"optical alignment" has a "Y" parameter that is explained as: None
"optical alignment" has a "Save aligned micrograph" parameter that is explained as: None
"optical alignment" has a "Save movie" parameter that is explained as: Save Aligned movie
"optical alignment" has a "" parameter that is explained as: Set to true if you want the GPU implementation of Optical Flow
"optical alignment" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
"optical alignment" has a "Window size" parameter that is explained as: Window size (shifts are assumed to be constant within this window).
"optical alignment" has a "Group Size" parameter that is explained as: The number of frames in each group at the last step
"optical alignment" has a "Use previous movie alignment to SUM frames?" parameter that is explained as: Input movies could have alignment information froma previous protocol. If you select *Yes*, the previous alignment will be taken into account.
"optical alignment" has a "Compute PSD (before/after)?" parameter that is explained as: If Yes, the protocol will compute for each movie the PSD of the average micrograph (without OF alignement) and after that, to compare each PSDs
"optical alignment" has a "Keep images in RAM ?" parameter that is explained as: If True, the protocol will increase the demand of RAM, decreasing disc access
"optical alignment" has a "Apply Dose filter" parameter that is explained as: Apply a dose-dependent filter to frames before summing them. Pre-exposure and dose per frame should  be specified during movies import.
"optical alignment" has a "Save unweighted micrographs?" parameter that is explained as: Yes by default, if you have selected to apply a dose-dependent filter to the frames
"optical alignment" has a "Apply Dose filter before alignment?" parameter that is explained as: if *True*, you apply dose filter before perform the alignment; else will apply after alignment.
"optical alignment" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"optical alignment" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"optical alignment" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "apply deformation field - Zernike3D" can be found in the xmipp3 plugin.
"apply deformation field - Zernike3D" protocol help is as follows:
  Protocol for PDB deformation based on Zernike3D basis. .
"apply deformation field - Zernike3D" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"apply deformation field - Zernike3D" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"apply deformation field - Zernike3D" has a "Zernike3D volume(s)" parameter that is explained as: Volume(s) with Zernike3D coefficients assigned.
"apply deformation field - Zernike3D" has a "Input volume mask" parameter that is explained as: None
"apply deformation field - Zernike3D" has a "Zernike Degree" parameter that is explained as: Degree Zernike Polynomials of the deformation=1,2,3,...
"apply deformation field - Zernike3D" has a "Harmonical Degree" parameter that is explained as: Degree Spherical Harmonics of the deformation=1,2,3,...
"apply deformation field - Zernike3D" has a "Apply to structure?" parameter that is explained as: If True, you will be able to provide an atomic structure to be deformed based on the Zernike3D coefficients associated to the input volume(s). If False, the coefficients will be applied to the volume(s) directly.
"apply deformation field - Zernike3D" has a "Input PDB" parameter that is explained as: Atomic structure to apply the deformation fields defined by the Zernike3D coefficients associated to the input volume. For better results, the volume(s) and structure should be aligned
"apply deformation field - Zernike3D" has a "Move structure to box origin?" parameter that is explained as: If PDB has been aligned inside Scipion, set to False. Otherwise, this option will correctly place the PDB in the origin of the volume.

The protocol named "metaprotocol heterogeneity subset" can be found in the xmipp3 plugin.
"metaprotocol heterogeneity subset" protocol help is as follows:
  Metaprotocol to select a set of particles from a 3DClasses and a
    Volume from a SetOfVolumes
     .
"metaprotocol heterogeneity subset" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"metaprotocol heterogeneity subset" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"metaprotocol heterogeneity subset" has a "Input set of 3D classes" parameter that is explained as: Select the set of 3D classes to select an specific set of particles.
"metaprotocol heterogeneity subset" has a "Input Idx" parameter that is explained as: Identifier of the volume and particles selected

The protocol named "metaprotocol golden highres" can be found in the xmipp3 plugin.
"metaprotocol golden highres" protocol help is as follows:
  Metaprotocol to run golden version of highres.
"metaprotocol golden highres" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"metaprotocol golden highres" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"metaprotocol golden highres" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"metaprotocol golden highres" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"metaprotocol golden highres" has a "Full-size Images" parameter that is explained as: Select a set of images at full resolution
"metaprotocol golden highres" has a "Initial volumes" parameter that is explained as: Select a set of volumes with 2 volumes or a single volume
"metaprotocol golden highres" has a "Radius of particle (px)" parameter that is explained as: This is the radius (in pixels) of the spherical mask covering the particle in the input images
"metaprotocol golden highres" has a "Symmetry group" parameter that is explained as: If no symmetry is present, give c1
"metaprotocol golden highres" has a "Initial resolution" parameter that is explained as: In Angstroms. The minimum resolution to be used in the first step of the protocol. Then, the resolution will be automatically adjusted.
"metaprotocol golden highres" has a "Maximum resolution" parameter that is explained as: In Angstroms. The maximum resolution to be used along the protocol. Set it to -1 for automatic adjustment.
"metaprotocol golden highres" has a "Discard particles?" parameter that is explained as: Discard particles when two distributions are estimated?
"metaprotocol golden highres" has a "Split method" parameter that is explained as: When discard particles is allowed, choose the method between hypothesis testing or Otsu thresholding
"metaprotocol golden highres" has a "Adaptive threshold HT" parameter that is explained as: Choose if you want to use an adaptive threshold for the hypothesis testing.
"metaprotocol golden highres" has a "Max. shift (%)" parameter that is explained as: Maximum shift as a percentage of the image size
"metaprotocol golden highres" has a "Min." parameter that is explained as: Side views are around 90 degrees, top views around 0
"metaprotocol golden highres" has a "Max." parameter that is explained as: You may generate redudant galleries by setting this angle to 180, this may help if c1 symmetry is considered
"metaprotocol golden highres" has a "Mask" parameter that is explained as: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
"metaprotocol golden highres" has a "Symmetrize volume within mask?" parameter that is explained as: None
"metaprotocol golden highres" has a "Mask symmetry" parameter that is explained as: If no symmetry is present, give c1
"metaprotocol golden highres" has a "Mask" parameter that is explained as: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
"metaprotocol golden highres" has a "Apply helical symmetry?" parameter that is explained as: None
"metaprotocol golden highres" has a "Radius" parameter that is explained as: In Angstroms
"metaprotocol golden highres" has a "Dihedral symmetry" parameter that is explained as: None
"metaprotocol golden highres" has a "Min. Rotation" parameter that is explained as: In degrees
"metaprotocol golden highres" has a "Max. Rotation" parameter that is explained as: In degrees
"metaprotocol golden highres" has a "Min. Z shift" parameter that is explained as: In angstroms
"metaprotocol golden highres" has a "Max. Z shift" parameter that is explained as: In angstroms
"metaprotocol golden highres" has a "Post-processing command" parameter that is explained as: A command template that is used to post-process the reconstruction. The following variables can be used %(sampling)s %(dim)s %(volume)s %(iterDir)s. The command should read Spider volumes and modify the input volume.the command should be accessible either from the PATH or provide the absolute path.
Examples: 
xmipp_transform_filter -i %(volume)s --fourier low_pass 15 --sampling %(sampling)s
/home/joe/myScript %(volume)s sampling=%(sampling)s dim=%(dim)s
"metaprotocol golden highres" has a "Significant denoising Real space" parameter that is explained as: None
"metaprotocol golden highres" has a "Significant denoising Fourier space" parameter that is explained as: None
"metaprotocol golden highres" has a "Laplacian denoising" parameter that is explained as: It can only be used if there is a mask
"metaprotocol golden highres" has a "Blind deconvolution" parameter that is explained as: None
"metaprotocol golden highres" has a "Attenuate undershooting" parameter that is explained as: None
"metaprotocol golden highres" has a "Attenuate undershooting (K)" parameter that is explained as: Values below avg-K*sigma are attenuated
"metaprotocol golden highres" has a "Evaluate difference" parameter that is explained as: None
"metaprotocol golden highres" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"metaprotocol golden highres" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"metaprotocol golden highres" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "auto-picking (step 2)" can be found in the xmipp3 plugin.
"auto-picking (step 2)" protocol help is as follows:
 Protocol to pick particles automatically in a set of
    micrographs using previous training .
"auto-picking (step 2)" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"auto-picking (step 2)" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"auto-picking (step 2)" has a "Model source" parameter that is explained as: The files model_* can be copied from a previous protocol execution within this project or copied from an external directory. This latter option is useful incases in which the same kind of molecule is processed many times.
"auto-picking (step 2)" has a "Xmipp particle picking run" parameter that is explained as: Select the previous xmipp particle picking run.
"auto-picking (step 2)" has a "Xmipp particle picking model directory" parameter that is explained as: The directory must contain the files model_*, config.xmd and templates.stk
"auto-picking (step 2)" has a "Micrographs to pick" parameter that is explained as: Select from which set of micrographs to pick using the training from supervised run.If you use Same as supervised, the same set of micrographs used for training the picker will be used at this point. If you select Other, you can select another set of micrograph (normally from the same specimen) and pick them completely automatic using the trained picker.
"auto-picking (step 2)" has a "Micrographs" parameter that is explained as: Select other set of micrographs to pick using the trained picker.
"auto-picking (step 2)" has a "The following params are related to how streaming is done in Scipion." parameter that is explained as: None
"auto-picking (step 2)" has a "Sleep when waiting (secs)" parameter that is explained as: If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
"auto-picking (step 2)" has a "Batch size" parameter that is explained as: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
"auto-picking (step 2)" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"auto-picking (step 2)" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"auto-picking (step 2)" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "add noise particles" can be found in the xmipp3 plugin.
"add noise particles" protocol help is as follows:
     
    Given a set of particles, the protocol will add noise to them 
    The types of noise are Uniform, Student and Gaussian.
    .
"add noise particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"add noise particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"add noise particles" has a "Input particles" parameter that is explained as: Select a set of particles.
"add noise particles" has a "Noise Type" parameter that is explained as: None
"add noise particles" has a "Standard Deviation" parameter that is explained as: Please, introduce the standard deviation value.Mean value can be changed in advanced mode.
"add noise particles" has a "Mean" parameter that is explained as: Please, introduce the mean value (default = 0).
"add noise particles" has a "Degree of Freedom" parameter that is explained as: Please, introduce the Degree of Freedom.Mean value can be changed in advanced mode.
"add noise particles" has a "Standard Deviation" parameter that is explained as: Please, introduce the standard deviation value.Mean value can be changed in advanced mode.
"add noise particles" has a "Mean" parameter that is explained as: Please, introduce the mean value (default = 0).
"add noise particles" has a "Minimum Value" parameter that is explained as: Please, introduce the minimum value. (default = 0)
"add noise particles" has a "Maximum Value" parameter that is explained as: Please, introduce the maximum value (default = 1).
"add noise particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"add noise particles" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"add noise particles" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "add noise volume/s" can be found in the xmipp3 plugin.
"add noise volume/s" protocol help is as follows:
     
    Given a set of volumes, or a volume the protocol will add noise to them 
    The types of noise are Uniform, Student and Gaussian.
    .
"add noise volume/s" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"add noise volume/s" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"add noise volume/s" has a "Input Volume/s" parameter that is explained as: Select a volume or Set of volumes.
"add noise volume/s" has a "Noise Type" parameter that is explained as: None
"add noise volume/s" has a "Standard Deviation" parameter that is explained as: Please, introduce the standard deviation value.Mean value can be changed in advanced mode.
"add noise volume/s" has a "Mean" parameter that is explained as: Please, introduce the mean value (default = 0).
"add noise volume/s" has a "Degree of Freedom" parameter that is explained as: Please, introduce the Degree of Freedom.Mean value can be changed in advanced mode.
"add noise volume/s" has a "Standard Deviation" parameter that is explained as: Please, introduce the standard deviation value.Mean value can be changed in advanced mode.
"add noise volume/s" has a "Mean" parameter that is explained as: Please, introduce the mean value (default = 0).
"add noise volume/s" has a "Minimum Value" parameter that is explained as: Please, introduce the minimum value. (default = 0)
"add noise volume/s" has a "Maximum Value" parameter that is explained as: Please, introduce the maximum value (default = 1).
"add noise volume/s" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"add noise volume/s" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"add noise volume/s" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "align volume" can be found in the xmipp3 plugin.
"align volume" protocol help is as follows:
  
    Aligns a set of volumes using cross correlation 
    or a Fast Fourier method. 

     .
"align volume" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"align volume" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"align volume" has a "Reference volume" parameter that is explained as: Reference volume to be used for the alignment.
"align volume" has a "Input volume(s)" parameter that is explained as: Select one or more volumes (Volume or SetOfVolumes)
to be aligned againt the reference volume.
"align volume" has a "Apply mask?" parameter that is explained as: Apply a 3D Binary mask to the volumes
"align volume" has a "Mask type" parameter that is explained as: Select the type of mask you want to apply
"align volume" has a "Mask radius" parameter that is explained as: Insert the radius for the mask
"align volume" has a "Mask file" parameter that is explained as: Select the volume mask object
"align volume" has a "Alignment algorithm" parameter that is explained as: Exhaustive searches all possible combinations within a search space.Local searches around a given position.Be aware that the Fast Fourier algorithm requires a special compilationof Xmipp (--cltomo flag). It performs the same job as the  exhaustive method but much faster.
"align volume" has a "Min" parameter that is explained as: None
"align volume" has a "Max" parameter that is explained as: None
"align volume" has a "Step" parameter that is explained as: None
"align volume" has a "Min" parameter that is explained as: None
"align volume" has a "Max" parameter that is explained as: None
"align volume" has a "Step" parameter that is explained as: None
"align volume" has a "Min" parameter that is explained as: None
"align volume" has a "Max" parameter that is explained as: None
"align volume" has a "Step" parameter that is explained as: None
"align volume" has a "Min" parameter that is explained as: None
"align volume" has a "Max" parameter that is explained as: None
"align volume" has a "Step" parameter that is explained as: None
"align volume" has a "Min" parameter that is explained as: None
"align volume" has a "Max" parameter that is explained as: None
"align volume" has a "Step" parameter that is explained as: None
"align volume" has a "Min" parameter that is explained as: None
"align volume" has a "Max" parameter that is explained as: None
"align volume" has a "Step" parameter that is explained as: None
"align volume" has a "Min" parameter that is explained as: None
"align volume" has a "Max" parameter that is explained as: None
"align volume" has a "Step" parameter that is explained as: None
"align volume" has a "Rot" parameter that is explained as: None
"align volume" has a "Tilt" parameter that is explained as: None
"align volume" has a "Psi" parameter that is explained as: None
"align volume" has a "X" parameter that is explained as: None
"align volume" has a "Y" parameter that is explained as: None
"align volume" has a "Z" parameter that is explained as: None
"align volume" has a "Optimize scale" parameter that is explained as: Choose YES if you want to optimize the scale of input volume/s based on the reference
"align volume" has a "Initial scale" parameter that is explained as: None
"align volume" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"align volume" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"align volume" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "align volume web" can be found in the xmipp3 plugin.
"align volume web" protocol help is as follows:
  Aligns a set of volumes using cross correlation.
    Based on Xmipp protocol for aligning volumes, but
    the parameters are restricted for ease of use.
    .
"align volume web" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"align volume web" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"align volume web" has a "Reference volume" parameter that is explained as: Reference volume to be used for the alignment.
"align volume web" has a "Input volume(s)" parameter that is explained as: Select one or more volumes (Volume or SetOfVolumes)
to be aligned againt the reference volume.
"align volume web" has a "Apply mask?" parameter that is explained as: Apply a 3D Binary mask to the volumes
"align volume web" has a "Mask type" parameter that is explained as: Select the type of mask you want to apply
"align volume web" has a "Mask radius" parameter that is explained as: Insert the radius for the mask
"align volume web" has a "Mask file" parameter that is explained as: Select the volume mask object
"align volume web" has a "Alignment algorithm" parameter that is explained as: Exhaustive searches all possible combinations within a search space.Local searches around a given position.Be aware that the Fast Fourier algorithm requires a special compilationof Xmipp (--cltomo flag). It performs the same job as the  exhaustive method but much faster.
"align volume web" has a "Min" parameter that is explained as: None
"align volume web" has a "Max" parameter that is explained as: None
"align volume web" has a "Step" parameter that is explained as: None
"align volume web" has a "Min" parameter that is explained as: None
"align volume web" has a "Max" parameter that is explained as: None
"align volume web" has a "Step" parameter that is explained as: None
"align volume web" has a "Min" parameter that is explained as: None
"align volume web" has a "Max" parameter that is explained as: None
"align volume web" has a "Step" parameter that is explained as: None
"align volume web" has a "Min" parameter that is explained as: None
"align volume web" has a "Max" parameter that is explained as: None
"align volume web" has a "Step" parameter that is explained as: None
"align volume web" has a "Min" parameter that is explained as: None
"align volume web" has a "Max" parameter that is explained as: None
"align volume web" has a "Step" parameter that is explained as: None
"align volume web" has a "Min" parameter that is explained as: None
"align volume web" has a "Max" parameter that is explained as: None
"align volume web" has a "Step" parameter that is explained as: None
"align volume web" has a "Min" parameter that is explained as: None
"align volume web" has a "Max" parameter that is explained as: None
"align volume web" has a "Step" parameter that is explained as: None
"align volume web" has a "Rot" parameter that is explained as: None
"align volume web" has a "Tilt" parameter that is explained as: None
"align volume web" has a "Psi" parameter that is explained as: None
"align volume web" has a "X" parameter that is explained as: None
"align volume web" has a "Y" parameter that is explained as: None
"align volume web" has a "Z" parameter that is explained as: None
"align volume web" has a "Optimize scale" parameter that is explained as: Choose YES if you want to optimize the scale of input volume/s based on the reference
"align volume web" has a "Initial scale" parameter that is explained as: None
"align volume web" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"align volume web" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"align volume web" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "align volume and particles" can be found in the xmipp3 plugin.
"align volume and particles" protocol help is as follows:
  
    Aligns a volume (inputVolume) using a Fast Fourier method
    with respect to a reference one (inputReference).
     The obtained alignment parameters are used to align the set of particles or subtomograms
     (inputParticles) that generated the input volume.
     .
"align volume and particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"align volume and particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"align volume and particles" has a "Reference volume" parameter that is explained as: Reference volume to be used for the alignment.
"align volume and particles" has a "Input volume" parameter that is explained as: Select one volume to be aligned against the reference volume.
"align volume and particles" has a "Input particles" parameter that is explained as: Select one set of particles to be aligned against the reference set of particles using the transformation calculated with the reference and input volumes.
"align volume and particles" has a "Alignment mode" parameter that is explained as: None
"align volume and particles" has a "Symmetry group" parameter that is explained as: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] page for a description of the symmetries accepted by Xmipp
"align volume and particles" has a "Wrap" parameter that is explained as: Wrap the input volume when aligning to the reference
"align volume and particles" has a "Apply mask?" parameter that is explained as: Apply a 3D Binary mask to the volumes
"align volume and particles" has a "Mask type" parameter that is explained as: Select the type of mask you want to apply
"align volume and particles" has a "Mask radius" parameter that is explained as: Insert the radius for the mask
"align volume and particles" has a "Mask file" parameter that is explained as: Select the volume mask object
"align volume and particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"align volume and particles" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"align volume and particles" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "analyze local defocus" can be found in the xmipp3 plugin.
"analyze local defocus" protocol help is as follows:
 Assigns to each micrograph a coefficient (R2) which evaluates the result of the
        local defocus adjustment and displays the local defocus for all the particles in each micrograph..
"analyze local defocus" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"analyze local defocus" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"analyze local defocus" has a "Input micrographs" parameter that is explained as: None
"analyze local defocus" has a "Input images" parameter that is explained as: Set of particles with assigned local defocus

The protocol named "break symmetry" can be found in the xmipp3 plugin.
"break symmetry" protocol help is as follows:
 
    Given an input set of particles with angular assignment, find an
    equivalent angular assignment for a given symmetry.

    Be aware that input symmetry values follows Xmipp conventions as described in:
    http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry
    .
"break symmetry" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"break symmetry" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"break symmetry" has a "Input Particles" parameter that is explained as: None
"break symmetry" has a "Symmetry group" parameter that is explained as: See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format in Xmipp.
If no symmetry is present, use _c1_.
"break symmetry" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "angular graph consistency" can be found in the xmipp3 plugin.
"angular graph consistency" protocol help is as follows:
 
    Performs soft alignment validation of a set of particles previously aligned
    confronting them using Graph filtered correlations representation. This
    protocol produces an histogram with two groups of particles.
    .
"angular graph consistency" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"angular graph consistency" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"angular graph consistency" has a "Input volume" parameter that is explained as: Select the input volume(s).
"angular graph consistency" has a "Input particles" parameter that is explained as: Select the input projection images.
"angular graph consistency" has a "Symmetry group" parameter that is explained as: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
"angular graph consistency" has a "Angular Sampling (degrees)" parameter that is explained as: Angular distance (in degrees) between neighboring projection points 
"angular graph consistency" has a "correlation level for validation" parameter that is explained as: threshold correlation to be used in validation. Keep this value in the range [0.90 -- 0.97]
"angular graph consistency" has a "Minimum allowed tilt angle" parameter that is explained as: Tilts below this value will not be considered for the alignment
"angular graph consistency" has a "Maximum allowed tilt angle without mirror check" parameter that is explained as: Tilts above this value will not be considered for the alignment without mirror check
"angular graph consistency" has a "Target resolution (A)" parameter that is explained as: Low pass filter the particles to this resolution. This usually helps a lot obtaining good alignment. You should have a good reason to modify this value outside the range  [8-10] A
"angular graph consistency" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"angular graph consistency" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"angular graph consistency" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "apply alignment 2d" can be found in the xmipp3 plugin.
"apply alignment 2d" protocol help is as follows:
  Apply alignment parameters and produce a new set of images. .
"apply alignment 2d" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"apply alignment 2d" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"apply alignment 2d" has a "Input Particles" parameter that is explained as: Select the particles that you want to apply thealignment parameters.
"apply alignment 2d" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"apply alignment 2d" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "apply transformation matrix" can be found in the xmipp3 plugin.
"apply transformation matrix" protocol help is as follows:
  
    Apply transformation matrix  of an aligned volume on 
    a set of particles to modify their angular assignment.
    Note:
    These particles are practically related to the 
    aligned volume (but before alignment).
    .
"apply transformation matrix" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"apply transformation matrix" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"apply transformation matrix" has a "Input particles" parameter that is explained as: Aligned particles that their  angular assignment needs to be modified.
"apply transformation matrix" has a "Input volume" parameter that is explained as: Volume that we want to use its transformation matrix to modify angular assignment of input particles. (This is normally the output volume of protocol_align_volume)
"apply transformation matrix" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"apply transformation matrix" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"apply transformation matrix" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "assign tiltpairs" can be found in the xmipp3 plugin.
"assign tiltpairs" protocol help is as follows:
     
    From two sets of points (tilted and untilted) the protocol determines
    the affine transformation between these sets.
    .
"assign tiltpairs" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"assign tiltpairs" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"assign tiltpairs" has a "Micrograph tilt pair" parameter that is explained as: Select micrographs tilt pair.
"assign tiltpairs" has a "Input type" parameter that is explained as: Select a Set of Coordinates or a Set or Particles.
"assign tiltpairs" has a "Untilted input" parameter that is explained as: Select the untilted input set, it can be either coordinates or particles (that contains coordinates.
"assign tiltpairs" has a "Tilted input" parameter that is explained as: Select the tilted input set, it can be either coordinates or particles (that contains coordinates. It should be of the same type of the input untilted.
"assign tiltpairs" has a "Tilt angle" parameter that is explained as: Tilt angle estimation, the method will look for the assignment in the interval of [tilt_angle-15, tilt_angle+15].
 By default: tilt angle = -1, if there is not any information about the tilt angle
"assign tiltpairs" has a "Threshold value" parameter that is explained as: Parameter between 0 and 1 that allows to define if 
a tilt point can be matched with a certain untilt point.
The matching is performed only if the distance is lesser
than threshold * particlesize.
"assign tiltpairs" has a "Maximum shift (pixels)" parameter that is explained as: Maximum allowed distance (in pixels) that the tilt micrograph can be shifted respect to the untilted micrograph
"assign tiltpairs" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"assign tiltpairs" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"assign tiltpairs" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "boost particles" can be found in the xmipp3 plugin.
"boost particles" protocol help is as follows:
  This protocol tries to boost the frequencies of the particles to imporve them, based on an adjustment on its correspondent projections from a reference volume. .
"boost particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"boost particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"boost particles" has a "Particles " parameter that is explained as: Specify a SetOfParticles
"boost particles" has a "Reference volume " parameter that is explained as: Specify a volume.
"boost particles" has a "Circular mask radius: " parameter that is explained as: Radius of the circular mask to avoid edge artifacts. If -1 it is half the X dimension of the input particles
"boost particles" has a "Maximum resolution: " parameter that is explained as: Maximum resolution (in A) of the data 
"boost particles" has a "Ignore particles with negative beta0 or R2?: " parameter that is explained as: Particles with negative beta0 or R2 will not appear in the output set as they are considered bad particles. Moreover, negative betas will not contribute to mean beta if "mean" option is selected
"boost particles" has a "Limit frequency?: " parameter that is explained as: Limit frequency in the adjustment process to the frequency correspondent to the resolution indicated in "Maximum resolution" field above
"boost particles" has a "Decay of the filter (sigma): " parameter that is explained as: Decay of the filter (sigma) to smooth the mask transition
"boost particles" has a "Fourier padding factor: " parameter that is explained as: The volume is zero padded by this factor to produce projections
"boost particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"boost particles" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "cl2d" can be found in the xmipp3 plugin.
"cl2d" protocol help is as follows:
  Classifies a set of images using a clustering algorithm to subdivide
    the original dataset into a given number of classes. .
"cl2d" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"cl2d" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"cl2d" has a "Input images" parameter that is explained as: Select the input images to be classified.
"cl2d" has a "Number of classes:" parameter that is explained as: Number of classes (or references) to be generated.
"cl2d" has a "Random initialization of classes:" parameter that is explained as: Initialize randomly the first classes. If you don't initialize randomly, you must supply a set of initial classes
"cl2d" has a "Initial classes" parameter that is explained as: Set of initial classes to start the classification
"cl2d" has a "Number of initial classes:" parameter that is explained as: Initial number of classes used in the first level.
"cl2d" has a "Number of iterations:" parameter that is explained as: Maximum number of iterations within each level.
"cl2d" has a "Comparison method" parameter that is explained as: Use correlation or correntropy
"cl2d" has a "Clustering method" parameter that is explained as: Use the classical clustering criterion or the robust
"cl2d" has a "Additional parameters" parameter that is explained as: Additional parameters for classify_CL2D: 
 --verbose, --corrSplit, ...
"cl2d" has a "Perform core analysis" parameter that is explained as: An image belongs to the core if it is close (see Junk Zscore and PCA Zscore) to the class center
"cl2d" has a "Junk Zscore" parameter that is explained as: Which is the average Z-score to be considered as junk. Typical values go from 1.5 to 3. For the Gaussian distribution 99.5% of the data is within a Z-score of 3. Lower Z-scores reject more images. Higher Z-scores accept more images.
"cl2d" has a "PCA Zscore" parameter that is explained as: Which is the PCA Z-score to be considered as junk. Typical values go from 1.5 to 3. For the Gaussian distribution 99.5% of the data is within a Z-score of 3. Lower Z-scores reject more images. Higher Z-scores accept more images.
"cl2d" has a "Perform stable core analysis" parameter that is explained as: Two images belong to the stable core if they have been essentially together along the classification process
"cl2d" has a "Tolerance" parameter that is explained as: An image belongs to the stable core if it has been with other images in the same class in all the previous levels except possibly a few of them. Tolerance defines how few is few. Tolerance=0 means that an image must be in all previous levels with the rest of images in the core.
"cl2d" has a "Compute class hierarchy" parameter that is explained as: None
"cl2d" has a "Analyze rejected particles" parameter that is explained as: To see the analysis you need to browse the execution directory and go into the different levels
"cl2d" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"cl2d" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "align with cl2d" can be found in the xmipp3 plugin.
"align with cl2d" protocol help is as follows:
  Aligns a set of particles using the CL2D algorithm. .
"align with cl2d" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"align with cl2d" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"align with cl2d" has a "Input Particles" parameter that is explained as: None
"align with cl2d" has a "Use a Reference Image ?" parameter that is explained as: If you set to *Yes*, you should provide a reference image.
If *No*, the default generation is done by averaging subsets of the input images.
"align with cl2d" has a "Reference image" parameter that is explained as: Image that will serve as class reference. If the input is a set, then the first image will be used as reference.
"align with cl2d" has a "Maximum shift (px):" parameter that is explained as: None
"align with cl2d" has a "Number of iterations:" parameter that is explained as: Maximum number of iterations
"align with cl2d" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"align with cl2d" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "2D classes mapping" can be found in the xmipp3 plugin.
"2D classes mapping" protocol help is as follows:
  Create a low dimensional mapping from a SetOfClasses2D with interactive selection of classes.
    Use mouse left-click to select/deselect classes individually or mouse right-click to select/deselect
    several classes..
"2D classes mapping" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"2D classes mapping" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"2D classes mapping" has a "Input 2D classes" parameter that is explained as: Select the input classes to be mapped.
"2D classes mapping" has a "Interactive class selection?" parameter that is explained as: None
"2D classes mapping" has a "Dimension reduction method" parameter that is explained as: None
"2D classes mapping" has a "Distance metric to compare images" parameter that is explained as: None

The protocol named "ctf consensus" can be found in the xmipp3 plugin.
"ctf consensus" protocol help is as follows:
 
    Protocol to make a selection of meaningful CTFs in basis of the defocus
    values, the astigmatism, the resolution, other Xmipp parameters, and
    the agreement with a secondary CTF for the same set of micrographs.
    .
"ctf consensus" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"ctf consensus" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"ctf consensus" has a "Input CTF" parameter that is explained as: Select the estimated CTF to evaluate
"ctf consensus" has a "Use Defocus for selection" parameter that is explained as: Use this button to decide if carry out the selection taking into account or not the defocus values.
"ctf consensus" has a "Min" parameter that is explained as: None
"ctf consensus" has a "Max" parameter that is explained as: None
"ctf consensus" has a "Use Astigmatism for selection" parameter that is explained as: Use this button to decide if carry out the selection taking into account or not the astigmatism value.
"ctf consensus" has a "Astigmatism (A)" parameter that is explained as: Maximum value allowed for astigmatism in Angstroms. If the evaluated CTF has a larger Astigmatism, it will be discarded.
"ctf consensus" has a "Use Astigmatism percentage for selection" parameter that is explained as: Use this button to decide if carry out the selection taking into account or not the astigmatism value.
"ctf consensus" has a "Astigmatism percentage" parameter that is explained as: Maximum value allowed for astigmatism percentage (|defocus_U-defocus_V|/mean_defocus). If the evaluated CTF has a larger Astigmatism Percentage, it will be discarded.
"ctf consensus" has a "Use Resolution for selection" parameter that is explained as: Use this button to decide if carry out the selection taking into account or not the resolution value.
"ctf consensus" has a "Resolution (A)" parameter that is explained as: Minimum value for resolution in Angstroms. If the evaluated CTF has not reached that minimum, it will be discarded.
"ctf consensus" has a "Use Xmipp criteria for selection" parameter that is explained as: Use this button to decide if carrying out the selection taking into account the Xmipp parameters.
Only available when Xmipp CTF estimation was used for the _Input CTF_ or for the _Secondary CTF_.
"ctf consensus" has a "Minimum 1st zero" parameter that is explained as: Minimun value of CritFirstZero
"ctf consensus" has a "Min" parameter that is explained as: None
"ctf consensus" has a "Max" parameter that is explained as: None
"ctf consensus" has a "Correlation 1st-3rd zero" parameter that is explained as: Minimum value of correlation between 1st and 3rd zeros
"ctf consensus" has a "CTF Margin" parameter that is explained as: Minimum value of CritCtfMargin
"ctf consensus" has a "CritIceness" parameter that is explained as: Minimum value of the iceness.
"ctf consensus" has a "Min" parameter that is explained as: None
"ctf consensus" has a "Max" parameter that is explained as: None
"ctf consensus" has a "Calculate Consensus Resolution" parameter that is explained as: Option for calculating consensus resolution. The algorithm assumes that two CTF are consistent if the phase (wave aberration function) of the two CTFs are closer than 90 degrees.
The reported consensusResolution is the resolution at which the two CTF phases differ in 90 degrees.
"ctf consensus" has a "Secondary CTF" parameter that is explained as: CTF to be compared with reference CTF
"ctf consensus" has a "Minimum consensus resolution (A)." parameter that is explained as: Minimum value for the consensus resolution in Angstroms.
If there are noticeable discrepancies between the two estimations below this resolution, it will be discarded.
"ctf consensus" has a "Average equivalent metadata?" parameter that is explained as: If *Yes*, making an average of those metadata present in both CTF estimations (defocus, astigmatism angle...)
 If *No*, the primary estimation metadata will persist.
"ctf consensus" has a "Include all secondary metadata?" parameter that is explained as: If *Yes*, all metadata in the *Secondary CTF* will be included in the resulting CTF.
 If *No*, only the primary metadata (plus consensus scores) will be in the resulting CTF.
"ctf consensus" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"ctf consensus" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"ctf consensus" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "ctf_correct_wiener2d" can be found in the xmipp3 plugin.
"ctf_correct_wiener2d" protocol help is as follows:
     
    Perform CTF correction by Wiener filtering.
    .
"ctf_correct_wiener2d" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"ctf_correct_wiener2d" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"ctf_correct_wiener2d" has a "Input particles" parameter that is explained as: Select the input projection images .
"ctf_correct_wiener2d" has a "Isotropic Correction" parameter that is explained as: If true, Consider that there is not astigmatism and then it is performed an isotropic correction.
"ctf_correct_wiener2d" has a "Padding factor" parameter that is explained as: Padding factor for Wiener correction 
"ctf_correct_wiener2d" has a "Wiener constant" parameter that is explained as:  Wiener-filter constant (if < 0: use FREALIGN default)
"ctf_correct_wiener2d" has a "Correct for CTF envelope" parameter that is explained as:  Only in cases where the envelope is well estimated correct for it
"ctf_correct_wiener2d" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"ctf_correct_wiener2d" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"ctf_correct_wiener2d" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "defocus group" can be found in the xmipp3 plugin.
"defocus group" protocol help is as follows:
 
    Given a set of CTFs group them by defocus value.
    The output is a metadata file containing 
     a list of defocus values that delimite 
    each defocus group.
    .
"defocus group" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"defocus group" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"defocus group" has a "Input particles with CTF" parameter that is explained as: Select the input particles. 
 they should have information about the CTF (hasCTF=True)
"defocus group" has a "Error for grouping" parameter that is explained as: Maximum error when grouping, the higher the more groupsThis is a 1D program, only defocus U is used
 The frequency at which the phase difference between the CTFs
belonging to 2 particles is equal to Pi/2 is computed 
 If this difference is less than 1/(2*factor*sampling_rate)
then images are placed in different groups

The protocol named "ctf estimation" can be found in the xmipp3 plugin.
"ctf estimation" protocol help is as follows:
  Protocol to estimate CTF on a set of micrographs using Xmipp. .
"ctf estimation" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"ctf estimation" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"ctf estimation" has a "Do recalculate ctf?" parameter that is explained as: None
"ctf estimation" has a "Input previous run" parameter that is explained as: None
"ctf estimation" has a "" parameter that is explained as: None
"ctf estimation" has a "Input Micrographs" parameter that is explained as: None
"ctf estimation" has a "Automatic Downsampling Factor" parameter that is explained as: Recommended value to downsample
"ctf estimation" has a "Manual CTF Downsampling factor" parameter that is explained as: Set to 1 for no downsampling. Non-integer downsample factors are possible. This downsampling is only used for estimating the CTF and it does not affect any further calculation. Ideally the estimation of the CTF is optimal when the Thon rings are not too concentrated at the origin (too small to be seen) and not occupying the whole power spectrum (since this downsampling might entail aliasing).
"ctf estimation" has a "Use defoci from a previous CTF estimation" parameter that is explained as: None
"ctf estimation" has a "Previous CTF estimation" parameter that is explained as: Choose some CTF estimation related to input micrographs, in case you want to use the defocus values found previously
"ctf estimation" has a "Optimize defocus" parameter that is explained as: If set to False, then the previous defocus is taken
"ctf estimation" has a "Find additional phase shift?" parameter that is explained as: If the data was collected with phase plate, this will find additional phase shift due to phase plate
"ctf estimation" has a "Automatic CTF downsampling detection" parameter that is explained as: If this option is chosen, the algorithm automatically tries by default the suggested Downsample factor; and if it fails, +1; and if it fails, -1.
"ctf estimation" has a "Allow amplitude constrast refinement" parameter that is explained as: The amplitude contrast is normally kept fixed, but insome experiments it has been found that refining it might result in some improvement in the final FSC. This is not a standard practice, and should be used with caution
"ctf estimation" has a "Skip borders" parameter that is explained as: Remove the borders of the micrograph. If True, two times the window size will be cropped.
"ctf estimation" has a "Lowest" parameter that is explained as: None
"ctf estimation" has a "Highest" parameter that is explained as: None
"ctf estimation" has a "Min" parameter that is explained as: None
"ctf estimation" has a "Max" parameter that is explained as: None
"ctf estimation" has a "Window size" parameter that is explained as: The PSD is estimated from small patches of this size. Bigger patches allow identifying more details. However, since there are fewer windows, estimations are noisier.
"ctf estimation" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"ctf estimation" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"ctf estimation" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "center particles" can be found in the xmipp3 plugin.
"center particles" protocol help is as follows:
  Realignment of un-centered particles. .
"center particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"center particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"center particles" has a "Input Classes" parameter that is explained as: Set of classes to be read
"center particles" has a "Set of micrographs" parameter that is explained as: Set of micrographs related to the selected input classes
"center particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "compare angles" can be found in the xmipp3 plugin.
"compare angles" protocol help is as follows:
     
    Compare two sets of angles. The output is a list of all common particles with
    the angular difference between both assignments. The output is constructed by 
    keeping the information from the Set 1 and adding the shiftDiff and angularDiff.
    .
"compare angles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"compare angles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"compare angles" has a "Input particles 1" parameter that is explained as: Select the input experimental images with an angular assignment.
"compare angles" has a "Input particles 2" parameter that is explained as: Select the input experimental images with an angular assignment.
"compare angles" has a "Symmetry group" parameter that is explained as: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] page for a description of the symmetries accepted by Xmipp

The protocol named "compare reprojections" can be found in the xmipp3 plugin.
"compare reprojections" protocol help is as follows:
 Compares a set of classes or averages with the corresponding projections of a reference volume.
    The set of images must have a 3D angular assignment and the protocol computes the residues
    (the difference between the experimental images and the reprojections). The zscore of the mean
    and variance of the residues are computed. Large values of these scores may indicate outliers.
    The protocol also analyze the covariance matrix of the residual and computes the logarithm of
    its determinant [Cherian2013]. The extremes of this score (called zScoreResCov), that is
    values particularly low or high, may indicate outliers..
"compare reprojections" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"compare reprojections" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"compare reprojections" has a "Input images" parameter that is explained as: None
"compare reprojections" has a "Volume to compare images to" parameter that is explained as: Volume to be used for class comparison
"compare reprojections" has a "Use input angular assignment (if available)" parameter that is explained as: None
"compare reprojections" has a "Optimize gray scale" parameter that is explained as: None
"compare reprojections" has a "Ignore CTF" parameter that is explained as: By ignoring the CTF you will create projections more similar to what a person expects, while by using the CTF you will create projections more similar to what the microscope sees
"compare reprojections" has a "Evaluate residuals" parameter that is explained as: If this option is chosen, then the residual covariance matrix is calculated and characterized. But this option takes time and disk space
"compare reprojections" has a "Symmetry group" parameter that is explained as: See http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format. If no symmetry is present, give c1
"compare reprojections" has a "Angular sampling rate" parameter that is explained as: In degrees. This sampling defines how fine the projection gallery from the volume is explored.
"compare reprojections" has a "Filter at resolution: " parameter that is explained as: Resolution (A) at which subtraction will be performed, filtering the volume projections.Value 0 implies no filtering.
"compare reprojections" has a "Decay of the filter (sigma): " parameter that is explained as: Decay of the filter (sigma parameter) to smooth the mask transition
"compare reprojections" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"compare reprojections" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "consensus classes" can be found in the xmipp3 plugin.
"consensus classes" protocol help is as follows:
  Compare several SetOfClasses.
        Return the consensus clustering based on a objective function
        that uses the similarity between clusters intersections and
        the entropy of the clustering formed.
    .
"consensus classes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"consensus classes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"consensus classes" has a "Input classes" parameter that is explained as: Select several sets of classes where to evaluate the intersections.
"consensus classes" has a "Minimum class size" parameter that is explained as: Minimum output class size. If set to zero it will not have any effect
"consensus classes" has a "Metric" parameter that is explained as: Distance metric used when comparing clusters

The protocol named "consensus local defocus" can be found in the xmipp3 plugin.
"consensus local defocus" protocol help is as follows:
 This protocol compares the estimations of local defocus computed by different protocols for a set of particles.
"consensus local defocus" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"consensus local defocus" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"consensus local defocus" has a "Input particles to assign the consensus defocus" parameter that is explained as: Particle set of interest to estimate the defocus
"consensus local defocus" has a "Input defocus estimations" parameter that is explained as: Sets of particles with different local defocus estimations to compare

The protocol named "picking consensus" can be found in the xmipp3 plugin.
"picking consensus" protocol help is as follows:
 
    Protocol to estimate the agreement between different particle picking
    algorithms. The protocol takes several Sets of Coordinates calculated
    by different programs and/or different parameter settings. Let's say:
    we consider N independent pickings. Then, a coordinate is considered
    to be a correct particle if M pickers have selected the same particle
    (within a radius in pixels specified in the form).

    If you want to be very strict, then set M=N; that is, a coordinate
    represents a particle if it has been selected by all particles (this
    is the default behaviour). Then you may relax this condition by setting
    M=N-1, N-2, ...

    If you want to be very flexible, set M=1, in this way it suffices that
    1 picker has selected the coordinate to be considered as a particle. Note
    that in this way, the cleaning of the dataset has to be performed by other
    means (screen particles, 2D and 3D classification, ...).
    .
"picking consensus" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"picking consensus" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"picking consensus" has a "Input coordinates" parameter that is explained as: Select the set of coordinates to compare
"picking consensus" has a "Radius" parameter that is explained as: All coordinates within this radius (in pixels) are presumed to correspond to the same particle
"picking consensus" has a "Consensus" parameter that is explained as: How many times need a particle to be selected to be considered as a consensus particle.
*Set to -1* to indicate that it needs to be selected by all algorithms: *AND* operation.
*Set to 1* to indicate that it suffices that only 1 algorithm selects the particle: *OR* operation.
"picking consensus" has a "Consensus mode" parameter that is explained as: If the number of votes to progress to the output must be either (=) strictly speaking equals to the consensus number or (>=) at least equals.

The protocol named "convert pdbs to volumes" can be found in the xmipp3 plugin.
"convert pdbs to volumes" protocol help is as follows:
  Convert atomic structure(s) into volume(s) .
"convert pdbs to volumes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"convert pdbs to volumes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"convert pdbs to volumes" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"convert pdbs to volumes" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"convert pdbs to volumes" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"convert pdbs to volumes" has a "Input structure(s) " parameter that is explained as: Specify input atomic structure(s).
"convert pdbs to volumes" has a "Sampling rate (Å/px)" parameter that is explained as: Sampling rate (Angstroms/pixel)
"convert pdbs to volumes" has a "Use a volume as an empty template?" parameter that is explained as: Use an existing volume to define the size and origin for the output volume. If this optionis selected, make sure that "Center PDB" in advanced parameters is set to *No*.
"convert pdbs to volumes" has a "Input volume " parameter that is explained as: The origin and the final size of the output volume will be taken from this volume.
"convert pdbs to volumes" has a "Set final size?" parameter that is explained as: None
"convert pdbs to volumes" has a "Box side size (px)" parameter that is explained as: This size should apply to all volumes
"convert pdbs to volumes" has a "Final size (px) Z" parameter that is explained as: Final size in Z in pixels. If no value is provided, protocol will estimate it.
"convert pdbs to volumes" has a "Final size (px) Y" parameter that is explained as: Final size in Y in pixels. If no value is provided, protocol will estimate it.
"convert pdbs to volumes" has a "Final size (px) X" parameter that is explained as: Final size in X in pixels. If desired output size is x = y = z you can only fill this field. If no value is provided, protocol will estimate it.
"convert pdbs to volumes" has a "Center PDB" parameter that is explained as: Center PDB with the center of mass.
"convert pdbs to volumes" has a "Store centered PDB" parameter that is explained as: Set to 'Yes' if you want to save centered PDB. It will be stored in the output directory of this protocol.
"convert pdbs to volumes" has a "Convert CIF to PDB" parameter that is explained as: If set to true and input atom struct file is a CIF, it will get converted to PDB.
"convert pdbs to volumes" has a "Clean tmp files" parameter that is explained as: Delete all non-output files once the protocol has finished producing them.

The protocol named "core analysis" can be found in the xmipp3 plugin.
"core analysis" protocol help is as follows:
  Analyzes the core of a 2D classification. The core is calculated through
    the Mahalanobis distance from each image to the center of the class. .
"core analysis" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"core analysis" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"core analysis" has a "Input classes" parameter that is explained as: Set of input classes to be analyzed
"core analysis" has a "Junk Zscore" parameter that is explained as: Which is the average Z-score to be considered as junk. Typical values go from 1.5 to 3. For the Gaussian distribution 99.5% of the data is within a Z-score of 3. Lower Z-scores reject more images. Higher Z-scores accept more images.
"core analysis" has a "PCA Zscore" parameter that is explained as: Which is the PCA Z-score to be considered as junk. Typical values go from 1.5 to 3. For the Gaussian distribution 99.5% of the data is within a Z-score of 3. Lower Z-scores reject more images. Higher Z-scores accept more images.
"core analysis" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"core analysis" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "create gallery" can be found in the xmipp3 plugin.
"create gallery" protocol help is as follows:
 
    Create a gallery of projections from a volume.
    This gallery of projections may help to understand the images
    observed in the microscope.
    .
"create gallery" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"create gallery" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"create gallery" has a "Input volume" parameter that is explained as: None
"create gallery" has a "Symmetry group" parameter that is explained as: Seehttps://github.com/I2PC/xmipp-portal/wiki/Symmetry for a description of the symmetry groups format. If no symmetry is present, give c1
"create gallery" has a "Min" parameter that is explained as: None
"create gallery" has a "Max" parameter that is explained as: None
"create gallery" has a "Step" parameter that is explained as: None
"create gallery" has a "Min" parameter that is explained as: None
"create gallery" has a "Max" parameter that is explained as: None
"create gallery" has a "Step" parameter that is explained as: None
"create gallery" has a "Maximum frequency" parameter that is explained as: Normalized to 0.5
"create gallery" has a "Shift sigma" parameter that is explained as: In pixels

The protocol named "create 2d mask" can be found in the xmipp3 plugin.
"create 2d mask" protocol help is as follows:
  Create a 2D mask.
    The mask can be created with a given geometrical shape (Circle, Rectangle,
    Crown...) or it can be obtained from operating on a 2d image or a previuous
    mask. .
"create 2d mask" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"create 2d mask" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"create 2d mask" has a "Sampling Rate (Å/px)" parameter that is explained as: None
"create 2d mask" has a "Mask size (px)" parameter that is explained as: Select the mask dimensions in pixels. The mask will be size x size pixels
"create 2d mask" has a "Mask type" parameter that is explained as: None
"create 2d mask" has a "Radius (px)" parameter that is explained as: Mask radius, if -1, the radius will be MaskSize/2
"create 2d mask" has a "Box size" parameter that is explained as: Mask box size, if -1, the box size will be MaskSize/2
"create 2d mask" has a "Inner radius (px)" parameter that is explained as: Inner radius in pixels
"create 2d mask" has a "Outer radius (px)" parameter that is explained as: Outer radius in pixels, if -1, the outer radius will be MaskSize/2
"create 2d mask" has a "Sigma (px)" parameter that is explained as: Gaussian sigma in pixels. If -1, sigma will be MaskSize/6
"create 2d mask" has a "Border decay (px)" parameter that is explained as: This is the fall-off of the two borders of the crown
"create 2d mask" has a "Shift Center" parameter that is explained as: Shift Mask Center to a new origin.
"create 2d mask" has a "X center offset" parameter that is explained as: New x center coordinate
"create 2d mask" has a "Y center offset" parameter that is explained as: New y center coordinate

The protocol named "create 3d mask" can be found in the xmipp3 plugin.
"create 3d mask" protocol help is as follows:
  Create a 3D mask.
    The mask can be created with a given geometrical shape (Sphere, Box,
    Cylinder...) or it can be obtained from operating on a 3d volume or a
    previous mask.
    .
"create 3d mask" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"create 3d mask" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"create 3d mask" has a "Mask source" parameter that is explained as: None
"create 3d mask" has a "Input volume" parameter that is explained as: Select the volume that will be used to create the mask
"create 3d mask" has a "Operation" parameter that is explained as: None
"create 3d mask" has a "Threshold" parameter that is explained as: Select the threshold. Gray values lesser than the thresholdwill be set to zero, otherwise will be one (mask area).
"create 3d mask" has a "Segmentation type" parameter that is explained as: None
"create 3d mask" has a "Number of voxels" parameter that is explained as: None
"create 3d mask" has a "Number of aminoacids" parameter that is explained as: None
"create 3d mask" has a "Mass (Da)" parameter that is explained as: None
"create 3d mask" has a "Sampling Rate (Å/px)" parameter that is explained as: None
"create 3d mask" has a "Mask size (px)" parameter that is explained as: Select the mask dimensions in voxels. The mask will be size x size x size voxels
"create 3d mask" has a "Mask type" parameter that is explained as: None
"create 3d mask" has a "Radius (px)" parameter that is explained as: Mask radius, if -1, the radius will be MaskSize/2
"create 3d mask" has a "Shift center of the mask?" parameter that is explained as: None
"create 3d mask" has a "X" parameter that is explained as: None
"create 3d mask" has a "Y" parameter that is explained as: None
"create 3d mask" has a "Z" parameter that is explained as: None
"create 3d mask" has a "Box size" parameter that is explained as: Mask box size, if -1, the box size will be MaskSize/2
"create 3d mask" has a "Inner radius (px)" parameter that is explained as: Inner radius in pixels
"create 3d mask" has a "Outer radius (px)" parameter that is explained as: Outer radius in pixels, if -1, the outer radius will be MaskSize/2
"create 3d mask" has a "Height (px)" parameter that is explained as: Cylinder height in pixels. If -1, height will be MaskSize
"create 3d mask" has a "Sigma (px)" parameter that is explained as: Gaussian sigma in pixels. If -1, sigma will be MaskSize/6
"create 3d mask" has a "Border decay (px)" parameter that is explained as: This is the fall-off of the two borders of the crown
"create 3d mask" has a "Feature File" parameter that is explained as: Create a mask using a feature file. Follows an example of feature file 
# XMIPP_STAR_1 *
# Type of feature (sph, blo, gau, Cyl, dcy, cub, ell, con)(Required)
# The operation after adding the feature to the phantom (+/=) (Required)
# The feature density (Required)
# The feature center (Required)
# The vector for special parameters of each vector (Required)
# Sphere: [radius] 
# Blob : [radius alpha m] Gaussian : [sigma]
# Cylinder : [xradius yradius height rot tilt psi]
# DCylinder : [radius height separation rot tilt psi]
# Cube : [xdim ydim zdim rot tilt psi]
# Ellipsoid : [xradius yradius zradius rot tilt psi]
# Cone : [radius height rot tilt psi]
data_block1
 _dimensions3D  '34 34 34' 
 _phantomBGDensity  0.
 _scale  1.
data_block2
loop_
 _featureType
 _featureOperation
 _featureDensity
 _featureCenter
 _featureSpecificVector
sph + 1 '3.03623188  0.02318841 -5.04130435' '7'

"create 3d mask" has a "Remove small objects" parameter that is explained as: To remove small clusters of points. The input mask has to be binary.
"create 3d mask" has a "Minimum size" parameter that is explained as: Connected components whose size is smaller than this number in voxels will be removed
"create 3d mask" has a "Keep largest component" parameter that is explained as: To keep cluster greater than a given size. The input mask has to be binary
"create 3d mask" has a "Symmetrize mask" parameter that is explained as: None
"create 3d mask" has a "Symmetry group" parameter that is explained as: To obtain a symmetric mask. See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry 
for a description of the symmetry groups format. 
If no symmetry is present, give c1
"create 3d mask" has a "Apply morphological operation" parameter that is explained as: Dilation (dilate white region). 
Erosion (erode white region). 
Closing (Dilation+Erosion, removes black spots). 
Opening (Erosion+Dilation, removes white spots). 

"create 3d mask" has a "Operation" parameter that is explained as: None
"create 3d mask" has a "Structural element size" parameter that is explained as: The larger this value, the more the effect will be noticed
"create 3d mask" has a "Invert the mask" parameter that is explained as: None
"create 3d mask" has a "Smooth borders" parameter that is explained as: Smoothing is performed by convolving the mask with a Gaussian.
"create 3d mask" has a "Gaussian sigma (px)" parameter that is explained as: The larger this value, the more the effect will be noticed

The protocol named "crop/resize particles" can be found in the xmipp3 plugin.
"crop/resize particles" protocol help is as follows:
  Crop or resize a set of particles .
"crop/resize particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"crop/resize particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"crop/resize particles" has a "Input Particles/Mask" parameter that is explained as: Input particles or 2D Mask to be cropped/resized.
"crop/resize particles" has a "Resize particles?" parameter that is explained as: If you set to *Yes*, you should provide a resize option.
"crop/resize particles" has a "Resize option" parameter that is explained as: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Dimensions_: Set the output dimensions. Resize operation can be done in Fourier space.
_Factor_: Set a resize factor to resize. 
 _Pyramid_: Use positive level value to expand and negative to reduce. 
Pyramid uses spline pyramids for the interpolation. All the rest uses normally interpolation
(cubic B-spline or bilinear interpolation). If you set the method to dimensions, you may choose
between interpolation and Fourier cropping.
"crop/resize particles" has a "Resize sampling rate (Å/px)" parameter that is explained as: Set the new output sampling rate.
"crop/resize particles" has a "Use fourier method to resize?" parameter that is explained as: If you set to *True*, the final dimensions must be lower than the original ones.
"crop/resize particles" has a "New image size (px)" parameter that is explained as: Size in pixels of the particle images <x> <y=x> <z=x>.
"crop/resize particles" has a "Resize factor" parameter that is explained as: New size is the old one x resize factor.
"crop/resize particles" has a "Pyramid level" parameter that is explained as: Use positive value to expand and negative to reduce.
"crop/resize particles" has a "Huge file" parameter that is explained as: If the file is huge, very likely you may have problems doing the antialiasing filter (because there is no memory for the input and its Fourier tranform). This option removes the antialiasing filter (meaning you will get aliased results), and performs a bilinear interpolation (to avoid having to produce the B-spline coefficients).
"crop/resize particles" has a "Apply a window operation?" parameter that is explained as: If you set to *Yes*, you should provide a window option.
"crop/resize particles" has a "Window operation" parameter that is explained as: Select how to change the size of the particles.
_cls.RESIZE_: provide the new size (in pixels) for your particles.
_crop_: choose how many pixels to crop from each border.

"crop/resize particles" has a "Crop size (px)" parameter that is explained as: Amount of pixels cropped from each border.
e.g: if you set 10 pixels, the dimensions of the
object (SetOfParticles, Volume or SetOfVolumes) will be
reduced in 20 pixels (2 borders * 10 pixels)
"crop/resize particles" has a "Window size (px)" parameter that is explained as: Size in pixels of the output object. It will be expanded or cutted in all directions such that the origin remains the same.
"crop/resize particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"crop/resize particles" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "crop/resize volumes" can be found in the xmipp3 plugin.
"crop/resize volumes" protocol help is as follows:
  Crop or resize a set of volumes .
"crop/resize volumes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"crop/resize volumes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"crop/resize volumes" has a "Input Volumes" parameter that is explained as: Can be a density volume or a SetOfVolumes.
"crop/resize volumes" has a "Resize volumes?" parameter that is explained as: If you set to *Yes*, you should provide a resize option.
"crop/resize volumes" has a "Resize option" parameter that is explained as: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Dimensions_: Set the output dimensions. Resize operation can be done in Fourier space.
_Factor_: Set a resize factor to resize. 
 _Pyramid_: Use positive level value to expand and negative to reduce. 
Pyramid uses spline pyramids for the interpolation. All the rest uses normally interpolation
(cubic B-spline or bilinear interpolation). If you set the method to dimensions, you may choose
between interpolation and Fourier cropping.
"crop/resize volumes" has a "Resize sampling rate (Å/px)" parameter that is explained as: Set the new output sampling rate.
"crop/resize volumes" has a "Use fourier method to resize?" parameter that is explained as: If you set to *True*, the final dimensions must be lower than the original ones.
"crop/resize volumes" has a "New image size (px)" parameter that is explained as: Size in pixels of the particle images <x> <y=x> <z=x>.
"crop/resize volumes" has a "Resize factor" parameter that is explained as: New size is the old one x resize factor.
"crop/resize volumes" has a "Pyramid level" parameter that is explained as: Use positive value to expand and negative to reduce.
"crop/resize volumes" has a "Huge file" parameter that is explained as: If the file is huge, very likely you may have problems doing the antialiasing filter (because there is no memory for the input and its Fourier tranform). This option removes the antialiasing filter (meaning you will get aliased results), and performs a bilinear interpolation (to avoid having to produce the B-spline coefficients).
"crop/resize volumes" has a "Apply a window operation?" parameter that is explained as: If you set to *Yes*, you should provide a window option.
"crop/resize volumes" has a "Window operation" parameter that is explained as: Select how to change the size of the particles.
_cls.RESIZE_: provide the new size (in pixels) for your particles.
_crop_: choose how many pixels to crop from each border.

"crop/resize volumes" has a "Crop size (px)" parameter that is explained as: Amount of pixels cropped from each border.
e.g: if you set 10 pixels, the dimensions of the
object (SetOfParticles, Volume or SetOfVolumes) will be
reduced in 20 pixels (2 borders * 10 pixels)
"crop/resize volumes" has a "Window size (px)" parameter that is explained as: Size in pixels of the output object. It will be expanded or cutted in all directions such that the origin remains the same.
"crop/resize volumes" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"crop/resize volumes" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"crop/resize volumes" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "deep center" can be found in the xmipp3 plugin.
"deep center" protocol help is as follows:
 Predict the center particles using deep learning..
"deep center" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"deep center" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"deep center" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"deep center" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"deep center" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"deep center" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
"deep center" has a "Input Image set" parameter that is explained as: The set of particles to predict
"deep center" has a "Train models" parameter that is explained as: Choose if you want to train a model using a centered set of particles
"deep center" has a "Number of models" parameter that is explained as: The maximum number of model available in xmipp is 5.
"deep center" has a "Input train set" parameter that is explained as: The set of particles to train the models
"deep center" has a "Number of epochs" parameter that is explained as: Number of epochs for training.
"deep center" has a "Batch size for training" parameter that is explained as: Batch size for training.
"deep center" has a "Learning rate" parameter that is explained as: Learning rate for training.
"deep center" has a "Image shifting" parameter that is explained as: A measure of the number of pixels that particles can be shifted in each direction from the center.
"deep center" has a "Patience" parameter that is explained as: Training will be stopped if the number of epochs without improvement is greater than patience.
"deep center" has a "Tolerance in pixels" parameter that is explained as: Max difference between predictions and their mean value.
"deep center" has a "Maximum number of models dropped per particle" parameter that is explained as: If more models are dropped, the particle is discarded.

The protocol named "deep denoising" can be found in the xmipp3 plugin.
"deep denoising" protocol help is as follows:
 None.
"deep denoising" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"deep denoising" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"deep denoising" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. In case to use several GPUs separate with comas:0,1,2
"deep denoising" has a "Train or predict model" parameter that is explained as: *Train*: Train the model using noisy particles or their projections in an initial volume*Predict*: The particles are denoised with a pretrained model
"deep denoising" has a "Continue training? (or train from scratch)" parameter that is explained as: Setting "yes" you can continue training from pretrained model  or your previous executions. If you choose"no" the model will be trained from scratch. yes option is experimental
"deep denoising" has a "Use your own model (or use pretrained)" parameter that is explained as: Setting "yes" you can choose your own model trained. If you choose"no" a general model pretrained will be assign
"deep denoising" has a "Set your model" parameter that is explained as: Choose the protocol where your model is trained
"deep denoising" has a "Select model type" parameter that is explained as: If you set to *GAN*, GAN will be employed employed. If you set to *U-Net* U-Net will be used instead
"deep denoising" has a "Input projections to train (mandatory)/compare (optional)" parameter that is explained as: use the protocol generate reprojections to generate the projections. If compare reprojections protocol output is used as "Input noisy particles", this field is ignored
"deep denoising" has a "Input noisy particles to denoise" parameter that is explained as: Input noisy particles from the protocol generate reprojections if you are training or from any other protocol if you are predicting. If compare reprojections protocol output is used as "Input noisy particles", "Input projections to train" is ignored
"deep denoising" has a "Input "empty" particles (optional)" parameter that is explained as: Input "empty" particles to learn how to deal with pure noise
"deep denoising" has a "Scale images to (px)" parameter that is explained as: Scale particles to desired size to improve trainingThe recommended particle size is 128 px. The size must be even.Do not use loss=perceptualLoss or loss=Both if  96< size <150.
"deep denoising" has a "Number of epochs" parameter that is explained as: Number of epochs for neural network training. GAN requires much more epochs (>100) to obtain succesfull results
"deep denoising" has a "Learning rate" parameter that is explained as: Learning rate for neural network training
"deep denoising" has a "Model depth" parameter that is explained as: Indicate the model depth. For 128-64 px images, 4 is the recommend value.  larger images may require bigger models
"deep denoising" has a "Regularization strength" parameter that is explained as: Indicate the regularization strength. Make it bigger if sufferening overfitting and smaller if suffering underfitting
"deep denoising" has a "Select how to generate training set" parameter that is explained as: *ParticlesAndSyntheticNoise*: Train using particles and synthetic noise
or
*OnlyParticles*: using only particles
or
*Both*: Train using both strategies
"deep denoising" has a "Select loss for training" parameter that is explained as: *MSE*: Train using mean squered error or
*PerceptualLoss*: Train using DeepConsensus perceptual loss
 or
*Both*: Train using both DeepConsensus perceptual loss and mean squered error

"deep denoising" has a "D/G trainig ratio" parameter that is explained as: Indicate the number of times the discriminator is trained for each generator training step. If discriminator loss is going to 0, make it smaller, whereas if the discriminator is not training, make it bigger
"deep denoising" has a "D/G loss ratio" parameter that is explained as: Indicate the 10^lossRatio times that the generator loss is stronger than  the discriminator loss. If discriminator loss is going to 0, make it smaller, whereas if the generator is not training, make it bigger
"deep denoising" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"deep denoising" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "deep global assignment" can be found in the xmipp3 plugin.
"deep global assignment" protocol help is as follows:
 Predict Euler Angles using deep learning..
"deep global assignment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"deep global assignment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"deep global assignment" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"deep global assignment" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"deep global assignment" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"deep global assignment" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
"deep global assignment" has a "Input Image set" parameter that is explained as: The set of particles to predict
"deep global assignment" has a "Train models" parameter that is explained as: Choose if you want to train a model using a centered set of particles
"deep global assignment" has a "Number of models" parameter that is explained as: The maximum number of model available in xmipp is 5.
"deep global assignment" has a "Input train set" parameter that is explained as: The set of particles to train the models
"deep global assignment" has a "Number of epochs" parameter that is explained as: Number of epochs for training.
"deep global assignment" has a "Batch size for training" parameter that is explained as: Batch size for training.
"deep global assignment" has a "Learning rate" parameter that is explained as: Learning rate for training.
"deep global assignment" has a "Image shifting" parameter that is explained as: A measure of the number of pixels that particles can be shifted in each direction from the center.
"deep global assignment" has a "Patience" parameter that is explained as: Training will be stopped if the number of epochs without improvement is greater than patience.
"deep global assignment" has a "Tolerance in pixels" parameter that is explained as: Max difference between predictions and their mean value.
"deep global assignment" has a "Maximum number of models dropped per particle" parameter that is explained as: If more models are dropped, the particle is discarded.
"deep global assignment" has a "Order of symmetry" parameter that is explained as: Order of the group of the molecule.

The protocol named "deep hand" can be found in the xmipp3 plugin.
"deep hand" protocol help is as follows:
 Protocol to returns handedness of structure from trained deep learning model
    .
"deep hand" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"deep hand" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"deep hand" has a "Input Volume" parameter that is explained as: Volume to process
"deep hand" has a "Mask Threshold" parameter that is explained as: Threshold for mask creation
"deep hand" has a "Alpha Threshold" parameter that is explained as: Threshold for alpha helix determination
"deep hand" has a "Hand Threshold" parameter that is explained as: Hand threshold to flip volume

The protocol named "deep micrograph cleaner" can be found in the xmipp3 plugin.
"deep micrograph cleaner" protocol help is as follows:
 Protocol to remove coordinates in carbon zones or large impurities.
"deep micrograph cleaner" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"deep micrograph cleaner" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"deep micrograph cleaner" has a "Input coordinates" parameter that is explained as: Select the SetOfCoordinates 
"deep micrograph cleaner" has a "Micrographs source" parameter that is explained as: By default, the micrographs from which the computation will be performed will be the ones used in the picking step ( _same as coordinates_ option ). 
If you select other option, you must provide a different set of micrographs to evaluate its regions. 
*Note*: In the _other_ case, ensure that provided micrographs and coordinates are related by micName or by micId. Difference in pixel size will be handled automatically.
*Note2*: *Particles must be dark* over a bright background. If not, use the _other_ option to provide an inverted setOfMicrograph.
"deep micrograph cleaner" has a "Input micrographs" parameter that is explained as: Select the SetOfMicrographs from which to extract.
"deep micrograph cleaner" has a "Coordinates scale" parameter that is explained as: If you select _same as coordinates_ option output coordinates will be mapped to the original micrographs and thus, they will preserve the scale.
If you select _scale to micrographs_ option, output coordinates will be mapped to the new micrographs and rescaled accordingly.
"deep micrograph cleaner" has a "Threshold" parameter that is explained as: Deep learning goodness score to select/discard coordinates. The bigger the threshold the more coordiantes will be ruled out. Ranges from 0 to 1. Use -1 to skip thresholding. Manual thresholding can be performed after execution through analyze results button. 
0.75 <= Recommended threshold <= 0.9
"deep micrograph cleaner" has a "Batch size" parameter that is explained as: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*0*    Put in the same step all the items  available.
 *>1*   The number of items that will be grouped into a step. -1, automatic decission
"deep micrograph cleaner" has a "saveMasks" parameter that is explained as: Save predicted masks?
"deep micrograph cleaner" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation. Select the one you want to use. CPU may become quite slow.
"deep micrograph cleaner" has a "" parameter that is explained as: Add a list of GPU devices that can be used.

The protocol named "local deepRes" can be found in the xmipp3 plugin.
"local deepRes" protocol help is as follows:
     
    Given a map the protocol assigns local resolutions to each voxel of the map.
    .
"local deepRes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"local deepRes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"local deepRes" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
"local deepRes" has a "Input Volume" parameter that is explained as: Select a volume for determining its local resolution.
"local deepRes" has a "Mask" parameter that is explained as: Binary mask. The mask determines which points are specimen and which are not
"local deepRes" has a "Expected resolutions range" parameter that is explained as: The program uses a trained network to determine resolutions between 2.5Å-13.0Å  or resolutions between 1.5Å-6.0Å

The protocol named "deepEMhancer" can be found in the xmipp3 plugin.
"deepEMhancer" protocol help is as follows:
     
    Given a map the protocol performs automatic deep post-processing to enhance visualization. Usage guide at
    https://github.com/rsanchezgarc/deepEMhancer
    .
"deepEMhancer" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"deepEMhancer" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"deepEMhancer" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. Select the GPU ID in which the protocol will run (select only 1 GPU)
"deepEMhancer" has a "Would you like to use half maps?" parameter that is explained as: DeepEMhancer uses either half maps or non-sharpened non-masked input volumes. Please, select the type of input map(s) you will provide
"deepEMhancer" has a "Are the half maps included in the volume?" parameter that is explained as: When you import a map, you can associate half maps to it. Select *yes* if the half maps are associatedto the input volume. If half maps are not associated, select *No* andyou will be able to provide then as regular maps
"deepEMhancer" has a "Volume Half 1" parameter that is explained as: Select half map 1 to apply deep postprocessing. 
"deepEMhancer" has a "Volume Half 2" parameter that is explained as: Select half map 2 to apply deep postprocessing. 
"deepEMhancer" has a "Input Volume" parameter that is explained as: Select a volume to apply deep postprocessing. Unmasked, non-sharpened input required
"deepEMhancer" has a "Input normalization" parameter that is explained as: Input normalization is critical for the algorithm to work.
If you select *Automatic normalization* input will beautomatically normalized (generally works but may fail).
If you select *Normalization from statistics* input will benormalized according the statistics of the noise of the volume and thus, you will need to providethe mean and standard deviation of the noise. Additionally, a binary mask (1 protein, 0 not protein) for the protein can be used for normalization if you select *Normalization from binary mask* . The mask should be as tight as possible.
nBad results may be obtained if normalization does not work, so you may want to try different options if not good enough results are observerd
"deepEMhancer" has a "binary mask" parameter that is explained as: The mask determines which voxels are protein (1) and which are not (0)
"deepEMhancer" has a "noise mean" parameter that is explained as: The mean of the noise used to normalize the input
"deepEMhancer" has a "noise standard deviation" parameter that is explained as: The standard deviation of the noise used to normalize the input
"deepEMhancer" has a "Model power" parameter that is explained as: Select the deep learning model to use.
If you select *tight target* the postprocessing will be more sharpen, but some regions of the protein could be masked out.
If you select *wide target* input will be less sharpen but most of the regions of the protein will be preserved
Option *highRes*,  is recommended for high resolution volumes
"deepEMhancer" has a "Remove small CC after processing" parameter that is explained as: If you set to *Yes*, a post-processing step will be launched to remove small connected componentsthat are likely noise. This step may remove protein in some unlikely situations, but generally, itslighly improves results
"deepEMhancer" has a "Relative size (0. to 1.) CC to remove" parameter that is explained as: The relative size of a small connected component to be removed, as the fraction of total voxels>0 
"deepEMhancer" has a "Batch size" parameter that is explained as: Number of cubes to process simultaneously. Make it lower if CUDA Out Of Memory error happens and increase it if low GPU performance observed

The protocol named "denoise particles" can be found in the xmipp3 plugin.
"denoise particles" protocol help is as follows:
  Remove particles noise by filtering them. 
    This filtering process is based on a projection over a basis created
    from some averages (extracted from classes). This filtering is not 
    intended for processing particles. The huge filtering they will be 
    passed through is known to remove part of the signal with the noise. 
    However this is a good method for clearly see which particle are we 
    going to process before it's done.
    .
"denoise particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"denoise particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"denoise particles" has a "Input Particles" parameter that is explained as: Input images you want to filter. It is important that the images have alignment information with respect to the chosen set of classes. This is the standard situation after CL2D or ML2D.
"denoise particles" has a "Input Classes" parameter that is explained as: Select the input classes for the basis construction against images will be projected to.
"denoise particles" has a "Max. number of classes" parameter that is explained as: Maximum number of classes.
"denoise particles" has a "Number of PCA bases" parameter that is explained as: Number of PCA bases.
"denoise particles" has a "Number of PCA bases on which to project" parameter that is explained as: Number of PCA bases on which to project.
"denoise particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"denoise particles" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"denoise particles" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "eliminate empty classes" can be found in the xmipp3 plugin.
"eliminate empty classes" protocol help is as follows:
  Takes a set of classes (or averages) and using statistical methods
    (variances of sub-parts of input image) eliminates those samples,
    where there is no object/particle (only noise is presented there).
    Threshold parameter can be used for fine-tuning the algorithm for
    type of data. Also discards classes with less population than a given
    percentage.
    .
"eliminate empty classes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"eliminate empty classes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"eliminate empty classes" has a "Input classes" parameter that is explained as: Select the input averages to be classified.
"eliminate empty classes" has a "Threshold used in elimination" parameter that is explained as: Higher threshold => more particles will be eliminated. Set to -1 for no elimination, even so the "xmipp_scoreEmptiness" value will be attached to every paricle for a posterior inspection.
"eliminate empty classes" has a "Use class population" parameter that is explained as: Consider class population to reject a class.
"eliminate empty classes" has a "Min. population (%)" parameter that is explained as: Minimum population to accept a class.
Classes with less population than the mean population times this value will be rejected.
"eliminate empty classes" has a "Add features" parameter that is explained as: Add features used for the ranking to each one of the input particles.
"eliminate empty classes" has a "Turning on denoising" parameter that is explained as: Option for turning on denoising method while computing emptiness feature.
"eliminate empty classes" has a "Denoising factor:" parameter that is explained as: Factor to be used during Gaussian blurring. Higher value applies stronger denoising, could be more precise but also slower.

The protocol named "eliminate empty particles" can be found in the xmipp3 plugin.
"eliminate empty particles" protocol help is as follows:
  Takes a set of particles and using statistical methods
    (variance of variances of sub-parts of input image) eliminates those samples,
    where there is no object/particle (only noise is presented there).
    Threshold parameter can be used for fine-tuning the algorithm for type of data.
    .
"eliminate empty particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"eliminate empty particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"eliminate empty particles" has a "Input particles" parameter that is explained as: Select the input particles to be classified.
"eliminate empty particles" has a "Threshold used in elimination:" parameter that is explained as: Higher threshold => more particles will be eliminated. Set to -1 for no elimination, even so the "xmipp_scoreEmptiness" value will be attached to every paricle for a posterior inspection.
"eliminate empty particles" has a "Add features" parameter that is explained as: Add features used for the ranking to each one of the input particles.
"eliminate empty particles" has a "Turning on denoising" parameter that is explained as: Option for turning on denoising method while computing emptiness feature.
"eliminate empty particles" has a "Denoising factor:" parameter that is explained as: Factor to be used during Gaussian blurring. Higher value applies stronger denoising, could be more precise but also slower.

The protocol named "enrich" can be found in the xmipp3 plugin.
"enrich" protocol help is as follows:
     
    Method to get two volume from different classes (with different conformation)
    and correcting (deforming) all images of one of the volumes (input volume) 
    with respect to the another one as a reference, using optical flow algorithm.
    The output is a setOfParticles contaied deformed reference particles.
    .
"enrich" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"enrich" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"enrich" has a "do Gold Standard?" parameter that is explained as: If YES provide half1 and half2 maps for referenceand for input volumes.
"enrich" has a "Reference volume" parameter that is explained as: This is the volume that will be used as the reference in OF algorithm. If you want to use Gold-Standard provide here half1 map
"enrich" has a "Reference volume half1" parameter that is explained as: This is the half1 volume that will be used as the reference for half1 in OF algorithm.
"enrich" has a "Reference volume half2" parameter that is explained as: This is half2 volume that will be used as the reference for half2 in OF algorithm.
"enrich" has a "Input volume" parameter that is explained as: Volume that we want to process its related particles.
"enrich" has a "Input volume half1" parameter that is explained as: Volume that we want to process its related particles. It should represent half1 map.
"enrich" has a "Input volume half2" parameter that is explained as: Volume that we want to process its related particles. It should represent half2 map.
"enrich" has a "Input particles" parameter that is explained as: Aligned particles related to the input volume. These particles will be processed (deformed) based on the reference volume using OF algorithm.If selected doGoldStandard True the particles have to have  information about the halfId they belong.
"enrich" has a "Reference and input volumes need to be aligned?" parameter that is explained as: Input and reference volumes must be aligned. If you have not aligned them before choose this option, so protocol will handle it internally.
"enrich" has a "Use Fast Rotational Matching." parameter that is explained as: Use Fast Rotational Matching. Before use it you have to install it by scipion install frmThis method for volume alignment is much more fast than exhaustive search
"enrich" has a "Resolution Limit (A)" parameter that is explained as: Resolution limit used to low pass filter both input and reference map(s).Based on previous experimental results, a good value for  seems to be 20A 
"enrich" has a "Window size" parameter that is explained as: Size of the search window at each pyramid level (shifts are assumed to be constant within this window).
"enrich" has a "pyramid Scale" parameter that is explained as: Parameter, specifying the image scale (<1) to build pyramids for each image. pyrScale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous one.
"enrich" has a "Number of Levels" parameter that is explained as: Number of pyramid layers including the initial image; levels=1 means that no extra layers are created and only the original images are used.
"enrich" has a "Iterations" parameter that is explained as: Number of iterations the algorithm does at each pyramid level.
"enrich" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"enrich" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"enrich" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "extract movie particles" can be found in the xmipp3 plugin.
"extract movie particles" protocol help is as follows:
  Extract a set of Particles from each frame of a set of Movies.
    .
"extract movie particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"extract movie particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"extract movie particles" has a "Input Movies" parameter that is explained as: Select a set of previously imported movies.
"extract movie particles" has a "Input coordinates" parameter that is explained as: None
"extract movie particles" has a "Particle box size (px)" parameter that is explained as: In pixels. The box size is the size of the boxed particles, actual particles may be smaller than this.
"extract movie particles" has a "Apply movie alignments to extract?" parameter that is explained as: If the input movies contains frames alignment, you decide whether to use that information for extracting the particles taking into account the shifts between frames.
"extract movie particles" has a "First" parameter that is explained as: None
"extract movie particles" has a "Last" parameter that is explained as: None
"extract movie particles" has a "Fill pixels outside borders" parameter that is explained as: Xmipp by default create blank particles whose boxes fall outside of the micrograph borders. Set this option to True if you want those pixels outside the borders to be filled with the closest pixel value available
"extract movie particles" has a "Dust removal (Recommended)" parameter that is explained as: Sets pixels with unusually large values to random values from a Gaussian with zero-mean and unity-standard deviation.
"extract movie particles" has a "Threshold for dust removal" parameter that is explained as: Pixels with a signal higher or lower than this value times the standard deviation of the image will be affected. For cryo, 3.5 is a good value. For high-contrast negative stain, the signal itself may be affected so that a higher value may be preferable.
"extract movie particles" has a "Invert contrast" parameter that is explained as: Invert the contrast if your particles are black over a white background.
"extract movie particles" has a "Normalize (Recommended)" parameter that is explained as: It subtract a ramp in the gray values and normalizes so that in the  background there is 0 mean and standard deviation 1.
"extract movie particles" has a "Normalization type" parameter that is explained as: OldXmipp (mean(Image)=0, stddev(Image)=1). 
NewXmipp (mean(background)=0, stddev(background)=1)
Ramp (subtract background+NewXmipp).
"extract movie particles" has a "Background radius (px)" parameter that is explained as: Pixels outside this circle are assumed to be noise and their stddev is set to 1. Radius for background circle definition (in pix.). If this value is 0, then half the box size is used.
"extract movie particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"extract movie particles" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"extract movie particles" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "extract particles" can be found in the xmipp3 plugin.
"extract particles" protocol help is as follows:
 Protocol to extract particles from a set of coordinates.
"extract particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"extract particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"extract particles" has a "Input coordinates" parameter that is explained as: Select the SetOfCoordinates 
"extract particles" has a "Micrographs source" parameter that is explained as: By default the particles will be extracted from the micrographs used in the picking step ( _same as picking_ option ). 
If you select _other_ option, you must provide a different set of micrographs to extract from. 
*Note*: In the _other_ case, ensure that provided micrographs and coordinates are related by micName or by micId. Difference in pixel size will be handled automatically.
"extract particles" has a "Input micrographs" parameter that is explained as: Select the SetOfMicrographs from which to extract.
"extract particles" has a "CTF estimation" parameter that is explained as: Choose some CTF estimation related to input micrographs. 
 CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
"extract particles" has a "Downsampling factor" parameter that is explained as: Select a value greater than 1.0 to reduce the size of micrographs before extracting the particles. If 1.0 is used, no downsample is applied. Non-integer downsample factors are possible. 
"extract particles" has a "Particle box size (px)" parameter that is explained as: This is size of the boxed particles (in pixels). Note that if you use downsample option, the particles are boxed out after downsampling. Use the wizard to check boxSize changes after downsampling or using a different pixel size. 
"extract particles" has a "Fill pixels outside borders" parameter that is explained as: Xmipp by default skips particles whose boxes fall outside of the micrograph borders. Set this option to True if you want those pixels outside the borders to be filled with the closest pixel value available
"extract particles" has a "Dust removal (Recommended)" parameter that is explained as: Sets pixels with unusually large values to random values from a Gaussian with zero-mean and unity-standard deviation.
"extract particles" has a "Threshold for dust removal" parameter that is explained as: Pixels with a signal higher or lower than this value times the standard deviation of the image will be affected. For cryo, 3.5 is a good value. For high-contrast negative stain, the signal itself may be affected so that a higher value may be preferable.
"extract particles" has a "Invert contrast" parameter that is explained as: Invert the contrast if your particles are black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background. Frealign (up to v9.07) requires black particles over a white background
"extract particles" has a "Phase flipping" parameter that is explained as: Use the information from the CTF to compensate for phase reversals.
Phase flip is recommended in Xmipp or Eman
(even Wiener filtering and bandpass filter are recommended for obtaining better 2D classes)
Otherwise (Frealign, Relion, Spider, ...), phase flip is not recommended.
"extract particles" has a "Normalize (Recommended)" parameter that is explained as: It subtract a ramp in the gray values and normalizes so that in the background there is 0 mean and standard deviation 1.
"extract particles" has a "Normalization type" parameter that is explained as: OldXmipp (mean(Image)=0, stddev(Image)=1). 
NewXmipp (mean(background)=0, stddev(background)=1) 
  Ramp (subtract background+NewXmipp).
"extract particles" has a "Background radius (px)" parameter that is explained as: Pixels outside this circle are assumed to be noise and their stddev is set to 1. Radius for background circle definition (in pix.). If this value is 0, then half the box size is used.
"extract particles" has a "Patch size for the variance filter (px)" parameter that is explained as: Windows size to make the variance filtter and compute the Gini coeff. A twice of the particle size is recommended. Set at -1 applies 1.5*BoxSize.
"extract particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"extract particles" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"extract particles" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "extract particle pairs" can be found in the xmipp3 plugin.
"extract particle pairs" protocol help is as follows:
 Protocol to extract particles from a set of tilted pairs coordinates.
"extract particle pairs" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"extract particle pairs" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"extract particle pairs" has a "Coordinates tilted pairs" parameter that is explained as: Select the CoordinatesTiltPairs
"extract particle pairs" has a "Micrographs source" parameter that is explained as: By default the particles will be extracted from the micrographs used in the picking step ( _same as picking_ option ).
If you select _other_ option, you must provide a different set of micrographs to extract from.
*Note*: In the _other_ case, ensure that provided micrographs and coordinates are related by micName or by micId. Difference in pixel size will be handled automatically.
"extract particle pairs" has a "Input tilt pair micrographs" parameter that is explained as: Select the tilt pair micrographs from which to extract.
"extract particle pairs" has a "CTF estimation (untilted mics)" parameter that is explained as: Choose some CTF estimation related to input UNTILTED micrographs. 
 CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
"extract particle pairs" has a "CTF estimation (tilted mics)" parameter that is explained as: Choose some CTF estimation related to input TILTED micrographs. 
 CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
"extract particle pairs" has a "Downsampling factor" parameter that is explained as: Select a value greater than 1.0 to reduce the size of micrographs before extracting the particles. If 1.0 is used, no downsample is applied. Non-integer downsample factors are possible. 
"extract particle pairs" has a "Particle box size" parameter that is explained as: In pixels. The box size is the size of the boxed particles, actual particles may be smaller than this. If you do downsampling after extraction, provide final box size here.
"extract particle pairs" has a "Fill pixels outside borders" parameter that is explained as: Xmipp by default skips particles whose boxes fall outside of the micrograph borders. Set this option to True if you want those pixels outside the borders to be filled with the closest pixel value available
"extract particle pairs" has a "Dust removal (Recommended)" parameter that is explained as: Sets pixels with unusually large values to random values from a Gaussian with zero-mean and unity-standard deviation.
"extract particle pairs" has a "Threshold for dust removal" parameter that is explained as: Pixels with a signal higher or lower than this value times the standard deviation of the image will be affected. For cryo, 3.5 is a good value. For high-contrast negative stain, the signal itself may be affected so that a higher value may be preferable.
"extract particle pairs" has a "Invert contrast" parameter that is explained as: Invert the contrast if your particles are black over a white background. Xmipp, Spider, Relion and Eman require white particles over a black background, Frealign (up to v9.07) requires black particles over a white background
"extract particle pairs" has a "Phase flipping" parameter that is explained as: Use the information from the CTF to compensate for phase reversals.
Phase flip is recommended in Xmipp or Eman
(even Wiener filtering and bandpass filter are recommended for obtaining better 2D classes)
Otherwise (Frealign, Relion, Spider, ...), phase flip is not recommended.
"extract particle pairs" has a "Normalize (Recommended)" parameter that is explained as: It subtract a ramp in the gray values and normalizes so that in the background there is 0 mean and standard deviation 1.
"extract particle pairs" has a "Normalization type" parameter that is explained as: OldXmipp (mean(Image)=0, stddev(Image)=1).
NewXmipp (mean(background)=0, stddev(background)=1)
Ramp (subtract background+NewXmipp).
"extract particle pairs" has a "Background radius" parameter that is explained as: Pixels outside this circle are assumed to be noise and their stddev is set to 1. Radius for background circle definition (in pix.). If this value is 0, then half the box size is used.
"extract particle pairs" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"extract particle pairs" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"extract particle pairs" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "extract asymmetric unit" can be found in the xmipp3 plugin.
"extract asymmetric unit" protocol help is as follows:
  generates files for volumes and FSCs to submit structures to EMDB
    .
"extract asymmetric unit" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"extract asymmetric unit" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"extract asymmetric unit" has a "Input Volume" parameter that is explained as: This volume will be cropped
"extract asymmetric unit" has a "Symmetry" parameter that is explained as: See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format in Xmipp.
If no symmetry is present, use _c1_.
"extract asymmetric unit" has a "Symmetry Order" parameter that is explained as: Order of cyclic symmetry.
"extract asymmetric unit" has a "offset" parameter that is explained as: rotate unit cell around z-axis by offset degrees
"extract asymmetric unit" has a "Inner Radius (px)" parameter that is explained as: inner Mask radius, if -1, the radius will be 0
"extract asymmetric unit" has a "Outer Radius (px)" parameter that is explained as: outer Mask radius, if -1, the radius will be volume_size/2
"extract asymmetric unit" has a "Expand Factor" parameter that is explained as: Increment cropped region by this factor

The protocol named "resolution fso" can be found in the xmipp3 plugin.
"resolution fso" protocol help is as follows:
     
    Given two half maps the protocol estimates Fourier Shell Occupancy to determine the global anisotropy of the map.
    See more information here: https://github.com/I2PC/xmipp/wiki/FSO---Fourier-Shell-Occupancy
    .
"resolution fso" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"resolution fso" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"resolution fso" has a "Are the half volumes stored with the input volume?" parameter that is explained as: Usually, the half volumes are stored as properties of the input volume. If this is not the case, set this to False and specify the two halves you want to use.
"resolution fso" has a "Input Half Maps" parameter that is explained as: Select a half maps for determining its  resolution anisotropy and resolution.
"resolution fso" has a "Half Map 1" parameter that is explained as: Select one map for determining the directional FSC resolution.
"resolution fso" has a "Half Map 2" parameter that is explained as: Select the second map for determining the directional FSC resolution.
"resolution fso" has a "Mask" parameter that is explained as: The mask determines which points are specimen and which are not
"resolution fso" has a "Cone Angle" parameter that is explained as: Angle between the axis of the cone and the generatrix. An angle of 17 degrees is the best angle (see Nat MethodsJL Vilas 2023) to measuare the directional FSCs
"resolution fso" has a "Estimate 3DFSC " parameter that is explained as: Set to estimate the 3DFSCD map. This is a 3D function that depends of the resolution.The profile of the 3DFSC along a given direction is the directiontal FSC
"resolution fso" has a "FSC Threshold" parameter that is explained as: Threshold for the fsc. By default the standard 0.143. Other common thresholds are 0.5 and 0.3.
"resolution fso" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"resolution fso" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "filter particles" can be found in the xmipp3 plugin.
"filter particles" protocol help is as follows:
  Apply Fourier filters to a set of particles  .
"filter particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"filter particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"filter particles" has a "Input Particles" parameter that is explained as: None
"filter particles" has a "Filter space" parameter that is explained as: None
"filter particles" has a "Filter mode" parameter that is explained as: Depending on the filter mode some frequency (freq.) components
are kept and some are removed.
 _low pass_: components below *High freq.* are preserved.
 _high pass_: components above *Low freq.* are preserved.
 _band pass_: components between *Low freq.* and *High freq.* are preserved. 
ctf: apply first CTF in CTFset to all the particles. This is normally for simulated data.
   : This is not a CTF correction.
"filter particles" has a "Filter mode" parameter that is explained as: median: replace each pixel with the median of neighboring pixels.

"filter particles" has a "Filter mode" parameter that is explained as: DAUB4: filter using the DAUB4 wavelet transform.
 
"filter particles" has a "Provide resolution in Angstroms?" parameter that is explained as: If *Yes*, the resolution values for the filter
should be provided in Angstroms. If *No*, the
values should be in normalized frequencies (between 0 and 0.5).
"filter particles" has a "Lowest" parameter that is explained as: None
"filter particles" has a "Highest" parameter that is explained as: None
"filter particles" has a "Decay length" parameter that is explained as: Amplitude decay in a [[https://en.wikipedia.org/wiki/Raised-cosine_filter][raised cosine]]
"filter particles" has a "Lowest" parameter that is explained as: None
"filter particles" has a "Highest" parameter that is explained as: None
"filter particles" has a "Frequency decay" parameter that is explained as: Amplitude decay in a [[https://en.wikipedia.org/wiki/Raised-cosine_filter][raised cosine]]
"filter particles" has a "CTF Object" parameter that is explained as: Object with CTF information if empty it will take the CTF information related with the first particle.
Note that this is normally used with simulated data.
"filter particles" has a "mode" parameter that is explained as: filter mode to be applied in wavelet space
"filter particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "filter volumes" can be found in the xmipp3 plugin.
"filter volumes" protocol help is as follows:
  Apply Fourier filters to a set of volumes .
"filter volumes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"filter volumes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"filter volumes" has a "Input Volumes" parameter that is explained as: Can be a density volume or a SetOfVolumes.
"filter volumes" has a "Filter space" parameter that is explained as: None
"filter volumes" has a "Filter mode" parameter that is explained as: Depending on the filter mode some frequency (freq.) components
are kept and some are removed.
 _low pass_: components below *High freq.* are preserved.
 _high pass_: components above *Low freq.* are preserved.
 _band pass_: components between *Low freq.* and *High freq.* are preserved. 
ctf: apply first CTF in CTFset to all the particles. This is normally for simulated data.
   : This is not a CTF correction.
"filter volumes" has a "Filter mode" parameter that is explained as: median: replace each pixel with the median of neighboring pixels.

"filter volumes" has a "Filter mode" parameter that is explained as: DAUB4: filter using the DAUB4 wavelet transform.
 
"filter volumes" has a "Provide resolution in Angstroms?" parameter that is explained as: If *Yes*, the resolution values for the filter
should be provided in Angstroms. If *No*, the
values should be in normalized frequencies (between 0 and 0.5).
"filter volumes" has a "Lowest" parameter that is explained as: None
"filter volumes" has a "Highest" parameter that is explained as: None
"filter volumes" has a "Decay length" parameter that is explained as: Amplitude decay in a [[https://en.wikipedia.org/wiki/Raised-cosine_filter][raised cosine]]
"filter volumes" has a "Lowest" parameter that is explained as: None
"filter volumes" has a "Highest" parameter that is explained as: None
"filter volumes" has a "Frequency decay" parameter that is explained as: Amplitude decay in a [[https://en.wikipedia.org/wiki/Raised-cosine_filter][raised cosine]]
"filter volumes" has a "CTF Object" parameter that is explained as: Object with CTF information if empty it will take the CTF information related with the first particle.
Note that this is normally used with simulated data.
"filter volumes" has a "mode" parameter that is explained as: filter mode to be applied in wavelet space
"filter volumes" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"filter volumes" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"filter volumes" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "FlexAlign" can be found in the xmipp3 plugin.
"FlexAlign" protocol help is as follows:
 
    Wrapper protocol to Xmipp Movie Alignment by cross-correlation
    .
"FlexAlign" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"FlexAlign" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"FlexAlign" has a "Input Movies" parameter that is explained as: Select a set of previously imported movies.
"FlexAlign" has a "from" parameter that is explained as: None
"FlexAlign" has a "to" parameter that is explained as: None
"FlexAlign" has a "Use ALIGN frames range to SUM?" parameter that is explained as: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
"FlexAlign" has a "from" parameter that is explained as: None
"FlexAlign" has a "to" parameter that is explained as: None
"FlexAlign" has a "Binning factor" parameter that is explained as: 1x or 2x. Bin stack before processing.
"FlexAlign" has a "X" parameter that is explained as: None
"FlexAlign" has a "Y" parameter that is explained as: None
"FlexAlign" has a "X" parameter that is explained as: None
"FlexAlign" has a "Y" parameter that is explained as: None
"FlexAlign" has a "Save aligned micrograph" parameter that is explained as: None
"FlexAlign" has a "Save movie" parameter that is explained as: Save Aligned movie
"FlexAlign" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"FlexAlign" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"FlexAlign" has a "Maximum resolution (A)" parameter that is explained as: Maximum resolution in A that will be preserved during correlation.
"FlexAlign" has a "Compute PSD?" parameter that is explained as: If Yes, the protocol will compute PSD for each movie before and after the alignment
"FlexAlign" has a "Maximum shift (A)" parameter that is explained as: Maximum allowed distance (in A) that each frame can be shifted with respect to the next.
"FlexAlign" has a "Compute local alignment?" parameter that is explained as: If Yes, the protocol will try to determine local shifts, similarly to MotionCor2.
"FlexAlign" has a "Auto control points" parameter that is explained as: If on, protocol will automatically determine necessary number of control points.
"FlexAlign" has a "X" parameter that is explained as: None
"FlexAlign" has a "Y" parameter that is explained as: None
"FlexAlign" has a "t" parameter that is explained as: None
"FlexAlign" has a "Auto patches" parameter that is explained as: If on, protocol will automatically determine necessary number of patches.
"FlexAlign" has a "X" parameter that is explained as: None
"FlexAlign" has a "Y" parameter that is explained as: None
"FlexAlign" has a "Min size of the patch (A)" parameter that is explained as: How many A should contain each patch?
"FlexAlign" has a "Group N frames" parameter that is explained as: Group every specified number of frames by adding them together.                         The alignment is then performed on the summed frames.
"FlexAlign" has a "Rotate gain reference:" parameter that is explained as: Rotate gain reference counter-clockwise.
"FlexAlign" has a "Flip gain reference:" parameter that is explained as: Flip gain reference after rotation. For tiff movies, gain is automatically upside-down flipped
"FlexAlign" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"FlexAlign" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"FlexAlign" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "generate reprojections" can be found in the xmipp3 plugin.
"generate reprojections" protocol help is as follows:
 Compares a set of classes or averages with the corresponding projections of a reference volume.
    The set of images must have a 3D angular assignment and the protocol computes the residues
    (the difference between the experimental images and the reprojections). The zscore of the mean
    and variance of the residues are computed. Large values of these scores may indicate outliers.
    The protocol also analyze the covariance matrix of the residual and computes the logarithm of
    its determinant [Cherian2013]. The extremes of this score (called zScoreResCov), that is
    values particularly low or high, may indicate outliers..
"generate reprojections" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"generate reprojections" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"generate reprojections" has a "Input images" parameter that is explained as: None
"generate reprojections" has a "Volume to compare images to" parameter that is explained as: Volume to be used for class comparison
"generate reprojections" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"generate reprojections" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "gl2d" can be found in the xmipp3 plugin.
"gl2d" protocol help is as follows:
  2D alignment using Xmipp GPU Correlation algorithm. .
"gl2d" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"gl2d" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"gl2d" has a "Input Particles" parameter that is explained as: None
"gl2d" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"gl2d" has a "Use a Set of Reference Images ?" parameter that is explained as: If you set to *Yes*, you should provide a set of reference images.
If *No*, the default generation is done by averaging subsets of the input images.
"gl2d" has a "Reference images" parameter that is explained as: Set of images that will serve as class reference
"gl2d" has a "Number of classes:" parameter that is explained as: Number of classes (or references) to be generated
"gl2d" has a "Maximum shift (%):" parameter that is explained as: Maximum shift allowed during the alignment as percentage of the input set size
"gl2d" has a "Number of best images:" parameter that is explained as: Number of classes to assign every input image during the alignment
"gl2d" has a "Number of iterations in split stage:" parameter that is explained as: Maximum number of iterations in split stage
"gl2d" has a "Number of iterations in classify stage:" parameter that is explained as: Maximum number of iterations when the  classification of the whole image set is carried out
"gl2d" has a "Allow attraction ?" parameter that is explained as: If you set to *Yes*, you allow to generate classes with low number of images associated.
If *No*, all the generated classes will be balanced
"gl2d" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"gl2d" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "helical symmetry" can be found in the xmipp3 plugin.
"helical symmetry" protocol help is as follows:
  Estimate helical parameters and symmetrize.
    
    Helical symmetry is defined as V(r,rot,z)=V(r,rot+k*DeltaRot,z+k*Deltaz).
    .
"helical symmetry" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"helical symmetry" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"helical symmetry" has a "Input volume" parameter that is explained as: None
"helical symmetry" has a "Cylinder inner radius" parameter that is explained as: The helix is supposed to occupy this radius in voxels around the Z axis. Leave it as -1 for symmetrizing the whole volume
"helical symmetry" has a "Cylinder outer radius" parameter that is explained as: The helix is supposed to occupy this radius in voxels around the Z axis. Leave it as -1 for symmetrizing the whole volume
"helical symmetry" has a "Apply dihedral symmetry" parameter that is explained as: None
"helical symmetry" has a "Force the dihedral axis to be in X" parameter that is explained as: If this option is chosen, then the dihedral axis is not searched and it is assumed that it is around X.
"helical symmetry" has a "Apply Cn symmetry" parameter that is explained as: None
"helical symmetry" has a "Cn symmetry" parameter that is explained as: None
"helical symmetry" has a "Height fraction" parameter that is explained as: The helical parameters are only sought using the fraction indicated by this number. In this way, you can avoid including planes that are poorly resolved at the extremes of the volume. However, note that the algorithm can perfectly work with a fraction of 1.
"helical symmetry" has a "Minimum rotational angle" parameter that is explained as: In degrees
"helical symmetry" has a "Maximum rotational angle" parameter that is explained as: In degrees
"helical symmetry" has a "Angular step" parameter that is explained as: In degrees
"helical symmetry" has a "Minimum shift Z" parameter that is explained as: In Angstroms
"helical symmetry" has a "Maximum shift Z" parameter that is explained as: In Angstroms
"helical symmetry" has a "Shift step" parameter that is explained as: In Angstroms
"helical symmetry" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"helical symmetry" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "operate particles" can be found in the xmipp3 plugin.
"operate particles" protocol help is as follows:
  Apply an operation to two sets of particles  .
"operate particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"operate particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"operate particles" has a "Input Particles" parameter that is explained as: None
"operate particles" has a "Operation" parameter that is explained as: Binary operations: 
*plus*: Sums two images, volumes or adds a numerical value to an image. 
*minus*: Subtracts two images, volumes or subtracts a numerical value to an image. 
*multiply*: Multiplies two images, volumes, or multiplies per a given number. 
*divide*: Divides two images, volumes, or divides per a given number. 
*minimum*: Minimum of two images, volumes, or number (pixel-wise). 
*maximum*: Maximum of two images, volumes, or number (pixel-wise). 
*dot product*: Dot product between two images or volumes. 
Unary operations: 
*log*: Computes the natural logarithm of an image. 
*log10*: Computes the decimal logarithm of an image. 
*sqrt*: Computes the square root of an image 
*abs*: Computes the absolute value of an image. 
*pow*: Computes the power of an image. 
*slice*: Extracts a given slice from a volume (first slice=0). 
*column*: Extracts a given column from a image or volume. 
*row*: Extracts a given row from a image or volume. 
*radial average*: Compute the radial average of an image. 
*reset*: Set the image to 0
"operate particles" has a "Second operand is a value?" parameter that is explained as: Set to true if you want to use a value of the second operand
"operate particles" has a "Input Particles (2nd)" parameter that is explained as: Set a SetOfParticles. The particles must be the same dimensions as the input particles.
"operate particles" has a "Input value " parameter that is explained as: Set the desire float value
"operate particles" has a "Input value " parameter that is explained as: This value must be integer
"operate particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "operate volumes" can be found in the xmipp3 plugin.
"operate volumes" protocol help is as follows:
  Apply an operation to two sets of volumes .
"operate volumes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"operate volumes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"operate volumes" has a "Input Volumes" parameter that is explained as: Can be a density volume or a SetOfVolumes.
"operate volumes" has a "Operation" parameter that is explained as: Binary operations: 
*plus*: Sums two images, volumes or adds a numerical value to an image. 
*minus*: Subtracts two images, volumes or subtracts a numerical value to an image. 
*multiply*: Multiplies two images, volumes, or multiplies per a given number. 
*divide*: Divides two images, volumes, or divides per a given number. 
*minimum*: Minimum of two images, volumes, or number (pixel-wise). 
*maximum*: Maximum of two images, volumes, or number (pixel-wise). 
*dot product*: Dot product between two images or volumes. 
Unary operations: 
*log*: Computes the natural logarithm of an image. 
*log10*: Computes the decimal logarithm of an image. 
*sqrt*: Computes the square root of an image 
*abs*: Computes the absolute value of an image. 
*pow*: Computes the power of an image. 
*slice*: Extracts a given slice from a volume (first slice=0). 
*column*: Extracts a given column from a image or volume. 
*row*: Extracts a given row from a image or volume. 
*radial average*: Compute the radial average of an image. 
*reset*: Set the image to 0
"operate volumes" has a "Second operand is a value?" parameter that is explained as: Set to true if you want to use a value of the second operand
"operate volumes" has a "Input Volumes (2nd)" parameter that is explained as: This parameter depends of the input volume(s). If it is set a volume (or a SetOfVolumes) as input, this must be a *Volume* (or *SetOfVolumes*) object.
"operate volumes" has a "Input value " parameter that is explained as: Set the desire float value
"operate volumes" has a "Input value " parameter that is explained as: This value must be integer
"operate volumes" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"operate volumes" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"operate volumes" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "kerdensom" can be found in the xmipp3 plugin.
"kerdensom" protocol help is as follows:
 
    Classifies a set of images using  Kohonen's Self-Organizing Feature Maps (SOM) 
    and Fuzzy c-means clustering technique (FCM) .
    
    The kerdenSOM algorithm anneals from an initial high regularization factor
    to a final lower one, in a user-defined number of steps.
    
    KerdenSOM is an excellent tool for classification, especially when
    using a large number of data and classes and when the transition between
    the classes is almost continuous, with no clear separation between them.
    
    The input images must be previously aligned.
    .
"kerdensom" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"kerdensom" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"kerdensom" has a "Input images" parameter that is explained as: Select the input images from the project.It should be a SetOfParticles class
"kerdensom" has a "Use a Mask ?" parameter that is explained as: If you set to *Yes*, you should provide a mask
"kerdensom" has a "Mask" parameter that is explained as: Mask image will serve to enhance the classification
"kerdensom" has a "X" parameter that is explained as: None
"kerdensom" has a "Y" parameter that is explained as: None
"kerdensom" has a "Initial regularization factor" parameter that is explained as: The kerdenSOM algorithm anneals from an initial high regularization factorto a final lower one, in a user-defined number of steps.If the output map is too smooth, lower the regularization factorsIf the output map is not organized, higher the regularization factorsSee [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/KerDenSOM][KerDenSOM]]
"kerdensom" has a "Final regularization factor:" parameter that is explained as: None
"kerdensom" has a "Regularization steps:" parameter that is explained as: Number of steps to lower the regularization factor
"kerdensom" has a "Additional parameters:" parameter that is explained as: Additional parameters for kerdensom program. 
 For a complete descriptionSee [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/KerDenSOM][KerDenSOM]]

The protocol named "localdeblur sharpening" can be found in the xmipp3 plugin.
"localdeblur sharpening" protocol help is as follows:
     
    Given a resolution map the protocol calculate the sharpened map.
    .
"localdeblur sharpening" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"localdeblur sharpening" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"localdeblur sharpening" has a "Input Map" parameter that is explained as: Select a volume for sharpening.
"localdeblur sharpening" has a "Resolution Map" parameter that is explained as: Select a local resolution map. LocalDeblur has been specially designed to work with resolution maps obtained with MonoRes, however resolution map from ResMap and BlocRes are also accepted.
"localdeblur sharpening" has a "lambda" parameter that is explained as: Regularization Param.The method determines this parameter automatically. This parameter is directly related to the convergence. Increasing it would accelerate the convergence, however it presents the risk of falling into local minima.
"localdeblur sharpening" has a "K" parameter that is explained as: K = 0.025 works well for all tested cases. K should be in the 0.01-0.05 range. For maps with FSC resolution lower than 6Å, K = 0.01 can be a good alternative.
"localdeblur sharpening" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"localdeblur sharpening" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "estimate local defocus" can be found in the xmipp3 plugin.
"estimate local defocus" protocol help is as follows:
 Compares a set of particles with the corresponding projections of a reference volume.
    The set of particles must have a 3D angular assignment.
    This protocol refines the CTF, computing local defocus change.
    The maximun allowed defocus is a parameter introduced by the user (advanced).
    The protocol gives back the input set of particles with the refine local defocus and the defocus change with relation to the global defocus..
"estimate local defocus" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"estimate local defocus" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"estimate local defocus" has a "Input images" parameter that is explained as: None
"estimate local defocus" has a "Volume to compare images to" parameter that is explained as: Volume to be used for class comparison
"estimate local defocus" has a "Maximum defocus change (A)" parameter that is explained as: None
"estimate local defocus" has a "Maximum gray scale change" parameter that is explained as: The reprojection is modified as a*P+b, a is restricted to the interval [1-maxGrayScale,1+maxGrayScale]
"estimate local defocus" has a "Maximum gray shift change" parameter that is explained as: The reprojection is modified as a*P+b, b is restricted to the interval [-maxGrayShift,maxGrayShift]
"estimate local defocus" has a "Force defocusV to be equal than defocusU" parameter that is explained as: As the CTF usually suffers from astigmatism (it is not spherical but ellipsoidal), the defocus vary if computed in X or Y direction, being defocus U value the defocus in X direction and defocus V value the defocus in Y direction.
"estimate local defocus" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"estimate local defocus" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "volume local adjustment" can be found in the xmipp3 plugin.
"volume local adjustment" protocol help is as follows:
 Protocol to adjust locally volume intensity to a reference volume. Occupancy volume is saved in protocol folder. Based on 
    https://www.sciencedirect.com/science/article/pii/S1047847723000874?via%3Dihub.
"volume local adjustment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"volume local adjustment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"volume local adjustment" has a "Reference volume" parameter that is explained as: Specify a volume to be used as reference volume.
"volume local adjustment" has a "Input volume" parameter that is explained as: Specify a volume which will be adjusted to the reference volume.
"volume local adjustment" has a "Mask for reference volume" parameter that is explained as: Specify a mask to define region of interest (which is signal in white (1s) and background in black (0s))
"volume local adjustment" has a "Neighborhood (A)" parameter that is explained as: Side length (in Angstroms) of a square which will define the region of adjustment
"volume local adjustment" has a "Perform subtraction?" parameter that is explained as: Perform subtraction of reference volume minus input volume in real space

The protocol named "ml2d" can be found in the xmipp3 plugin.
"ml2d" protocol help is as follows:
 
    Perform (multi-reference) 2D-alignment using 
    a maximum-likelihood ( *ML* ) target function.
    
    Initial references can be generated from random subsets of the experimental
    images or can be provided by the user (this can introduce bias). The output
    of the protocol consists of the refined 2D classes (weighted averages over 
    all experimental images). The experimental images are not altered at all.    
    
    Although the calculations can be rather time-consuming (especially for 
    many, large experimental images and a large number of references we 
    strongly recommend to let the calculations converge. 
    .
"ml2d" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"ml2d" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"ml2d" has a "Input particles" parameter that is explained as: Select the input images from the project.
"ml2d" has a "Generate classes?" parameter that is explained as: If you set to *No*, you should provide class images. If *Yes*, the default generation is done by averaging subsets of the input images (less bias introduced).
"ml2d" has a "Number of classes:" parameter that is explained as: Number of classes to be generated.
"ml2d" has a "Class image(s)" parameter that is explained as: Image(s) that will serve as initial 2D classes
"ml2d" has a "Use MLF2D instead of ML2D?" parameter that is explained as: None
"ml2d" has a "Use CTF-amplitude correction?" parameter that is explained as: If set to *Yes*, the input images file should contains.
 If set to *No*, provide the images pixel size in Angstrom.
"ml2d" has a "Are the images CTF phase flipped?" parameter that is explained as: You can run MLF with or without having phase flipped the images.
"ml2d" has a "High-resolution limit (Ang)" parameter that is explained as: No frequencies higher than this limit will be taken into account.
If zero is given, no limit is imposed.
"ml2d" has a "Also include mirror in the alignment?" parameter that is explained as: Including the mirror transformation is useful if your particleshave a handedness and may fall either face-up or face-down on the grid.
"ml2d" has a "Use the fast version?" parameter that is explained as: If set to *Yes*, a fast approach will be used to avoid
searching in the whole solutions space.             

For details see (and please cite): 
[[http://dx.doi.org/10.1093/bioinformatics/bti1140][Scheres et al., Bioinformatics, 2005]] 
"ml2d" has a "Refine the normalization for each image?" parameter that is explained as: This variant of the algorithm deals with normalization errors. 

For details see (and please cite): 
 [[http://dx.doi.org/10.1107/S0907444909012049][Scheres et al., Acta Crystallogr D Biol Crystallogr, 2009]] 
"ml2d" has a "Maximum number of iterations" parameter that is explained as: If the convergence has not been reached after this numberof iterations, the process will be stopped.
"ml2d" has a "In-plane rotation sampling (degrees)" parameter that is explained as: In-plane rotation sampling interval (degrees).
"ml2d" has a "Std for pixel noise" parameter that is explained as: Expected standard deviation for pixel noise.
"ml2d" has a "Std for origin offset" parameter that is explained as: Expected standard deviation for origin offset (pixels).
"ml2d" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"ml2d" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"ml2d" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "apply 2d mask" can be found in the xmipp3 plugin.
"apply 2d mask" protocol help is as follows:
  Apply mask to a set of particles .
"apply 2d mask" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"apply 2d mask" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"apply 2d mask" has a "Input Particles" parameter that is explained as: None
"apply 2d mask" has a "Mask source" parameter that is explained as: Select which type of mask do you want to apply. 
 
"apply 2d mask" has a "Input mask" parameter that is explained as: None
"apply 2d mask" has a "Mask type" parameter that is explained as: None
"apply 2d mask" has a "Radius (px)" parameter that is explained as: Mask radius, if -1, the radius will be MaskSize/2
"apply 2d mask" has a "Box size" parameter that is explained as: Mask box size, if -1, the box size will be MaskSize/2
"apply 2d mask" has a "Inner radius (px)" parameter that is explained as: Inner radius in pixels
"apply 2d mask" has a "Outer radius (px)" parameter that is explained as: Outer radius in pixels, if -1, the outer radius will be MaskSize/2
"apply 2d mask" has a "Sigma (px)" parameter that is explained as: Gaussian sigma in pixels. If -1, sigma will be MaskSize/6
"apply 2d mask" has a "Border decay (px)" parameter that is explained as: This is the fall-off of the two borders of the crown
"apply 2d mask" has a "Shift Center" parameter that is explained as: Shift Mask Center to a new origin.
"apply 2d mask" has a "X center offset" parameter that is explained as: New x center coordinate
"apply 2d mask" has a "Y center offset" parameter that is explained as: New y center coordinate
"apply 2d mask" has a "Fill with " parameter that is explained as: Select how are you going to fill the pixel values outside the mask. 
"apply 2d mask" has a "Fill value" parameter that is explained as: Value to fill the pixel values outside the mask. 
"apply 2d mask" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "apply 3d mask" can be found in the xmipp3 plugin.
"apply 3d mask" protocol help is as follows:
  Apply mask to a volume .
"apply 3d mask" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"apply 3d mask" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"apply 3d mask" has a "Input Volumes" parameter that is explained as: Can be a density volume or a SetOfVolumes.
"apply 3d mask" has a "Mask source" parameter that is explained as: Select which type of mask do you want to apply. 
 
"apply 3d mask" has a "Input mask" parameter that is explained as: None
"apply 3d mask" has a "Mask type" parameter that is explained as: None
"apply 3d mask" has a "Radius (px)" parameter that is explained as: Mask radius, if -1, the radius will be MaskSize/2
"apply 3d mask" has a "Shift center of the mask?" parameter that is explained as: None
"apply 3d mask" has a "X" parameter that is explained as: None
"apply 3d mask" has a "Y" parameter that is explained as: None
"apply 3d mask" has a "Z" parameter that is explained as: None
"apply 3d mask" has a "Box size" parameter that is explained as: Mask box size, if -1, the box size will be MaskSize/2
"apply 3d mask" has a "Inner radius (px)" parameter that is explained as: Inner radius in pixels
"apply 3d mask" has a "Outer radius (px)" parameter that is explained as: Outer radius in pixels, if -1, the outer radius will be MaskSize/2
"apply 3d mask" has a "Height (px)" parameter that is explained as: Cylinder height in pixels. If -1, height will be MaskSize
"apply 3d mask" has a "Sigma (px)" parameter that is explained as: Gaussian sigma in pixels. If -1, sigma will be MaskSize/6
"apply 3d mask" has a "Border decay (px)" parameter that is explained as: This is the fall-off of the two borders of the crown
"apply 3d mask" has a "Fill with " parameter that is explained as: Select how are you going to fill the pixel values outside the mask. 
"apply 3d mask" has a "Fill value" parameter that is explained as: Value to fill the pixel values outside the mask. 
"apply 3d mask" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"apply 3d mask" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"apply 3d mask" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "directional resolution MonoDir" can be found in the xmipp3 plugin.
"directional resolution MonoDir" protocol help is as follows:
     
    Given a map the protocol assigns local resolutions to each voxel of the map.
    .
"directional resolution MonoDir" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"directional resolution MonoDir" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"directional resolution MonoDir" has a "Input Volume" parameter that is explained as: Select a volume for determining its local resolution.
"directional resolution MonoDir" has a "Binary Mask" parameter that is explained as: The mask determines which points are specimen and which ones not
"directional resolution MonoDir" has a "Significance" parameter that is explained as: Relution is computed using hipothesis tests, this value determinesthe significance of that test
"directional resolution MonoDir" has a "Resolution Step" parameter that is explained as: The resolution will be sought in steps of this values, with step = 0.3, then 1A, 1.3A, 1.6A,...
"directional resolution MonoDir" has a "Fast Computation" parameter that is explained as: Fast computation is recommended for large volumes.
"directional resolution MonoDir" has a "Is the original premasked?" parameter that is explained as: Sometimes the original volume is masked inside a spherical mask. In this caseplease select yes
"directional resolution MonoDir" has a "Spherical mask radius (px)" parameter that is explained as: When the original volume is originally premasked, the noise estimation oughtto be performed inside that premask, and out of the provieded mask asked in the previusbox. The radius value, determines the radius of the spherical premask. By defaultradius = -1 use the half of the volume size as radius
"directional resolution MonoDir" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"directional resolution MonoDir" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "local MonoRes" can be found in the xmipp3 plugin.
"local MonoRes" protocol help is as follows:
     
    Given a map the protocol assigns local resolutions to each voxel of the map.
    .
"local MonoRes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"local MonoRes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"local MonoRes" has a "Would you like to use half volumes?" parameter that is explained as: The noise estimation for determining the local resolution is performed via half volumes.
"local MonoRes" has a "Are the half volumes stored with the input volume?" parameter that is explained as: Usually, the half volumes are stored as properties of the input volume. If this is not the case, set this to False and specify the two halves you want to use.
"local MonoRes" has a "Input Volume" parameter that is explained as: Select a volume for determining its local resolution.
"local MonoRes" has a "Input Half Maps" parameter that is explained as: Select a volume for determining its local resolution.
"local MonoRes" has a "Volume Half 1" parameter that is explained as: Select the first half of a volume for determining its local resolution.
"local MonoRes" has a "Volume Half 2" parameter that is explained as: Select the second half of a volume for determining a local resolution.
"local MonoRes" has a "Binary Mask" parameter that is explained as: The mask determines which points are specimen and which are not
"local MonoRes" has a "Exclude Area" parameter that is explained as: The mask determines the area of the protein to beexcluded in the estimation of the local resolution
"local MonoRes" has a "Significance" parameter that is explained as: Resolution is computed using hypothesis tests, this value determines the significance of that test
"local MonoRes" has a "Mask threshold" parameter that is explained as: If the provided mask is not binary. Then, MonoReswill try to binarize it. Mask values below the thresholdwill be change to 0 and above the thresthol will be 1
"local MonoRes" has a "Use noise inside protein?" parameter that is explained as: (Yes recommended) the noise distribution will be estimated in the protein region (inside the mask) by means of the difference of both half maps.
"local MonoRes" has a "Consider noise gaussian?" parameter that is explained as: It assumes the noise in the map as gaussian. Note that this assumption might not be true, despite ,it is  in general.
"local MonoRes" has a "High" parameter that is explained as: None
"local MonoRes" has a "Low" parameter that is explained as: None
"local MonoRes" has a "Step" parameter that is explained as: None
"local MonoRes" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"local MonoRes" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "movie dose analysis" can be found in the xmipp3 plugin.
"movie dose analysis" protocol help is as follows:
  Protocol for the dose analysis .
"movie dose analysis" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"movie dose analysis" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"movie dose analysis" has a "Input Movies" parameter that is explained as: Select one or several movies. A dose analysis be calculated for each one of them.
"movie dose analysis" has a "Maximum percentage difference (%)" parameter that is explained as: By default, a difference of 5% against the median dose is used to assume that the dose has an incorrect value.
"movie dose analysis" has a "Samples to estimate the median dose" parameter that is explained as: By default, 20 movies are used to compute the global median.
"movie dose analysis" has a "Window step (movies)" parameter that is explained as: By default, every 50 movies (window=50) we compute the percentage of incorrect dose analysis to check if there is any anomally in the dose.
"movie dose analysis" has a "Windows maximum faulty percentage (%)" parameter that is explained as: By default, if 30% of the movies are discardedit assume that the dose has an incorrect value that endures in time.

The protocol named "movie gain" can be found in the xmipp3 plugin.
"movie gain" protocol help is as follows:
  Estimate the gain image of a camera, directly analyzing one of its movies.
    It can correct the orientation of an external gain image (by comparing it with the estimated).
    Finally, it estimates the residual gain (the gain of the movie after correcting with a gain).
    The gain used in the correction will be preferably the external gain, but can also be the estimated
    gain if the first is not found.
    The same criteria is used for assigning the gain to the output movies (external corrected > external > estimated)
    .
"movie gain" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"movie gain" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"movie gain" has a "Input Movies" parameter that is explained as: Select several movies. A gain image will be calculated for each one of them.
"movie gain" has a "Estimate movies gain" parameter that is explained as: Estimate the gain from a set of movies using the algorith from xmipp
"movie gain" has a "Estimate external gain orientation" parameter that is explained as: Estimate the relative orientation between the estimated and the existing gain
"movie gain" has a "Estimate residual gain" parameter that is explained as: If there is a gain image associated with input movies, you can decide to use it instead of estimating raw/residual gain image. Location of this gain image needs to be indicated in import movies protocol.
"movie gain" has a "Normalize existing gain" parameter that is explained as: Normalize the input gain so that it has a mean of 1
"movie gain" has a "Estimate the sigma parameter" parameter that is explained as: Estimate the sigma parameter for the gain image computation
"movie gain" has a "Frame step" parameter that is explained as: By default, every 5th frame is used to compute the movie gain. If you set this parameter to 2, 3, ..., then only every 2nd, 3rd, ... frame will be used.
"movie gain" has a "Movie step" parameter that is explained as: By default, every 250 movies (movieStep=250) is used to compute the movie gain. If you set this parameter to 2, 3, ..., then every 2nd, 3rd, ... movie will be used.
"movie gain" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"movie gain" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"movie gain" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "movie maxshift" can be found in the xmipp3 plugin.
"movie maxshift" protocol help is as follows:
 
    Protocol to make an automatic rejection of those movies whose
    frames move more than a given threshold.
        Rejection criteria:
            - *by frame*: Rejects movies with drifts between frames
                              bigger than a certain maximum.
            - *by whole movie*: Rejects movies with a total travel
                                         bigger than a certain maximum.
            - *by frame and movie*: Rejects movies if both conditions
                                                above are met.
            - *by frame or movie*: Rejects movies if one of the conditions
                                             above are met.
    .
"movie maxshift" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"movie maxshift" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"movie maxshift" has a "Input Movies" parameter that is explained as: Select a set of previously aligned Movies.
"movie maxshift" has a "Rejection type" parameter that is explained as: Rejection criteria:
 - *by frame*: Rejects movies with drifts between frames bigger than a certain maximum.
 - *by whole movie*: Rejects movies with a total travel bigger than a certain maximmum.
 - *by frame and movie*: Rejects movies if both conditions above are met.
 - *by frame or movie*: Rejects movies if one of the conditions above are met.
"movie maxshift" has a "Max. frame shift (A)" parameter that is explained as: Maximum drift between consecutive frames to evaluate the frame condition.
"movie maxshift" has a "Max. movie shift (A)" parameter that is explained as: Maximum total travel to evaluate the whole movie condition.

The protocol named "movie resize" can be found in the xmipp3 plugin.
"movie resize" protocol help is as follows:
 
    Resize a set of movies. Only downsampling is allowed.
    .
"movie resize" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"movie resize" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"movie resize" has a "Input Movies" parameter that is explained as: Select a set of movies to be resized.
"movie resize" has a "Resize option" parameter that is explained as: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Dimensions_: Set the output dimensions. 
_Factor_: Set a resize factor to resize. 
 
"movie resize" has a "Resize sampling rate (A/px)" parameter that is explained as: Set the new output sampling rate.
"movie resize" has a "New image size (px)" parameter that is explained as: Size in pixels of the particle images <x> <y=x> <z=x>.
"movie resize" has a "Downsampling factor" parameter that is explained as: New size is the old one x resize factor.
"movie resize" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"movie resize" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"movie resize" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "multireference alignability" can be found in the xmipp3 plugin.
"multireference alignability" protocol help is as follows:
     
    Performs soft alignment validation of a set of particles confronting them
    against a given 3DEM map. This protocol produces particle alignment
    precision and accuracy parameters.
    .
"multireference alignability" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"multireference alignability" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"multireference alignability" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"multireference alignability" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"multireference alignability" has a "Input volume" parameter that is explained as: Select the input volume(s).
"multireference alignability" has a "Input particles" parameter that is explained as: Select the input projection images.
"multireference alignability" has a "Symmetry group" parameter that is explained as: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
"multireference alignability" has a "Angular Sampling (degrees)" parameter that is explained as: Angular distance (in degrees) between neighboring projection points 
"multireference alignability" has a "Number of Orientations for particle" parameter that is explained as: Parameter to define the number of most similar volume 
    projected images for each projection image
"multireference alignability" has a "Do not use the weights" parameter that is explained as: Do not use the weights in the clustering calculation
"multireference alignability" has a "Pseudo symmetry group" parameter that is explained as: Add only in case the map is close to a symmetry different and more restrict than the one reported in the parameter Symmetry group.See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
"multireference alignability" has a "Minimum allowed tilt angle" parameter that is explained as: Tilts below this value will not be considered for the alignment
"multireference alignability" has a "Maximum allowed tilt angle without mirror check" parameter that is explained as: Tilts above this value will not be considered for the alignment without mirror check
"multireference alignability" has a "CTF correction" parameter that is explained as: Perform CTF correction by Wiener filtering.
"multireference alignability" has a "Isotropic Correction" parameter that is explained as: If true, Consider that there is not astigmatism and then it is performed an isotropic correction.
"multireference alignability" has a "Padding factor" parameter that is explained as: Padding factor for Wiener correction 
"multireference alignability" has a "Wiener constant" parameter that is explained as:  Wiener-filter constant (if < 0: use FREALIGN default)
"multireference alignability" has a "Correct for CTF envelope" parameter that is explained as:  Only in cases where the envelope is well estimated correct for it
"multireference alignability" has a "Target resolution (A)" parameter that is explained as: Low pass filter the particles to this resolution. This usually helps a lot obtaining good alignment. You should have a good reason to modify this value outside the range  [8-10] A
"multireference alignability" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"multireference alignability" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"multireference alignability" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "multiple fscs" can be found in the xmipp3 plugin.
"multiple fscs" protocol help is as follows:
 
    Compute the FSCs between a reference volume and a set of input volumes.
    A mask can be provided and the volumes are aligned by default.
    .
"multiple fscs" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"multiple fscs" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"multiple fscs" has a "Reference volume" parameter that is explained as: The rest of volumes will be compared to this one
"multiple fscs" has a "Volumes to compare" parameter that is explained as: Set of volumes to compare to the reference volume
"multiple fscs" has a "Mask" parameter that is explained as: A mask may be provided and it is applied before comparing the different volumes
"multiple fscs" has a "Align volumes?" parameter that is explained as: Align volumes to reference before comparing. A local alignment is performed so the initial orientation of the volumes should be relatively similar
"multiple fscs" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"multiple fscs" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"multiple fscs" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "normalize strain" can be found in the xmipp3 plugin.
"normalize strain" protocol help is as follows:
 
    Normalize the local strain and rotations amongst several runs
    .
"normalize strain" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"normalize strain" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"normalize strain" has a "input strain calculations" parameter that is explained as: Select the runs of strain calculations to be normalized

The protocol named "optical alignment" can be found in the xmipp3 plugin.
"optical alignment" protocol help is as follows:
 
    Wrapper protocol to Xmipp Movie Alignment by Optical Flow
    .
"optical alignment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"optical alignment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"optical alignment" has a "Input Movies" parameter that is explained as: Select a set of previously imported movies.
"optical alignment" has a "from" parameter that is explained as: None
"optical alignment" has a "to" parameter that is explained as: None
"optical alignment" has a "Use ALIGN frames range to SUM?" parameter that is explained as: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
"optical alignment" has a "from" parameter that is explained as: None
"optical alignment" has a "to" parameter that is explained as: None
"optical alignment" has a "Binning factor" parameter that is explained as: 1x or 2x. Bin stack before processing.
"optical alignment" has a "X" parameter that is explained as: None
"optical alignment" has a "Y" parameter that is explained as: None
"optical alignment" has a "X" parameter that is explained as: None
"optical alignment" has a "Y" parameter that is explained as: None
"optical alignment" has a "Save aligned micrograph" parameter that is explained as: None
"optical alignment" has a "Save movie" parameter that is explained as: Save Aligned movie
"optical alignment" has a "" parameter that is explained as: Set to true if you want the GPU implementation of Optical Flow
"optical alignment" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
"optical alignment" has a "Window size" parameter that is explained as: Window size (shifts are assumed to be constant within this window).
"optical alignment" has a "Group Size" parameter that is explained as: The number of frames in each group at the last step
"optical alignment" has a "Use previous movie alignment to SUM frames?" parameter that is explained as: Input movies could have alignment information froma previous protocol. If you select *Yes*, the previous alignment will be taken into account.
"optical alignment" has a "Compute PSD (before/after)?" parameter that is explained as: If Yes, the protocol will compute for each movie the PSD of the average micrograph (without OF alignement) and after that, to compare each PSDs
"optical alignment" has a "Keep images in RAM ?" parameter that is explained as: If True, the protocol will increase the demand of RAM, decreasing disc access
"optical alignment" has a "Apply Dose filter" parameter that is explained as: Apply a dose-dependent filter to frames before summing them. Pre-exposure and dose per frame should  be specified during movies import.
"optical alignment" has a "Save unweighted micrographs?" parameter that is explained as: Yes by default, if you have selected to apply a dose-dependent filter to the frames
"optical alignment" has a "Apply Dose filter before alignment?" parameter that is explained as: if *True*, you apply dose filter before perform the alignment; else will apply after alignment.
"optical alignment" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"optical alignment" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"optical alignment" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "manual-picking (step 1)" can be found in the xmipp3 plugin.
"manual-picking (step 1)" protocol help is as follows:
  Picks particles in a set of micrographs
    either manually or in a supervised mode.
    .
"manual-picking (step 1)" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"manual-picking (step 1)" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"manual-picking (step 1)" has a "Input Micrographs" parameter that is explained as: Select the SetOfMicrographs to be used during picking.
"manual-picking (step 1)" has a "Save discarded particles" parameter that is explained as: Generates an output with the manually discarded particles.
"manual-picking (step 1)" has a "Run in interactive mode" parameter that is explained as: If YES, you can pick particles in differents sessions.
If NO, once an outputCoordinates is created, the protocol finishes. 
(the last can be useful when other protocol waits until this finish -internal scheduled-)

The protocol named "tilt pairs particle picking" can be found in the xmipp3 plugin.
"tilt pairs particle picking" protocol help is as follows:
  Picks particles in a set of untilted-tilted pairs of micrographs. .
"tilt pairs particle picking" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"tilt pairs particle picking" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"tilt pairs particle picking" has a "Micrographs tilt pair" parameter that is explained as: Select the MicrographsTiltPair 

The protocol named "phantom volume" can be found in the xmipp3 plugin.
"phantom volume" protocol help is as follows:
  Create phantom volume from a feature description file using xmipp_phantom_create .
"phantom volume" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"phantom volume" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"phantom volume" has a "Create phantom" parameter that is explained as: create a phantom description: x y z backgroundValue geometry(cyl, sph...) +(superimpose) desnsityValue origin radius height rot tilt psi. See more information in https://web.archive.org/web/20180813105422/http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/FileFormats#Phantom_metadata_file
"phantom volume" has a "Sampling rate" parameter that is explained as: None

The protocol named "pick noise" can be found in the xmipp3 plugin.
"pick noise" protocol help is as follows:
 Protocol to pick noise particles.
"pick noise" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"pick noise" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"pick noise" has a "Input coordinates" parameter that is explained as: Set of true particle coordinates. Noise coordinates are chosen so that they are sufficiently far from particles
"pick noise" has a "Number of noise particles" parameter that is explained as: Number of noise particles to extract from each micrograph. Set to -1 for extracting the same amount of noise particles as the number true particles for that micrograph
"pick noise" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"pick noise" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "remove duplicates" can be found in the xmipp3 plugin.
"remove duplicates" protocol help is as follows:
 
    This protocol removes coordinates that are closer than a given threshold.
    The remaining coordinate is the average of the previous ones.
    .
"remove duplicates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"remove duplicates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"remove duplicates" has a "Input coordinates" parameter that is explained as: Select the set of coordinates to compare
"remove duplicates" has a "Radius" parameter that is explained as: All coordinates within this radius (in pixels) are presumed to correspond to the same particle

The protocol named "preprocess micrographs" can be found in the xmipp3 plugin.
"preprocess micrographs" protocol help is as follows:
 Protocol to preprocess a set of micrographs in the project.
    You can crop borders, remove bad pixels, etc. .
"preprocess micrographs" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"preprocess micrographs" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"preprocess micrographs" has a "Input micrographs" parameter that is explained as: Select the SetOfMicrograph to be preprocessed.
"preprocess micrographs" has a "Operations are performed in the order shown below" parameter that is explained as: None
"preprocess micrographs" has a "Crop borders?" parameter that is explained as: Crop a given amount of pixels from each border.
"preprocess micrographs" has a "Pixels to crop" parameter that is explained as: Amount of pixels you want to crop from borders.
"preprocess micrographs" has a "Take logarithm?" parameter that is explained as: Depending on your acquisition system you may need to take the logarithm of the pixel values in order to have a linear relationship betweenthe gray values in the image and those in the volume. a - b ln(x+c) by default 4.431-0.4018*LN((P1+336.6)) is applied (right one for nikon coolscan 9000)
"preprocess micrographs" has a "a" parameter that is explained as: None
"preprocess micrographs" has a "b" parameter that is explained as: None
"preprocess micrographs" has a "c" parameter that is explained as: None
"preprocess micrographs" has a "Remove bad pixels?" parameter that is explained as: Values will be thresholded to this multiple of standard deviations. Typical values are about 5, i.e., pixel values beyond 5 times the standard deviation will be substituted by the local median. Set this option to -1 for not applying it.
"preprocess micrographs" has a "Multiple of Stddev" parameter that is explained as: Multiple of standard deviation.
"preprocess micrographs" has a "Invert contrast?" parameter that is explained as: Multiply by -1
"preprocess micrographs" has a "Downsample micrographs?" parameter that is explained as: Downsample micrographs by a given factor.
"preprocess micrographs" has a "Downsampling factor" parameter that is explained as: Non-integer downsample factors are possible. Must be larger than 1.
"preprocess micrographs" has a "Denoising" parameter that is explained as: Apply a denoising method
"preprocess micrographs" has a "Max. number of iterations" parameter that is explained as: Max. number of iterations. Higher number = better output but slower calculation. Must be larger than 1.
"preprocess micrographs" has a "Gaussian filter" parameter that is explained as: Apply a Gaussian filter in real space
"preprocess micrographs" has a "Gaussian sigma (px)" parameter that is explained as: The larger this value, the more the effect will be noticed
"preprocess micrographs" has a "Highpass filter" parameter that is explained as: Apply a highpass filter in real space
"preprocess micrographs" has a "Cutoff frequency" parameter that is explained as: In normalized frequencies (<0.5). For example, if you want to remove patterns larger than 500 pixels, use 1/500=0.002
"preprocess micrographs" has a "Transition bandwidth" parameter that is explained as: In normalized frequencies (<0.5). For example, if you want to remove patterns larger than 1000 pixels, use 1/1000=0.001
"preprocess micrographs" has a "Lowpass filter" parameter that is explained as: Apply a lowpass filter in real space
"preprocess micrographs" has a "Cutoff frequency" parameter that is explained as: In normalized frequencies (<0.5). For example, if you want to remove the crystalline ice at a frequency of 4A and the pixel size is 0.5A, then the cutoff should be 0.5/4=0.125
"preprocess micrographs" has a "Transition bandwidth" parameter that is explained as: In normalized frequencies (<0.5). The number of pixels in Fourier will be approximately lowRaised*Xdim
"preprocess micrographs" has a "Normalize micrograph?" parameter that is explained as: Normalize micrographs to be zero mean and standard deviation one
"preprocess micrographs" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"preprocess micrographs" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"preprocess micrographs" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "preprocess particles" can be found in the xmipp3 plugin.
"preprocess particles" protocol help is as follows:
  Preprocess a set of particles. You can remove dust, normalize, 
        apply threshold, etc .
"preprocess particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"preprocess particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"preprocess particles" has a "Input Particles" parameter that is explained as: None
"preprocess particles" has a "Dust removal" parameter that is explained as: Sets pixels with unusually large values torandom values from a Gaussian with zero-mean and unity-standard deviation.
"preprocess particles" has a "Threshold for dust removal" parameter that is explained as: Pixels with a signal higher or lower thanthis value times the standard deviation of the imagewill be affected. For cryo, 3.5 is a good value.For high-contrast negative stain, the signal itselfmay be affected so that a higher value may be preferable.
"preprocess particles" has a "Randomize phases" parameter that is explained as: Randomize phases beyond a certain frequency.
"preprocess particles" has a "Maximum Resolution" parameter that is explained as: Angstroms.
"preprocess particles" has a "Normalize" parameter that is explained as: It subtract a ramp in the gray values and normalizesso that in the background there is 0 mean andstandard deviation 1.
"preprocess particles" has a "Normalization type" parameter that is explained as: OldXmipp: mean(Image)=0, stddev(Image)=1
NewXmipp: mean(background)=0, stddev(background)=1
Ramp: subtract background + NewXmipp
"preprocess particles" has a "Background radius" parameter that is explained as: Pixels outside this circle are assumed to be noise andtheir stddev is set to 1. Radius for backgroundcircle definition (in pix.).If this value is 0, then half the box size is used.
"preprocess particles" has a "Center images" parameter that is explained as: None
"preprocess particles" has a "Phase flip images" parameter that is explained as: None
"preprocess particles" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"preprocess particles" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"preprocess particles" has a "Invert contrast" parameter that is explained as: Invert the contrast if your particles are black overa white background.
"preprocess particles" has a "Threshold" parameter that is explained as: Remove voxels below a certain value.
"preprocess particles" has a "Fill with " parameter that is explained as: Select how are you going to fill the pixel valuesoutside the mask.
"preprocess particles" has a "Threshold value" parameter that is explained as: Grey value below which all voxels should be set to 0.
"preprocess particles" has a "Substitute by" parameter that is explained as: If you select: value: Selected are substitute by a desired value.            binarize: Selected are set to 0, non-selected to 1.                 avg: Average of non-selected.
"preprocess particles" has a "Fill value" parameter that is explained as:  Substitute selected pixels by this value.
"preprocess particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "preprocess volumes" can be found in the xmipp3 plugin.
"preprocess volumes" protocol help is as follows:
  Protocol for Xmipp-based preprocess for volumes .
"preprocess volumes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"preprocess volumes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"preprocess volumes" has a "Input Volumes" parameter that is explained as: Can be a density volume or a SetOfVolumes.
"preprocess volumes" has a "Change hand" parameter that is explained as: Change hand by applying a mirror along X.
"preprocess volumes" has a "Change icosahedral orientation" parameter that is explained as: Change from one icosahedral standard orientation to another.
"preprocess volumes" has a "from" parameter that is explained as: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] for a description of the symmetry groups format.
"preprocess volumes" has a "to" parameter that is explained as: None
"preprocess volumes" has a "Randomize phases" parameter that is explained as: Randomize phases beyond a certain frequency.
"preprocess volumes" has a "Maximum Resolution" parameter that is explained as: Angstroms.
"preprocess volumes" has a "Symmetrize" parameter that is explained as: Symmetrize the input model.
"preprocess volumes" has a "Symmetry group" parameter that is explained as: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] for a description of the symmetry groups format.If no symmetry is present, set the Symmetrize field to not.
"preprocess volumes" has a "Aggregation mode" parameter that is explained as: Symmetrized volumes can be averaged or summed.
"preprocess volumes" has a "Wrap" parameter that is explained as: by default, the image/volume is wrapped
"preprocess volumes" has a "Apply Laplacian" parameter that is explained as: Laplacian denoising
"preprocess volumes" has a "Mask volume" parameter that is explained as: None
"preprocess volumes" has a "Adjust gray values" parameter that is explained as: Adjust input gray values so that it is compatiblewith a set of projections.
"preprocess volumes" has a "Set of particles" parameter that is explained as: Set of images to which the model should conform.The set of images should have the final pixel sizeand the final size of the model.
"preprocess volumes" has a "Symmetry group" parameter that is explained as: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]]for a description of the symmetry groups format.If no symmetry is present, give c1.
"preprocess volumes" has a "Segment" parameter that is explained as: Separate the molecule from its background.
"preprocess volumes" has a "Segmentation Type" parameter that is explained as: Type of segmentation.
"preprocess volumes" has a "Molecule Mass" parameter that is explained as: In automatic segmentation, set it to -1.
"preprocess volumes" has a "Normalize background" parameter that is explained as: Set background to have zero mean and standard deviation 1.
"preprocess volumes" has a "Mask Radius" parameter that is explained as: In pixels. Set to -1 for half of the size of the volume.
"preprocess volumes" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"preprocess volumes" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"preprocess volumes" has a "Invert contrast" parameter that is explained as: Invert the contrast if your particles are black overa white background.
"preprocess volumes" has a "Threshold" parameter that is explained as: Remove voxels below a certain value.
"preprocess volumes" has a "Fill with " parameter that is explained as: Select how are you going to fill the pixel valuesoutside the mask.
"preprocess volumes" has a "Threshold value" parameter that is explained as: Grey value below which all voxels should be set to 0.
"preprocess volumes" has a "Substitute by" parameter that is explained as: If you select: value: Selected are substitute by a desired value.            binarize: Selected are set to 0, non-selected to 1.                 avg: Average of non-selected.
"preprocess volumes" has a "Fill value" parameter that is explained as:  Substitute selected pixels by this value.
"preprocess volumes" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"preprocess volumes" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"preprocess volumes" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "projection matching" can be found in the xmipp3 plugin.
"projection matching" protocol help is as follows:
  3D reconstruction and classification using multireference projection matching.
"projection matching" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"projection matching" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"projection matching" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                   Select the one you want to use.
"projection matching" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"projection matching" has a "Input particles" parameter that is explained as: Select the input particles. 
 If you want perform *CTF* correction the input particles 
 should have information about the CTF (hasCTF=True)
"projection matching" has a "Use initial angles/shifts ? " parameter that is explained as: Set to *Yes* if you want to use the projection assignment (angles/shifts) 
 associated with the input particles (hasProjectionAssigment=True)
"projection matching" has a "Initial 3D reference volume" parameter that is explained as: Input 3D reference reconstruction.
"projection matching" has a "Clean up intermediate files?" parameter that is explained as: Save disc space by cleaning up intermediate files. 
 Be careful, many options of the visualization protocol will not work anymore, 
 since all class averages, selfiles etc will be deleted. 
"projection matching" has a "Perform CTF correction?" parameter that is explained as: If set to true, a CTF (amplitude and phase) corrected map will be refined, 
 and the data will be processed in CTF groups. 

 _NOTE_: You cannot combine CTF-correction with re-alignment of the classes. 
 Remember that CTF information should be provided in the images input file. 
 
"projection matching" has a "Make CTF groups automatically?" parameter that is explained as: Make CTF groups based on a maximum differences at a given resolution limit. 
 _NOTE_: If this option is set to false, a docfile with the defocus values where to  

 split the images in distinct defocus group has to be provided (see expert option below) 
 
"projection matching" has a "Maximum difference for grouping" parameter that is explained as: If the difference between the CTF-values up to the resolution limit specified 
 below is larger than the value given here, two images will be placed in 
 distinct CTF groups.
"projection matching" has a "Resolution limit (A) for grouping" parameter that is explained as: Maximum resolution where to consider CTF-differences among different groups. 
 One should use somewhat higher resolutions than those aimed for in the refinement.
"projection matching" has a "Set of defocus" parameter that is explained as: Set with defocus values where to split into groups. 
 This field is compulsory if you do not want to make the CTF groups automatically. 

 _NOTE_: The requested docfile can be made initially with the *xmipp_ctf_group* program, 
 and then it can be edited manually to suit your needs.
"projection matching" has a "Padding factor" parameter that is explained as: Application of CTFs to reference projections and of Wiener filter 
 to class averages will be done using padded images. 
 Use values larger than one to pad the images.
"projection matching" has a "Wiener constant" parameter that is explained as: Term that will be added to the denominator of the Wiener filter. 
 In theory, this value is the inverse of the signal-to-noise ratio 
 If a negative value is taken, the program will use a default value as in FREALIGN 
 (i.e. 10% of average sum terms over entire space)  
 see Grigorieff JSB 157 (2006) pp117-125
"projection matching" has a "Mask reference volumes" parameter that is explained as: Masking the reference volume will increase the signal to noise ratio. 
 Do not provide a very tight mask. 
 
"projection matching" has a "Radius of spherical mask (px)" parameter that is explained as: This is the radius (in pixels) of the spherical mask 
"projection matching" has a "Mask Object" parameter that is explained as: The mask file should have the same dimensions as your input particles. 
 The protein region should be 1 and the solvent should be 0.
"projection matching" has a "Number of iterations" parameter that is explained as: Number of iterations to perform.
"projection matching" has a "Inner radius for rotational correlation:" parameter that is explained as:  In pixels from the image center
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "8 8 2 2 " 
    specifies 4 iterations, the first two set the value to 8 
    and the last two to 2. An alternative compact notation 
    is ("2x8 2x0", i.e.,
    2 iterations with value 8, and 2 with value 2).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "Outer radius for rotational correlation" parameter that is explained as:  In pixels from the image center. Use a negative number to use the entire image.
    *WARNING*: this radius will be use for masking before computing resolution
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "8 8 2 2 " 
    specifies 4 iterations, the first two set the value to 8 
    and the last two to 2. An alternative compact notation 
    is ("2x8 2x0", i.e.,
    2 iterations with value 8, and 2 with value 2).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "Available memory to store all references (Gb)" parameter that is explained as:  This is only for the storage of the references. If your projections do not fit in memory, 
    the projection matching program will run MUCH slower. But, keep in mind that probably 
    some additional memory is needed for the operating system etc.
    Note that the memory per computing node needs to be given. That is, when using threads, 
    this value will be multiplied automatically by the number of (shared-memory) threads.
    
"projection matching" has a "Angular sampling rate (deg)" parameter that is explained as:  Angular distance (in degrees) between neighboring projection  points
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "8 8 2 2 " 
    specifies 4 iterations, the first two set the value to 8 
    and the last two to 2. An alternative compact notation 
    is ("2x8 2x0", i.e.,
    2 iterations with value 8, and 2 with value 2).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "Angular search range (deg)" parameter that is explained as:  Maximum change in rot & tilt  (in +/- degrees)
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1000 1000 10 10 " 
    specifies 4 iterations, the first two set the value to 1000 (no restriction)
    and the last two to 10degrees. An alternative compact notation 
    is ("2x1000 2x10", i.e.,
    2 iterations with value 1000, and 2 with value 10).
    <Note:> if there are less values than iterations the last value is reused
    <Note:> if there are more values than iterations the extra value are ignored
    
"projection matching" has a "Perturb projection directions?" parameter that is explained as:  If set to 1, this option will result to a Gaussian perturbation to the 
    evenly sampled projection directions of the reference library. 
    This may serve to decrease the effects of model bias.
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1 1 0" 
    specifies 3 iterations, the first two set the value to 1 
    and the last to 0. An alternative compact notation 
    is ("2x1 0", i.e.,
    2 iterations with value 1, and 1 with value 0).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "Projection method" parameter that is explained as: select projection method, by default Fourier with padding 1 and interpolation bspline
"projection matching" has a "Padding factor for projection" parameter that is explained as: Increase the padding factor will improve projection quality but 
    projection generation will be slower. In general padding 1 and spline is OK
    
"projection matching" has a "Interpolation kernel for projection" parameter that is explained as:  Interpolation kernel for the generation of projections.
    
"projection matching" has a "Maximum change in origin offset" parameter that is explained as:  Maximum shift allowed per iteration.
    You may specify this option for each iteration.
    This can be done by a sequence of numbers (for instance, "1000 10 5"
    specifies 3 iterations, the first two set the value to 1000
    (almost no restriction) and the last to 5.
    An alternative compact notation
    is ("2x1000 5", i.e.,
    2 iterations with value 1000, and 1 with value 5).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra values are ignored
    
"projection matching" has a "Search range for 5D translational search" parameter that is explained as:  Give search range from the image center for 5D searches (in +/- pixels).
    Values larger than 0 will results in 5D searches (which may be CPU-intensive)
    Give 0 for conventional 3D+2D searches. 
    Note that after the 5D search, for the optimal angles always 
    a 2D exhaustive search is performed anyway (making it ~5D+2D)
    Provide a sequence of numbers (for instance, "5 5 3 0" specifies 4 iterations,
    the first two set the value to 5, then one with 3, resp 0 pixels.
    An alternative compact notation is ("3x5 2x3 0", i.e.,
    3 iterations with value 5, and 2 with value 3 and the rest with 0).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
    
"projection matching" has a "Step size for 5D translational search" parameter that is explained as: " Provide a sequence of numbers (for instance, "2 2 1 1" specifies 4 iterations,
    the first two set the value to 2, then two with 1 pixel.
    An alternative compact notation is ("2x2 2x1", i.e.,
    2 iterations with value 2, and 2 with value 1).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "Restrict tilt angle search?" parameter that is explained as: Restrict tilt angle search 
 
"projection matching" has a "Lower-value for restricted tilt angle search" parameter that is explained as: Lower-value for restricted tilt angle search 
 
"projection matching" has a "Higher-value for restricted tilt angle search" parameter that is explained as: Higher-value for restricted tilt angle search 
 
"projection matching" has a "Point group symmetry" parameter that is explained as:  See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] for a description of the symmetry groups format.
If no symmetry is present, give c1. 
"projection matching" has a "Symmetry group for Neighbourhood computations" parameter that is explained as:  If you do not know what this is leave it blank.
    This symmetry will be using for compute neighboring points,
    but not for sampling or reconstruction
    See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]]
    for a description of the symmetry groups format
    If no symmetry is present, give c1
    
"projection matching" has a "compute only closest neighbor" parameter that is explained as: This option is only relevant if symmetryGroupNeighbourhood !=''
    If set to 1 only one neighbor will be computed per sampling point
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1 1 0" 
    specifies 3 iterations, the first two set the value to 1 
    and the last to 0. An alternative compact notation 
    is ("2x1 0", i.e.,
    2 iterations with value 1, and 1 with value 0).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "Discard images?" parameter that is explained as:  
    None : No images will be discarded.
    maxCC  : Minimum Cross Correlation, discard images with CC below a fixed value.
    percentage : Discard percentage of images with less CC.
    classPercentage: Discard percentage of images in each projection direction with less CC.
    Value of each option is set below.
    
"projection matching" has a "discard image if CC below" parameter that is explained as:  
    Discard images with cross-correlation (CC) below this value.
    Provide a sequence of numbers (for instance, "0.3 0.3 0.5 0.5" specifies 4 iterations,
    the first two set the value to 0.3, then two with 0.5.
    An alternative compact notation would be ("2x0.3 2x0.5").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "discard image percentage with less CC" parameter that is explained as:  
    Discard this percentage of images with less cross-correlation (CC)
    Provide a sequence of numbers (for instance, "20 20 10 10" specifies 4 iterations,
    the first two set the value to 20%, then two with 10%
    An alternative compact notation would be ("2x20 2x10").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    Set to zero to prevent discarding any images
    
"projection matching" has a "discard image percentage in class with less CC" parameter that is explained as:  
    Discard this percentage of images in each class(projection direction)
    with less cross-correlation (CC)    
    Provide a sequence of numbers (for instance, "20 20 10 10" specifies 4 iterations,
    the first two set the value to 20%, then two with 10%
    An alternative compact notation would be ("2x20 2x10").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    Set to zero to prevent discarding any images
    
"projection matching" has a "Perform scale search?" parameter that is explained as:  If true perform scale refinement. (UNDER DEVELOPMENT!!!!) 
  
"projection matching" has a "Step scale factors size" parameter that is explained as: Scale step factor size (1 means 0.01 in/de-crements around 1).
    Provide a sequence of numbers (for instance, "1 1 .5 .5" specifies 4 iterations,
    the first two set the value to 1%, then two with .5%
    An alternative compact notation would be ("2x1 2x0.5").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    Set to zero to prevent discarding any images
"projection matching" has a "Number of scale steps" parameter that is explained as:  
    Number of scale steps.
    With default values (ScaleStep='1' and ScaleNumberOfSteps='3'): 1 +/-0.01 | +/-0.02 | +/-0.03.    
    With values ScaleStep='2' and ScaleNumberOfSteps='4' it performs a scale search over:
    1 +/-0.02 | +/-0.04 | +/-0.06 | +/-0.08.    
    In general scale correction should only be applied to the last iteration. Do not use it unless
    your data is fairly well aligned.
    
"projection matching" has a "Additional options for Projection_Matching" parameter that is explained as:  For details see:
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Projection_matching][projection matching]] and
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Mpi_projection_matching][mpi projection matching]]
    try -Ri xx -Ro yy for restricting angular search (xx and yy are
    the particle inner and outter radius)
    
"projection matching" has a "Perform 2D re-alignment" parameter that is explained as: None
"projection matching" has a "Perform 2D re-alignment of classes?" parameter that is explained as:  After performing a 3D projection matching iteration, each of the
    subsets of images assigned to one of the library projections is
    re-aligned using a 2D-alignment protocol.
    This may serve to remove model bias.
    For details see:
    [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Align2d][align 2d]]
    Note that you cannot combine this option with CTF-correction!
    You may specify this option for each iteration. 
    This can be done by a sequence of 0 or 1 numbers (for instance, "1 1 0 0" 
    specifies 4 iterations, the first two applied alig2d while the last 2
    dont. An alternative compact notation is 
    is ("2x1 2x0", i.e.,
    2 iterations with value 1, and 2 with value 0).
    *Note:*if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    *IMPORTANT:* if you set this variable to 0 the output  of the projection
    muching step will be copied as output of align2d
    
"projection matching" has a "Number of align2d iterations:" parameter that is explained as:  Use at least 3 iterations
    The number of align iteration may change in each projection matching iteration
    Ffor instance, "4 4 3 3 " 
    specifies 4 alig2d iterations in the first projection matching iteration 
    and  two 3 alig2d iteration in the last 2 projection matching iterations.
    An alternative compact notation 
    is ("2x4 2x3", i.e.,
    2 iterations with value 4, and 2 with value 3).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "Maximum change in origin offset (+/- pixels)" parameter that is explained as: Maximum change in shift  (+/- pixels)
    You must specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1000 1000 10 10 " 
    specifies 4 iterations, the first two set the value to 1000 (no restriction)
    and the last two to 10degrees. An alternative compact notation 
    is ("2x1000 2x10", i.e.,
    2 iterations with value 1000, and 2 with value 10).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "Maximum change in rotation (+/- degrees)" parameter that is explained as: Maximum change in shift  (+/- pixels)
    You must specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1000 1000 10 10 " 
    specifies 4 iterations, the first two set the value to 1000 (no restriction)
    and the last two to 10degrees. An alternative compact notation 
    is ("2x1000 2x10", i.e.,
    2 iterations with value 1000, and 2 with value 10).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "Reconstruction method" parameter that is explained as:  Select what reconstruction method to use.
    fourier: Fourier space interpolation (with griding).
    art: Agebraic reconstruction technique
    wbp : Weight back project method.
    
"projection matching" has a "Initial maximum frequency" parameter that is explained as:  This number is only used in the first iteration. 
    From then on, it will be set to resolution computed in the resolution section
    
"projection matching" has a "Additional parameters for fourier" parameter that is explained as:  For details see:
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Fourier][fourier]]
    
"projection matching" has a "Values of lambda for ART" parameter that is explained as:  *IMPORTANT:* ou must specify a value of lambda for each iteration even
    if ART has not been selected.
    *IMPORTANT:* NOte that we are using the WLS version of ART that 
    uses geater lambdas than the plain art.
    See for details:
    [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Art][xmipp art]]
    You must specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, ".1 .1 .3 .3" 
    specifies 4 iterations, the first two set the value to 0.1 
    (no restriction)
    and the last  two to .3. An alternative compact notation 
    is ("2x.1 2x.3").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "Additional parameters for ART" parameter that is explained as:  For details see:
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Art][xmipp art]]
    
"projection matching" has a "Additional parameters for WBP" parameter that is explained as:  For details see:
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Wbp][xmipp wbp]]
    
"projection matching" has a "Compute resolution?" parameter that is explained as:  For details see:
    [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Resolution][xmipp resolution]].
    
"projection matching" has a "Split references averages?" parameter that is explained as: In theory each reference average should be splited
    in two when computing the resolution. In this way each
    projection direction will be represented in each of the
    subvolumes used to compute the resolution. A much faster
    but less accurate approach is to split the 
    proyection directions in two but not the averages. We
    recommend the first approach for small volumes and the second for
    large volumes (especially when using small angular
    sampling rates.
    *IMPORTANT:* the second option has ONLY been implemented for FOURIER
    reconstruction method. Other reconstruction methods require this
    flag to be set to True
    You may specify this option for each iteration. 
    This can be done by a sequence of 0 or 1 numbers (for instance, "1 1 0 0" 
    specifies 4 iterations, the first two split the images   while the last 2
    don't. an alternative compact notation is 
    is ("2x1 2x0", i.e.,
    2 iterations with value 1, and 2 with value 0).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more vapplications/scripts/protocols/new_protocol_projmatch.pyalues than iterations the extra value are ignored
    
"projection matching" has a "Low-pass filter the reference?" parameter that is explained as: None
"projection matching" has a "Use estimated resolution for low-pass filtering?" parameter that is explained as:  If set to true, the volume will be filtered at a frecuency equal to
   the  resolution computed with a FSC=0.5 threshold, possibly 
   plus a constant provided by the user in the next input box. 

   If set to false, then the filtration will be made at the constant 
   value provided by the user in the next box (in digital frequency, 
   i.e. pixel^-1: minimum 0, maximum 0.5)
    
"projection matching" has a "Constant to be added to the estimated resolution" parameter that is explained as:  The meaning of this field depends on the previous flag.
    If set to true, then the volume will be filtered at a frequency equal to
    the  resolution computed with resolution_fsc (FSC=0.5) plus the value 
    provided in this field 
    If set to false, the volume will be filtered at the resolution
    provided in this field 
    This value is in digital frequency, or pixel^-1: minimum 0, maximum 0.5
    
    If you detect correlation between noisy regions decrease this value 
    (even to negative values)
    
    You can specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, ".15 .15 .1 .1"
    specifies 4 iterations, the first two set the constant to .15
    and the last two to 0.1. An alternative compact notation 
    is ("2x.15 2x0.1", i.e.,
    4 iterations with value 0.15, and three with value .1).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "Constant to be added to the reconstruction maximum frequency" parameter that is explained as:  The meaning of this field depends on the <use FSC for filter> flag.
    If set to true, then the volume will be reconstructed up to the frequency equal to
    the resolution computed with resolution_fsc (FSC=0.5) plus the value 
    provided in this field 
    If set to false, the volume will be reconstructed up to the resolution
    provided in this field 
    This value is in digital frequency, or pixel^-1: minimum 0, maximum 0.5
    
    You can specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, ".15 .15 .1 .1" 
    specifies 4 iterations, the first two set the constant to .15
    and the last two to 0.1. An alternative compact notation 
    is ("2x.15 2x0.1", i.e.,
    4 iterations with value 0.15, and three with value .1).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
"projection matching" has a "MPI job size" parameter that is explained as: Minimum size of jobs in mpi processes.
    Set to 1 for large images (e.g. 500x500)
    and to 10 for small images (e.g. 100x100)
    
"projection matching" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"projection matching" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"projection matching" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "random conical tilt" can be found in the xmipp3 plugin.
"random conical tilt" protocol help is as follows:
 Creates initial volumes by using a set of projections/classes
    from a tilted-pair picking process and using RCT algorithm. .
"random conical tilt" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"random conical tilt" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"random conical tilt" has a "Input particles tilt pair" parameter that is explained as: Select the input particles tilt pair file that will be used.  file. This file is used to associate each micrograph with its tilted equivalent.
"random conical tilt" has a "Input classes" parameter that is explained as: Select the input images or classes from the project.
"random conical tilt" has a "Thin Object" parameter that is explained as: If the object is thin, then the tilted projections can be stretched to match the untilted projections
"random conical tilt" has a "Maximum allowed shift for tilted particles (pixels)" parameter that is explained as: Particles that shift more will be discarded. A value larger than the image size will not discard any particle.
"random conical tilt" has a "Skip tilted translation alignment" parameter that is explained as: If the tilted image quality is very low, then this alignment might result in poor estimates.
"random conical tilt" has a "Additional reconstruction parameters" parameter that is explained as: See: http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Reconstruct_art_v31
"random conical tilt" has a "Filter reconstructed volumes?" parameter that is explained as: Filtering may be useful to remove noise, especially when few particles contribute to the reconstruction.
"random conical tilt" has a "Resolution of the low-pass filter (dig.freq)" parameter that is explained as: Resolution of the low-pass filter (dig.freq)
"random conical tilt" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"random conical tilt" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"random conical tilt" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "ransac" can be found in the xmipp3 plugin.
"ransac" protocol help is as follows:
  
    Computes an initial 3d model from a set of projections/classes 
    using RANSAC algorithm.
    
    This method is based on an initial non-lineal dimensionality
    reduction approach which allows to select representative small 
    sets of class average images capturing the most of the structural 
    information of the particle under study. These reduced sets are 
    then used to generate volumes from random orientation assignments. 
    The best volume is determined from these guesses using a random 
    sample consensus (RANSAC) approach.    
     .
"ransac" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"ransac" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"ransac" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"ransac" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"ransac" has a "Input averages" parameter that is explained as: Select the input images from the project.It should be a SetOfClasses2D object
"ransac" has a "Symmetry group" parameter that is explained as: See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format in Xmipp.
If no symmetry is present, use _c1_.
"ransac" has a "Angular sampling rate" parameter that is explained as: In degrees. This sampling defines how fine the projection gallery from the volume is explored.
"ransac" has a "Number of RANSAC iterations" parameter that is explained as: Number of initial volumes to test by RANSAC
"ransac" has a "Perform dimensionality reduction" parameter that is explained as: The dimensionality reduction is performed using the Local Tangent SpaceAlignment. See http://www.stat.missouri.edu/~ys873/research/LTSA11.pdf
"ransac" has a "Number of grids per dimension" parameter that is explained as: Number of squares to sample the classes
"ransac" has a "Number of random samples" parameter that is explained as: Number of squares to sample the classes
"ransac" has a "Inliers threshold" parameter that is explained as: Correlation value threshold to determine if an experimental projection is an inlier or outlier.
"ransac" has a "Number of best volumes to refine" parameter that is explained as: Number of best volumes to refine using projection matching approach and the input classes
"ransac" has a "Number of iterations to refine the volumes" parameter that is explained as: Number of iterations to refine the best volumes using projection matching approach and the input classes
"ransac" has a "Initial volume" parameter that is explained as: You may provide a very rough initial volume as a way to constraint the angular search.For instance, when reconstructing a fiber, you may provide a cylinder so that side viewsare assigned to the correct tilt angle, although the rotational angle may be completely wrong
"ransac" has a "Max frequency of the initial volume" parameter that is explained as:  Max frequency of the initial volume in Angstroms
"ransac" has a "Use all images to refine" parameter that is explained as:  When refining a RANSAC volume, use all images to refine it instead of only inliers
"ransac" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"ransac" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"ransac" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "reconstruct fourier" can be found in the xmipp3 plugin.
"reconstruct fourier" protocol help is as follows:
     
    Reconstruct a volume using Xmipp_reconstruct_fourier from a given set of particles.
    The alignment parameters will be converted to a Xmipp xmd file
    and used as direction projections to reconstruct.
    .
"reconstruct fourier" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"reconstruct fourier" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"reconstruct fourier" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"reconstruct fourier" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"reconstruct fourier" has a "Input particles" parameter that is explained as: Select the input images from the project.
"reconstruct fourier" has a "Symmetry group" parameter that is explained as: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
"reconstruct fourier" has a "Maximum resolution (A)" parameter that is explained as: Maximum resolution (in Angstrom) to consider 
in Fourier space (default Nyquist).
Param *--maxres* in Xmipp.
"reconstruct fourier" has a "Projection" parameter that is explained as: None
"reconstruct fourier" has a "Volume" parameter that is explained as: None
"reconstruct fourier" has a "Legacy version" parameter that is explained as: Use original CPU version of the algorithm. This should not be necessary, but it's present to ensure backward compatibility
"reconstruct fourier" has a "Approximative version" parameter that is explained as: If on, an approximation of the original algorithm will be used. This will result in faster processing times, but (slightly) less precise result
"reconstruct fourier" has a "Extra parameters: " parameter that is explained as: Extra parameters to *xmipp_(cuda_)reconstruct_fourier* program:

                      --iter () : Subtract projections of this map from the images used for reconstruction
                      
"reconstruct fourier" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"reconstruct fourier" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"reconstruct fourier" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "highres" can be found in the xmipp3 plugin.
"highres" protocol help is as follows:
 This is a 3D refinement protocol whose main input is a volume and a set of particles.
       The set of particles has to be at full size (the finer sampling rate available), but
       the rest of inputs (reference volume and masks) can be at any downsampling factor.
       The protocol scales the input images and volumes to a reasonable size depending on
       the resolution of the previous iteration.
       
       The protocol works with any input volume, whichever its resolution, as long as it
       is a reasonable initial volume for the set of particles. The protocol does not
       resolve the heterogeneous problem (it assumes an homogeneous population),
       although it is somewhat tolerant through the use of particle weights in the
       reconstruction process.
       
       It is recommended to perform several global alignment iterations before entering
       into the local iterations. The switch from global to local should be performed when
       a substantial percentage of the particles do not move from one iteration to the next.
       
       The algorithm reports the cross correlation (global alignment) or cost (local) function
       per defocus group, so that we can see which was the percentile of each particle in its
       defocus group. You may want to perform iterations one by one, and remove from one
       iteration to the next, those particles that worse fit the model..
"highres" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"highres" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"highres" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"highres" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"highres" has a "Continue from a previous run?" parameter that is explained as: If you set to *Yes*, you should select a previousrun of type *XmippProtReconstructHighRes* class and some of the input parameterswill be taken from it.
"highres" has a "Full-size Images" parameter that is explained as: Select a set of images at full resolution
"highres" has a "Initial volumes" parameter that is explained as: Select a set of volumes with 2 volumes or a single volume. If the input particles have an angular assignment, then you may leave empty this field and a 3D reconstruction of the input images is performed using reconstruct_fourier.
"highres" has a "Radius of particle (px)" parameter that is explained as: This is the radius (in pixels) of the spherical mask covering the particle in the input images
"highres" has a "Select previous run" parameter that is explained as: Select a previous run to continue from.
"highres" has a "Symmetry group" parameter that is explained as: If no symmetry is present, give c1
"highres" has a "Remove intermediate files" parameter that is explained as: None
"highres" has a "Low pass filter?" parameter that is explained as: Apply a low pass filter to the previous iteration whose maximum frequency is the current resolution(A) + resolutionOffset(A). If resolutionOffset>0, then fewer informationis used (meant to avoid overfitting). If resolutionOffset<0, then more information is allowed (meant for a greedy convergence).
"highres" has a "FSC criterion" parameter that is explained as: The resolution of the reconstruction is defined as the inverse of the frequency at which the FSC drops below this value. Typical values are 0.143 and 0.5
"highres" has a "Resolution offset (A)" parameter that is explained as: None
"highres" has a "Spherical mask?" parameter that is explained as: Apply a spherical mask of the size of the particle. If the postprocessing indicates that it has helical symmetry,then a cylindrical mask is applied
"highres" has a "Positivity?" parameter that is explained as: Remove from the next reference all negative values
"highres" has a "Mask" parameter that is explained as: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
"highres" has a "Dropout" parameter that is explained as: This is the probability with which voxels are dropped (set to 0.0) inside the binary mask
"highres" has a "Next reference command" parameter that is explained as: A command template that is used to generate next reference. The following variables can be used %(sampling)s %(dim)s %(volume)s %(iterDir)s. The command should read Spider volumes and modify the input volume.the command should be accessible either from the PATH or provide the absolute path.
Examples: 
xmipp_transform_filter -i %(volume)s --fourier low_pass 15 --sampling %(sampling)s
/home/joe/myScript %(volume)s sampling=%(sampling)s dim=%(dim)s
"highres" has a "Remove reference to save space?" parameter that is explained as: Remove reference volumes once they are not needed any more.
"highres" has a "" parameter that is explained as: None
"highres" has a "Multiresolution approach" parameter that is explained as: In the multiresolution approach the sampling rate of the images is adapted to the current resolution
"highres" has a "Max. shift (%)" parameter that is explained as: Maximum shift as a percentage of the image size
"highres" has a "Min." parameter that is explained as: Side views are around 90 degrees, top views around 0
"highres" has a "Max." parameter that is explained as: You may generate redudant galleries by setting this angle to 180, this may help if c1 symmetry is considered
"highres" has a "Image alignment" parameter that is explained as: None
"highres" has a "Number of iterations" parameter that is explained as: None
"highres" has a "Random subset size" parameter that is explained as: Stochastic alignment is performed by taking random subsets of images of this size
"highres" has a "Step size" parameter that is explained as: The update is performed as V(k+1)=(1-alpha)*V(k)+alpha*R(k+1), that is, the previous volume weights 1-alpha, while the new one weights alpha
"highres" has a "Restrict reconstruction angles" parameter that is explained as: You may reconstruct only with those images falling on a certain range. This is particularly useful for helices where you may want to use projections very close to 90 degrees
"highres" has a "Min." parameter that is explained as: Perform an angular assignment and only use those images whose angles are within these limits
"highres" has a "Max." parameter that is explained as: Perform an angular assignment and only use those images whose angles are within these limits
"highres" has a "Max. Target Resolution" parameter that is explained as: In Angstroms. The actual maximum resolution will be the maximum between this number of 0.5 * previousResolution, meaning thatin a single step you cannot increase the resolution more than 1/2
"highres" has a "" parameter that is explained as: The gallery of reprojections is randomly perturbed this number of times
"highres" has a "" parameter that is explained as: Significant alignment is allowed to replicate each image up to this number of times
"highres" has a "Optimize shifts?" parameter that is explained as: Optimize shifts within a limit
"highres" has a "Max. shift variation" parameter that is explained as: Percentage of the image size
"highres" has a "Optimize scale?" parameter that is explained as: Optimize scale within a limit
"highres" has a "Max. scale variation" parameter that is explained as: None
"highres" has a "Optimize angles?" parameter that is explained as: Optimize angles within a limit
"highres" has a "Optimize gray values?" parameter that is explained as: Optimize gray values. Do not perform this unless the reconstructed volume is gray-compatible with the projections, i.e., the volumes haven been produced from projections
"highres" has a "Max. gray scale variation" parameter that is explained as: None
"highres" has a "Max. gray shift variation" parameter that is explained as: As a factor of the image standard deviation
"highres" has a "Optimize defocus?" parameter that is explained as: None
"highres" has a "Max. defocus variation" parameter that is explained as: In Angstroms
"highres" has a "Fourier padding factor" parameter that is explained as: The volume is zero padded by this factor to produce projections
"highres" has a "Weight by SSNR?" parameter that is explained as: Weight input images by SSNR
"highres" has a "Weight by Continuous cost?" parameter that is explained as: Weight input images by angular assignment cost
"highres" has a "Weight by angular stability?" parameter that is explained as: Weight input images by angular stability between iterations
"highres" has a "Weight by CC percentile?" parameter that is explained as: Weight input images by their fitness (cross correlation) percentile in their defocus group
"highres" has a "Minimum CC weight" parameter that is explained as: Weights are between this value and 1. If most of the particles are good, this value should be high (e.g., 0.9)
"highres" has a "Mask" parameter that is explained as: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
"highres" has a "Symmetrize volume within mask?" parameter that is explained as: None
"highres" has a "Mask symmetry" parameter that is explained as: If no symmetry is present, give c1
"highres" has a "Mask" parameter that is explained as: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
"highres" has a "Apply helical symmetry?" parameter that is explained as: None
"highres" has a "Radius" parameter that is explained as: In Angstroms
"highres" has a "Dihedral symmetry" parameter that is explained as: None
"highres" has a "Min. Rotation" parameter that is explained as: In degrees
"highres" has a "Max. Rotation" parameter that is explained as: In degrees
"highres" has a "Min. Z shift" parameter that is explained as: In angstroms
"highres" has a "Max. Z shift" parameter that is explained as: In angstroms
"highres" has a "Post-processing command" parameter that is explained as: A command template that is used to post-process the reconstruction. The following variables can be used %(sampling)s %(dim)s %(volume)s %(iterDir)s. The command should read Spider volumes and modify the input volume.the command should be accessible either from the PATH or provide the absolute path.
Examples: 
xmipp_transform_filter -i %(volume)s --fourier low_pass 15 --sampling %(sampling)s
/home/joe/myScript %(volume)s sampling=%(sampling)s dim=%(dim)s
"highres" has a "Significant denoising Real space" parameter that is explained as: None
"highres" has a "Significant denoising Fourier space" parameter that is explained as: None
"highres" has a "Laplacian denoising" parameter that is explained as: It can only be used if there is a mask
"highres" has a "Blind deconvolution" parameter that is explained as: None
"highres" has a "Attenuate undershooting" parameter that is explained as: None
"highres" has a "Attenuate undershooting (K)" parameter that is explained as: Values below avg-K*sigma are attenuated
"highres" has a "Evaluate difference" parameter that is explained as: None
"highres" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"highres" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"highres" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "reconstruct significant" can be found in the xmipp3 plugin.
"reconstruct significant" protocol help is as follows:
 
    This algorithm addresses the initial volume problem in SPA
    by setting it in a Weighted Least Squares framework and
    calculating the weights through a statistical approach based on
    the cumulative density function of different image similarity measures.
    .
"reconstruct significant" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"reconstruct significant" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"reconstruct significant" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"reconstruct significant" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"reconstruct significant" has a "Input classes" parameter that is explained as: Select the input classes2D from the project.
It should be a SetOfClasses2D class with  class representative
"reconstruct significant" has a "Symmetry group" parameter that is explained as: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]]for a description of the symmetry groups format. If no symmetry is present, give c1.
"reconstruct significant" has a "Is there a reference volume(s)?" parameter that is explained as: You may use a reference volume to initialize  the calculations. For instance, this is very  useful to obtain asymmetric volumes from symmetric  references. The symmetric reference  is provided as starting point, choose no symmetry  group (c1), and reconstruct_significantwill tend to break the symmetry finding a suitable  volume. The reference volume can also be useful, for instance, when reconstructing a fiber.  Provide in this case a cylinder of a  suitable size.
"reconstruct significant" has a "Initial 3D reference volumes" parameter that is explained as: None
"reconstruct significant" has a "Angular sampling" parameter that is explained as: Angular sampling in degrees for generating the projection gallery.
"reconstruct significant" has a "Minimum tilt (deg)" parameter that is explained as: Use the minimum and maximum tilts to limit the  angular search. This can be useful, for instance, in the reconstruction of fibers from side views. 0 degrees is a top view, while 90 degrees is a  side view.
"reconstruct significant" has a "Maximum tilt (deg)" parameter that is explained as: Use the minimum and maximum tilts to limit the  angular search. This can be useful, for instance, in the reconstruction of fibers from side views. 0 degrees is a top view, while 90 degrees is a  side view.
"reconstruct significant" has a "Maximum shift (px):" parameter that is explained as: Set to -1 for free shift search
"reconstruct significant" has a "Keep intermediate volumes" parameter that is explained as: Keep all volumes and angular assignments along  iterations
"reconstruct significant" has a "Use new maximum resolution?" parameter that is explained as: You may use a new maximum resolution to simplify the calculations keeping only low frequency information.
"reconstruct significant" has a "Target resolution" parameter that is explained as: Target resolution (A).
"reconstruct significant" has a "Starting significance" parameter that is explained as: 80 means 80% of significance. Use larger numbers to relax the starting significance and have a  smoother landscape of solutions
"reconstruct significant" has a "Number of iterations" parameter that is explained as: Number of iterations to go from the initial  significance to the final one
"reconstruct significant" has a "Final significance" parameter that is explained as: 99.5 means 99.5% of significance. Use smaller  numbers to be more strict and have a sharper  reconstruction. Be aware that if you are too strict, you may end with very few projections  and the reconstruction becomes verynoisy.
"reconstruct significant" has a "Use IMED" parameter that is explained as: Use IMED for the weighting. IMED is an alternative to correlation that can discriminate better among very similar images
"reconstruct significant" has a "Strict direction" parameter that is explained as: If the direction  is strict, then only the most  significant experimental images can contribute  to it. As a consequence, many experimental classes are lost and only the best contribute to the 3D reconstruction. Be aware that only the best can be very few depending on the cases.
"reconstruct significant" has a "Angular neighborhood" parameter that is explained as: Images in an angular neighborhood also determines the weight of each image. It should be at least  twice the angular sampling
"reconstruct significant" has a "Do not apply Fisher" parameter that is explained as: Images are preselected using Fisher's confidence interval on the correlation coefficient. Check this box if you do not want to make this preselection.
"reconstruct significant" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"reconstruct significant" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"reconstruct significant" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "swarm consensus" can be found in the xmipp3 plugin.
"swarm consensus" protocol help is as follows:
 This is a 3D refinement protocol whose main input is a set of volumes and a set of particles.
       The set of particles has to be at full size (the finer sampling rate available), but
       the rest of inputs (reference volume and masks) can be at any downsampling factor.
       The protocol scales the input images and volumes to a size that depends on the target resolution.

       The input set of volumes is considered to be a swarm of volumes and they try to optimize
       the correlation between the volumes and the set of particles. This is an stochastic maximization
       and only a fraction of the particles are used to update the volumes and evaluate them.
    .
"swarm consensus" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"swarm consensus" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"swarm consensus" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"swarm consensus" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"swarm consensus" has a "Full-size Images" parameter that is explained as: Select a set of images at full resolution
"swarm consensus" has a "Initial volumes" parameter that is explained as: Select a set of volumes with 2 volumes or a single volume
"swarm consensus" has a "Radius of particle (px)" parameter that is explained as: This is the radius (in pixels) of the spherical mask covering the particle in the input images
"swarm consensus" has a "Symmetry group" parameter that is explained as: See http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups formatIf no symmetry is present, give c1
"swarm consensus" has a "Mask" parameter that is explained as: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
"swarm consensus" has a "Number of iterations" parameter that is explained as: None
"swarm consensus" has a "Max. Target Resolution" parameter that is explained as: In Angstroms.
"swarm consensus" has a "Min. Angle" parameter that is explained as: The angular search is limited by this parametr (in degrees).
"swarm consensus" has a "# Images to update" parameter that is explained as: None
"swarm consensus" has a "# Images to evaluate" parameter that is explained as: None
"swarm consensus" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"swarm consensus" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"swarm consensus" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "resolution 3D" can be found in the xmipp3 plugin.
"resolution 3D" protocol help is as follows:
  Computes resolution by several methods .
"resolution 3D" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"resolution 3D" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"resolution 3D" has a "Volume to compare" parameter that is explained as: This volume will be compared to the reference volume.
"resolution 3D" has a "Calculate FSC and DPR?" parameter that is explained as: If set True calculate FSC and DPR.
"resolution 3D" has a "Reference volume" parameter that is explained as: Input volume will be compared to this volume.
"resolution 3D" has a "Calculate B-factor?" parameter that is explained as: If set True the so-called B-factor will be estimated.
The B-factor can be used to sharpen a volume.
The high-resolution features will enhanced, thereby
correcting the envelope functions of the microscope,
detector etc. This implementation follows the
automated mode based on methodology developed by Rosenthal2003

*Note*: after finished, you can apply the B-factor through
   the _Analyze Results_ GUI.

The protocol named "resolution alignment" can be found in the xmipp3 plugin.
"resolution alignment" protocol help is as follows:
     
    Given two half maps the protocol estimates if the reconstruction presents angular
    alignment errors. To do that, a set of directional FSC along all possible directions
    are estimated. The result is a curve Resolution-radius. If this curve presents a slope
    then the map present angular assignment errors, but it the graph is flat (horizontal), the map
    is error free. Note that this protocol generates a plot, not a Scipion object. Its result
    can only be visualized.
    .
"resolution alignment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"resolution alignment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"resolution alignment" has a "Are the half volumes stored with the input volume?" parameter that is explained as: Usually, the half volumes are stored as properties of the input volume. If this is not the case, set this to False and specify the two halves you want to use.
"resolution alignment" has a "Input Half Maps" parameter that is explained as: Select a half maps for determining its  resolution anisotropy and resolution.
"resolution alignment" has a "Half Map 1" parameter that is explained as: Select one map for determining the directional FSC resolution.
"resolution alignment" has a "Half Map 2" parameter that is explained as: Select the second map for determining the directional FSC resolution.
"resolution alignment" has a "Mask" parameter that is explained as: The mask determines which points are specimen and which are not
"resolution alignment" has a "Is a the protein a helix" parameter that is explained as: blablabla
"resolution alignment" has a "Limit the protein radius" parameter that is explained as: blablabla
"resolution alignment" has a "use directional fsc" parameter that is explained as: blablabla
"resolution alignment" has a "Cone Angle" parameter that is explained as: Angle between the axis of the cone and the generatrix. An angle of 17 degrees is the best angle (see publicationVilas 2021) to measuare directional FSCs
"resolution alignment" has a "FSC Threshold" parameter that is explained as: Threshold for the fsc. By default the standard 0.143. Other common thresholds are 0.5 and 0.3.
"resolution alignment" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"resolution alignment" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "rotate volume" can be found in the xmipp3 plugin.
"rotate volume" protocol help is as follows:
  Rotate a volume around x,y,z .
"rotate volume" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"rotate volume" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"rotate volume" has a "Volume " parameter that is explained as: Specify a volume.
"rotate volume" has a "Rotation mode: " parameter that is explained as: Align (x,y,z) with Z axis
"rotate volume" has a "Axis: " parameter that is explained as: Align (x,y,z) with Z axis
"rotate volume" has a "Degrees: " parameter that is explained as: degrees of rotation in selected axis

The protocol named "rotational symmetry" can be found in the xmipp3 plugin.
"rotational symmetry" protocol help is as follows:
 
    Estimate the orientation of a rotational axis and symmetrize.
    The user should know the order of the axis (two-fold, three-fold, ...)
    If this is unknown you may try several and see the most consistent results.
    .
"rotational symmetry" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"rotational symmetry" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"rotational symmetry" has a "Input volume" parameter that is explained as: None
"rotational symmetry" has a "Symmetry order" parameter that is explained as: 3 for a three-fold symmetry axis, 4 for a four-fold symmetry axis, ...
"rotational symmetry" has a "Search mode" parameter that is explained as: None
"rotational symmetry" has a "Initial rotational angle" parameter that is explained as: In degrees
"rotational symmetry" has a "Initial tilt angle" parameter that is explained as: In degrees. tilt=0 is a top axis while tilt=90 defines a side axis
"rotational symmetry" has a "Min" parameter that is explained as: None
"rotational symmetry" has a "Max" parameter that is explained as: None
"rotational symmetry" has a "Step" parameter that is explained as: None
"rotational symmetry" has a "Min" parameter that is explained as: None
"rotational symmetry" has a "Max" parameter that is explained as: None
"rotational symmetry" has a "Step" parameter that is explained as: None
"rotational symmetry" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"rotational symmetry" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "deep consensus picking" can be found in the xmipp3 plugin.
"deep consensus picking" protocol help is as follows:
  Protocol to compute a smart consensus between different particle picking
        algorithms. The protocol takes several Sets of Coordinates calculated
        by different programs and/or different parameter settings. Let's say:
        we consider N independent pickings. Then, a neural network is trained
        using different subset of picked and not picked cooridantes. Finally,
        a coordinate is considered to be a correct particle according to the
        neural network predictions.
        In streaming, the network is trained and used to predict in batches.
        The network is trained until the number of particles set is reached,
        meanwhile, a preliminary output is generated. Once the threshold is reached,
        the final output is produced by batches.
    .
"deep consensus picking" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"deep consensus picking" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"deep consensus picking" has a "" parameter that is explained as: Set to true if you want to use GPU implementation 
"deep consensus picking" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
"deep consensus picking" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"deep consensus picking" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"deep consensus picking" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"deep consensus picking" has a "Select model type" parameter that is explained as: If you set to *New*, a new model randomly initialized will be employed. If you set to *Pretrained* a pretrained model will be used. If you set to *PreviousRun*, a model trained in a previous run, within this project, will be employed
"deep consensus picking" has a "Select previous run" parameter that is explained as: Select a previous run to continue from.
"deep consensus picking" has a "Skip training and score directly with pretrained model?" parameter that is explained as: If you set to *No*, you should provide training set. If set to *Yes* the coordinates will be directly scored using the pretrained/previous model
"deep consensus picking" has a "Input coordinates" parameter that is explained as: Select the set of coordinates to compare
"deep consensus picking" has a "Relative Radius" parameter that is explained as: All coordinates within this radius (as fraction of particle size) are presumed to correspond to the same particle
"deep consensus picking" has a "Tolerance threshold" parameter that is explained as: The method attach a score between 0 and 1, where 0 if for _bad_ particles and 1 for _good_ ones. Introduce -1 to let pass all for posterior inspection.
"deep consensus picking" has a "How to extract particles from micrograph" parameter that is explained as: Our method, internally, uses particles that are extracted from preprocess micrographs. Preprocess steps are:
1) mic donwsampling to the required size such that the particle box size become 128 px. 
   E.g. xmipp_transform_downsample -i in/100_movie_aligned.mrc -o out1/100_movie_aligned.mrc --step newSamplingRate --method fourier
2) mic normalization to 0 mean and 1 std and mic contrast inversion to have white particles.
   E.g.  xmipp_transform_normalize -i out1/101_movie_aligned.mrc -o out2/101_movie_aligned.mrc --method OldXmipp [ --invert ]
3) particles extraction.
   E.g. xmipp_micrograph_scissor  -i out2/101_movie_aligned.mrc --pos particles@Runs/101_movie_aligned.pos -o out3/105_movie_aligned_particles  --Xdim 128 --downsampling newSamplingRate --fillBorders  ( Correct your coordinates with newSamplingRate if needed)
4) OPTIONAL: phase flipping using CTF.
 xmipp_ctf_phase_flip  -i particles/105_movie_aligned_noDust.xmp -o particles/105_movie_aligned_flipped.xmp --ctf ctfPath/105_movie_aligned.ctfParam --sampling newSamplingRate
"deep consensus picking" has a "Did you invert the micrographs contrast (particles are bright now)?" parameter that is explained as: If you invert the contrast, your particles will be white over a black background in the micrograph. We use white particles. Select *No* if you already have inverted the constrast in the micrograph so that we can extract white particles directly
"deep consensus picking" has a "Ignore CTF" parameter that is explained as: Deep Consensus extracts particles. Do you want to ignore CTF for particle extraction
"deep consensus picking" has a "CTF estimation" parameter that is explained as: Choose some CTF estimation related to input micrographs. 
CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
"deep consensus picking" has a "Number of epochs" parameter that is explained as: Number of epochs for neural network training.
"deep consensus picking" has a "Learning rate" parameter that is explained as: Learning rate for neural network training
"deep consensus picking" has a "Auto stop training when convergency is detected?" parameter that is explained as: If you set to *Yes*, the program will automatically stop training if there is no improvement for consecutive 2 epochs, learning rate will be decreased by a factor 10. If learningRate_t < 0.01*learningrate_0 training will stop. Warning: Sometimes convergency seems to be reached, but after time, improvement can still happen. Not recommended for very small data sets (<100 true particles)
"deep consensus picking" has a "Training mean val_acc threshold" parameter that is explained as: Stop training if at any training batch the selected threshold is achieved
"deep consensus picking" has a "Regularization strength" parameter that is explained as: L2 regularization for neural network weights.Make it bigger if suffering overfitting (validation acc decreases but training acc increases)
Typical values range from 1e-1 to 1e-6
"deep consensus picking" has a "Number of models for ensemble" parameter that is explained as: Number of models to fit in order to build an ensamble. Tipical values are 1 to 5. The more the better until a point where no gain is obtained. Each model increases running time linearly
"deep consensus picking" has a "Expected number of particles to use for training" parameter that is explained as: Number of particles for training the CNN. Once surpassed, there will not be more training
Set to -1 to use all the particles found
It will determine the size of the CNNUsually, the bigger the better, but more training data is needed
Three CNN sizes: n < 1500 | 1500 <= n < 20000 | n >= 20000
"deep consensus picking" has a "Perform testing after training?" parameter that is explained as: If you set to *Yes*, you should select a testing positive set and a testing negative set
"deep consensus picking" has a "Set of positive test particles" parameter that is explained as: Select the set of ground true positive particles.
"deep consensus picking" has a "Set of negative test particles" parameter that is explained as: Select the set of ground false positive particles.
"deep consensus picking" has a "Additional training data" parameter that is explained as: If you set to *None*, only the AND and RANDOM will be used for training.
If you set to *Precompiled*, a precompiled additional training set will be added to to the AND and RANDOM sets for training.
If you set to *Custom*, you can provide your own data that will be added to the AND and RANDOM sets for training.

"deep consensus picking" has a "Additional training data" parameter that is explained as: You can provide either particles or coordinates as additional training set.If you provide coordinantes, they have to be picked from the same micrographs that theinputs
 If you provide particles, they have to be processed in the same way that the protocoldoes (128x128 pixels and withe particles). Thus, what the protocol does is to perform the following steps:
1) mic donwsampling to the required size such that the particle box size become 128 px. 
   E.g. xmipp_transform_downsample -i in/100_movie_aligned.mrc -o out1/100_movie_aligned.mrc --step newSamplingRate --method fourier
2) mic normalization to 0 mean and 1 std and mic contrast inversion to have WHITE particles.
 E.g.  xmipp_transform_normalize -i out1/101_movie_aligned.mrc -o out2/101_movie_aligned.mrc --method OldXmipp [ --invert ]
3) particles extraction.
   E.g. xmipp_micrograph_scissor  -i out2/101_movie_aligned.mrc --pos particles@Runs/101_movie_aligned.pos -o out3/105_movie_aligned_particles  --Xdim 128 --downsampling newSamplingRate --fillBorders  ( Correct your coordinates with newSamplingRate if needed)
4) OPTIONAL: phase flipping using CTF.
 xmipp_ctf_phase_flip  -i particles/105_movie_aligned_noDust.xmp -o particles/105_movie_aligned_flipped.xmp --ctf ctfPath/105_movie_aligned.ctfParam --sampling newSamplingRate
Then, particles are extracted with no further alteration.
Please ensure that the additional particles have been preprocessed as indicated before.

"deep consensus picking" has a "Positive train particles 128px (optional)" parameter that is explained as: Select a set of true positive particles. Take care of the preprocessing (128x128 pixels, contrast inverted (white particles), possibly CTF corrected
"deep consensus picking" has a "Positive coordinates(optional)" parameter that is explained as: Select a set of true coordinates collected from the same microgaphs that the input
"deep consensus picking" has a "Weight of positive additional train data" parameter that is explained as: Select the weigth for the additional train set of positive particles.The weight value indicates internal particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of internal particles
"deep consensus picking" has a "Negative train particles 128px (optional)" parameter that is explained as: Select a set of false positive particles. Take care of the preprocessing: 128x128 pixels, contrast inverted (white particles), possibly CTF corrected
"deep consensus picking" has a "Negative coordinates(optional)" parameter that is explained as: Select a set of incorrect coordinates collected from the same microgaphs that the input
"deep consensus picking" has a "Weight of negative additional train data" parameter that is explained as: Select the weigth for the additional train set of negative particles. The weight value indicates the number of times each image may be included at most per epoch. Deep consensus internal particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of internal particles
"deep consensus picking" has a "Perform preliminar predictions with on training CNN" parameter that is explained as: The protocol will make preliminar preedictions with the network before it is fully trained
These preliminar results will be stored in a different output set
"deep consensus picking" has a "Extraction batch size" parameter that is explained as: Size of the extraction batches (in number of micrographs)
"deep consensus picking" has a "Training batch size" parameter that is explained as: Size of the training batches (in number of micrographs).The CNN needs a minimum number of particles to train for each batch, if there are not enough particles, the batch size must be increased

The protocol named "screen deep learning" can be found in the xmipp3 plugin.
"screen deep learning" protocol help is as follows:
  Protocol for screening particles using deep learning. .
"screen deep learning" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"screen deep learning" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"screen deep learning" has a "" parameter that is explained as: Set to true if you want to use GPU implementation
"screen deep learning" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
"screen deep learning" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"screen deep learning" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"screen deep learning" has a "Use previously trained model?" parameter that is explained as: If you set to *Yes*, you should select a previous run of type *XmippProtScreenDeepLearning* class and some of the input parameters will be taken from it.
"screen deep learning" has a "Select previous run" parameter that is explained as: Select a previous run to continue from.
"screen deep learning" has a "Continue training on previously trainedModel?" parameter that is explained as: If you set to *Yes*, you should provide training set
"screen deep learning" has a "True particles" parameter that is explained as: Select a set of particles that contains mostly true particles
"screen deep learning" has a "Number of different negative dataset" parameter that is explained as: Data from all negative datasets will be used for training. Maximun number is 4.

"screen deep learning" has a "Set of negative train particles 1" parameter that is explained as: Select the set of negative particles for training.
"screen deep learning" has a "Weight of negative train particles 1" parameter that is explained as: Select the weigh for the negative set of particles. The weight value indicates the number of times each image may be included at most per epoch. Positive particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of positive particles
"screen deep learning" has a "Set of negative train particles 2" parameter that is explained as: Select the set of negative particles for training.
"screen deep learning" has a "Weight of negative train particles 2" parameter that is explained as: Select the weigh for the negative set of particles. The weight value indicates the number of times each image may be included at most per epoch. Positive particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of positive particles
"screen deep learning" has a "Set of negative train particles 3" parameter that is explained as: Select the set of negative particles for training.
"screen deep learning" has a "Weight of negative train particles 3" parameter that is explained as: Select the weigh for the negative set of particles. The weight value indicates the number of times each image may be included at most per epoch. Positive particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of positive particles
"screen deep learning" has a "Set of negative train particles 4" parameter that is explained as: Select the set of negative particles for training.
"screen deep learning" has a "Weight of negative train particles 4" parameter that is explained as: Select the weigh for the negative set of particles. The weight value indicates the number of times each image may be included at most per epoch. Positive particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of positive particles
"screen deep learning" has a "Set of putative particles to score" parameter that is explained as: Select the set of putative particles to classify as good (score close to 1.0) or bad (score close to 0.0).
"screen deep learning" has a "Number of epochs" parameter that is explained as: Number of epochs for neural network training.
"screen deep learning" has a "Learning rate" parameter that is explained as: Learning rate for neural network training
"screen deep learning" has a "Auto stop training when convergence is detected?" parameter that is explained as: If you set to *Yes*, the program will automatically stop training if there is no improvement for consecutive 2 epochs, learning rate will be decreased by a factor 10. If learningRate_t < 0.01*learningrate_0 training will stop. Warning: Sometimes convergence seems to be reached, but after time, improvement can still happen. Not recommended for very small data sets (<100 true particles)
"screen deep learning" has a "Regularization strength" parameter that is explained as: L2 regularization for neural network weights.Make it bigger if suffering overfitting. Typical values range from 1e-1 to 1e-6
"screen deep learning" has a "Number of models for ensemble" parameter that is explained as: Number of models to fit in order to build an ensemble. Tipical values are 1 to 5. The more the better until a point where no gain is obtained. Each model increases running time linearly
"screen deep learning" has a "Perform testing after training?" parameter that is explained as: If you set to *Yes*, you should select a testing positive set and a testing negative set
"screen deep learning" has a "Set of positive test particles" parameter that is explained as: Select the set of ground true positive particles.
"screen deep learning" has a "Set of negative test particles" parameter that is explained as: Select the set of ground false positive particles.

The protocol named "screen particles" can be found in the xmipp3 plugin.
"screen particles" protocol help is as follows:
 Protocol to attach different merit values to every particle metadata for subsequent pruning the set.
There are different merit values to be calculated:
    - zScore evaluates the similarity of a particles with an average (lower zScore -> higher similarity).
    - SSNR evaluates the signal/noise ration in the Fourier space.
    - Variance evaluates the varaince on the micrographs context where the particle was picked.
    .
"screen particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"screen particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"screen particles" has a "Input Particles" parameter that is explained as: None
"screen particles" has a "Automatic rejection by Zscore" parameter that is explained as: zScore evaluates the similarity of a particles with an average. The rejection can be:
  None (no rejection)
  MaxZscore (reject a particle if its zScore is larger than this value).
   Percentage (reject a given percentage for this criteria).
"screen particles" has a "zScore threshold" parameter that is explained as: Maximum Zscore.
"screen particles" has a "Percentage (%)" parameter that is explained as: The worse percentage of particles according to metadata labels: ZScoreShape1, ZScoreShape2, ZScoreSNR1, ZScoreSNR2, ZScoreHistogram are automatically disabled.
"screen particles" has a "Automatic rejection by SSNR" parameter that is explained as: SSNR evaluates the signal/noise ration in the Fourier space. The rejection can be:
  None (no rejection)
  Percentage (reject a given percentage of the lowest SSNRs).
"screen particles" has a "Percentage (%)" parameter that is explained as: The worse percentage of particles according to SSNR are automatically disabled.
"screen particles" has a "Automatic rejection by Variance" parameter that is explained as: Variance evaluates the varaince on the micrographs context where the particle was picked. The rejection can be:
  None (no rejection)
  Variance (taking into account only the variance)
  Var. and Gini (taking into account also the Gini coeff.)
"screen particles" has a "Add features" parameter that is explained as: Add features used for the ranking to each one of the input particles
"screen particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "shift particles" can be found in the xmipp3 plugin.
"shift particles" protocol help is as follows:
  This protocol shifts particles to center them into a point selected in a volume. To do so, it generates new
    shifted images and modify the transformation matrix according to the shift performed..
"shift particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"shift particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"shift particles" has a "Particles" parameter that is explained as: Select the SetOfParticles with transformation matrix to be shifted.
"shift particles" has a "Select position in volume?" parameter that is explained as: Select the position where the particles will be shifted in a volume displayed in a wizard.
"shift particles" has a "Volume" parameter that is explained as: Volume to select the point (by clicking in the wizard for selecting the new center) that will be the new center of the particles.
"shift particles" has a "x" parameter that is explained as: Use the wizard to select the new center for the shifted particles by shift+click on the blue point a drag it to the desired location while pressing shift.
"shift particles" has a "y" parameter that is explained as: None
"shift particles" has a "z" parameter that is explained as: None
"shift particles" has a "Volume mask" parameter that is explained as: 3D mask to compute the center of mass, the particles will be shifted to the computed center of mass
"shift particles" has a "Apply shift to particles?" parameter that is explained as: Yes: The shift is applied to particle images and zero shift is stored in the metadata. No: The shift is stored in the transformation matrix in the metadata, but not applied to the particle image (i.e. the output images are the same of input images). This option takes less time and the shift could be applied later using protocol "xmipp3 - apply alignment 2d" or by re-extracting the particles.
"shift particles" has a "Use original box size for the shifted particles?" parameter that is explained as: Use input particles box size for the shifted particles.
"shift particles" has a "Final box size" parameter that is explained as: Box size for the shifted particles.
"shift particles" has a "Inverse" parameter that is explained as: Use inverse transformation matrix
"shift particles" has a "Interpolation" parameter that is explained as: Linear: Use bilinear/trilinear interpolation
Spline: Use spline interpolation

The protocol named "shift volume" can be found in the xmipp3 plugin.
"shift volume" protocol help is as follows:
  This protocol shifts a volume according to the input shifts.
"shift volume" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"shift volume" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"shift volume" has a "Volume" parameter that is explained as: Volume to shift
"shift volume" has a "Use the same shifts as for the particles?" parameter that is explained as: Use output shifts of protocol "shift particles" which should be executed previously
"shift volume" has a "Shift particles protocol" parameter that is explained as: None
"shift volume" has a "x" parameter that is explained as: None
"shift volume" has a "y" parameter that is explained as: None
"shift volume" has a "z" parameter that is explained as: None
"shift volume" has a "Use original box size for the shifted volume?" parameter that is explained as: Use input volume box size for the shifted volume.
"shift volume" has a "Final box size" parameter that is explained as: Box size of the shifted volume.

The protocol named "simulate ctf" can be found in the xmipp3 plugin.
"simulate ctf" protocol help is as follows:
 
    Simulate the effect of the CTF (no amplitude decay).
    A random defocus is chosen between the lower and upper defocus for each projection.
    .
"simulate ctf" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"simulate ctf" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"simulate ctf" has a "Input particles" parameter that is explained as: None
"simulate ctf" has a "Voltage (kV)" parameter that is explained as: None
"simulate ctf" has a "Spherical aberration Cs (mm)" parameter that is explained as: None
"simulate ctf" has a "Fraction inelastic scattering" parameter that is explained as: Between 0 and 1
"simulate ctf" has a "Lower defocus (A)" parameter that is explained as: Negative value is overfocus
"simulate ctf" has a "Upper defocus (A)" parameter that is explained as: Negative value is overfocus
"simulate ctf" has a "Simulate astigmatic CTF?" parameter that is explained as: If yes, defocusU and defocusV will have different values with a difference determined by the user, and there will be a value for angle
"simulate ctf" has a "Lower defocus angle (degrees)" parameter that is explained as: Between 0 and 90
"simulate ctf" has a "Upper defocus angle (degrees)" parameter that is explained as: Between 0 and 90
"simulate ctf" has a "Lower defocus difference between defocusU and defocusV (A)" parameter that is explained as: None
"simulate ctf" has a "Upper defocus difference between defocusU and defocusV(A)" parameter that is explained as: None

The protocol named "solid angles" can be found in the xmipp3 plugin.
"solid angles" protocol help is as follows:
     
    Construct image groups based on the angular assignment. All images assigned within a solid angle
    are assigned to a class. Classes are not exclusive and an image may be assigned to multiple classes
    .
"solid angles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"solid angles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"solid angles" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"solid angles" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"solid angles" has a "Input volume" parameter that is explained as: Select the input volume.
"solid angles" has a "Input particles" parameter that is explained as: Select the input experimental images with an angular assignment.
"solid angles" has a "Symmetry group" parameter that is explained as: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] page for a description of the symmetries accepted by Xmipp
"solid angles" has a "Angular sampling" parameter that is explained as: In degrees
"solid angles" has a "Angular distance" parameter that is explained as: In degrees. An image belongs to a group if its distance is smaller than this value
"solid angles" has a "Maximum shift" parameter that is explained as: In pixels
"solid angles" has a "Number of directional classes" parameter that is explained as: By default only one class will be computed for each projection direction. More classes could becomputed and this is needed for protocols split-volume. 
"solid angles" has a "Homogeneize groups" parameter that is explained as: Set to -1 for no homogeneization. Set to 0 for homogeneizing to the minimum of class size. Set to any other number to homogeneize to that particular number
"solid angles" has a "Target resolution (A)" parameter that is explained as: None
"solid angles" has a "Refine angles" parameter that is explained as: Refine the angles of the classes using a continuous angular assignment
"solid angles" has a "Number of CL2D iterations" parameter that is explained as: None
"solid angles" has a "Split volume" parameter that is explained as: If desired, the protocol can use the directional classes calculated in this protocol to divide the input volume into 2 distinct 3D classes as measured by PCA. If the PCA component is just noise, it means that the algorithm does not find a difference between the 2D classes
"solid angles" has a "Mask" parameter that is explained as: The mask values must be binary: 0 (remove these voxels) and 1 (let them pass).
"solid angles" has a "Number of reconstructions" parameter that is explained as: Number of random reconstructions to perform
"solid angles" has a "Number of images/reconstruction" parameter that is explained as: Number of images per reconstruction. Consider that reconstructions with symmetry c1 will be perfomed
"solid angles" has a "Confidence level" parameter that is explained as: This parameter is alpha. Two volumes, one at alpha/2 and another one at 1-alpha/2, will be generated
"solid angles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"solid angles" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "split frames" can be found in the xmipp3 plugin.
"split frames" protocol help is as follows:
 
    Wrapper protocol to Xmipp split Odd Even
    .
"split frames" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"split frames" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"split frames" has a "Input movies" parameter that is explained as: Select a set of movies to be split into two sets (odd and even).It means, the set of frames is split in two subsets.
"split frames" has a "Sum Frames" parameter that is explained as: Set yes to get a set of micrograms, or no to get a set of movies.

The protocol named "split volume" can be found in the xmipp3 plugin.
"split volume" protocol help is as follows:
 Split volume in two.
"split volume" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"split volume" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"split volume" has a "Directional classes" parameter that is explained as: Select a set of particles with angles. Preferrably the output of a run of directional classes
"split volume" has a "Symmetry group" parameter that is explained as: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
"split volume" has a "Mask" parameter that is explained as: The mask values must be binary: 0 (remove these voxels) and 1 (let them pass).
"split volume" has a "Number of reconstructions" parameter that is explained as: Number of random reconstructions to perform
"split volume" has a "Number of images/reconstruction" parameter that is explained as: Number of images per reconstruction. Consider that reconstructions with symmetry c1 will be perfomed
"split volume" has a "Confidence level" parameter that is explained as: This parameter is alpha. Two volumes, one at alpha/2 and another one at 1-alpha/2, will be generated

The protocol named "gl2d streaming" can be found in the xmipp3 plugin.
"gl2d streaming" protocol help is as follows:
  2D alignment in full streaming using Xmipp GPU Correlation.
    The set of classes will be growing whilst new particle images are
    received..
"gl2d streaming" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"gl2d streaming" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"gl2d streaming" has a "Input Particles" parameter that is explained as: None
"gl2d streaming" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"gl2d streaming" has a "Maximum shift (%):" parameter that is explained as: Maximum shift allowed during the alignment as percentage of the input set size
"gl2d streaming" has a "Number of best images:" parameter that is explained as: Number of classes to assign every input image during the alignment
"gl2d streaming" has a "Number of iterations in split stage:" parameter that is explained as: Maximum number of iterations in split stage
"gl2d streaming" has a "Number of iterations in classify stage:" parameter that is explained as: Maximum number of iterations when the classification of the whole image set is carried out
"gl2d streaming" has a "Image size" parameter that is explained as: The image size can be downsampled to accelerate the classification
"gl2d streaming" has a "Threshold to split" parameter that is explained as: The threshold in the number of images assigned to one class to make a spliting of that class
"gl2d streaming" has a "Block size" parameter that is explained as: The inputs will be processed in a block-by-block basis of this size
"gl2d streaming" has a "Maximum number of classes" parameter that is explained as: Maximum number of classes to be generated
"gl2d streaming" has a "Use CL2D" parameter that is explained as: If you set to *Yes*, you will use CL2D (CPU) to make the split process
"gl2d streaming" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"gl2d streaming" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "gl2d static" can be found in the xmipp3 plugin.
"gl2d static" protocol help is as follows:
  2D alignment in semi streaming using Xmipp GPU Correlation.
    A previous set of classes must be provided to include the new images in the
    corresponding class although the representatives will be maintained..
"gl2d static" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"gl2d static" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"gl2d static" has a "Input Particles" parameter that is explained as: None
"gl2d static" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"gl2d static" has a "Set of references" parameter that is explained as: Set of references that will serve as reference for the classification. This can be a set of classes or set of averages
"gl2d static" has a "Maximum shift (px):" parameter that is explained as: Maximum shift allowed during the alignment as percentage of the input set size
"gl2d static" has a "Number of best images:" parameter that is explained as: Number of the best images to keep for every class

The protocol named "struct map" can be found in the xmipp3 plugin.
"struct map" protocol help is as follows:
  Protocol for structure mapping based on correlation distance. .
"struct map" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"struct map" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"struct map" has a "Input volume(s)" parameter that is explained as: Select one or more volumes (SetOfClasses3D)
for structure mapping.
"struct map" has a "Target resolution" parameter that is explained as: In Angstroms, the images and the volume are rescaled so that this resolution is at 2/3 of the Fourier spectrum.
"struct map" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"struct map" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"struct map" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "struct map - Zernike3D" can be found in the xmipp3 plugin.
"struct map - Zernike3D" protocol help is as follows:
  Protocol for structure mapping based on Zernike3D. .
"struct map - Zernike3D" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"struct map - Zernike3D" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"struct map - Zernike3D" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                           Select the one you want to use.
"struct map - Zernike3D" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"struct map - Zernike3D" has a "Input volume(s)" parameter that is explained as: Select one or more volumes (Volume or SetOfVolumes)
for structure mapping.
"struct map - Zernike3D" has a "Compare two sets?" parameter that is explained as: Useful when two Sets are intended to be compared independently (e.g. comparing EMDBS and Maps coming from PDBs).
"struct map - Zernike3D" has a "Second set of volumes" parameter that is explained as: Select one or more volumes (Volume or SetOfVolumes)
to compare to the first set.
"struct map - Zernike3D" has a "Target resolution" parameter that is explained as: In Angstroms, the images and the volume are rescaled so that this resolution is at 2/3 of the Fourier spectrum.
"struct map - Zernike3D" has a "Multiresolution" parameter that is explained as: Perform the analysis comparing different filtered versions of the volumes. The values specified here will determine the cutoff frequency of the filter in normalized units (normalized to 1/2).
"struct map - Zernike3D" has a "Sphere radius" parameter that is explained as: Radius of the sphere where the spherical harmonics will be computed (in voxels).
"struct map - Zernike3D" has a "Zernike Degree" parameter that is explained as: Degree Zernike Polynomials of the deformation=1,2,3,...
"struct map - Zernike3D" has a "Harmonical Degree" parameter that is explained as: Degree Spherical Harmonics of the deformation=1,2,3,...
"struct map - Zernike3D" has a "Regularization" parameter that is explained as: Penalization to deformations (higher values penalize more the deformation).
"struct map - Zernike3D" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"struct map - Zernike3D" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"struct map - Zernike3D" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "subtract projection" can be found in the xmipp3 plugin.
"subtract projection" protocol help is as follows:
  This protocol computes the subtraction between particles and a reference volume, by computing its projections with the same angles that input particles have. Then, each particle and the correspondent projection of the reference volume are numerically adjusted and subtracted using a mask which denotes the region to keep. .
"subtract projection" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"subtract projection" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"subtract projection" has a "Particles " parameter that is explained as: Specify a SetOfParticles
"subtract projection" has a "Reference volume " parameter that is explained as: Specify a volume.
"subtract projection" has a "Circular mask radius: " parameter that is explained as: Radius of the circular mask to avoid edge artifacts. If -1 it is half the X dimension of the input particles
"subtract projection" has a "Maximum resolution: " parameter that is explained as: Maximum resolution (in A) of the data 
"subtract projection" has a "Ignore particles with negative beta0 or R2?: " parameter that is explained as: Particles with negative beta0 or R2 will not appear in the output set as they are considered bad particles. Moreover, negative betas will not contribute to mean beta if "mean" option is selected
"subtract projection" has a "Limit frequency?: " parameter that is explained as: Limit frequency in the adjustment process to the frequency correspondent to the resolution indicated in "Maximum resolution" field above
"subtract projection" has a "Decay of the filter (sigma): " parameter that is explained as: Decay of the filter (sigma) to smooth the mask transition
"subtract projection" has a "Fourier padding factor: " parameter that is explained as: The volume is zero padded by this factor to produce projections
"subtract projection" has a "Mask " parameter that is explained as: Specify a 3D mask for the region of the input volume that you want to keep or subtract, avoiding masks with 1s in background. If no mask is given, the subtraction is performed in whole images.
"subtract projection" has a "Mask contains the part to " parameter that is explained as: None
"subtract projection" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"subtract projection" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tilt analysis" can be found in the xmipp3 plugin.
"tilt analysis" protocol help is as follows:
  Estimate the tilt of a micrograph, by analyzing the PSD correlations of different segments of the image.
    .
"tilt analysis" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"tilt analysis" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"tilt analysis" has a "Input micrographs" parameter that is explained as: Select the SetOfMicrograph to be preprocessed.
"tilt analysis" has a "Window size" parameter that is explained as: By default, the micrograph will be divided into windows of dimensions 512x512, the PSD its correlations will be computed in every segment.
"tilt analysis" has a "Objective resolution" parameter that is explained as: By default, micrographs PSD will be cropped into a central windows of dimensions (xdim*(sampling rate/objective resolution)) x (ydim*(sampling rate/objective resolution)).
"tilt analysis" has a "Mean correlation threshold" parameter that is explained as: By default, micrographs will be divided into an output set and a discarded set based on the mean and std threshold
"tilt analysis" has a "STD correlation threshold" parameter that is explained as: By default, micrographs will be divided into an output set and a discarded set based on the mean and std threshold.
"tilt analysis" has a "" parameter that is explained as: Save the micrograph segments, the PSD of those segments and the correlation statistics of those segments.
"tilt analysis" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"tilt analysis" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"tilt analysis" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "trigger data" can be found in the xmipp3 plugin.
"trigger data" protocol help is as follows:
 
    Waits until certain number of images is prepared and then
    send them to output.
    It can be done in 3 ways:
        - If "Send all items to output?" is _No_:
            Once the number of items is reached, a setOfImages is returned and
            the protocol finishes (ending the streaming from this point).
        - If "Send all items to output?" is _Yes_ and:
            - If "Split items to multiple sets?" is _Yes_:
                Multiple closed outputs will be returned as soon as
                the number of items is reached.
            - If "Split items to multiple sets?" is _No_:
                Only one output is returned and it is growing up in batches of
                a certain number of items (completely in streaming).
    .
"trigger data" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"trigger data" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"trigger data" has a "Input images" parameter that is explained as: None
"trigger data" has a "Wait for signal to stop the stream?" parameter that is explained as: If NO is selected, normal functionality.
If YES is selected it will wait for a signal to stop the stream.
 For this option, select send all items to output with a minimum size of 1
"trigger data" has a "Minimum output size" parameter that is explained as: How many particles need to be on input to create output set.
"trigger data" has a "Send all items to output?" parameter that is explained as: If NO is selected, only a closed subset of "Output size" items will be send to output.
If YES is selected it will still running in streaming.
"trigger data" has a "Split items to multiple sets?" parameter that is explained as: If YES is selected, multiple closed outputs of "Output size" are returned.
If NO is selected, only one open and growing output is returned
"trigger data" has a "Send signal to stop a stream?" parameter that is explained as: If NO is selected, normal functionality.
If YES is selected it will send a signal to a connected Trigger data protocol.
 For this option, select the option send all items to output.
"trigger data" has a "Trigger data protocol" parameter that is explained as: Select the trigger data protocol that you will send a signal to stop the stream.
"trigger data" has a "Delay (sec)" parameter that is explained as: Delay in seconds before checking new output

The protocol named "validate fsc-q" can be found in the xmipp3 plugin.
"validate fsc-q" protocol help is as follows:
 
    The protocol assesses the quality of the fit.
    .
"validate fsc-q" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"validate fsc-q" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"validate fsc-q" has a "Input Volume" parameter that is explained as: Select a volume.
"validate fsc-q" has a "Input PDB from file: " parameter that is explained as: None
"validate fsc-q" has a "Refined PDB: " parameter that is explained as: Specify the desired input structure.
"validate fsc-q" has a "PDB File path: " parameter that is explained as: Specify a path to desired PDB structure.
"validate fsc-q" has a "Volume from PDB: " parameter that is explained as: Volume created from the PDB. The volume should be aligned with the reconstruction map. If the volume is not entered, it is automatically created from the PDB.
"validate fsc-q" has a "Soft Mask" parameter that is explained as: The mask determines which points are specimen and which are not. If the mask is not passed, the method creates an automatic mask from the PDB.
"validate fsc-q" has a "window size" parameter that is explained as: Kernel size (slidding window) for determining local resolution (pixels/voxels).
"validate fsc-q" has a "Set origin of coordinates" parameter that is explained as: Option YES:
A new volume will be created with the given ORIGIN of coordinates. 
"validate fsc-q" has a "x" parameter that is explained as: offset along x axis
"validate fsc-q" has a "y" parameter that is explained as: offset along y axis
"validate fsc-q" has a "z" parameter that is explained as: offset along z axis
"validate fsc-q" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"validate fsc-q" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"validate fsc-q" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "validate_nontilt" can be found in the xmipp3 plugin.
"validate_nontilt" protocol help is as follows:
     
    Ranks a set of volumes according to their alignment reliability obtained from a clusterability test.
    .
"validate_nontilt" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"validate_nontilt" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"validate_nontilt" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"validate_nontilt" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"validate_nontilt" has a "Input volumes" parameter that is explained as: Select the input volumes.
"validate_nontilt" has a "Input particles" parameter that is explained as: Select the input projection images .
"validate_nontilt" has a "Symmetry group" parameter that is explained as: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
"validate_nontilt" has a "Image alignment" parameter that is explained as: None
"validate_nontilt" has a "High" parameter that is explained as: None
"validate_nontilt" has a "Low" parameter that is explained as: None
"validate_nontilt" has a "Angular Sampling (degrees)" parameter that is explained as: Angular distance (in degrees) between neighboring projection points 
"validate_nontilt" has a "Number of orientations per particle" parameter that is explained as: Number of possible orientations in which a particle can be 

"validate_nontilt" has a "Significance" parameter that is explained as: Significance of the aligniability with respect to a a set of uniformly distributed random points 

"validate_nontilt" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"validate_nontilt" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "validate overfitting" can be found in the xmipp3 plugin.
"validate overfitting" protocol help is as follows:
     
    Check how the resolution changes with the number of projections used for 
    3D reconstruction. 

    NOTE:
    Using the output plot, with the reconstruction of aligned gaussian noise,
    you can assess the validity of the reconstruction from your micrograph
    images. Practically, if the resolution of reconstruction based on your
    images is not considerably different from aligned gaussian noise one
    (for less number of particles),your images may not produce a valid
    reconstruction.

    This method has been proposed by:
    B. Heymann "Validation of 3D EM Reconstructions", 2015.
    (see References)
    .
"validate overfitting" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"validate overfitting" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"validate overfitting" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"validate overfitting" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"validate overfitting" has a "Input particles" parameter that is explained as: Select the input images from the project.
"validate overfitting" has a "Resize input particles and volume?" parameter that is explained as: If obtaining the best possible reconstruction is not your goal, you can resize your input particales and volume to reduce running time of the protocol
"validate overfitting" has a "New size (px)" parameter that is explained as: Resizing input particles and volumeusing fourier method
"validate overfitting" has a "Calculate the noise bound for resolution?" parameter that is explained as: Select if you want to obtain the noise bound for resolution. This calculation will increase the computational time of this protocol.
"validate overfitting" has a "Initial 3D reference volume" parameter that is explained as: Input 3D reference reconstruction to align gaussian noise.
"validate overfitting" has a "Symmetry group" parameter that is explained as: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] pagefor a description of the symmetry formataccepted by Xmipp
"validate overfitting" has a "Number of particles" parameter that is explained as: Number of particles in each subset and consequently number of subsets (for instance, in default values,a number of 6 subsets with given values are chosen)
Note:
The number of particles in each subset should not be larger than 1/2 of the input set of particles. The protocol consider this issue automatically. It means that if the input set of particles are lower than 10,000, you could leave default values unchanged.
"validate overfitting" has a "Number of times the randomization is performed" parameter that is explained as: None
"validate overfitting" has a "Maximum resolution (dig.freq)" parameter that is explained as: Nyquist is 0.5
"validate overfitting" has a "Angular sampling rate" parameter that is explained as: None
"validate overfitting" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"validate overfitting" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"validate overfitting" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "volumes adjust" can be found in the xmipp3 plugin.
"volumes adjust" protocol help is as follows:
  This protocol scales a volume in order to assimilate it to another one.
    The volume with the best resolution should be the first one.
    The volumes should be aligned previously and they have to be equal in size.
"volumes adjust" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"volumes adjust" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"volumes adjust" has a "Volume 1 " parameter that is explained as: Specify a volume.
"volumes adjust" has a "Mask volumes?" parameter that is explained as: The masks are not mandatory but highly recommendable.
"volumes adjust" has a "Mask for volume 1" parameter that is explained as: Specify a mask for volume 1.
"volumes adjust" has a "Filter at resolution: " parameter that is explained as: Resolution (A) at which subtraction will be performed, filtering the input volumes.Value 0 implies no filtering.
"volumes adjust" has a "Decay of the filter (sigma): " parameter that is explained as: Decay of the filter (sigma parameter) to smooth the mask transition
"volumes adjust" has a "Number of iterations: " parameter that is explained as: None
"volumes adjust" has a "Relaxation factor (lambda): " parameter that is explained as: Relaxation factor for Fourier amplitude projector (POCS), it should be between 0 and 1, being 1 no relaxation and 0 no modification of volume 2 amplitudes
"volumes adjust" has a "Match the rotationally averaged Fourier amplitudes?" parameter that is explained as: Match the rotationally averaged Fourier amplitudes when adjusting the amplitudes instead of taking them directly from the reference volume. For subtraction and consensus it is recommended to set it to True but for sharpening it is recommended to set it to False
"volumes adjust" has a "Compute energy?" parameter that is explained as: Compute energy difference between the different adjustment steps and iterations to see if the method reaches convergence
"volumes adjust" has a "Volume 2 " parameter that is explained as: Specify a volume.
"volumes adjust" has a "Mask for volume 2" parameter that is explained as: Specify a mask for volume 1.

The protocol named "volume consensus" can be found in the xmipp3 plugin.
"volume consensus" protocol help is as follows:
  This protocol performs a fusion of all the input volumes, which should be preprocessed with protocol 'volume
    substraction' saving volume 2, in order to be as similar as possible before the fusion. The output of
    this protocol is the consensus volume and another volume which indicates the maximun difference between input
    volumes in each voxel..
"volume consensus" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"volume consensus" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"volume consensus" has a "Volumes" parameter that is explained as: Select the volumes for the consensus.

The protocol named "volumes subtraction" can be found in the xmipp3 plugin.
"volumes subtraction" protocol help is as follows:
  This protocol scales a volume in order to adjust it to another one. Then, it can calculate the subtraction
    of the two volumes. Second input can be a pdb. The volumes should be aligned previously and they have to
    be equal in size.
"volumes subtraction" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"volumes subtraction" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"volumes subtraction" has a "Volume 1 " parameter that is explained as: Specify a volume.
"volumes subtraction" has a "Mask volumes?" parameter that is explained as: The masks are not mandatory but highly recommendable.
"volumes subtraction" has a "Mask for volume 1" parameter that is explained as: Specify a mask for volume 1.
"volumes subtraction" has a "Filter at resolution: " parameter that is explained as: Resolution (A) at which subtraction will be performed, filtering the input volumes.Value 0 implies no filtering.
"volumes subtraction" has a "Decay of the filter (sigma): " parameter that is explained as: Decay of the filter (sigma parameter) to smooth the mask transition
"volumes subtraction" has a "Number of iterations: " parameter that is explained as: None
"volumes subtraction" has a "Relaxation factor (lambda): " parameter that is explained as: Relaxation factor for Fourier amplitude projector (POCS), it should be between 0 and 1, being 1 no relaxation and 0 no modification of volume 2 amplitudes
"volumes subtraction" has a "Match the rotationally averaged Fourier amplitudes?" parameter that is explained as: Match the rotationally averaged Fourier amplitudes when adjusting the amplitudes instead of taking them directly from the reference volume. For subtraction and consensus it is recommended to set it to True but for sharpening it is recommended to set it to False
"volumes subtraction" has a "Compute energy?" parameter that is explained as: Compute energy difference between the different adjustment steps and iterations to see if the method reaches convergence
"volumes subtraction" has a "Is the second input a PDB?" parameter that is explained as: If yes, the protocol will generate and store in folder "extra" of this protocol a volume and a mask from the pdb. This is not the recommended option, as the automatic conversion of the PDB into a density map may not be successful due to origin mismatches. We recommend to convert previously the PDB, inspect the converted map and use the map as input. If not, a second volume has to be input and optionally (but highly recommendable), a mask for it.
"volumes subtraction" has a "Retrieve PDB from" parameter that is explained as: Retrieve PDB data from server, use a pdb Object, or a local file
"volumes subtraction" has a "Input pdb " parameter that is explained as: Specify a pdb object. This is not the recommended option, as the automatic conversion of the PDB into a density map may not be successful due to origin mismatches. We recommendto convert previously the PDB, inspect the converted map and use the map as input.
"volumes subtraction" has a "File path" parameter that is explained as: Specify a path to desired PDB structure.
"volumes subtraction" has a "Volume 2 " parameter that is explained as: Specify a volume.
"volumes subtraction" has a "Mask for volume 2" parameter that is explained as: Specify a mask for volume 1.
"volumes subtraction" has a "Save intermediate files?" parameter that is explained as: Save input volume 1 filtered and input volume 2 adjusted, whichare the volumes that are really subtracted.

The protocol named "volume deform - Zernike3D" can be found in the xmipp3 plugin.
"volume deform - Zernike3D" protocol help is as follows:
  Protocol for volume deformation based on Zernike3D. .
"volume deform - Zernike3D" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"volume deform - Zernike3D" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"volume deform - Zernike3D" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                           Select the one you want to use.
"volume deform - Zernike3D" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"volume deform - Zernike3D" has a "Volume 1" parameter that is explained as: None
"volume deform - Zernike3D" has a "Volume 2" parameter that is explained as: None
"volume deform - Zernike3D" has a "Multiresolution" parameter that is explained as: Perform the analysys comparing different filtered versions of the volumes
"volume deform - Zernike3D" has a "Target resolution" parameter that is explained as: In Angstroms, the images and the volume are rescaled so that this resolution is at 2/3 of the Fourier spectrum.
"volume deform - Zernike3D" has a "Sphere radius" parameter that is explained as: Radius of the sphere where the spherical harmonics will be computed.
"volume deform - Zernike3D" has a "Zernike Degree" parameter that is explained as: Degree Zernike Polynomials of the deformation=1,2,3,...
"volume deform - Zernike3D" has a "Harmonical Degree" parameter that is explained as: Degree Spherical Harmonics of the deformation=1,2,3,...
"volume deform - Zernike3D" has a "Regularization" parameter that is explained as: Penalization to deformations (higher values penalize more the deformation).
"volume deform - Zernike3D" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"volume deform - Zernike3D" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "calculate strain" can be found in the xmipp3 plugin.
"calculate strain" protocol help is as follows:
 Compare two states of a volume to analyze the local strains and rotations.
"calculate strain" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"calculate strain" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"calculate strain" has a "Initial state" parameter that is explained as: Initial state of the structure, it will be deformed to fit into the final state
"calculate strain" has a "Final state" parameter that is explained as: Initial state of the structure, it will be deformed to fit into the final state
"calculate strain" has a "Mask for the final state" parameter that is explained as: Binary mask that defines where the strains and rotations will be calculated
"calculate strain" has a "Symmetry group" parameter that is explained as: See http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups formatIf no symmetry is present, give c1

The protocol named "local resolution/local bfactor" can be found in the xmipp3 plugin.
"local resolution/local bfactor" protocol help is as follows:
     
    Given a local resolution map and an atomic model, this protocols provides the matching between the
    local resolution with the local bfactor per residue.
    .
"local resolution/local bfactor" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"local resolution/local bfactor" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"local resolution/local bfactor" has a "Atomic model" parameter that is explained as: Select an atomic model. The atom positions will be taken to estimate the local resolution around them and then, the  local resolution associated to each residue.
"local resolution/local bfactor" has a "Normalize Resolution" parameter that is explained as: The normalizedlocal resolution map is defined as(LR - FSC)/FSC, where LR is the local resolution of agiven voxel, and FSC is the FSC resolution in A. This map provides information about whether the local resolution isgreater or lesser than the FSC. The local resolution normalized map is used to carry out the matching with the localbfactor per residue. Yes means that the local resolution will benormalized by the algorithm. No means that the input local resolution map is already a normalized local resolution map.
"local resolution/local bfactor" has a "Local Resolution Map" parameter that is explained as: Select a local resolution map. Alternatively, the input. can be a normalized local resolution map, in this caseset the Normalize resolution to No
"local resolution/local bfactor" has a "Normalized Local Resolution Map" parameter that is explained as: Select a normalized local resolution map. The local resolution normalized map is defined as (LR - FSC)/FSC, where LR is the local resolution of agiven voxel, and FSC is the FSC resolution in A
"local resolution/local bfactor" has a "FSC resolution (A)" parameter that is explained as: The global resolution of the map in A
"local resolution/local bfactor" has a "Use median" parameter that is explained as: The local resolution per residue can be estimated usingthe mean (by default - No) or the median (yes)
"local resolution/local bfactor" has a "is the atomic centered" parameter that is explained as: True if the atomic model centered in midle of the local resolution map
"local resolution/local bfactor" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"local resolution/local bfactor" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "assign alignment" can be found in the pwem plugin.
"assign alignment" protocol help is as follows:
  Assign the alignment calculated for a set of particles to another set.
    This protocol will take into account the differences of pixel size (A/pix)
    between the two sets and multiply by the right factor the shifts.
    The particles with the alignment can also be a subset of the other images
    .
"assign alignment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"assign alignment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"assign alignment" has a "Input particles" parameter that is explained as: Select the particles that you want to update the new alignment.
"assign alignment" has a "Input alignments" parameter that is explained as: Select the particles with alignment to be apply to the other particles.
"assign alignment" has a "Assign random subsets?" parameter that is explained as: If yes, the random subset information from the assignment input will be transferred to the output particles.
"assign alignment" has a "Ignore fractional shifts" parameter that is explained as: When extracting coordinates, the integer part of the shifts from the alignment can be transferred to the 2d coordinate. The remaining decimal part is stored as xFrac and yFrac in the particles. Leave this active if you want current alignment shifts to be used, IGNORING the decimal fraction that might be annotated in case this set comes from an "extract coordinates" and you chose to "Apply particle shifts?"
"assign alignment" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "invert hand" can be found in the pwem plugin.
"invert hand" protocol help is as follows:
  Modify the transformation matrix of a set of particles
    So that the handedness changes
    .
"invert hand" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"invert hand" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"invert hand" has a "Input particles" parameter that is explained as: Select the particles that you want to update the new alignment.
"invert hand" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "average frames" can be found in the pwem plugin.
"average frames" protocol help is as follows:
 
    Very simple protocol to align all the frames of a given data collection
    session. It can be used as a sanity check.
    .
"average frames" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"average frames" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"average frames" has a "Input Movies" parameter that is explained as: Select a set of previously imported movies.

The protocol named "box size checkpoint" can be found in the pwem plugin.
"box size checkpoint" protocol help is as follows:
 
    Protocol to make a validation operations on particle picking boxsize.
    For sanity check all the generated outputs are even numbers.
    .
"box size checkpoint" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"box size checkpoint" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"box size checkpoint" has a "Particle box size reference (px)" parameter that is explained as: This is the reference size of the boxed particles (in pixels).
For sanity check if it is not, it will be transform to an even number.
"box size checkpoint" has a "Particle box size secondary reference (px)" parameter that is explained as: This is a secondary size of the boxed particles (in pixels).
For sanity check if it is not, it will be transform to an even number.
"box size checkpoint" has a "Maximum proportional difference" parameter that is explained as: This proportion is calulated with the following formula:
Proportional diff = 1 - min(boxSize1, boxSize2)/max(boxSize1, boxSize2)
"box size checkpoint" has a "If disagreed stayed with the primary reference?" parameter that is explained as: Select yes if you want to use the primary reference as output.
"box size checkpoint" has a "Average the particle boxsize?" parameter that is explained as: Select yes if you want to use an average of the box sizes as output.
"box size checkpoint" has a "Use timer?" parameter that is explained as: Select yes if you want to use a timer to take the decision.
"box size checkpoint" has a "Time to wait:" parameter that is explained as: Time in seconds that the protocol will remain running. A correct format is an integer number in seconds or the following syntax: {days}d {hours}h {minutes}m {seconds}s separated by spaces e.g: 1d 2h 20m 15s,  10m 3s, 1h, 20s or 25.

The protocol named "box size related parameters" can be found in the pwem plugin.
"box size related parameters" protocol help is as follows:
 
    Protocol to make mathematical operations on particle picking boxsize.
    For sanity check all the generated outputs are even numbers.
    .
"box size related parameters" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"box size related parameters" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"box size related parameters" has a "Input micrographs" parameter that is explained as: Select the SetOfMicrographs from where we extract the sampling rate
"box size related parameters" has a "Particle box size (px)" parameter that is explained as: This is size of the boxed particles (in pixels).
For sanity check if it is not, it will be transform to an even number.
"box size related parameters" has a "Extract particles boxsize?" parameter that is explained as: Select yes if you want to generate these parameters.
"box size related parameters" has a "Factor to multiply the box size (px)" parameter that is explained as: Extraction box size (px) = picking box size (px) * *factor*
"box size related parameters" has a "Calculate gautomatch picking parameters?" parameter that is explained as: Select yes if you want to generate these parameters.
"box size related parameters" has a "Factor to obtain the particle radius (A)" parameter that is explained as: Particle radius in Angstrom. Default will be equal to 75% of reference size (box size).
Particle radius (A) = picking box size (px) * sampling_rate (A/px) * *factor*
"box size related parameters" has a "Factor to obtain the min inter-particle distance (A)" parameter that is explained as: Minimum distance between particles in Angstrom
 Use value of 0.9~1.1X diameter; can be 0.3~0.5X for filament-like particle.
Min inter-particle distnace (A) = picking box size (px) * sampling_rate (A/px) * *factor*
"box size related parameters" has a "Factor to obtain the local sigma diameter (A)" parameter that is explained as: Diameter for estimation of local sigma, in Angstrom.
Usually this diameter could be 0.5-2x of your particle diameter according to several factors. When using bigger values, normally you should decrease *Local sigma cut-off*. For smaller and sharper high density contamination/ice/metal particles you could use a smaller diameter and larger *Local sigma cut-off*.
Local sigma diameter (A) = picking box size (px) * sampling_rate (A/px) * *factor*
"box size related parameters" has a "Factor to obtain the local average diameter (A)" parameter that is explained as: Diameter for estimation of local average, in Angstrom. 1.5~2.0X particle diameter suggested.
However, if you have sharp/small ice or any dark/bright dots, using a smaller value will be much better to get rid of these areas.
Local average diameter (A) = picking box size (px) * sampling_rate (A/px) * *factor*
"box size related parameters" has a "Calculate relion picking parameters?" parameter that is explained as: Select yes if you want to generate these parameters.
"box size related parameters" has a "Factor to obtain the Min diameter for LoG filter (A)" parameter that is explained as: This should correspond to the smallest size of your particles projections in Ångstroms.
Min diameter for LoG filter (A) = picking box size (px) * sampling_rate (A/px) * *factor*
"box size related parameters" has a "Factor to obtain the Max diameter for LoG filter (A)" parameter that is explained as: This should correspond to the largest size of your particles projections in Ångstroms.
Max diameter for LoG filter (A) = picking box size (px) * sampling_rate (A/px) * *factor*
"box size related parameters" has a "Calculate topaz picking parameters?" parameter that is explained as: Select yes if you want to generate these parameters.
"box size related parameters" has a "Factor to obtain the particle radius (px)" parameter that is explained as: Pixel radius around particle centers to consider.
Particle radius (px) = picking box size (px) * *factor*
"box size related parameters" has a "Number of particles per image" parameter that is explained as: Expected number of particles per micrograph.
 If -1 it will be estimated for you.
"box size related parameters" has a "Calculate picking consensus parameters?" parameter that is explained as: Select yes if you want to generate these parameters.
"box size related parameters" has a "Factor to obtain the particle radius (px)" parameter that is explained as: Pixel radius around particle centers to consider.
Particle radius (px) = picking box size (px) * *factor*
"box size related parameters" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"box size related parameters" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"box size related parameters" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "assign ctf" can be found in the pwem plugin.
"assign ctf" protocol help is as follows:
  This protocol assigns a CTF estimation to a particular
    set of particles producing a new set. .
"assign ctf" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"assign ctf" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"assign ctf" has a "Input type:" parameter that is explained as: Select the type of objects that you want to assign the CTF.
"assign ctf" has a "Input set" parameter that is explained as: Select the images (micrographs or particles) that you want to update the CTF parameters.
"assign ctf" has a "Input CTF" parameter that is explained as: Select the CTFs that will be used to update particles. It can be another set of particles
"assign ctf" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "numeric classes extractor" can be found in the pwem plugin.
"numeric classes extractor" protocol help is as follows:
  Extracts items from a SetOfClasses based on number of items assigned to the class
    .
"numeric classes extractor" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"numeric classes extractor" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"numeric classes extractor" has a "Input classes" parameter that is explained as: Set of classes to extract items from.
"numeric classes extractor" has a "Extract representative?" parameter that is explained as: Set to true if you want to extract the image that represents the class otherwise all items supporting the class will be extracted.
"numeric classes extractor" has a "Biggest N classes" parameter that is explained as: Will take the N biggest classes. Those having most element supporting them.

The protocol named "create stream data" can be found in the pwem plugin.
"create stream data" protocol help is as follows:
  create  setofXXXX in streaming mode.
        micrograph -> read a micrograph in memory and writes it nDim times
        movie      -> read a movie in memory and writes it nDim times
        randomMicrographs -> creates a micrograph with random values
        and applies a random CTF
        particles  -> read nDim particles in memory and writes it in streaming
    .
"create stream data" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"create stream data" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"create stream data" has a "set Of" parameter that is explained as: create set of
"create stream data" has a "movie" parameter that is explained as: This movie will be copied "number of items" times
"create stream data" has a "micrograph" parameter that is explained as: This micrograph will be copied "number of items" times
"create stream data" has a "xdim" parameter that is explained as: X dim 
"create stream data" has a "ydim" parameter that is explained as: Y dim 
"create stream data" has a "SetOfParticles" parameter that is explained as: These particles will be written in streaming
"create stream data" has a "SetOfCoordinates" parameter that is explained as: These Coordinates will be written in streaming
"create stream data" has a "groups" parameter that is explained as: How many items will be created every iteration
"create stream data" has a "number of items" parameter that is explained as: setofXX size
"create stream data" has a "samplingRate" parameter that is explained as: Sampling rate
"create stream data" has a "Create Object each (sec)" parameter that is explained as: create one object each creationInterval seconds
"create stream data" has a "Extra random seconds interval" parameter that is explained as: Each object will be generated in a random time uniformly picked from the interval defined by[baseInterval, baseInterval+extraInterval]
"create stream data" has a "delay (sec)" parameter that is explained as: wait this seconds before creating stream data
"create stream data" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"create stream data" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"create stream data" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Crossed subset" can be found in the pwem plugin.
"Crossed subset" protocol help is as follows:
 
    Create a subset of the main set based on a matching field in another set. e.g.: Use _micName field (in both fields)
    to select micrographs (main set) present in a set of coordinates (secondary set)
    .
"Crossed subset" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Crossed subset" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Crossed subset" has a "Main set" parameter that is explained as: Set to be reduced
"Crossed subset" has a "Main field" parameter that is explained as: Field in the main set that contains the values in common with the secondary set. Use any of the metadata viewers to find the field name.
"Crossed subset" has a "Secondary set" parameter that is explained as: Set holding the matching field. e.g: Set of Coordinates hold the micName that can be used to filter a set of micrographs (main set)
"Crossed subset" has a "Secondary field" parameter that is explained as: Field in the secondary set that contains the values in common with the main set. Use any of the metadata viewers to find the field name.

The protocol named "export to emdb/pdb" can be found in the pwem plugin.
"export to emdb/pdb" protocol help is as follows:
  generates files for elements to submit structures to EMDB/PDB.
        Since mmcif/pdb is only partially supported by some software
        the protocol creates 4 versions of the atomic struct file with the hope that at least
        one of them will work.
    .
"export to emdb/pdb" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"export to emdb/pdb" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"export to emdb/pdb" has a "Main EM map to export" parameter that is explained as: This EM map is mandatory for EMDB and it will be exported using mrc format. If this map is associated to their respective half maps, they will be exported as well.
"export to emdb/pdb" has a "Additional maps to export?" parameter that is explained as: Select YES if you want to add some more EM maps to export.
"export to emdb/pdb" has a "Additional EM maps to export" parameter that is explained as: These additional EM maps will be also exported using mrc format.
"export to emdb/pdb" has a "FSC file to export" parameter that is explained as: This FSCs will be exported using XML format
"export to emdb/pdb" has a "Masks to export?" parameter that is explained as: Select YES if you want to add some  masks to export.
"export to emdb/pdb" has a "Masks to export" parameter that is explained as: These mask will be exported using mrc format
"export to emdb/pdb" has a "Atomic structure to export" parameter that is explained as: This atomic structure will be exported using mmCIF format
"export to emdb/pdb" has a "Image to export" parameter that is explained as: This image is mandatory for EMDB
"export to emdb/pdb" has a "symmetry group" parameter that is explained as: symmetry group of the map.
"export to emdb/pdb" has a "Symmetry Order" parameter that is explained as: Order of cyclic symmetry.
"export to emdb/pdb" has a "Export to directory" parameter that is explained as: Directory where the files will be generated.

The protocol named "extract coordinates" can be found in the pwem plugin.
"extract coordinates" protocol help is as follows:
  
    Extract the coordinates information from a set of particles.
    
    This protocol is useful when we want to re-extract the particles
    (maybe resulting from classification and cleaning) with the 
    original dimensions. It can be also handy to visualize the resulting
    particles in their location on micrographs.
    .
"extract coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"extract coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"extract coordinates" has a "Input particles" parameter that is explained as: Select the particles from which you want
to extract the coordinates and micrographs.
"extract coordinates" has a "Input micrographs" parameter that is explained as: Select the micrographs to which you want to
associate the coordinates from the particles.
"extract coordinates" has a "Apply particle shifts?" parameter that is explained as: Apply particle shifts (ONLY INTEGER PART) from 2D alignment to recalculate new coordinates. This can be useful for re-centering particle coordinates.
IMPORTANT: Only the integer part of the shifts will be applied in order to avoid interpolation. If you are re-extracting particles and want to apply the remaining decimal part of the shifts, set to  "yes" the option "Were particle shifts applied?" in alignment assign protocol.
"extract coordinates" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "import averages" can be found in the pwem plugin.
"import averages" protocol help is as follows:
 Protocol to import a set of averages to the project.
"import averages" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import averages" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import averages" has a "" parameter that is explained as: You can import particles directly from the binary files, or import from other packages formats. 
Currently, we can import from: emx, xmipp3, relion, scipion, frealign, eman, cryosparc 
Following are the expected import files for each one:
*emx*: particles.emx
*xmipp3*: images.xmd
*relion*: itXX_data.star
*scipion*: particles.sqlite
*eman*: particleSet.lst
*cryosparc*: particles.cs

"import averages" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import averages" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import averages" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import averages" has a "Input EMX file" parameter that is explained as: Select the EMX file containing particles information.
 See more about 
[[http://i2pc.cnb.csic.es/emx][EMX format]]
"import averages" has a "Alignment Type" parameter that is explained as: Is this a 2D alignment, a 3D alignment or a set of projections
"import averages" has a "Particles metadata file" parameter that is explained as: Select the particles Xmipp metadata file.
It is usually a images.xmd file result
from Xmipp protocols execution.
"import averages" has a "Star file" parameter that is explained as: Select a *_data.star file from a
previous Relion execution.To detect if the input particles contains alignment information, it is required to have the optimiser.star file corresponding to the data.star
"import averages" has a "Ignore ID column?" parameter that is explained as: Set this option to True to regenerate 
the id's of the particles. By default 
it is read from metadata file.        
This option can be useful when merging
different metadatas and id's are not  
longer unique.
"import averages" has a "Particles sqlite file" parameter that is explained as: Select the particles sqlite file.

"import averages" has a "For Frealign you need to import both stack and .par files." parameter that is explained as: None
"import averages" has a "Stack file" parameter that is explained as: Select an stack file with the particles.
"import averages" has a "Param file" parameter that is explained as: Select a Frealign .par file with the refinement information.
"import averages" has a "Lst file" parameter that is explained as: Select a *.lst set file from EMAN2 project.
"import averages" has a "cs file" parameter that is explained as: Select a .cs file.
It is usually a .cs file result from cryoSPARC job execution.
"import averages" has a "Pixel size (sampling rate) Å/px" parameter that is explained as: None
"import averages" has a "Have data been phase-flipped?" parameter that is explained as: Set this to Yes if the images have been ctf-phase corrected.
"import averages" has a "Use the wizard button to import acquisition." parameter that is explained as: Depending on the import Format, the wizard
will try to import the acquisition values.
If not found, required ones should be provided.
"import averages" has a "Microscope voltage (kV)" parameter that is explained as: Microscope voltage
"import averages" has a "Spherical aberration (mm)" parameter that is explained as: Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
"import averages" has a "Amplitude Contrast" parameter that is explained as: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
"import averages" has a "Magnification rate" parameter that is explained as: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
"import averages" has a "Process data in streaming?" parameter that is explained as: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
"import averages" has a "Timeout" parameter that is explained as: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

"import averages" has a "File timeout" parameter that is explained as: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "import ctf" can be found in the pwem plugin.
"import ctf" protocol help is as follows:
 Common protocol to import a set of ctfs into the project.
"import ctf" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import ctf" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import ctf" has a "Import from" parameter that is explained as: Select the type of import.
"import ctf" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import ctf" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import ctf" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import ctf" has a "Input micrographs" parameter that is explained as: Select the micrographs for which you want to update the CTF parameters.
"import ctf" has a "Process data in streaming?" parameter that is explained as: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
"import ctf" has a "Timeout" parameter that is explained as: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

"import ctf" has a "File timeout" parameter that is explained as: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "import coordinates" can be found in the pwem plugin.
"import coordinates" protocol help is as follows:
  Protocol to import a set of coordinates .
"import coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import coordinates" has a "Import from" parameter that is explained as: Select the type of import.
"import coordinates" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import coordinates" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import coordinates" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import coordinates" has a "Input micrographs" parameter that is explained as: Select the micrographs for which you want to import coordinates.
"import coordinates" has a "Box size" parameter that is explained as: None
"import coordinates" has a "Scale" parameter that is explained as: Factor to scale coordinates
"import coordinates" has a "Invert X" parameter that is explained as: None
"import coordinates" has a "Invert Y" parameter that is explained as: Invert Y for EMAN coordinates taken on dm3 or tif micrographs
"import coordinates" has a "Process data in streaming?" parameter that is explained as: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
"import coordinates" has a "Timeout" parameter that is explained as: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

"import coordinates" has a "File timeout" parameter that is explained as: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "import coordinate pairs" can be found in the pwem plugin.
"import coordinate pairs" protocol help is as follows:
  Protocol to import a set of tilt pair coordinates .
"import coordinate pairs" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import coordinate pairs" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import coordinate pairs" has a "Import from" parameter that is explained as: Select the type of import.
_Auto_ - detects coordinate file type by extension.
_Xmipp_ - provide *.pos files
_Eman_ - provide info/*.json files
"import coordinate pairs" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import coordinate pairs" has a "Micrograph .xmd file" parameter that is explained as: Provide input_micrographs.xmd file that contains tilt angles information. This file is usually created alongside the coordinates.
"import coordinate pairs" has a "Pattern untilted" parameter that is explained as: Pattern (that can include wildcards) of the files to import.
For example:
  *data/particles/***.spi*
  *~/Micrographs/mic/***.mrc*
"import coordinate pairs" has a "Pattern tilted" parameter that is explained as: Pattern (that can include wildcards) of the files to import.
For example:
  *data/particles/***.spi*
  *~/Micrographs/mic/***.mrc*
"import coordinate pairs" has a "Input tilt pair micrographs" parameter that is explained as: Select the tilt pair micrographs for which you want to import coordinates.
"import coordinate pairs" has a "Box size" parameter that is explained as: None
"import coordinate pairs" has a "Scale" parameter that is explained as: Factor to scale coordinates
"import coordinate pairs" has a "Invert X" parameter that is explained as: None
"import coordinate pairs" has a "Invert Y" parameter that is explained as: None

The protocol named "import mask" can be found in the pwem plugin.
"import mask" protocol help is as follows:
  Class for import masks from existing files. .
"import mask" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import mask" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import mask" has a "Mask path" parameter that is explained as: Select the file path of the mask

"import mask" has a "Pixel size (sampling rate) Å/px" parameter that is explained as: None

The protocol named "import micrographs" can be found in the pwem plugin.
"import micrographs" protocol help is as follows:
 Protocol to import a set of micrographs to the project.
"import micrographs" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import micrographs" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import micrographs" has a "Import from" parameter that is explained as: Select the type of import.
"import micrographs" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import micrographs" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import micrographs" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import micrographs" has a "Input EMX file" parameter that is explained as: Select the EMX file containing micrographs information.
See more about [[http://i2pc.cnb.csic.es/emx][EMX format]]
"import micrographs" has a "Micrographs metadata file" parameter that is explained as: Select the micrographs Xmipp metadata file.
It is usually a _micrograph.xmd_ file result
from import, preprocess or downsample protocols.
"import micrographs" has a "Micrographs sqlite file" parameter that is explained as: Select the micrographs sqlite file.

"import micrographs" has a "Have data been phase-flipped?" parameter that is explained as: Set this to Yes if the images have been ctf-phase corrected.
"import micrographs" has a "Use the wizard button to import acquisition." parameter that is explained as: Depending on the import Format, the wizard
will try to import the acquisition values.
If not found, required ones should be provided.
"import micrographs" has a "Microscope voltage (kV)" parameter that is explained as: Microscope voltage
"import micrographs" has a "Spherical aberration (mm)" parameter that is explained as: Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
"import micrographs" has a "Amplitude Contrast" parameter that is explained as: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
"import micrographs" has a "Magnification rate" parameter that is explained as: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
"import micrographs" has a "Sampling rate mode" parameter that is explained as: You can specify the sampling rate (pixel size) directly from the image
(A/pixel, Ts) or by specifying the magnification rate (M) and the scanner
pixel size (microns/pixel, Tm).

They are related by  Ts = Tm / M
"import micrographs" has a "Pixel size (sampling rate) Å/px" parameter that is explained as: Pixel size
"import micrographs" has a "Scanned pixel size (microns/px)" parameter that is explained as: 
"import micrographs" has a "Process data in streaming?" parameter that is explained as: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
"import micrographs" has a "Timeout" parameter that is explained as: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

"import micrographs" has a "File timeout" parameter that is explained as: Duration after which, if a file has not changed, we consider it as a new file. 

"import micrographs" has a "Reject from Set" parameter that is explained as: Files on this set will not be imported
"import micrographs" has a "Reject from" parameter that is explained as: Files acquired after this date will not be imported. Must follow format: YYYY-mm-dd HH:MM:SS 
e.g: 2019-01-14 14:18:05
"import micrographs" has a "Reject before" parameter that is explained as: Files acquired before this date will not be imported. Must follow format: YYYY-mm-dd HH:MM:SS 
e.g: 2019-01-14 14:18:05
"import micrographs" has a "Rejection file has RegExps" parameter that is explained as: Choose Yes if the rejection file contains regular expressions. Set to No if the rejection file contains file names. Ignore if not using a rejection file
"import micrographs" has a "Blacklist File" parameter that is explained as: Reject everything included in this file. If Use RegExps is True,lines will be interpreted as regular expressions. E.g: 
(.*)GRID_0[1-5](.*)
(.*)/GRID_10/Falcon_2019_01_14-16_(.*)
If Use RegExps is False, lines will be interpreted as file names. E.g.
/path/to/GRID_10/Falcon_2019_01_14-16_51_20_0_movie.mrcs
/path/to/GRID_10/Falcon_2019_01_14-16_55_40_0_movie.mrcs

The protocol named "import tilted micrographs" can be found in the pwem plugin.
"import tilted micrographs" protocol help is as follows:
 Protocol to import untilted-tilted pairs of micrographs in the project.
"import tilted micrographs" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import tilted micrographs" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import tilted micrographs" has a "Pattern untilted" parameter that is explained as: Pattern (that can include wildcards) of the files to import.
For example:
  *data/particles/***.spi*
  *~/Micrographs/mic/***.mrc*
"import tilted micrographs" has a "Pattern tilted" parameter that is explained as: Pattern (that can include wildcards) of the files to import.
For example:
  *data/particles/***.spi*
  *~/Micrographs/mic/***.mrc*
"import tilted micrographs" has a "Copy files?" parameter that is explained as: None
"import tilted micrographs" has a "Microscope voltage (kV)" parameter that is explained as: Microscope voltage
"import tilted micrographs" has a "Spherical aberration (mm)" parameter that is explained as: Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
"import tilted micrographs" has a "Amplitude Contrast" parameter that is explained as: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
"import tilted micrographs" has a "Sampling rate mode" parameter that is explained as: You can specify the sampling rate (pixel size) directly from the image
(A/pixel, Ts) or by specifying the magnification rate (M) and the scanner
pixel size (microns/pixel, Tm).

They are related by  Ts = Tm / M
"import tilted micrographs" has a "Pixel size (sampling rate) Å/px" parameter that is explained as: Pixel size
"import tilted micrographs" has a "Magnification rate" parameter that is explained as: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
"import tilted micrographs" has a "Scanned pixel size (microns/px)" parameter that is explained as: None

The protocol named "import movies" can be found in the pwem plugin.
"import movies" protocol help is as follows:
  Protocol to import a set of movies (from direct detector cameras)
    to the project.
    .
"import movies" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import movies" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import movies" has a "" parameter that is explained as: Select the type of import.
"import movies" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import movies" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import movies" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import movies" has a "Have data been phase-flipped?" parameter that is explained as: Set this to Yes if the images have been ctf-phase corrected.
"import movies" has a "Use the wizard button to import acquisition." parameter that is explained as: Depending on the import Format, the wizard
will try to import the acquisition values.
If not found, required ones should be provided.
"import movies" has a "Microscope voltage (kV)" parameter that is explained as: Microscope voltage
"import movies" has a "Spherical aberration (mm)" parameter that is explained as: Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
"import movies" has a "Amplitude Contrast" parameter that is explained as: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
"import movies" has a "Magnification rate" parameter that is explained as: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
"import movies" has a "Sampling rate mode" parameter that is explained as: You can specify the sampling rate (pixel size) directly from the image
(A/pixel, Ts) or by specifying the magnification rate (M) and the scanner
pixel size (microns/pixel, Tm).

They are related by  Ts = Tm / M
"import movies" has a "Pixel size (sampling rate) Å/px" parameter that is explained as: Pixel size
"import movies" has a "Scanned pixel size (microns/px)" parameter that is explained as: 
"import movies" has a "Initial" parameter that is explained as: None
"import movies" has a "Per frame" parameter that is explained as: None
"import movies" has a "Gain image" parameter that is explained as: A gain reference related to a set of movies for gain correction
"import movies" has a "Dark image" parameter that is explained as: A dark image related to a set of movies
"import movies" has a "Process data in streaming?" parameter that is explained as: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
"import movies" has a "Timeout" parameter that is explained as: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

"import movies" has a "File timeout" parameter that is explained as: Duration after which, if a file has not changed, we consider it as a new file. 

"import movies" has a "Reject from Set" parameter that is explained as: Files on this set will not be imported
"import movies" has a "Reject from" parameter that is explained as: Files acquired after this date will not be imported. Must follow format: YYYY-mm-dd HH:MM:SS 
e.g: 2019-01-14 14:18:05
"import movies" has a "Reject before" parameter that is explained as: Files acquired before this date will not be imported. Must follow format: YYYY-mm-dd HH:MM:SS 
e.g: 2019-01-14 14:18:05
"import movies" has a "Rejection file has RegExps" parameter that is explained as: Choose Yes if the rejection file contains regular expressions. Set to No if the rejection file contains file names. Ignore if not using a rejection file
"import movies" has a "Blacklist File" parameter that is explained as: Reject everything included in this file. If Use RegExps is True,lines will be interpreted as regular expressions. E.g: 
(.*)GRID_0[1-5](.*)
(.*)/GRID_10/Falcon_2019_01_14-16_(.*)
If Use RegExps is False, lines will be interpreted as file names. E.g.
/path/to/GRID_10/Falcon_2019_01_14-16_51_20_0_movie.mrcs
/path/to/GRID_10/Falcon_2019_01_14-16_55_40_0_movie.mrcs
"import movies" has a "Input individual frames?" parameter that is explained as: Select Yes if movies are acquired in individual frame files. 
"import movies" has a "Number of frames" parameter that is explained as: Provide how many frames are per movie. 
"import movies" has a "Create movie stacks?" parameter that is explained as: Select Yes if you want to create a new stack for each movies with its frames. 
"import movies" has a "Write stacks in the project folder?" parameter that is explained as: If Yes, the created stack files will be written in the project folder. By default the movies will be written in the same place where input frames are.
"import movies" has a "Movie suffix" parameter that is explained as: Suffix added to the output movie filename.Use the extension to select the format (e.g., .mrcs, .stk)
"import movies" has a "Delete frame files?" parameter that is explained as: Select Yes if you want to remove the individual frame files after creating the movie stack. 
"import movies" has a "Previous movies to exclude" parameter that is explained as: Select a setOfMovies that are already imported that you want to exclude for this import.

The protocol named "import particles" can be found in the pwem plugin.
"import particles" protocol help is as follows:
 Protocol to import a set of particles to the project.
"import particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import particles" has a "Import from" parameter that is explained as: You can import particles directly from the binary files, or import from other packages formats. 
Currently, we can import from: emx, xmipp3, relion, scipion, frealign, eman, cryosparc 
Following are the expected import files for each one:
*emx*: particles.emx
*xmipp3*: images.xmd
*relion*: itXX_data.star
*scipion*: particles.sqlite
*eman*: particleSet.lst
*cryosparc*: particles.cs

"import particles" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import particles" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import particles" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import particles" has a "Input EMX file" parameter that is explained as: Select the EMX file containing particles information.
 See more about 
[[http://i2pc.cnb.csic.es/emx][EMX format]]
"import particles" has a "Alignment Type" parameter that is explained as: Is this a 2D alignment, a 3D alignment or a set of projections
"import particles" has a "Particles metadata file" parameter that is explained as: Select the particles Xmipp metadata file.
It is usually a images.xmd file result
from Xmipp protocols execution.
"import particles" has a "Star file" parameter that is explained as: Select a *_data.star file from a
previous Relion execution.To detect if the input particles contains alignment information, it is required to have the optimiser.star file corresponding to the data.star
"import particles" has a "Ignore ID column?" parameter that is explained as: Set this option to True to regenerate 
the id's of the particles. By default 
it is read from metadata file.        
This option can be useful when merging
different metadatas and id's are not  
longer unique.
"import particles" has a "Particles sqlite file" parameter that is explained as: Select the particles sqlite file.

"import particles" has a "For Frealign you need to import both stack and .par files." parameter that is explained as: None
"import particles" has a "Stack file" parameter that is explained as: Select an stack file with the particles.
"import particles" has a "Param file" parameter that is explained as: Select a Frealign .par file with the refinement information.
"import particles" has a "Lst file" parameter that is explained as: Select a *.lst set file from EMAN2 project.
"import particles" has a "cs file" parameter that is explained as: Select a .cs file.
It is usually a .cs file result from cryoSPARC job execution.
"import particles" has a "Have data been phase-flipped?" parameter that is explained as: Set this to Yes if the images have been ctf-phase corrected.
"import particles" has a "Use the wizard button to import acquisition." parameter that is explained as: Depending on the import Format, the wizard
will try to import the acquisition values.
If not found, required ones should be provided.
"import particles" has a "Microscope voltage (kV)" parameter that is explained as: Microscope voltage
"import particles" has a "Spherical aberration (mm)" parameter that is explained as: Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
"import particles" has a "Amplitude Contrast" parameter that is explained as: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
"import particles" has a "Magnification rate" parameter that is explained as: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
"import particles" has a "Pixel size (sampling rate) Å/px" parameter that is explained as: None
"import particles" has a "Process data in streaming?" parameter that is explained as: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
"import particles" has a "Timeout" parameter that is explained as: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

"import particles" has a "File timeout" parameter that is explained as: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "import atomic structure" can be found in the pwem plugin.
"import atomic structure" protocol help is as follows:
  Protocol to import an atomic structure  to the project.
Format may be PDB or MMCIF.
"import atomic structure" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import atomic structure" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import atomic structure" has a "Import atomic structure from" parameter that is explained as: Import mmCIF data from online server or local file
"import atomic structure" has a "Atomic structure ID " parameter that is explained as: Type a mmCIF ID (four alphanumeric characters).
"import atomic structure" has a "File path" parameter that is explained as: Specify a path to desired atomic structure.
"import atomic structure" has a "Input Volume" parameter that is explained as: Associate this volume to the mmCIF file.

The protocol named "import sequence" can be found in the pwem plugin.
"import sequence" protocol help is as follows:
  Protocol to import an aminoacid/nucleotide sequence file to the
    project.
"import sequence" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import sequence" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import sequence" has a "Sequence ID" parameter that is explained as: Write a sequence ID. Otherwise, if the sequence derives from GenBank/UniProt/PDB databases, the respective database ID will be selected as starting sequence ID; examples: if you select GenBank accession AJ520101, SCIPION will assign AJ520101 as sequence ID; if you select UniProt accession P12345, SCIPION will assign P12345 as sequence ID; if you select atomic structure 3lqd.cif, chain B, SCIPION will assign 3lqd_B as sequence ID. In the rest of cases, the Sequence name will be selected as starting Sequence ID.
"import sequence" has a "Sequence name" parameter that is explained as: Write a sequence name.
"import sequence" has a "Sequence description" parameter that is explained as: Write a description for your sequence. Otherwise, if the sequence derives from GenBank/UniProt/PDB databases, the respective database description will be selected as starting sequence description. In the rest of cases, no sequence description will be added.
"import sequence" has a "Import sequence of " parameter that is explained as: Select the type of sequence to import.
"import sequence" has a "From " parameter that is explained as: Select one of the four options: write the aminoacid sequence or import it from a previously loaded atomic structure, a local file or an online server.
"import sequence" has a "IUPAC Protein alphabet: " parameter that is explained as: Your raw sequence will be cleaned according a certain alphabet, i.e., only the letters contained in the alphabet will be maintained in the sequence. Select thus the type of protein alphabet in order to accomplish the cleaning:

Protein alphabet: IUPAC protein alphabet of the 20 standard amino acids; uppercase and single letter: *ACDEFGHIKLMNPQRSTVWY*.

Extended Protein alphabet: Extended uppercase IUPAC protein single letter alphabet including X etc.
In addition to the standard 20 single letter protein codes, this includes:
*B = Asx*; Aspartic acid (R) or Asparagine (N)
*X = Xxx*"; Unknown or other amino acid
*Z = Glx*; Glutamic acid (E) or Glutamine (Q)
*J = Xle*; Leucine (L) or Isoleucine (I), used in mass-spec (NMR)
*U = Sec*; Selenocysteine
*O = Pyl*; Pyrrolysine
This alphabet is not intended to be used with X for Selenocysteine (an ad-hoc standard prior to the IUPAC adoption of U instead).

"import sequence" has a "UniProt name/ID " parameter that is explained as: Write a UniProt ID (six or ten alphanumeric characters; examples: A2BC19, P12345, A0A022YWF9, DGAL_ECOLI).
 You can convert other database identifiers to UniProt accession codes by using the "ID Mapping" tab on https://www.uniprot.org/
"import sequence" has a "From " parameter that is explained as: Select one of the five options: write the nucleic acid sequence or import it from a local file or an online server.
"import sequence" has a "IUPAC Nucleic acid alphabet: " parameter that is explained as: Your raw sequence will be cleaned according a certain alphabet, i.e., only the letters contained in the alphabet will be maintained in the sequence. Select thus the type of nucleic acid alphabet in order to accomplish the cleaning:

 Ambiguous DNA alphabet: Uppercase IUPAC ambiguous DNA: *GATCRYWSMKHBVDN*.

Unambiguous DNA alphabet: Uppercase IUPAC unambiguous DNA (letters *GATC* only).

Extended DNA: Extended IUPAC DNA alphabet.
In addition to the standard letter codes GATC, this includes:
*B* = 5-bromouridine
*D* = 5,6-dihydrouridine
*S* = thiouridine
*W* = wyosine

Ambiguous RNA: Uppercase IUPAC ambiguous RNA; *GAUCRYWSMKHBVDN*

Unambigous RNA alphabet: Generic single letter RNA alphabet.


"import sequence" has a "Write your sequence here:" parameter that is explained as: Write the aminoacid or nucleotide raw sequence.

"import sequence" has a "Atomic structure from" parameter that is explained as: Import structure data from online server or local file
"import sequence" has a "Atomic structure ID " parameter that is explained as: Type a structure ID (four alphanumeric characters).
"import sequence" has a "File path" parameter that is explained as: Specify a path to desired atomic structure.
"import sequence" has a "Chain " parameter that is explained as: Select a particular chain of the atomic structure.
"import sequence" has a "File path" parameter that is explained as: Specify a path to desired aminoacid or nucleic acid sequence file.
If your file contains more than one sequence, only the first one will be considered.
"import sequence" has a "GenBank accession " parameter that is explained as: Write a GenBank accession.


The protocol named "import set of atomic structures" can be found in the pwem plugin.
"import set of atomic structures" protocol help is as follows:
  Protocol to import a set of atomic structure  to the project.
    Format may be PDB or MMCIF.
"import set of atomic structures" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import set of atomic structures" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import set of atomic structures" has a "Import atomic structures from" parameter that is explained as: Import mmCIF data from online server or local files
"import set of atomic structures" has a "Atomic structure IDs " parameter that is explained as: Type a mmCIF ID (four alphanumeric characters, comma-separated)
i.e: 5ni1, 1ake
"import set of atomic structures" has a "Files directory path: " parameter that is explained as: Specify a path to the directory where the files are stored.
The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import set of atomic structures" has a "Pattern: " parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.

You may create AtomStruct from PDB (.pdb) or CIF/mmCIF (.cif)

The protocol named "import volumes" can be found in the pwem plugin.
"import volumes" protocol help is as follows:
 Protocol to import a set of volumes to the project.
"import volumes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import volumes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import volumes" has a "Import from" parameter that is explained as: Import 3D map data from EMDB server or local file
"import volumes" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import volumes" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import volumes" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import volumes" has a "EMDB map ID (integer)" parameter that is explained as: Type an EMDB ID (Integer). 
"import volumes" has a "Set half maps" parameter that is explained as: Option YES:
Assign two half maps to the imported map.
"import volumes" has a "Path half map1" parameter that is explained as: Select first half map
"import volumes" has a "Path half map2" parameter that is explained as: Select second half map
"import volumes" has a "Pixel size (sampling rate) Å/px" parameter that is explained as: None
"import volumes" has a "Set origin of coordinates" parameter that is explained as: Option YES:
A new volume will be created with the given ORIGIN of coordinates. This ORIGIN will be set in the map file header.
The ORIGIN of coordinates will be placed at the center of the whole volume if you select n(x)/2, n(y)/2, n(z)/2 as x, y, z coordinates (n(x), n(y), n(z) are the dimensions of the whole volume). However, selecting 0, 0, 0 as x, y, z coordinates, the volume will be placed at the upper right-hand corner.

Option NO:
The ORIGIN of coordinates will be placed at the center of the whole volume (coordinates n(x)/2, n(y)/2, n(z)/2 by default). This ORIGIN will NOT be set in the map file header.

WARNING: In case you want to process the volume with programs requiring a specific symmetry regarding the origin of coordinates, for example the protocol extract unit cell, check carefully that the coordinates of the origin preserve the symmetry of the whole volume. This is particularly relevant for loading fragments/subunits of the whole volume.

"import volumes" has a "x" parameter that is explained as: offset along x axis (Angstroms)
"import volumes" has a "y" parameter that is explained as: offset along y axis (Angstroms)
"import volumes" has a "z" parameter that is explained as: offset along z axis (Angstroms)
"import volumes" has a "Process data in streaming?" parameter that is explained as: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
"import volumes" has a "Timeout" parameter that is explained as: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

"import volumes" has a "File timeout" parameter that is explained as: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "manual check point" can be found in the pwem plugin.
"manual check point" protocol help is as follows:
 
    This protocol is kept running for a time determined by a parameter or until
    the user determines it is convenient. This protocol is useful if we want a
    given protocol to be launched at the time the user sees appropriate.
    .
"manual check point" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"manual check point" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"manual check point" has a "Time to wait:" parameter that is explained as: Time in seconds that the protocol will remain running. A correct format is an integer number in seconds or the following syntax: {days}d {hours}h {minutes}m {seconds}s separated by spaces e.g: 1d 2h 20m 15s,  10m 3s, 1h, 20s or 25.

The protocol named "mathematical operator" can be found in the pwem plugin.
"mathematical operator" protocol help is as follows:
 
    Protocol to make mathematical operations on different inputs
    .
"mathematical operator" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"mathematical operator" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"mathematical operator" has a "Input X1:" parameter that is explained as: Write the value you want to consider as X1 or if it is a input pointer select from the list of available inputs.
"mathematical operator" has a "Input X2:" parameter that is explained as: Write the value you want to consider as X2 or if it is a input pointer select from the list of available inputs.
"mathematical operator" has a "Formula: " parameter that is explained as: Write the mathematical formula you want to calculate, e.g: (X1 + X2) * X1 * 0.9 
Please note that X1 and X2 would be replaced by the value you selected for each case. It is important to use upper cases when writing the expression.
"mathematical operator" has a "Result type:" parameter that is explained as: Choose the variable type you want your result to be, e.g: Integer

The protocol named "assign gain to movies" can be found in the pwem plugin.
"assign gain to movies" protocol help is as follows:
  Assign a gain image to a set of movies
    .
"assign gain to movies" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"assign gain to movies" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"assign gain to movies" has a "Input Movies" parameter that is explained as: Select a set of previously imported movies.
"assign gain to movies" has a "Gain image" parameter that is explained as: Select a gain image. The movie will be corrected as newMovie=Movie/gain

The protocol named "movie eraser" can be found in the pwem plugin.
"movie eraser" protocol help is as follows:
  
    Protocol for removing movies based on different conditions:
    - If the input is SetOfMicrographs, it removes movies already aligned into micrographs.
    - If the input is SetOfCoordinates, it removes movies with unselected particles.
    WARNING: There is no way back. Be sure you understand the consequences.
    .
"movie eraser" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"movie eraser" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"movie eraser" has a "Input set" parameter that is explained as: Select the SetOfMicrographs or Coordinates to drive the movie DELETION process.
"movie eraser" has a "Movies source" parameter that is explained as: Select the SetOfMovies to locate the movie files. Match will be done by ids!.
"movie eraser" has a "Dry mode" parameter that is explained as: None

The protocol named "assign Orig & Sampling" can be found in the pwem plugin.
"assign Orig & Sampling" protocol help is as follows:
  Modify the origin and sampling values assigned to a 3D map
    .
"assign Orig & Sampling" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"assign Orig & Sampling" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"assign Orig & Sampling" has a "Input Volume" parameter that is explained as: A new object volume will be created with the assigned sampling rate and origin. No new binary file will be created
"assign Orig & Sampling" has a "Copy volume" parameter that is explained as: Option Yes:
A new volume file will be copied otherwise a link to the input volume is made
NOTE: if the copy option is selected the new sampling/origin is stored in the header. Otherwise this information  is only stored in Scipion's database
"assign Orig & Sampling" has a "Set sampling rate" parameter that is explained as: Option Yes:
A new volume object will be created with the given SamplingRate. This sampling rate will NOT be set in the map file header.


"assign Orig & Sampling" has a "Pixel size (sampling rate) Å/px" parameter that is explained as: None
"assign Orig & Sampling" has a "Set origin" parameter that is explained as: Option Yes:
A new volume object will be created with the given ORIGIN of coordinates. This ORIGIN will NOT be set in the map file header.


"assign Orig & Sampling" has a "x" parameter that is explained as: offset along x axis (Å)
"assign Orig & Sampling" has a "  y" parameter that is explained as: offset along y axis (Å)
"assign Orig & Sampling" has a "  z" parameter that is explained as: offset along z axis (Å)

The protocol named "pdf report" can be found in the pwem plugin.
"pdf report" protocol help is as follows:
  
    Produce a pdf report from the files in a given directory.
    Supported file formats: *.tex, *.txt, *.jpg, *.png, *.pdf
    Files in the directory are sorted by name alphabetically,
    so if you want them to have the right order a possibility is to name them as
    0010-myText.txt
    0020-aFigure.png
    0030-anotherFigure.jpg
    0040-aPaper.pdf
    0050-anotherText.tex
    ...
    when these files are sorted, they will be sorted by the number in front.
    .
"pdf report" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"pdf report" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"pdf report" has a "Files directory" parameter that is explained as: Directory with the input files. 
Check protocol help for more details.

The protocol named "picking difference" can be found in the pwem plugin.
"picking difference" protocol help is as follows:
 
    Protocol to compute the difference between a reference SetOfParticles and
    a another set (usually a negative reference).

    The output will be a SetOfCoordinates with the particles in the reference
    input that are not close to coordinates in the negative input.

    .
"picking difference" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"picking difference" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"picking difference" has a "Input coordinates" parameter that is explained as: Select the reference set of coordinates.
"picking difference" has a "Negative coordinates" parameter that is explained as: Negative coordinates that will help to exclude coordinates from the input set. 
"picking difference" has a "Radius (px)" parameter that is explained as: Distance radius to consider that two coordinates close enough. If a particle in the input referenceset have any close particle in the negative set, it will not be included in the output set. 
"picking difference" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "edit projection" can be found in the pwem plugin.
"edit projection" protocol help is as follows:
 
    This protocol edits the projection directions of all the items of a set of particles using
    a formula. This could be useful for applying geometrical transformation to a set of
    particles.

    Several predefined operation are offered such as
    * apply the rotation matrix define by an origin vector and a target vector
    * rotate the projection vector around a given vector by  A degrees
    * convert between icosahedral symmetries
    * convert between dihedral symmetries
    * convert between tetrahedral symmetries
    .
"edit projection" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"edit projection" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"edit projection" has a "Set of particles to edit" parameter that is explained as: Set which items will be modified.Must be a set of particles with transformations.
"edit projection" has a "Select operation" parameter that is explained as: Select operation to be performed in the set.
 *rotate to vector* modifies the alignment matrix  so a reconstruction made from the images produces a  rotated reconstruction
 *convert between icosahedral symmetry* will modify  the alignment matrix so the reconstruction will have  the new symmetry provided
 *convert between dihedral symmetry* will modify  the alignment matrix so the reconstruction will have  the new symmetry provided
 *convert between tetrahedral symmetry* will modify  the alignment matrix so the reconstruction will have  the new symmetry provided

"edit projection" has a "x" parameter that is explained as: X Coordinate 
"edit projection" has a "y" parameter that is explained as: Y dim 
"edit projection" has a "z" parameter that is explained as: Z dim 
"edit projection" has a "x" parameter that is explained as: X Coordinate 
"edit projection" has a "y" parameter that is explained as: Y dim 
"edit projection" has a "z" parameter that is explained as: Z dim 
"edit projection" has a "x" parameter that is explained as: X coordinate 
"edit projection" has a "y" parameter that is explained as: Y coordinate 
"edit projection" has a "z" parameter that is explained as: Z coordinate
"edit projection" has a "angle (degrees)" parameter that is explained as: rotation angle 
"edit projection" has a "origin" parameter that is explained as: Source symmetry. 
"edit projection" has a "target" parameter that is explained as: Target symmetry. 
"edit projection" has a "origin" parameter that is explained as: Source symmetry. 
"edit projection" has a "target" parameter that is explained as: Target symmetry. 
"edit projection" has a "origin" parameter that is explained as: Source symmetry. 
"edit projection" has a "target" parameter that is explained as: Target symmetry. 
"edit projection" has a "Symmetry" parameter that is explained as: Symmetry type to use.
"edit projection" has a "Order" parameter that is explained as: Order of the symmetry: 6 for C6, ...

The protocol named "data summary" can be found in the pwem plugin.
"data summary" protocol help is as follows:
  Aggregates any set data based on its fields.
"data summary" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"data summary" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"data summary" has a "Any set" parameter that is explained as: Set with the dta to be aggregated
"data summary" has a "Summary operations" parameter that is explained as: Summary operations to apply to all fields in Fields parameter. e.g: MIN MAX AVG. Possible values are MIN, MAX, COUNT, AVG, SUM, TOTAL, GROUP_CONCAT. For more technical information see: https://www.sqlite.org/lang_aggfunc.html
"data summary" has a "Fields" parameter that is explained as: Fields to apply operations on. Fields can be found in the metadata viewers. The header of the columns are valid names. e.g: _samplingRate id. Fields listed here should support the operations specified: DO NOT add literal fields.
"data summary" has a "Group by" parameter that is explained as: Fields to make the group. An empty value will summarize the whole dataset.

The protocol named "edit set" can be found in the pwem plugin.
"edit set" protocol help is as follows:
 
    Protocol to edit attributes of all the items of a set using a formula.
    This could be useful for editing some values in the set. Use this
    protocol with extreme care, you can easily produce a set that is
    not consistent.
    .
"edit set" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"edit set" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"edit set" has a "Set to edit" parameter that is explained as: Set which items will be modified.
"edit set" has a "Formula" parameter that is explained as: A python code compatible with eval, where item represents each of the elements of the set. E.g.: item._resolution.set(item._resolution.get() +1).You could also use modules like "import numpy;  item._resolution .... "

The protocol named "filter set" can be found in the pwem plugin.
"filter set" protocol help is as follows:
 
    Protocol to filter sets based on its attributes through an expression that
    should evaluate to true or false. Some predefined expresions are stored (i.e.
    distance to center, distance between coordinates)
    .
"filter set" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"filter set" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"filter set" has a "Set to filter" parameter that is explained as: Set which items will be filtered.
"filter set" has a "Select operation" parameter that is explained as: Select operation to be performed in the set.
 *distance to center* keep coordinates that are farther from the center than a given value.
 *distance-between-coordinates* if two coordinates 
 are closer than a given value then keep only one. *formula* will apply the formula to the chosen attribute (i.e, resolution less than 2 )
"filter set" has a "Passing formula" parameter that is explained as: A python code compatible with eval that should evaluate to True or False, where item represents each of the elements of the set. E.g.: item._resolution.get() < 4).You could also use modules like "import numpy;  item._resolution .... "
"filter set" has a "distance (A)" parameter that is explained as: distance from coordinates to center or distance between coordinates 
"filter set" has a "keep first coordinate" parameter that is explained as: If 2 or more coordinates are closer than distancekeep the first one or delete all
"filter set" has a "Threshold: " parameter that is explained as: Number/proportion of items to keep:
	Number: n>=1 
	Proportion: 0<n<1
	Percentage: n%

Higher/lower values of the attribute: 
	Higher: positive number
	Lower: negative number

e.g: "-10%" == "-0.1" == 10% of the items with lower values
e.g: "5" == 5 items with higher values
"filter set" has a "Ranking field: " parameter that is explained as: Attribute to sort the set by.

The protocol named "split sets" can be found in the pwem plugin.
"split sets" protocol help is as follows:
  Protocol to split a set in two or more subsets.
    .
"split sets" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"split sets" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"split sets" has a "Input set" parameter that is explained as: Select the set of elements (images, etc) that you want to split.
"split sets" has a "Number of subsets" parameter that is explained as: Select how many subsets do you want to create.
"split sets" has a "Randomize elements" parameter that is explained as: Put the elements at random in the different subsets.

The protocol named "stress" can be found in the pwem plugin.
"stress" protocol help is as follows:
  stress  will  stress  test  a  computer system in various selectable
       ways. Several options require the program stress-ng.
    .
"stress" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"stress" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"stress" has a "No. CPU stressors" parameter that is explained as: start N workers spinning on sqrt(rand())
"stress" has a "No. memory stressors" parameter that is explained as: start N workers continuously calling mmap(2)/munmap(2) and writing to the allocated memory. It will use 100% per worker 
"stress" has a "Memory per stressors (Mb)" parameter that is explained as: allocate N bytes per vm worker. each stressors will use 100% of a CPU
"stress" has a "No IO stressors" parameter that is explained as: start N workers spinning on sync() (Disk io)
"stress" has a "TimeOut (sec)" parameter that is explained as: timeout after N seconds. Total execution time is timeout plus delay
"stress" has a "delay (sec)" parameter that is explained as: wait this seconds before stressing the system seconds
"stress" has a "Additional parameters" parameter that is explained as: Additional parameters for stress-ng (http://kernel.ubuntu.com/~cking/stress-ng/)

The protocol named "subset" can be found in the pwem plugin.
"subset" protocol help is as follows:
     
    Create a set with the elements of an original set that are also
    referenced in another set.
    
    Usually there is a bigger set with all the elements, and a smaller
    one obtained from classification, cleaning, etc. The desired result
    is a set with the elements from the original set that are also present
    somehow in the smaller set (in the smaller set they may be downsampled
    or processed in some other way).
    
    Both sets should be of the same kind (micrographs, particles, volumes)
    or related (micrographs and CTFs for example).
    .
"subset" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"subset" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"subset" has a "Full set of items" parameter that is explained as: Even if the operation can be applied to two arbitrary sets,
the most common use-case is to retrieve a subset of
elements from an original full set.
*Note*: the elements of the resulting set will be the same
ones as this input set.
"subset" has a "Make random subset" parameter that is explained as: Choose elements randomly form the full set.
"subset" has a "Number of elements" parameter that is explained as: How many elements will be taken from the full set.
"subset" has a "Make a subset from specific IDs" parameter that is explained as: Choose specific elements form the full set.
"subset" has a "IDs range or list" parameter that is explained as: Select the IDs that will be the subset.
You have several ways to specify the IDs.
Example: 
"1,3,5-8,17-20" -> [1,3, 5, 6, 7, 8, 17, 18, 19, 20]

"subset" has a "Other set" parameter that is explained as: The elements present in this set will be used to pick 
elements from the input full set.     
This means that the output set will contain elements with 
exact the same information of input full set.

Set operation: if _intersection_ is used,
elements that are both in input and other set
will be included. If _difference_, elements that
are in input but not in other will picked.
"subset" has a "Set operation" parameter that is explained as: Set operation: if _intersection_ is used,
elements that are both in input and other set
will be included. If _difference_, elements that
are in input but not in other will picked.

The protocol named "particles subset by coordinates" can be found in the pwem plugin.
"particles subset by coordinates" protocol help is as follows:
 
    Create a subset of those particles that have a particular set of coordinates
    .
"particles subset by coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"particles subset by coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"particles subset by coordinates" has a "Input particles" parameter that is explained as: Set of particles from which the subset will be taken
"particles subset by coordinates" has a "Input coordinates" parameter that is explained as: Only the particles with this set of coordinates will be output
"particles subset by coordinates" has a "Coordinate tolerance (px)" parameter that is explained as: Two coordinates are supposed to be the same if their X and Y distance is smaller or equal this value

The protocol named "particles subset by micrograph" can be found in the pwem plugin.
"particles subset by micrograph" protocol help is as follows:
 
    Create a subset of those particles that come from a particular set of micrographs
    .
"particles subset by micrograph" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"particles subset by micrograph" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"particles subset by micrograph" has a "Input particles" parameter that is explained as: Set of particles from which the subset will be taken
"particles subset by micrograph" has a "Input micrographs" parameter that is explained as: Only the particles in this set of micrographs will be output

The protocol named "parallel test" can be found in the pwem plugin.
"parallel test" protocol help is as follows:
  A parallel test protocol.
    .
"parallel test" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"parallel test" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"parallel test" has a "Number of iterations" parameter that is explained as: Repeat the insertion of steps N times.
"parallel test" has a "Number of parallel sleeps" parameter that is explained as: How many sleep steps can be done at the same time.
"parallel test" has a "Fail after" parameter that is explained as: If you set an id, the next step should fail
"parallel test" has a "Seconds to sleep" parameter that is explained as: None
"parallel test" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"parallel test" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"parallel test" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "join sets" can be found in the pwem plugin.
"join sets" protocol help is as follows:
  Protocol to join two or more sets of images.
    This protocol allows to select two or more set of images
    and will produce another set joining all elements of the 
    selected sets. It will validate that all sets are of the
    same type of elements (Micrographs, Particles or Volumes) 
    .
"join sets" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"join sets" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"join sets" has a "Input type:" parameter that is explained as: Select the type of objects that you want to union.
Special case All will allow you to select any type.
"join sets" has a "Input set" parameter that is explained as: Select two or more sets (of micrographs, particles, volumes, etc.) to be united. If you select 3 sets with 100, 200, 200 elements, the final set will contain a total of 500 elements.
"join sets" has a "Remove duplicates?" parameter that is explained as: By default, duplicated items found (same ID) within the input sets, will cause renumbering of all the items ids in the output set. This is the case for example when doing several imports (which will cause ids overlapping) but we really want to insert as new items in the output. 
On the other hand, items originated in a previous common protocol (above in the workflow) might have identical items and you would like to remove them. Therefore, set this option to *Yes* to remove duplicates and keep only one copy of the item (the first occurrence).
"join sets" has a "Force new ids" parameter that is explained as: Perform an automatic renumbering of ids to ensure all objects have unique ids. This will mean new objects will not be associated to the old ones.

The protocol named "wait" can be found in the pwem plugin.
"wait" protocol help is as follows:
 
    Auxiliary protocol, it just waits "seconds" seconds and then exits
    .
"wait" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"wait" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"wait" has a "wait(seconds)" parameter that is explained as: Number of seconds the protocol waits untill it exits.

The protocol named "auto-picking" can be found in the relion plugin.
"auto-picking" protocol help is as follows:
  This protocol runs Relion autopicking (version > 3.0).

    This Relion protocol uses the 'relion_autopick' program to pick particles
    from micrographs, either using references (2D averages or 3D volumes)

    The wrapper implementation does not read/write any FOM maps compared to Relion
    .
"auto-picking" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"auto-picking" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"auto-picking" has a "Input micrographs" parameter that is explained as: Select the input micrographs. If using the *Optimize* mode, just a subset of micrographs are used to compute the FOM maps. If in *Compute* mode, all micrographs will be auto-picked.
"auto-picking" has a "CTF estimation" parameter that is explained as: Choose some CTF estimation related to the input micrographs.
"auto-picking" has a "References" parameter that is explained as: The preferred way to autopick is by providing 2D references images that were obtained by 2D classification. 
The Gaussian blob references may be useful to kickstart a new data set.
"auto-picking" has a "Input references" parameter that is explained as: Input references (SetOfAverages) for auto-pick. 

Note that the absolute greyscale needs to be correct, 
so only use images with proper normalization.
"auto-picking" has a "Input references" parameter that is explained as: Input volume from which 2D references will be made by projection. Note that the absolute greyscale needs to be correct, so only use maps created by RELION itself from this data set.
"auto-picking" has a "Symmetry" parameter that is explained as: Symmetry point group of the 3D reference. Only projections in the asymmetric part of the sphere will be generated.
"auto-picking" has a "3D angular sampling (deg)" parameter that is explained as: There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
For autopicking, 30 degrees is usually fine enough, but for highly symmetrical objects one may need to go finer to adequately sample the asymmetric part of the sphere.
"auto-picking" has a "Lowpass filter references (A)" parameter that is explained as: Lowpass filter that will be applied to the references before template matching. 
Do NOT use very high-resolution templates to search your micrographs. 
The signal will be too weak at high resolution anyway, and you may find Einstein from noise...
"auto-picking" has a "Highpass filter (A)" parameter that is explained as: Highpass filter that will be applied to the micrographs. This may be useful to get rid of background ramps due to uneven ice distributions. Give a negative value to skip the highpass filter.  Useful values are often in the range of 200-400 Angstroms.
"auto-picking" has a "Angular sampling (deg)" parameter that is explained as: Angular sampling in degrees for exhaustive searches of the in-plane rotations for all references.
"auto-picking" has a "References have inverted contrast?" parameter that is explained as: Set to Yes to indicate that the reference have inverted contrast with respect to the particles in the micrographs.
"auto-picking" has a "Are References CTF corrected?" parameter that is explained as: Set to Yes if the references were created with CTF-correction inside RELION.
If set to Yes, the input micrographs should contain the CTF information.
"auto-picking" has a "Ignore CTFs until first peak?" parameter that is explained as: Set this to Yes, only if this option was also used to generate the references.
"auto-picking" has a "Picking threshold:" parameter that is explained as: Use lower thresholds to pick more particles (and more junk probably)
"auto-picking" has a "Minimum inter-particle distance (A):" parameter that is explained as: Particles closer together than this distance 
will be consider to be a single cluster. 
From each cluster, only one particle will be picked.
"auto-picking" has a "Maximum stddev noise:" parameter that is explained as: This is useful to prevent picking in carbon areas, or areas with big contamination features. Peaks in areas where the background standard deviation in the normalized micrographs is higher than this value will be ignored. Useful values are probably in the range 1.0 to 1.2. Set to -1 to switch off the feature to eliminate peaks due to high background standard deviations.
"auto-picking" has a "Minimum avg noise:" parameter that is explained as: This is useful to prevent picking in carbon areas, or areas with big contamination features. Peaks in areas where the background standard deviation in the normalized micrographs is higher than this value will be ignored. Useful values are probably in the range -0.5 to 0. Set to -999 to switch off the feature to eliminate peaks due to low average background densities.
"auto-picking" has a "Shrink factor" parameter that is explained as: This is useful to speed up the calculations, and to make them less memory-intensive. The micrographs will be downscaled (shrunk) to calculate the cross-correlations, and peak searching will be done in the downscaled FOM maps. When set to 0, the micrographs will de downscaled to the lowpass filter of the references, a value between 0 and 1 will downscale the micrographs by that factor. Note that the results will not be exactly the same when you shrink micrographs!
"auto-picking" has a "Use GPU acceleration?" parameter that is explained as: If set to Yes, the job will try to use GPU acceleration.
"auto-picking" has a "Which GPUs to use:" parameter that is explained as: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
"auto-picking" has a "Additional arguments:" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "relion_autopick" will print a list of possible options.
"auto-picking" has a "The following params are related to how streaming is done in Scipion." parameter that is explained as: None
"auto-picking" has a "Sleep when waiting (secs)" parameter that is explained as: If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
"auto-picking" has a "Batch size" parameter that is explained as: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
"auto-picking" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"auto-picking" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "assign optics groups" can be found in the relion plugin.
"assign optics groups" protocol help is as follows:
  Assign Optics Group name and related parameters to an input set.
     Input set can be: movies, micrographs or particles.

     Warning: all optics parameters from the input set itself are removed!
    .
"assign optics groups" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"assign optics groups" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"assign optics groups" has a "Input set" parameter that is explained as: Select the input set (Movies, Micrographs or Particles) to assign Optics Group parameters.
"assign optics groups" has a "Input Optics Groups from" parameter that is explained as: Select how to provide information about the optics groups. In the case of single group provide the parameters below, otherwise you need to provide a star file.
"assign optics groups" has a "Optics group name" parameter that is explained as: Relion-specific option. Name of this optics group. Each group of movies with different optics characteristics for CTF refinement should have a unique name.
"assign optics groups" has a "MTF-curve file" parameter that is explained as: User-provided STAR-file with the MTF-curve of the detector. Use the wizard to load one of the predefined ones provided at:
- [[https://www3.mrc-lmb.cam.ac.uk/relion/index.php/FAQs#Where_can_I_find_MTF_curves_for_typical_detectors.3F][Relion's Wiki FAQs]]
 - [[https://www.gatan.com/techniques/cryo-em#MTF][Gatan's website]]

Relion param: *--mtf*
"assign optics groups" has a "X" parameter that is explained as: None
"assign optics groups" has a "Y" parameter that is explained as: None
"assign optics groups" has a "Gain reference" parameter that is explained as: A gain reference file is required for gain correction
"assign optics groups" has a "Gain rotation" parameter that is explained as: Rotate the gain reference by this number times 90 degrees clockwise in relion_display. This is the same as -RotGain in MotionCor2. 
Note that MotionCor2 uses a different convention for rotation so it says 'counter-clockwise'.
"assign optics groups" has a "Gain flip" parameter that is explained as: Flip the gain reference after rotation. This is the same as -FlipGain in MotionCor2. 0 means do nothing, 1 means flip Y (upside down) and 2 means flip X (left to right).
"assign optics groups" has a "Defects file" parameter that is explained as: Location of a UCSF MotionCor2-style defect text file or a defect map that describe the defect pixels on the detector. Each line of a defect text file should contain four numbers specifying x, y, width and height of a defect region. A defect map is an image (MRC or TIFF), where 0 means good and 1 means bad pixels. The coordinate system is the same as the input movie before application of binning, rotation and/or flipping.

_Note that the format of the defect text is DIFFERENT from the defect text produced by SerialEM!_
 One can convert a SerialEM-style defect file into a defect map using IMOD utilities e.g.:
*clip defect -D defect.txt -f tif movie.tif defect_map.tif*
See explanations in the SerialEM manual.
Leave empty if you do not have any defects, or do not want to correct for defects on your detector.
"assign optics groups" has a "Input Star file with optics groups" parameter that is explained as: Provide input star file with Optics groups information. The input Star file should contain: 
- *data_optics* table with values for each group.
- *data_micrographs* table with two columns: 

	rlnMicrographName with the micName associated to the input set.
	rlnOpticsGroup with the group number associated to this micrograph.

If you provide rlnMicrographGainName in the optics table, it has to point to a transformed gain reference (rotated and flipped if necessary).

The protocol named "auto-picking LoG" can be found in the relion plugin.
"auto-picking LoG" protocol help is as follows:
 
    This Relion protocol uses 'relion_autopick' program for the
    Laplacian of Gaussian (LoG) option.
    .
"auto-picking LoG" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"auto-picking LoG" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"auto-picking LoG" has a "Input micrographs" parameter that is explained as: Select the input micrographs. If using the *Optimize* mode, just a subset of micrographs are used to compute the FOM maps. If in *Compute* mode, all micrographs will be auto-picked.
"auto-picking LoG" has a "Box size (px)" parameter that is explained as: Box size in pixels.
"auto-picking LoG" has a "Min diameter (A)" parameter that is explained as: None
"auto-picking LoG" has a "Max diameter (A)" parameter that is explained as: None
"auto-picking LoG" has a "Are the particles white?" parameter that is explained as: Set this option to No if the particles are black, and to Yes if the particles are white.
"auto-picking LoG" has a "Maximum resolution to consider (A)" parameter that is explained as: The Laplacian-of-Gaussian filter will be applied to downscaled micrographs with the corresponding size. Give a negative value to skip downscaling.
"auto-picking LoG" has a "Adjust default threshold (stddev)" parameter that is explained as: Use this to pick more (negative number -> lower threshold) or less (positive number -> higher threshold) particles compared to the default setting.
"auto-picking LoG" has a "Upper threshold (stddev)" parameter that is explained as: Use this to discard picks with LoG thresholds that are this many standard deviations above the average, e.g. to avoid high contrast contamination like ice and ethane droplets. Good values depend on the contrast of micrographs and need to be interactively explored; for low contrast micrographs, values of ~ 1.5 may be reasonable, but the same value will be too low for high-contrast micrographs.
"auto-picking LoG" has a "Additional arguments:" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "relion_autopick" will print a list of possible options.
"auto-picking LoG" has a "The following params are related to how streaming is done in Scipion." parameter that is explained as: None
"auto-picking LoG" has a "Sleep when waiting (secs)" parameter that is explained as: If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
"auto-picking LoG" has a "Batch size" parameter that is explained as: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
"auto-picking LoG" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"auto-picking LoG" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "bayesian polishing" can be found in the relion plugin.
"bayesian polishing" protocol help is as follows:
 
    Wrapper protocol for the Relion's Bayesian Polishing.

    As of release 3.0, Relion also implements a new Bayesian approach to beam
    induced motion correction. This approach aims to optimise a regularised
    likelihood, which allows us to associate with each hypothetical set of
    particle trajectories a prior likelihood that favors spatially coherent
    and temporally smooth motion without imposing any hard constraints.
    The smoothness prior term requires three parameters that describe the
    statistics of the observed motion. To estimate the prior that yields the
    best motion tracks for this particular dataset, we can first run the
    program in 'training mode'. Once the estimates have been obtained, one
    can then run the program again to fit tracks for the motion of all
    particles in the data set and to produce adequately weighted averages of
    the aligned movie frames.

    .
"bayesian polishing" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"bayesian polishing" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"bayesian polishing" has a "Input ALIGNED movies" parameter that is explained as: Provide a set of movies that have at least global alignment information.
"bayesian polishing" has a "Input particles" parameter that is explained as: Provide a set of particles from 3D auto-refine or CTF refinement.
"bayesian polishing" has a "Input Postprocess" parameter that is explained as: Select a PostProcess job. The mask used for this postprocessing will be applied to the unfiltered half-maps and should encompass the entire complex. The resulting FSC curve will be used for weighting the different frequencies.
"bayesian polishing" has a "first" parameter that is explained as: None
"bayesian polishing" has a "last" parameter that is explained as: None
"bayesian polishing" has a "Extraction size (px in unbinned movie)" parameter that is explained as: Size of the extracted particles in the unbinned original movie (in pixels). This should be an even number.
"bayesian polishing" has a "Re-scaled size (px)" parameter that is explained as: The re-scaled value needs to be an even number.
"bayesian polishing" has a "Write output in float16?" parameter that is explained as: Relion can write output images in float16 MRC (mode 12) format to save disk space. By default, float32 format is used.
"bayesian polishing" has a "Operation" parameter that is explained as: If *train optimal parameters* , then relion_motion_refine will estimate optimal parameter values for the three sigma values above on a subset of the data (determined by the minimum number of particles to be used below).

If *perform particle polishing* then relion_motion_refine will be run to estimate per-particle motion-tracks using the parameters below, and polished particles will be generated. 
"bayesian polishing" has a "Fraction of Fourier pixels for testing" parameter that is explained as: This fraction of Fourier pixels (at higher resolution) will be used for evaluation of the parameters (test set), whereas the rest (at lower resolution) will be used for parameter estimation itself (work set).
"bayesian polishing" has a "Use this many particles" parameter that is explained as: Use at least this many particles for the meta-parameter optimisation. The more particles the more expensive in time and computer memory the calculation becomes, but the better the results may get.
"bayesian polishing" has a "Sigma for velocity (A/dose)" parameter that is explained as: Standard deviation for the velocity regularisation. Smaller values requires the tracks to be shorter.
"bayesian polishing" has a "Sigma for divergence (A)" parameter that is explained as: Standard deviation for the divergence of tracks across the micrograph. Smaller values requires the tracks to be spatially more uniform in a micrograph.
"bayesian polishing" has a "Sigma for acceleration (A/dose)" parameter that is explained as: Standard deviation for the acceleration regularisation. Smaller values requires the tracks to be straighter.
"bayesian polishing" has a "min" parameter that is explained as: None
"bayesian polishing" has a "max" parameter that is explained as: None
"bayesian polishing" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"bayesian polishing" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"bayesian polishing" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "calculate fsc" can be found in the relion plugin.
"calculate fsc" protocol help is as follows:
 
    Relion protocol to calculate various FSC curves using relion_image_handler.
    .
"calculate fsc" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"calculate fsc" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"calculate fsc" has a "Select FSC type to compute" parameter that is explained as: 1) FSC overall - between two half-maps
2) FSC model-map - between atomic model and refined map
3) FSC work - model refined against half-map 1, compared to half-map 1
FSC free - model refined against half-map 1, compared to half-map 2
"calculate fsc" has a "Input half map 1" parameter that is explained as: None
"calculate fsc" has a "Input half map 2" parameter that is explained as: None
"calculate fsc" has a "Final map" parameter that is explained as: None
"calculate fsc" has a "Final atomic model" parameter that is explained as: None
"calculate fsc" has a "Atomic model refined against half-map 1" parameter that is explained as: None
"calculate fsc" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "center averages" can be found in the relion plugin.
"center averages" protocol help is as follows:
 
    Align class averages by their center of mass using *relion_image_handler*.
     (With *--shift_com* option)
    .
"center averages" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"center averages" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"center averages" has a "Input averages" parameter that is explained as: Select the input averages to be centered.
"center averages" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "2D classification" can be found in the relion plugin.
"2D classification" protocol help is as follows:
  This protocol runs Relion 2D classification..
"2D classification" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"2D classification" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"2D classification" has a "" parameter that is explained as: None
"2D classification" has a "" parameter that is explained as: None
"2D classification" has a "Continue from a previous run?" parameter that is explained as: If you set to *Yes*, you should select a previousrun of type *ProtRelionClassify2D* class and most of the input parameterswill be taken from it.
"2D classification" has a "Input particles" parameter that is explained as: Select the input images from the project.
"2D classification" has a "Consider previous alignment?" parameter that is explained as: If set to Yes, then alignment information from input particles will be considered.
"2D classification" has a "Consider alignment as priors?" parameter that is explained as: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
"2D classification" has a "" parameter that is explained as: None
"2D classification" has a "Particle mask diameter (A)" parameter that is explained as: The experimental images will be masked with a soft circular mask with this <diameter>. Make sure this diameter is not set too small because that may mask away part of the signal! If set to a value larger than the image size no masking will be performed.

The same diameter will also be used for a spherical mask of the reference structures if no user-provided mask is specified.
"2D classification" has a "Mask particles with zeros?" parameter that is explained as: If set to <Yes>, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform. This will remove noise and therefore increase sensitivity in the alignment and classification. However, it will also introduce correlations between the Fourier components that are not modelled. When set to <No>, then the solvent area is filled with random noise, which prevents introducing correlations.High-resolution refinements (e.g. in 3D auto-refine) tend to work better when filling the solvent area with random noise, some classifications go better when using zeros.
"2D classification" has a "Select previous run" parameter that is explained as: Select a previous run to continue from.
"2D classification" has a "Continue from iteration" parameter that is explained as: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
"2D classification" has a "Reference averages" parameter that is explained as: This option is not recommended and should be used with care. The provided averages will be used as initial 2D references. If this option is used, the number of classes will be ignored. 
"2D classification" has a "Reference mask (optional)" parameter that is explained as: User-provided mask for the references (default is to use spherical mask with particle_diameter)
"2D classification" has a "CTF parameters are not available in continue mode" parameter that is explained as: None
"2D classification" has a "Do CTF-correction?" parameter that is explained as: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
"2D classification" has a "Have data been phase-flipped?      (Don't answer, see help)" parameter that is explained as: The phase-flip status is recorded and managed by Scipion. 
 In other words, when you import or extract particles, 
Scipion will record whether or not phase flipping has been done.

Note that CTF-phase flipping is NOT a necessary pre-processing step 
for MAP-refinement in RELION, as this can be done inside the internal
CTF-correction. However, if the phases have been flipped, the program will handle it.
"2D classification" has a "Ignore CTFs until first peak?" parameter that is explained as: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
"2D classification" has a "Do manual grouping ctfs?" parameter that is explained as: Set this to Yes the CTFs will grouping manually.
"2D classification" has a "Defocus range for group creation (in Angstroms)" parameter that is explained as: Particles will be grouped by defocus.This parameter is the bin for a histogram.All particles assigned to a bin form a group
"2D classification" has a "minimum size for defocus group" parameter that is explained as: If defocus group is smaller than this value, it will be expanded until number of particles per defocus group is reached
"2D classification" has a "Number of classes:" parameter that is explained as: The number of classes (K) for a multi-reference refinement. These classes will be made in an unsupervised manner from a single reference by division of the data into random subsets during the first iteration.
"2D classification" has a "Regularisation parameter T" parameter that is explained as: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D refinements, values of 1-2 for 2D refinements. Too small values yield too-low resolution structures; too high values result in over-estimated resolutions and overfitting.
"2D classification" has a "Use VDAM algorithm?" parameter that is explained as: If set to Yes, the faster VDAM algorithm will be used. This algorithm was introduced with Relion-4.0. If set to No, then the slower EM algorithm needs to be used.
"2D classification" has a "Number of VDAM mini-batches" parameter that is explained as: Number of mini-batches to be processed using the VDAM algorithm. Using 200 has given good results for many data sets. Using 100 will run faster, at the expense of some quality in the results.
"2D classification" has a "Center class averages?" parameter that is explained as: If set to Yes, every iteration the class average images will be centered on their center-of-mass. This will work only for positive signals, so the particles should be white.
"2D classification" has a "Number of iterations" parameter that is explained as: Number of iterations to be performed. Note that the current implementation does NOT comprise a convergence criterium. Therefore, the calculations will need to be stopped by the user if further iterations do not yield improvements in resolution or classes. If continue option is True, you going to do this number of new iterations (e.g. if *Continue from iteration* is set 3 and this param is set 25, the final iteration of the protocol will be the 28th.
"2D classification" has a "Limit resolution E-step to (A)" parameter that is explained as: If set to a positive number, then the expectation step (i.e. the alignment) will be done only including the Fourier components up to this resolution (in Angstroms). This is useful to prevent overfitting, as the classification runs in RELION are not to be guaranteed to be 100% overfitting-free (unlike the _3D auto-refine_ with its gold-standard FSC). In particular for very difficult data sets, e.g. of very small or featureless particles, this has been shown to give much better class averages. In such cases, values in the range of 7-12 Angstroms have proven useful.
"2D classification" has a "Perform image alignment?" parameter that is explained as: If set to No, then rather than performing both alignment and classification, only classification will be performed. This allows the use of very focused masks. This requires that the optimal orientations of all particles are already calculated.
"2D classification" has a "In-plane angular sampling (deg)" parameter that is explained as: The sampling rate for the in-plane rotation angle (psi) in degrees.
Using fine values will slow down the program. Recommended value for
most 2D refinements: 5 degrees. 

If auto-sampling is used, this will be the value for the first 
iteration(s) only, and the sampling rate will be increased 
automatically after that.
"2D classification" has a "Initial offset range (pix)" parameter that is explained as: Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
"2D classification" has a "Initial offset step (pix)" parameter that is explained as: Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid.
"2D classification" has a "Allow coarser sampling?" parameter that is explained as: If set to Yes, the program will use coarser angular and translational samplings if the estimated accuracies of the assignments is still low in the earlier iterations. This may speed up the calculations.
"2D classification" has a "Use parallel disc I/O?" parameter that is explained as: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
"2D classification" has a "Number of pooled particles:" parameter that is explained as: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
"2D classification" has a "Pre-read all particles into RAM?" parameter that is explained as: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
"2D classification" has a "Copy particles to scratch directory: " parameter that is explained as: If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
"2D classification" has a "Combine iterations through disc?" parameter that is explained as: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
"2D classification" has a "Use GPU acceleration?" parameter that is explained as: If set to Yes, the job will try to use GPU acceleration.
"2D classification" has a "Which GPUs to use:" parameter that is explained as: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
"2D classification" has a "Over-sampling" parameter that is explained as: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
"2D classification" has a "Additional arguments" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--dont_combine_weights_via_disc
--verb 1
--pad 2

"2D classification" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"2D classification" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"2D classification" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "3D classification" can be found in the relion plugin.
"3D classification" protocol help is as follows:
 
    Protocol to classify 3D using Relion Bayesian approach.
    Relion employs an empirical Bayesian approach to refinement of (multiple)
    3D reconstructions or 2D class averages in electron cryo-EM. Many
    parameters of a statistical model are learned from the data, which
    leads to objective and high-quality results.
    .
"3D classification" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"3D classification" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"3D classification" has a "" parameter that is explained as: None
"3D classification" has a "" parameter that is explained as: None
"3D classification" has a "Continue from a previous run?" parameter that is explained as: If you set to *Yes*, you should select a previousrun of type *ProtRelionClassify3D* class and most of the input parameterswill be taken from it.
"3D classification" has a "Input particles" parameter that is explained as: Select the input images from the project.
"3D classification" has a "Consider previous alignment?" parameter that is explained as: If set to Yes, then alignment information from input particles will be considered.
"3D classification" has a "Consider alignment as priors?" parameter that is explained as: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
"3D classification" has a "" parameter that is explained as: None
"3D classification" has a "Particle mask diameter (A)" parameter that is explained as: The experimental images will be masked with a soft circular mask with this <diameter>. Make sure this diameter is not set too small because that may mask away part of the signal! If set to a value larger than the image size no masking will be performed.

The same diameter will also be used for a spherical mask of the reference structures if no user-provided mask is specified.
"3D classification" has a "Mask particles with zeros?" parameter that is explained as: If set to <Yes>, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform. This will remove noise and therefore increase sensitivity in the alignment and classification. However, it will also introduce correlations between the Fourier components that are not modelled. When set to <No>, then the solvent area is filled with random noise, which prevents introducing correlations.High-resolution refinements (e.g. in 3D auto-refine) tend to work better when filling the solvent area with random noise, some classifications go better when using zeros.
"3D classification" has a "Select previous run" parameter that is explained as: Select a previous run to continue from.
"3D classification" has a "Continue from iteration" parameter that is explained as: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
"3D classification" has a "Reference averages" parameter that is explained as: This option is not recommended and should be used with care. The provided averages will be used as initial 2D references. If this option is used, the number of classes will be ignored. 
"3D classification" has a "Input volume(s)" parameter that is explained as: Initial reference 3D map, it should have the same dimensions and the same pixel size as your input particles.
"3D classification" has a "Reference mask (optional)" parameter that is explained as: A volume mask containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask. If no mask is given, a soft spherical mask based on the <radius> of the mask for the experimental images will be applied.

In some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. Check _Advaced_ level and select another volume mask
"3D classification" has a "Second reference mask (optional)" parameter that is explained as: For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas.
"3D classification" has a "Use solvent-flattened FSCs?" parameter that is explained as: If set to Yes, then instead of using unmasked maps to calculate the gold-standard FSCs during refinement, masked half-maps are used and a post-processing-like correction of the FSC curves (with phase-randomisation) is performed every iteration. This only works when a reference mask is provided on the I/O tab. This may yield higher-resolution maps, especially when the mask contains only a relatively small volume inside the box.
"3D classification" has a "Is initial 3D map on absolute greyscale?" parameter that is explained as: The probabilities are based on squared differences, so that the absolute grey scale is important. 
Probabilities are calculated based on a Gaussian noise model, which contains a squared difference term between the reference and the experimental image. This has a consequence that the reference needs to be on the same absolute intensity grey-scale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity grey-scale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. Therefore: if the map was reconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No. If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent MAP refinement. Therefore, if in doubt it is recommended to set this option to No.
"3D classification" has a "Symmetry" parameter that is explained as: See [[https://relion.readthedocs.io/en/latest/Reference/Conventions.html#symmetry][Relion Symmetry]] page for a description of the symmetry format accepted by Relion
"3D classification" has a "Initial low-pass filter (A)" parameter that is explained as: It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s).
"3D classification" has a "CTF parameters are not available in continue mode" parameter that is explained as: None
"3D classification" has a "Do CTF-correction?" parameter that is explained as: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
"3D classification" has a "Have data been phase-flipped?      (Don't answer, see help)" parameter that is explained as: The phase-flip status is recorded and managed by Scipion. 
 In other words, when you import or extract particles, 
Scipion will record whether or not phase flipping has been done.

Note that CTF-phase flipping is NOT a necessary pre-processing step 
for MAP-refinement in RELION, as this can be done inside the internal
CTF-correction. However, if the phases have been flipped, the program will handle it.
"3D classification" has a "Ignore CTFs until first peak?" parameter that is explained as: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
"3D classification" has a "Do manual grouping ctfs?" parameter that is explained as: Set this to Yes the CTFs will grouping manually.
"3D classification" has a "Defocus range for group creation (in Angstroms)" parameter that is explained as: Particles will be grouped by defocus.This parameter is the bin for a histogram.All particles assigned to a bin form a group
"3D classification" has a "minimum size for defocus group" parameter that is explained as: If defocus group is smaller than this value, it will be expanded until number of particles per defocus group is reached
"3D classification" has a "Number of classes:" parameter that is explained as: The number of classes (K) for a multi-reference refinement. These classes will be made in an unsupervised manner from a single reference by division of the data into random subsets during the first iteration.
"3D classification" has a "Regularisation parameter T" parameter that is explained as: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D refinements, values of 1-2 for 2D refinements. Too small values yield too-low resolution structures; too high values result in over-estimated resolutions and overfitting.
"3D classification" has a "Number of iterations" parameter that is explained as: Number of iterations to be performed. Note that the current implementation does NOT comprise a convergence criterium. Therefore, the calculations will need to be stopped by the user if further iterations do not yield improvements in resolution or classes. If continue option is True, you going to do this number of new iterations (e.g. if *Continue from iteration* is set 3 and this param is set 25, the final iteration of the protocol will be the 28th.
"3D classification" has a "Use fast subsets (for large data sets)?" parameter that is explained as: If set to Yes, the first 5 iterations will be done with random subsets of only K*100 particles (K being the number of classes); the next 5 with K*300 particles, the next 5 with 30% of the data set; and the final ones with all data. This was inspired by a cisTEM implementation by Niko Grigorieff et al.
"3D classification" has a "Use Blush regularisation?" parameter that is explained as: If set to Yes, relion_refine will use a neural network to perform regularisation by denoising at every iteration, instead of the standard smoothness regularisation.
"3D classification" has a "Limit resolution E-step to (A)" parameter that is explained as: If set to a positive number, then the expectation step (i.e. the alignment) will be done only including the Fourier components up to this resolution (in Angstroms). This is useful to prevent overfitting, as the classification runs in RELION are not to be guaranteed to be 100% overfitting-free (unlike the _3D auto-refine_ with its gold-standard FSC). In particular for very difficult data sets, e.g. of very small or featureless particles, this has been shown to give much better class averages. In such cases, values in the range of 7-12 Angstroms have proven useful.
"3D classification" has a "Perform image alignment?" parameter that is explained as: If set to No, then rather than performing both alignment and classification, only classification will be performed. This allows the use of very focused masks. This requires that the optimal orientations of all particles are already calculated.
"3D classification" has a "Initial angular sampling (deg)" parameter that is explained as: There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
"3D classification" has a "Initial offset range (pix)" parameter that is explained as: Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
"3D classification" has a "Initial offset step (pix)" parameter that is explained as: Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid.
"3D classification" has a "Perform local angular search?" parameter that is explained as: If set to Yes, then rather than performing exhaustive angular searches, local searches within the range given below will be performed. A prior Gaussian distribution centered at the optimal orientation in the previous iteration and with a stddev of 1/3 of the range given below will be enforced.
"3D classification" has a "Local angular search range" parameter that is explained as: Local angular searches will be performed within +/- the given amount (in degrees) from the optimal orientation in the previous iteration. A Gaussian prior (also see previous option) will be applied, so that orientations closer to the optimal orientation in the previous iteration will get higher weights than those further away.
"3D classification" has a "Relax symmetry" parameter that is explained as: With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020.
"3D classification" has a "Allow coarser sampling?" parameter that is explained as: If set to Yes, the program will use coarser angular and translational samplings if the estimated accuracies of the assignments is still low in the earlier iterations. This may speed up the calculations.
"3D classification" has a "Use parallel disc I/O?" parameter that is explained as: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
"3D classification" has a "Number of pooled particles:" parameter that is explained as: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
"3D classification" has a "Skip padding" parameter that is explained as: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
"3D classification" has a "Pre-read all particles into RAM?" parameter that is explained as: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
"3D classification" has a "Copy particles to scratch directory: " parameter that is explained as: If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
"3D classification" has a "Combine iterations through disc?" parameter that is explained as: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
"3D classification" has a "Use GPU acceleration?" parameter that is explained as: If set to Yes, the job will try to use GPU acceleration.
"3D classification" has a "Which GPUs to use:" parameter that is explained as: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
"3D classification" has a "Over-sampling" parameter that is explained as: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
"3D classification" has a "Additional arguments" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--dont_combine_weights_via_disc
--verb 1
--pad 2

"3D classification" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"3D classification" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"3D classification" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "clean project" can be found in the relion plugin.
"clean project" protocol help is as follows:
 
    Run Relion gentle clean procedure for the whole project.
    .
"clean project" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"clean project" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"clean project" has a "Gentle clean procedure will move all intermediate files from finished Relion protocols to Trash folder. For iteration-based jobs, only the last iteration files are kept." parameter that is explained as: None

The protocol named "estimate gain reference" can be found in the relion plugin.
"estimate gain reference" protocol help is as follows:
 
    Using *relion_convert_to_tiff* to estimate the gain reference from a set of movies.
    .
"estimate gain reference" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"estimate gain reference" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"estimate gain reference" has a "Input Movies" parameter that is explained as: Select a set of movies to be used in the gain estimation.
"estimate gain reference" has a "Subset" parameter that is explained as: Use a subset of the movies for the estimation. If 0, all input movies will be used. 
"estimate gain reference" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"estimate gain reference" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "compress movies" can be found in the relion plugin.
"compress movies" protocol help is as follows:
 
    Using *relion_convert_to_tiff* to compress a set of movies.
    .
"compress movies" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"compress movies" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"compress movies" has a "Input Movies" parameter that is explained as: Select a set of previously imported movies.
"compress movies" has a "Input gain estimation protocol (optional)" parameter that is explained as: Provide an estimate gain reference protocol from where the gain file will be taken.
"compress movies" has a "Compression type" parameter that is explained as: None
"compress movies" has a "Deflate level" parameter that is explained as: deflate level. 1 (fast) to 9 (slowest but best compression)
"compress movies" has a "EER fractionation" parameter that is explained as: The number of hardware frames to group into one fraction. This option is relevant only for Falcon4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
"compress movies" has a "EER upsampling" parameter that is explained as: EER upsampling (1 = 4K or 2 = 8K). 8K rendering is not recommended by Relion. See https://relion.readthedocs.io/en/latest/Reference/MovieCompression.html
"compress movies" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"compress movies" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"compress movies" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "create 3d mask" can be found in the relion plugin.
"create 3d mask" protocol help is as follows:
  This protocols creates a 3D mask using Relion.
    The mask is created from a 3d volume or by comparing two input volumes.
    .
"create 3d mask" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"create 3d mask" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"create 3d mask" has a "Input volume" parameter that is explained as: Select the volume that will be used to create the mask
"create 3d mask" has a "Lowpass filter map by (A)" parameter that is explained as: Lowpass filter that will be applied to the input map, prior to binarization. To calculate solvent masks, a lowpass filter of 15-20A may work well.
"create 3d mask" has a "Initial binarisation threshold" parameter that is explained as: This threshold is used to make an initial binary mask from the average of the two unfiltered half-reconstructions. If you don't know what value to use, display one of the unfiltered half-maps in a 3D surface rendering viewer and find the lowest threshold that gives no noise peaks outside the reconstruction.
"create 3d mask" has a "Compare with another volume to produce a mask?" parameter that is explained as: Logical comparison of two input volumes to produce a mask
"create 3d mask" has a "Input volume (second)" parameter that is explained as: Select the volume that will be compared to the first one
"create 3d mask" has a "Operation" parameter that is explained as: *AND*: Pixels in the initial mask will be one if the input AND the second volume are above the threshold value.
*OR*: Pixels in the initial mask will be one if the input OR the second volume are above the threshold value.
*AND_NOT*: pixels in the initial mask will be one if the input is above the threshold AND the second volume is below it.
*OR_NOT*: pixels in the initial mask will be one if the input is above the threshold OR the second volume is below it.
"create 3d mask" has a "Extend binary mask by (px)" parameter that is explained as: The initial binary mask is extended this number of pixels in all directions.
"create 3d mask" has a "Add a soft-edge (px)" parameter that is explained as: The extended binary mask is further extended with a raised-cosine soft edge of the specified width.
"create 3d mask" has a "Invert final mask" parameter that is explained as: Invert the final mask
"create 3d mask" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"create 3d mask" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "ctf refinement" can be found in the relion plugin.
"ctf refinement" protocol help is as follows:
  Wrapper protocol for the Relion's CTF refinement. .
"ctf refinement" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"ctf refinement" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"ctf refinement" has a "Input particles" parameter that is explained as: Provide a set of particles for local CTF refinement.
"ctf refinement" has a "Input Postprocess" parameter that is explained as: Select a PostProcess job. The mask used for this postprocessing will be applied to the unfiltered half-maps and should encompass the entire complex. The resulting FSC curve will be used for weighting the different frequencies.

Note that for helices it is common practice to use a mask only encompassing the central 30% or so of the box. This gives higher resolution estimates, as it disregards ill-defined regions near the box edges. However, for ctf_refine it is better to use a mask encompassing (almost) the entire box, as otherwise there may not be enough signal. 
"ctf refinement" has a "Estimate (anisotropic) magnification?" parameter that is explained as: If set to Yes, then relion_ctf_refine will also estimate the (anisotropic) magnification per optics group. This option cannot be done simultaneously with higher-order aberration estimation. It's probably best to estimate the one that is most off first, and the other one second. It might be worth repeating the estimation if both are off.
"ctf refinement" has a "Perform CTF parameter fitting?" parameter that is explained as: If set to Yes, then relion_ctf_refine will be used to estimate the selected parameters below.
"ctf refinement" has a "Fit defocus?" parameter that is explained as: If set to per-particle or per-micrograph, then relion_ctf_refine will estimate a defocus values.
"ctf refinement" has a "Fit astigmatism? " parameter that is explained as: If set to per-particle or per-micrograph, then relion_ctf_refine will estimate astigmatism.
"ctf refinement" has a "Fit B-factor?" parameter that is explained as: If set to per-particle or per-micrograph, then relion_ctf_refine will estimate B-factors that describe the signal falloff.
"ctf refinement" has a "Fit phase-shift? " parameter that is explained as: If set to per-particle or per-micrograph, then relion_ctf_refine will estimate astigmatism.
"ctf refinement" has a "Estimate beamtilt?" parameter that is explained as: If set to Yes, then relion_ctf_refine will also estimate the beamtilt per optics group. This option is only recommended for data sets that extend beyond 4.5 Angstrom resolution.
"ctf refinement" has a "Also estimate trefoil?" parameter that is explained as: If set to Yes, then relion_ctf_refine will also estimate the trefoil (3-fold astigmatism) per optics group. This option is only recommended for data sets that extend beyond 3.5 Angstrom resolution.
"ctf refinement" has a "Estimate 4th order aberrations?" parameter that is explained as: If set to Yes, then relion_ctf_refine will also estimate the Cs and the tetrafoil (4-fold astigmatism) per optics group. This option is only recommended for data sets that extend beyond 3 Angstrom resolution.
"ctf refinement" has a "Minimum resolution for fits (A)" parameter that is explained as: The minimum spatial frequency (in Angstrom) used in the beam tilt fit.
"ctf refinement" has a "Additional arguments" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program
"ctf refinement" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"ctf refinement" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"ctf refinement" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "expand symmetry" can be found in the relion plugin.
"expand symmetry" protocol help is as follows:
  This protocols wraps relion_particle_symmetry_expand program.

    Given an input set of particles with angular assignment,
    expand the set by applying a pseudo-symmetry.
    .
"expand symmetry" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"expand symmetry" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"expand symmetry" has a "Input Particles" parameter that is explained as: None
"expand symmetry" has a "Symmetry group" parameter that is explained as: See [[https://relion.readthedocs.io/en/latest/Reference/Conventions.html#symmetry][Relion Symmetry]] page for a description of the symmetry format accepted by Relion
"expand symmetry" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "export coordinates" can be found in the relion plugin.
"export coordinates" protocol help is as follows:
  Export coordinates from Relion to be used outside Scipion. .
"export coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"export coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"export coordinates" has a "Input coordinates" parameter that is explained as: Select the SetOfCoordinates 

The protocol named "export ctf" can be found in the relion plugin.
"export ctf" protocol help is as follows:
  Export a SetOfCTF to a Relion STAR file. .
"export ctf" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"export ctf" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"export ctf" has a "Input CTF" parameter that is explained as: Select set of CTF that you want to export.
"export ctf" has a "Micrographs source" parameter that is explained as: By default the micrograph used to create theexported STAR files are those used for the CTF estimation. You can selected *other* to use a different set of micrographs (e.g., dose weighted)
"export ctf" has a "Input micrographs" parameter that is explained as: Select the SetOfMicrographs from which to extract.
"export ctf" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "export particles" can be found in the relion plugin.
"export particles" protocol help is as follows:
  Export particles from Relion to be used outside Scipion. .
"export particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"export particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"export particles" has a "Input particles" parameter that is explained as: Select the input images from the project.
"export particles" has a "Write alignment information?" parameter that is explained as: If *Yes* the alignment information (2D or 3D) will be written to the resulting .star file if the particles contains such information.
"export particles" has a "Binary stack files" parameter that is explained as: If *Don't write stacks* is chosen, only the star files will be written out. Alternatively, you can select to write images into a single stack file or several stacks (one per micrograph). 

The protocol named "particles extraction" can be found in the relion plugin.
"particles extraction" protocol help is as follows:
  Protocol to extract particles using a set of coordinates. .
"particles extraction" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"particles extraction" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"particles extraction" has a "Input coordinates" parameter that is explained as: Select the SetOfCoordinates 
"particles extraction" has a "Micrographs source" parameter that is explained as: By default the particles will be extracted from the micrographs used in the picking step ( _same as picking_ option ). 
If you select _other_ option, you must provide a different set of micrographs to extract from. 
*Note*: In the _other_ case, ensure that provided micrographs and coordinates are related by micName or by micId. Difference in pixel size will be handled automatically.
"particles extraction" has a "Input micrographs" parameter that is explained as: Select the SetOfMicrographs from which to extract.
"particles extraction" has a "CTF estimation" parameter that is explained as: Choose some CTF estimation related to input micrographs. 
 CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
"particles extraction" has a "Particle box size (px)" parameter that is explained as: This is size of the boxed particles (in pixels).
"particles extraction" has a "Rescale particles?" parameter that is explained as: If set to Yes, particles will be re-scaled. Note that the re-scaled size below will be in the down-scaled images.
"particles extraction" has a "Re-scaled size (px)" parameter that is explained as: Final size in pixels of the extracted particles. The provided value should be an even number. 
"particles extraction" has a "Write output in float16?" parameter that is explained as: Relion can write output images in float16 MRC (mode 12) format to save disk space. By default, float32 format is used.
"particles extraction" has a "Invert contrast?" parameter that is explained as: Invert the contrast if your particles are black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background. Frealign (up to v9.07) requires black particles over a white background
"particles extraction" has a "Normalize particles?" parameter that is explained as: If set to Yes, particles will be normalized in the way RELION prefers it.
"particles extraction" has a "Diameter background circle before scaling (px)" parameter that is explained as: Particles will be normalized to a mean value of zero and a standard-deviation of one for all pixels in the background area. The background area is defined as all pixels outside a circle with this given diameter in pixels (before rescaling). When specifying a negative value, a default value of 75% of the Particle box size will be used.
"particles extraction" has a "Stddev for white dust removal: " parameter that is explained as: Remove very white pixels from the extracted particles. Pixels values higher than this many times the image stddev will be replaced with values from a Gaussian distribution. 
Use negative value to switch off dust removal.
"particles extraction" has a "Stddev for black dust removal: " parameter that is explained as: Remove very black pixels from the extracted particles. Pixels values higher than this many times the image stddev will be replaced with values from a Gaussian distribution. 
Use negative value to switch off dust removal.
"particles extraction" has a "The following params are related to how streaming is done in Scipion." parameter that is explained as: None
"particles extraction" has a "Sleep when waiting (secs)" parameter that is explained as: If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
"particles extraction" has a "Batch size" parameter that is explained as: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
"particles extraction" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"particles extraction" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "import coordinates" can be found in the relion plugin.
"import coordinates" protocol help is as follows:
 
    Import coordinates from a particles star file.
    .
"import coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import coordinates" has a "Input STAR file path with coordinates" parameter that is explained as: None
"import coordinates" has a "Input micrographs" parameter that is explained as: Select the micrographs for which you want to import coordinates.
"import coordinates" has a "Box size" parameter that is explained as: None
"import coordinates" has a "Scale" parameter that is explained as: Factor to scale coordinates
"import coordinates" has a "Invert X" parameter that is explained as: None
"import coordinates" has a "Invert Y" parameter that is explained as: Invert Y for EMAN coordinates taken on dm3 or tif micrographs

The protocol named "3D initial model" can be found in the relion plugin.
"3D initial model" protocol help is as follows:
  This protocols creates a 3D initial model using Relion.

    Generate a 3D initial model _de novo_ from 2D particles using
    Relion Stochastic Gradient Descent (SGD) algorithm.
    .
"3D initial model" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"3D initial model" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"3D initial model" has a "Continue from a previous run?" parameter that is explained as: If you set to *Yes*, you should select a previousrun of type *ProtRelionInitialModel* class and most of the input parameters will be taken from it.
"3D initial model" has a "Input particles" parameter that is explained as: Select the input images from the project.
"3D initial model" has a "Particle mask diameter (A)" parameter that is explained as: The experimental images will be masked with a soft circular mask with this <diameter>. Make sure this diameter is not set too small because that may mask away part of the signal! If set to a value larger than the image size no masking will be performed.

The same diameter will also be used for a spherical mask of the reference structures if no user-provided mask is specified.
"3D initial model" has a "Select previous run" parameter that is explained as: Select a previous run to continue from.
"3D initial model" has a "Continue from iteration" parameter that is explained as: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
"3D initial model" has a "CTF parameters are not available in continue mode" parameter that is explained as: None
"3D initial model" has a "Do CTF-correction?" parameter that is explained as: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
"3D initial model" has a "Have data been phase-flipped?      (Don't answer, see help)" parameter that is explained as: The phase-flip status is recorded and managed by Scipion. 
 In other words, when you import or extract particles, 
Scipion will record whether or not phase flipping has been done.

Note that CTF-phase flipping is NOT a necessary pre-processing step 
for MAP-refinement in RELION, as this can be done inside the internal
CTF-correction. However, if the phases have been flipped, the program will handle it.
"3D initial model" has a "Ignore CTFs until first peak?" parameter that is explained as: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
"3D initial model" has a "Do manual grouping ctfs?" parameter that is explained as: Set this to Yes the CTFs will grouping manually.
"3D initial model" has a "Defocus range for group creation (in Angstroms)" parameter that is explained as: Particles will be grouped by defocus.This parameter is the bin for a histogram.All particles assigned to a bin form a group
"3D initial model" has a "minimum size for defocus group" parameter that is explained as: If defocus group is smaller than this value, it will be expanded until number of particles per defocus group is reached
"3D initial model" has a "Number of VDAM mini-batches" parameter that is explained as: How many iterations (i.e. mini-batches) to perform with the VDAM algorithm?
"3D initial model" has a "Regularisation parameter T" parameter that is explained as: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D initial model calculations.
"3D initial model" has a "Number of classes" parameter that is explained as: The number of classes (K) for a multi-reference ab initio SGD refinement. These classes will be made in an unsupervised manner, starting from a single reference in the initial iterations of the SGD, and the references will become increasingly dissimilar during the in between iterations.
"3D initial model" has a "Flatten and enforce non-negative solvent?" parameter that is explained as: If set to Yes, the job will apply a spherical mask and enforce all values in the reference to be non-negative.
"3D initial model" has a "Symmetry" parameter that is explained as: The initial model is always generated in C1 and then aligned to and symmetrized with the specified point group. If the automatic alignment fails, please manually rotate run_itNNN_class001.mrc (NNN is the number of iterations) so that it conforms the symmetry convention.
"3D initial model" has a "Run in C1 and apply symmetry later?" parameter that is explained as: If set to Yes, the gradient-driven optimisation is run in C1 and the symmetry orientation is searched and applied later. If set to No, the entire optimisation is run in the symmetry point group indicated above.
"3D initial model" has a "Use parallel disc I/O?" parameter that is explained as: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
"3D initial model" has a "Number of pooled particles:" parameter that is explained as: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
"3D initial model" has a "Pre-read all particles into RAM?" parameter that is explained as: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
"3D initial model" has a "Copy particles to scratch directory: " parameter that is explained as: If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
"3D initial model" has a "Combine iterations through disc?" parameter that is explained as: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
"3D initial model" has a "Use GPU acceleration?" parameter that is explained as: If set to Yes, the job will try to use GPU acceleration.
"3D initial model" has a "Which GPUs to use:" parameter that is explained as: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
"3D initial model" has a "Additional arguments" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--dont_combine_weights_via_disc
--verb 1
--pad 2

"3D initial model" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"3D initial model" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "local resolution" can be found in the relion plugin.
"local resolution" protocol help is as follows:
  This protocol does local resolution estimation using Relion.

    This program basically performs a series of post-processing operations
    with a small soft, spherical mask that is moved over the entire map,
    while using phase-randomisation to estimate the convolution effects
    of that mask.
    .
"local resolution" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"local resolution" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"local resolution" has a "Select a previous refinement protocol" parameter that is explained as: Select any previous refinement protocol to get the 3D half maps. Note that it is recommended that the refinement protocol uses a gold-standard method.
"local resolution" has a "User-provided solvent mask" parameter that is explained as: Provide a mask with values between 0 and 1 around all domains of the complex. ResMap uses this mask for local resolution calculation. RELION does NOT use this mask for calculation, but makes a histogram of local resolution within this mask.
"local resolution" has a "Calibrated pixel size (A)" parameter that is explained as: Provide the final, calibrated pixel size in Angstroms. If 0, the input pixel size will be used. This value may be different from the pixel-size used thus far, e.g. when you have recalibrated the pixel size using the fit to a PDB model. The X-axis of the output FSC plot will use this calibrated value.
"local resolution" has a "Provide B-factor:" parameter that is explained as: Probably, the overall B-factor as was estimated in the postprocess is a useful value for here. Use negative values for sharpening. Be careful: if you over-sharpen your map, you may end up interpreting noise for signal!
"local resolution" has a "MTF of the detector" parameter that is explained as: User-provided STAR-file with the MTF-curve of the detector.Relion param: <--mtf>
"local resolution" has a "Original detector pixel size (A)" parameter that is explained as: This is the original pixel size (in Angstroms) in the raw (non-super-resolution!) micrographs
"local resolution" has a "Select Advanced level if you want to adjust the parameters" parameter that is explained as: None
"local resolution" has a "Sampling rate (A)" parameter that is explained as: Sampling rate (in Angstroms) with which to sample the local-resolution map
"local resolution" has a "Mask radius (A)" parameter that is explained as: Radius (in A) of spherical mask for local-resolution map (default = 0.5*sampling)
"local resolution" has a "Edge width (A)" parameter that is explained as: Width of soft edge (in A) on masks for local-resolution map (default = sampling)
"local resolution" has a "Randomize phases from (A)" parameter that is explained as: Randomize phases from this resolution (in A)
"local resolution" has a "Lowest res limit (A)" parameter that is explained as: Lowest local resolution allowed (in A)
"local resolution" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"local resolution" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "motion correction" can be found in the relion plugin.
"motion correction" protocol help is as follows:
  Wrapper for the Relion's implementation of motioncor algorithm. .
"motion correction" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"motion correction" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"motion correction" has a "Input Movies" parameter that is explained as: Select a set of previously imported movies.
"motion correction" has a "from" parameter that is explained as: None
"motion correction" has a "to" parameter that is explained as: None
"motion correction" has a "Do dose-weighting?" parameter that is explained as: If set to Yes, the averaged micrographs will be dose-weighted.
"motion correction" has a "Save non-dose weighted as well?" parameter that is explained as: Aligned but non-dose weighted images are sometimes useful in CTF estimation, although there is no difference in most cases. Whichever the choice, CTF refinement job is always done on dose-weighted particles.
"motion correction" has a "Save sum of power spectra?" parameter that is explained as: Sum of non-dose weighted power spectra provides better signal for CTF estimation. The power spectra can be used by CTFFIND4 but not by GCTF.
"motion correction" has a "Sum power spectra every e/A2" parameter that is explained as: McMullan et al. (Ultramicroscopy, 2015) suggests summing power spectra every 4.0 e/A2 gives optimal Thon rings.
"motion correction" has a "Write output in float16?" parameter that is explained as: Relion can write output images in float16 MRC (mode 12) format to save disk space. By default, float32 format is used.
"motion correction" has a "Compute PSD?" parameter that is explained as: If Yes, the protocol will compute for each aligned micrograph the PSD using EMAN2.
"motion correction" has a "Compute micrograph thumbnail?" parameter that is explained as: When using this option, we will compute a micrograph thumbnail with EMAN2 and keep it with the micrograph object for visualization purposes.
"motion correction" has a "Additional arguments" parameter that is explained as: Extra parameters for Relion motion correction. 
"motion correction" has a "Bfactor" parameter that is explained as: The B-factor that will be applied to the micrographs.
"motion correction" has a "X" parameter that is explained as: None
"motion correction" has a "Y" parameter that is explained as: None
"motion correction" has a "Group frames" parameter that is explained as: Average together this many frames before calculating the beam-induced shifts.
"motion correction" has a "Binning factor" parameter that is explained as: Bin the micrographs this much by a windowing operation in the Fourier Transform. Binning at this level is hard to un-do later on, but may be useful to down-scale super-resolution images. Float-values may be used. Do make sure though that the resulting micrograph size is even.
"motion correction" has a "Gain rotation" parameter that is explained as: Rotate the gain reference by this number times 90 degrees clockwise in relion_display. This is the same as -RotGain in MotionCor2. 
Note that MotionCor2 uses a different convention for rotation so it says 'counter-clockwise'.
"motion correction" has a "Gain flip" parameter that is explained as: Flip the gain reference after rotation. This is the same as -FlipGain in MotionCor2. 0 means do nothing, 1 means flip Y (upside down) and 2 means flip X (left to right).
"motion correction" has a "Defects file" parameter that is explained as: Location of a UCSF MotionCor2-style defect text file or a defect map that describe the defect pixels on the detector. Each line of a defect text file should contain four numbers specifying x, y, width and height of a defect region. A defect map is an image (MRC or TIFF), where 0 means good and 1 means bad pixels. The coordinate system is the same as the input movie before application of binning, rotation and/or flipping.

_Note that the format of the defect text is DIFFERENT from the defect text produced by SerialEM!_
 One can convert a SerialEM-style defect file into a defect map using IMOD utilities e.g.:
*clip defect -D defect.txt -f tif movie.tif defect_map.tif*
See explanations in the SerialEM manual.
Leave empty if you do not have any defects, or do not want to correct for defects on your detector.
"motion correction" has a "EER fractionation" parameter that is explained as: The number of hardware frames to group into one fraction. This option is relevant only for Falcon4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
"motion correction" has a "EER upsampling" parameter that is explained as: EER upsampling (1 = 4K or 2 = 8K). 8K rendering is not recommended by Relion. See https://relion.readthedocs.io/en/latest/Reference/MovieCompression.html
"motion correction" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"motion correction" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "3D multi-body" can be found in the relion plugin.
"3D multi-body" protocol help is as follows:
 
    Relion protocol for multi-body refinement.

    This approach models flexible complexes as a user-defined number of rigid
    bodies that move independently of each other.
    Using separate focused refinements with iteratively improved partial
    signal subtraction, improved reconstructions are generated for
    each of the defined bodies.

    Moreover, using PCA on the relative orientations of the bodies
    over all particle images in the data set, we generate movies that describe
    the most important motions in the data.
    .
"3D multi-body" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"3D multi-body" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"3D multi-body" has a "Continue from a previous run?" parameter that is explained as: If you set to *Yes*, you should select a previous MultiBody protocol and most of the input parameters will be taken from it.
"3D multi-body" has a "Consensus refinement protocol" parameter that is explained as: Select any previous refinement protocol from where to run the multi-body refinement. The output volume will be used and some parameters from the optimiser.star file. 
"3D multi-body" has a "Body STAR file" parameter that is explained as: Provide the STAR file with all information about the bodies to be used in multi-body refinement. An example for a three-body refinement would look like this:

data_
loop_
_rlnBodyMaskName
_rlnBodyRotateRelativeTo
_rlnBodySigmaAngles
_rlnBodySigmaOffset
large_body_mask.mrc 2 10 2
small_body_mask.mrc 1 10 2
head_body_mask.mrc 2 10 2


 Where each data line represents a different body, and:
 - rlnBodyMaskName contains the name of a soft-edged mask with values in [0,1] that define the body; the mask name should be relative to the project folder;
 - rlnBodyRotateRelativeTo defines relative to which other body this body rotates (first body is number 1);
 - rlnBodySigmaAngles and _rlnBodySigmaOffset are the standard deviations (widths) of Gaussian priors on the consensus rotations and translations;

 Optionally, there can be a fifth column with _rlnBodyReferenceName. Entries can be 'None' (without the ''s) or the name of a MRC map with an initial reference for that body. In case the entry is None, the reference will be taken from the density in the consensus refinement.

Also note that larger bodies should be above smaller bodies in the STAR file. For more information, see the multi-body paper.
                           
"3D multi-body" has a "Reconstruct subtracted bodies?" parameter that is explained as: If set to Yes, then the reconstruction of each of the bodies will use the subtracted images. This may give useful insights about how well the subtraction worked. If set to No, the original particles are used for reconstruction (while the subtracted ones are still used for alignment). This will result in fuzzy densities for bodies outside the one used for refinement.
"3D multi-body" has a "Use Blush regularisation?" parameter that is explained as: If set to Yes, relion_refine will use a neural network to perform regularisation by denoising at every iteration, instead of the standard smoothness regularisation.
"3D multi-body" has a "Select previous run" parameter that is explained as: Select a previous run to continue from.
"3D multi-body" has a "Continue from iteration" parameter that is explained as: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
"3D multi-body" has a "Initial angular sampling (deg)" parameter that is explained as: There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere. 

Note that this will only be the value for the first few iteration(s): the sampling rate will be increased automatically after that.
"3D multi-body" has a "Initial offset range (pix)" parameter that is explained as: Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration. 

Note that this will only be the value for the first few iteration(s): the sampling rate will be increased automatically after that.
"3D multi-body" has a "Initial offset step (pix)" parameter that is explained as: Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid. 

Note that this will only be the value for the first few iteration(s): the sampling rate will be increased automatically after that.
"3D multi-body" has a "Run flexibility analysis?" parameter that is explained as: If set to Yes, after the multi-body refinement has completed, a PCA analysis will be run on the orientations all all bodies in the data set. This can be set to No initially, and then the job can be continued afterwards to only perform this analysis.
"3D multi-body" has a "Number of eigenvector movies:" parameter that is explained as: Series of ten output maps will be generated along this many eigenvectors. These maps can be opened as a "Volume Series" in UCSF Chimera, and then displayed as a movie. They represent the principal motions in the particles.
"3D multi-body" has a "Select particles based on eigenvalues?" parameter that is explained as: If set to Yes, a particles.star file is written out with all particles that have the below indicated eigenvalue in the selected range.
"3D multi-body" has a "Select on eigenvalue:" parameter that is explained as: This is the number of the eigenvalue to be used in the particle subset selection (start counting at 1).
"3D multi-body" has a "min" parameter that is explained as: None
"3D multi-body" has a "max" parameter that is explained as: None
"3D multi-body" has a "Use parallel disc I/O?" parameter that is explained as: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
"3D multi-body" has a "Number of pooled particles:" parameter that is explained as: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
"3D multi-body" has a "Skip padding" parameter that is explained as: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
"3D multi-body" has a "Pre-read all particles into RAM?" parameter that is explained as: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
"3D multi-body" has a "Copy particles to scratch directory: " parameter that is explained as: If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
"3D multi-body" has a "Combine iterations through disc?" parameter that is explained as: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
"3D multi-body" has a "Use GPU acceleration?" parameter that is explained as: If set to Yes, the job will try to use GPU acceleration.
"3D multi-body" has a "Which GPUs to use:" parameter that is explained as: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
"3D multi-body" has a "Additional arguments" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. They will be appended to the relion_refine command.
"3D multi-body" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"3D multi-body" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"3D multi-body" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "post-processing" can be found in the relion plugin.
"post-processing" protocol help is as follows:
 
    Relion post-processing protocol for automated masking,
    overfitting estimation, MTF-correction and B-factor sharpening.
    .
"post-processing" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"post-processing" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"post-processing" has a "Start from Relion refinement?" parameter that is explained as: Set to Yes if you wish to use as input a Relion protocol. Otherwise set it to No
"post-processing" has a "Input half map 1" parameter that is explained as: You might want to provide input half maps manually, in case you did not use 3D auto-refine or multi-body protocol that generates them automatically.
"post-processing" has a "Input half map 2" parameter that is explained as: You might want to provide input half maps manually, in case you did not use 3D auto-refine or multi-body protocol that generates them automatically.
"post-processing" has a "Select a previous refinement protocol" parameter that is explained as: Select any previous refinement protocol to get the 3D half maps. Note that it is recommended that the refinement protocol uses a gold-standard method.
"post-processing" has a "Which body to process?" parameter that is explained as: Only relevant if input protocol is 3D multi-body.
"post-processing" has a "Solvent mask" parameter that is explained as: Provide a soft mask where the protein is white (1) and the solvent is black (0). Often, the softer the mask the higher resolution estimates you will get. A soft edge of 5-10 pixels is often a good edge width.
"post-processing" has a "Calibrated pixel size (A)" parameter that is explained as: Provide the final, calibrated pixel size in Angstroms. If 0, the input pixel size will be used. This value may be different from the pixel-size used thus far, e.g. when you have recalibrated the pixel size using the fit to a PDB model. The X-axis of the output FSC plot will use this calibrated value.
"post-processing" has a "MTF of the detector" parameter that is explained as: User-provided STAR-file with the MTF-curve of the detector. Use the wizard to load one of the predefined ones provided at:
- [[https://www3.mrc-lmb.cam.ac.uk/relion/index.php/FAQs#Where_can_I_find_MTF_curves_for_typical_detectors.3F][Relion's Wiki FAQs]]
 - [[https://www.gatan.com/techniques/cryo-em#MTF][Gatan's website]]

Relion param: *--mtf*
"post-processing" has a "Original detector pixel size (A)" parameter that is explained as: This is the original pixel size (in Angstroms) in the raw (non-super-resolution!) micrographs
"post-processing" has a "Estimate B-factor automatically?" parameter that is explained as: If set to Yes, then the program will use the automated procedure described by Rosenthal and Henderson (2003, JMB) to estimate an overall B-factor for your map, and sharpen it accordingly.
"post-processing" has a "low" parameter that is explained as: None
"post-processing" has a "high" parameter that is explained as: None
"post-processing" has a "Provide B-factor:" parameter that is explained as: User-provided B-factor (in A^2) for map sharpening, e.g. -400. Use negative values for sharpening. Be careful: if you over-sharpen
your map, you may end up interpreting noise for signal!
Relion param: *--adhoc_bfac*
"post-processing" has a "Skip FSC-weighting for sharpening?" parameter that is explained as: If set to No (the default), then the output map will be low-pass filtered according to the mask-corrected, gold-standard FSC-curve. Sometimes, it is also useful to provide an ad-hoc low-pass filter (option below), as due to local resolution variations some parts of the map may be better and other parts may be worse than the overall resolution as measured by the FSC. In such  cases, set this option to Yes and provide an ad-hoc filter as described below.
"post-processing" has a "Ad-hoc low-pass filter (A):" parameter that is explained as: This option allows one to low-pass filter the map at a user-provided frequency (in Angstroms). When using a resolution that is higher than the gold-standard FSC-reported resolution, take care not to interpret noise in the map for signal.
"post-processing" has a "Low-pass filter edge width:" parameter that is explained as: Width of the raised cosine on the low-pass filter edge (in resolution shells)
Relion param: *--filter_edge_width*
"post-processing" has a "Randomize phases threshold" parameter that is explained as: Randomize phases from the resolution where FSC drops below this value
Relion param: *--randomize_at_fsc*
"post-processing" has a "Force mask?" parameter that is explained as: Use the mask even when the masked resolution is worse than the unmasked resolution.
"post-processing" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "preprocess particles" can be found in the relion plugin.
"preprocess particles" protocol help is as follows:
  This protocol wraps relion_preprocess program.

    It is used to perform normalisation, filtering or scaling of
    the particles.
    .
"preprocess particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"preprocess particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"preprocess particles" has a "Input particles" parameter that is explained as: Select the input images from the project.
"preprocess particles" has a "Normalize" parameter that is explained as: If set to True, particles will be normalized in theway RELION prefers it. It is recommended to *always normalize your particles*, and use a reasonable radius for the circle around your particles outside of which the standard deviation and average values for the noise are calculated.
*Note*: if the particles are re-scaled, the radius for normalize will be taken over the new dimensions.
"preprocess particles" has a "Background radius (px)" parameter that is explained as: Pixels outside this circle are assumed to be noise and their stddev is set to 1. Radius for background circle definition (in pixel).
"preprocess particles" has a "Remove dust from particles" parameter that is explained as: If there are white or black artifacts on the micrographs (e.g. caused by dust or hot/dead pixels), these may be removed by using a positive value for the dust removal options. All black/white pixels with values above the given parameter times the standard deviation of the noise are replaced by random values from aGaussian distribution. For cryo-EM data, valuesaround 3.5-5 are often useful. Make sure you do not erase part of the true signal.
"preprocess particles" has a "White" parameter that is explained as: None
"preprocess particles" has a "Black" parameter that is explained as: None
"preprocess particles" has a "Invert contrast" parameter that is explained as: Invert the contrast if your particles are black over a white background.
"preprocess particles" has a "Scale particles?" parameter that is explained as: Re-scale the particles to this size (in pixels).
"preprocess particles" has a "Scale size (px)" parameter that is explained as: New particle size in pixels.
"preprocess particles" has a "Window particles?" parameter that is explained as: Re-window the particles to this size (in pixels).
"preprocess particles" has a "Window size (px)" parameter that is explained as: New particles windows size (in pixels).
"preprocess particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"preprocess particles" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"preprocess particles" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "reconstruct" can be found in the relion plugin.
"reconstruct" protocol help is as follows:
  This protocol reconstructs a volume using Relion.

    Reconstruct a volume from a given set of particles.
    The alignment parameters will be converted to a Relion star file
    and used as direction projections to reconstruct.
    .
"reconstruct" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"reconstruct" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"reconstruct" has a "Input particles" parameter that is explained as: Select the input images from the project.
"reconstruct" has a "Symmetry group" parameter that is explained as: See [[https://relion.readthedocs.io/en/latest/Reference/Conventions.html#symmetry][Relion Symmetry]] page for a description of the symmetry format accepted by Relion
"reconstruct" has a "Maximum resolution (A)" parameter that is explained as: Maximum resolution (in Angstrom) to consider 
in Fourier space (default Nyquist).
"reconstruct" has a "Padding factor" parameter that is explained as: None
"reconstruct" has a "Subset to reconstruct" parameter that is explained as: Subset of images to consider.
"reconstruct" has a "Use only this class" parameter that is explained as: Consider only this class (-1: use all classes)
"reconstruct" has a "Extra parameters: " parameter that is explained as: Extra parameters to *relion_reconstruct* program. Address to Relion to see full list of options.
"reconstruct" has a "Apply CTF correction?" parameter that is explained as: None
"reconstruct" has a "Leave CTFs intact until first peak?" parameter that is explained as: None
"reconstruct" has a "Correct for Ewald-sphere curvature?" parameter that is explained as: None
"reconstruct" has a "Skip masking?" parameter that is explained as: Do not apply real space mask during Ewald sphere correction.
"reconstruct" has a "Mask diameter (A)" parameter that is explained as: Diameter (in A) of mask for Ewald-sphere curvature correction
"reconstruct" has a "Add a soft-edge (px)" parameter that is explained as: Width (in pixels) of the soft edge on the mask.
"reconstruct" has a "Reverse curvature?" parameter that is explained as: None
"reconstruct" has a "New box size (px)" parameter that is explained as: Box size of reconstruction after Ewald sphere correction.
"reconstruct" has a "Number of sectors" parameter that is explained as: Number of sectors for Ewald sphere correction.
"reconstruct" has a "Skip weighting?" parameter that is explained as: Do not apply weighting during during Ewald sphere correction.
"reconstruct" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"reconstruct" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "3D auto-refine" can be found in the relion plugin.
"3D auto-refine" protocol help is as follows:
  Protocol to refine a 3D map using Relion.

Relion employs an empirical Bayesian approach to refinement
of (multiple) 3D reconstructions
or 2D class averages in electron cryo-microscopy (cryo-EM). Many
parameters of a statistical model are learned from the data,which
leads to objective and high-quality results.
    .
"3D auto-refine" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"3D auto-refine" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"3D auto-refine" has a "" parameter that is explained as: None
"3D auto-refine" has a "" parameter that is explained as: None
"3D auto-refine" has a "Continue from a previous run?" parameter that is explained as: If you set to *Yes*, you should select a previousrun of type *ProtRelionRefine3D* class and most of the input parameterswill be taken from it.
"3D auto-refine" has a "Input particles" parameter that is explained as: Select the input images from the project.
"3D auto-refine" has a "Consider previous alignment?" parameter that is explained as: If set to Yes, then alignment information from input particles will be considered.
"3D auto-refine" has a "Consider alignment as priors?" parameter that is explained as: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
"3D auto-refine" has a "" parameter that is explained as: None
"3D auto-refine" has a "Particle mask diameter (A)" parameter that is explained as: The experimental images will be masked with a soft circular mask with this <diameter>. Make sure this diameter is not set too small because that may mask away part of the signal! If set to a value larger than the image size no masking will be performed.

The same diameter will also be used for a spherical mask of the reference structures if no user-provided mask is specified.
"3D auto-refine" has a "Mask particles with zeros?" parameter that is explained as: If set to <Yes>, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform. This will remove noise and therefore increase sensitivity in the alignment and classification. However, it will also introduce correlations between the Fourier components that are not modelled. When set to <No>, then the solvent area is filled with random noise, which prevents introducing correlations.High-resolution refinements (e.g. in 3D auto-refine) tend to work better when filling the solvent area with random noise, some classifications go better when using zeros.
"3D auto-refine" has a "Select previous run" parameter that is explained as: Select a previous run to continue from.
"3D auto-refine" has a "Continue from iteration" parameter that is explained as: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
"3D auto-refine" has a "Reference averages" parameter that is explained as: This option is not recommended and should be used with care. The provided averages will be used as initial 2D references. If this option is used, the number of classes will be ignored. 
"3D auto-refine" has a "Input volume" parameter that is explained as: Initial reference 3D map, it should have the same dimensions and the same pixel size as your input particles.
"3D auto-refine" has a "Reference mask (optional)" parameter that is explained as: A volume mask containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask. If no mask is given, a soft spherical mask based on the <radius> of the mask for the experimental images will be applied.

In some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. Check _Advaced_ level and select another volume mask
"3D auto-refine" has a "Second reference mask (optional)" parameter that is explained as: For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas.
"3D auto-refine" has a "Use solvent-flattened FSCs?" parameter that is explained as: If set to Yes, then instead of using unmasked maps to calculate the gold-standard FSCs during refinement, masked half-maps are used and a post-processing-like correction of the FSC curves (with phase-randomisation) is performed every iteration. This only works when a reference mask is provided on the I/O tab. This may yield higher-resolution maps, especially when the mask contains only a relatively small volume inside the box.
"3D auto-refine" has a "Is initial 3D map on absolute greyscale?" parameter that is explained as: The probabilities are based on squared differences, so that the absolute grey scale is important. 
Probabilities are calculated based on a Gaussian noise model, which contains a squared difference term between the reference and the experimental image. This has a consequence that the reference needs to be on the same absolute intensity grey-scale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity grey-scale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. Therefore: if the map was reconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No. If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent MAP refinement. Therefore, if in doubt it is recommended to set this option to No.
"3D auto-refine" has a "Symmetry" parameter that is explained as: See [[https://relion.readthedocs.io/en/latest/Reference/Conventions.html#symmetry][Relion Symmetry]] page for a description of the symmetry format accepted by Relion
"3D auto-refine" has a "Initial low-pass filter (A)" parameter that is explained as: It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s).
"3D auto-refine" has a "CTF parameters are not available in continue mode" parameter that is explained as: None
"3D auto-refine" has a "Do CTF-correction?" parameter that is explained as: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
"3D auto-refine" has a "Have data been phase-flipped?      (Don't answer, see help)" parameter that is explained as: The phase-flip status is recorded and managed by Scipion. 
 In other words, when you import or extract particles, 
Scipion will record whether or not phase flipping has been done.

Note that CTF-phase flipping is NOT a necessary pre-processing step 
for MAP-refinement in RELION, as this can be done inside the internal
CTF-correction. However, if the phases have been flipped, the program will handle it.
"3D auto-refine" has a "Ignore CTFs until first peak?" parameter that is explained as: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
"3D auto-refine" has a "Do manual grouping ctfs?" parameter that is explained as: Set this to Yes the CTFs will grouping manually.
"3D auto-refine" has a "Defocus range for group creation (in Angstroms)" parameter that is explained as: Particles will be grouped by defocus.This parameter is the bin for a histogram.All particles assigned to a bin form a group
"3D auto-refine" has a "minimum size for defocus group" parameter that is explained as: If defocus group is smaller than this value, it will be expanded until number of particles per defocus group is reached
"3D auto-refine" has a "Perform image alignment?" parameter that is explained as: If set to No, then rather than performing both alignment and classification, only classification will be performed. This allows the use of very focused masks. This requires that the optimal orientations of all particles are already calculated.
"3D auto-refine" has a "Initial angular sampling (deg)" parameter that is explained as: There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
"3D auto-refine" has a "Initial offset range (pix)" parameter that is explained as: Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
"3D auto-refine" has a "Initial offset step (pix)" parameter that is explained as: Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid.
"3D auto-refine" has a "Local search from auto-sampling (deg)" parameter that is explained as: In the automated procedure to increase the angular samplings, local angular searches of -6/+6 times the sampling rate will be used from this angular sampling rate onwards.
"3D auto-refine" has a "Relax symmetry" parameter that is explained as: With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020.
"3D auto-refine" has a "Use finer angular sampling faster?" parameter that is explained as: If set to Yes, then let auto-refinement proceed faster with finer angular samplings. Two additional command-line options will be passed to the refine program:

	--auto_ignore_angles lets angular sampling go down despite changes still happening in the angles
	--auto_resol_angles lets angular sampling go down if the current resolution already requires that sampling at the edge of the particle.

This option will make the computation faster, but has not been tested for many cases for potential loss in reconstruction quality upon convergence.
"3D auto-refine" has a "Use Blush regularisation?" parameter that is explained as: If set to Yes, relion_refine will use a neural network to perform regularisation by denoising at every iteration, instead of the standard smoothness regularisation.
"3D auto-refine" has a "Use parallel disc I/O?" parameter that is explained as: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
"3D auto-refine" has a "Number of pooled particles:" parameter that is explained as: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
"3D auto-refine" has a "Skip padding" parameter that is explained as: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
"3D auto-refine" has a "Pre-read all particles into RAM?" parameter that is explained as: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
"3D auto-refine" has a "Copy particles to scratch directory: " parameter that is explained as: If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
"3D auto-refine" has a "Combine iterations through disc?" parameter that is explained as: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
"3D auto-refine" has a "Use GPU acceleration?" parameter that is explained as: If set to Yes, the job will try to use GPU acceleration.
"3D auto-refine" has a "Which GPUs to use:" parameter that is explained as: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
"3D auto-refine" has a "Over-sampling" parameter that is explained as: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
"3D auto-refine" has a "Additional arguments" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--dont_combine_weights_via_disc
--verb 1
--pad 2
--low_resol_join_halves 40 (only not continue mode)
"3D auto-refine" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"3D auto-refine" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"3D auto-refine" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "remove preferential views" can be found in the relion plugin.
"remove preferential views" protocol help is as follows:
  Protocol to remove preferential views from a particle set.

    Inspired by https://github.com/leschzinerlab/Relion

    .
"remove preferential views" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"remove preferential views" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"remove preferential views" has a "Input particles" parameter that is explained as: Provide a set of particles.
"remove preferential views" has a "Number of particles to remove" parameter that is explained as: Number of particles to remove WITHIN the limits below.
"remove preferential views" has a "min" parameter that is explained as: None
"remove preferential views" has a "max" parameter that is explained as: None
"remove preferential views" has a "min" parameter that is explained as: None
"remove preferential views" has a "max" parameter that is explained as: None
"remove preferential views" has a "Remove views with specific in-plane rotation?" parameter that is explained as: Particle orientation on Euler sphere is defined by rot and tilt angles. Psi is for in-plane rotation only. Select *Yes* if you want to provide psi limits.
"remove preferential views" has a "min" parameter that is explained as: None
"remove preferential views" has a "max" parameter that is explained as: None

The protocol named "crop/resize volumes" can be found in the relion plugin.
"crop/resize volumes" protocol help is as follows:
  This protocol rescales/resizes 3D volumes using relion_image_handler. .
"crop/resize volumes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"crop/resize volumes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"crop/resize volumes" has a "Input Volumes" parameter that is explained as: Can be a Volume or a SetOfVolumes.
"crop/resize volumes" has a "Rescale volumes?" parameter that is explained as: None
"crop/resize volumes" has a "New sampling rate (Å/px)" parameter that is explained as: None
"crop/resize volumes" has a "Resize volumes to a new box?" parameter that is explained as: None
"crop/resize volumes" has a "New box size (px)" parameter that is explained as: Provide even box size.
"crop/resize volumes" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "2D class ranker" can be found in the relion plugin.
"2D class ranker" protocol help is as follows:
 
    Relion protocol to auto-select 2D class averages.
    .
"2D class ranker" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"2D class ranker" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"2D class ranker" has a "Input Relion 2D classification" parameter that is explained as: None
"2D class ranker" has a "Min. threshold for auto-selection" parameter that is explained as: Only classes with a predicted threshold above this value will be selected.
"2D class ranker" has a "Select at least this many particles" parameter that is explained as: Even if they have scores below the minimum threshold, select at least this many particles with the best scores.
"2D class ranker" has a "OR: Select at least this many classes" parameter that is explained as: Even if they have scores below the minimum threshold, select at least this many classes with the best scores.

The protocol named "subtract projection" can be found in the relion plugin.
"subtract projection" protocol help is as follows:
  Signal subtraction protocol of Relion.

    Subtract volume projections from the experimental particles.
    The particles must have projection alignment in order to
    properly generate volume projections.
    .
"subtract projection" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"subtract projection" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"subtract projection" has a "Start from Relion protocol?" parameter that is explained as: Set to Yes if you wish to use as input a Relion protocol. Otherwise set it to No
"subtract projection" has a "Input Relion protocol" parameter that is explained as: Select the 3D refinement/classification or multi-body run which you want to use for subtraction. It will use the maps from this run for the subtraction.
"subtract projection" has a "Input map to be projected" parameter that is explained as: Provide the input volume that will be used to calculate projections, which will be subtracted from the experimental particles. Make sure this map was calculated by RELION from the same particles as above, and preferably with those orientations, as it is crucial that the absolute greyscale is the same as in the experimental particles.
"subtract projection" has a "Use all particles from input protocol?" parameter that is explained as: If No, then you need to provide a subset of particles below.
"subtract projection" has a "Input particles subset" parameter that is explained as: Select the particles which are a SUBSET of the input protocol provided above.
"subtract projection" has a "Input particles" parameter that is explained as: Select the input particles.
"subtract projection" has a "Mask of the signal to keep" parameter that is explained as: Provide a soft mask where the protein density you wish to subtract from the experimental particles is black (0) and the density you wish to keep is white (1).
That is: *the mask should INCLUDE the part of the volume that you wish to KEEP.*
"subtract projection" has a "Write output in float16?" parameter that is explained as: Relion can write output images in float16 MRC (mode 12) format to save disk space. By default, float32 format is used.
"subtract projection" has a "This section is only used if starting from Relion input." parameter that is explained as: None
"subtract projection" has a "Do center subtracted images on mask?" parameter that is explained as: If set to Yes, the subtracted particles will be centered on projections of the center-of-mass of the input mask.
"subtract projection" has a "Do center on my coordinates?" parameter that is explained as: If set to Yes, the subtracted particles will be centered on projections of the x,y,z coordinates below. The unit is pixel, not angstrom. The origin is at the center of the box, not at the corner.
"subtract projection" has a "X" parameter that is explained as: None
"subtract projection" has a "Y" parameter that is explained as: None
"subtract projection" has a "Z" parameter that is explained as: None
"subtract projection" has a "New box size" parameter that is explained as: Provide a non-negative value to re-window the subtracted particles in a smaller box size.
"subtract projection" has a "This section is only used if NOT starting from Relion protocol." parameter that is explained as: None
"subtract projection" has a "Do CTF-correction?" parameter that is explained as: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
"subtract projection" has a "Ignore CTFs until first peak?" parameter that is explained as: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
"subtract projection" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"subtract projection" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "symmetrize volume" can be found in the relion plugin.
"symmetrize volume" protocol help is as follows:
 
    Symmetrize a volume using Relion programs:
        *relion_align_symmetry* and *relion_image_handler*.
    .
"symmetrize volume" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"symmetrize volume" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"symmetrize volume" has a "Input volume" parameter that is explained as: Select the input volume to be symmetrized. 
"symmetrize volume" has a "Symmetry" parameter that is explained as: Select which symmetry do you want to apply. 
"symmetrize volume" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "2D particles to subtomograms" can be found in the tomo plugin.
"2D particles to subtomograms" protocol help is as follows:
  Protocol to create a set of subtomograms from a selected 2D particles.
    .
"2D particles to subtomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"2D particles to subtomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"2D particles to subtomograms" has a "Set of subtomograms" parameter that is explained as: Select the set of subtomograms 
"2D particles to subtomograms" has a "Input set" parameter that is explained as: Select the 2D classes or a set of particles

The protocol named "2d coordinates to 3d coordinates" can be found in the tomo plugin.
"2d coordinates to 3d coordinates" protocol help is as follows:
  Turns 2d coordinates into set of 3d coordinates. Works in coordination with 'tomograms to micrographs' protocol.
"2d coordinates to 3d coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"2d coordinates to 3d coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"2d coordinates to 3d coordinates" has a "Tomograms" parameter that is explained as: Select the tomograms to be associated to the 3D coordinates
"2d coordinates to 3d coordinates" has a "2D Coordinates" parameter that is explained as: Set of 2d coordinates picked on tomogram slices.

The protocol named "assign alignment" can be found in the tomo plugin.
"assign alignment" protocol help is as follows:
  Assign the alignment stored in a set of Subtomograms/Coordinates3D
    to another set.
    Both sets should have same pixel size (A/px).
    The Subtomograms/Coordinates3D with the alignment can also be a subset of a bigger set.
    .
"assign alignment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"assign alignment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"assign alignment" has a "Input" parameter that is explained as: Select the Subtomograms/Coordinates3D that you want to update the new alignment.
"assign alignment" has a "Alignments" parameter that is explained as: Select the Subtomograms/Coordinates3D with alignment to be apply to the other object.

The protocol named "assign tomos to subtomos" can be found in the tomo plugin.
"assign tomos to subtomos" protocol help is as follows:
  This protocol assign tomograms to subtomograms that have been imported before without tomograms.
    Subtomograms should contain the name of the original tomogram in their own file name.
    .
"assign tomos to subtomos" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"assign tomos to subtomos" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"assign tomos to subtomos" has a "Subtomograms" parameter that is explained as: Select the subtomograms that you want to update with original tomograms as precedents.The subtomograms should contain the original tomogram name in their own filename.
"assign tomos to subtomos" has a "Tomograms" parameter that is explained as: Select the tomograms to be assigned to the subtomograms.

The protocol named "assign tomograms to tomo masks (segmentations)" can be found in the tomo plugin.
"assign tomograms to tomo masks (segmentations)" protocol help is as follows:
  This protocol assign tomograms to tomomasks (segmentations)..
"assign tomograms to tomo masks (segmentations)" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"assign tomograms to tomo masks (segmentations)" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"assign tomograms to tomo masks (segmentations)" has a "Tomo masks (segmentations)" parameter that is explained as: Select the tomo masks desired to be referred to the introduced tomograms. The match between both sets is carried out firstly by tsId and if not possible, then it will try to do it by filename.
"assign tomograms to tomo masks (segmentations)" has a "Tomograms" parameter that is explained as: Select the tomograms to be assigned to the input tomo masks.

The protocol named "Tilt-series assign alignment" can be found in the tomo plugin.
"Tilt-series assign alignment" protocol help is as follows:
 
    Assign the transformation matrices from an input set of tilt-series to a target one.
    .
"Tilt-series assign alignment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Tilt-series assign alignment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Tilt-series assign alignment" has a "Tilt-series from which to take the alignment" parameter that is explained as: Set of tilt-series from which transformation matrices will be obtained.
"Tilt-series assign alignment" has a "Tilt-series to assign the alignment to" parameter that is explained as: Set of tilt-series on which transformation matrices will be assigned.
"Tilt-series assign alignment" has a "Combine alignments" parameter that is explained as: If this option is selected and the the tilt-series to assign the alignment has a previous alignment, both precious and new alignment are combined.

The protocol named "ctf consensus tomo" can be found in the tomo plugin.
"ctf consensus tomo" protocol help is as follows:
 
     Validate a set of CTF tomo series and separate into two sets (good and
     bad tomo series )
    .
"ctf consensus tomo" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"ctf consensus tomo" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"ctf consensus tomo" has a "Input ctf tomo series" parameter that is explained as: None
"ctf consensus tomo" has a "Input secondary ctf tomo series" parameter that is explained as: CTF tomo series to be compared with reference CTF
"ctf consensus tomo" has a "Validation type" parameter that is explained as: Global mode: the series with at least one image that does not satisfy the criteria are rejected 
Per tilt mode: the series containing a certain number of images that does not satisfy the criteria are rejected
"ctf consensus tomo" has a "Number of images to rejected" parameter that is explained as: Number of images taking into account to rejected a ctf series
"ctf consensus tomo" has a "Defocus tolerance" parameter that is explained as: Validate the defocus deviation taking into account a threshold(tolerance) respect to a defocus expected value.
"ctf consensus tomo" has a "Tolerance value defocus" parameter that is explained as: Defocus tolerance value calculates as: 
asb(error)/mean_defocus
"ctf consensus tomo" has a "Astigmatism" parameter that is explained as: Validate the astigmatism taking into account a tolerance value.
"ctf consensus tomo" has a "Tolerance value astigmatism" parameter that is explained as: Astigmatism tolerance value calculated as: 
asb(error)/mean_astigmatism
"ctf consensus tomo" has a "Resolution" parameter that is explained as: Validate the resolution taking into account a expected resolution.
"ctf consensus tomo" has a "Minimum consensus resolution (A)" parameter that is explained as: Minimum value for the consensus resolution in Angstroms.
If there are noticeable discrepancies between the two estimations below this resolution, it will be discarded. 'Option for calculating consensus resolution. The algorithm assumes that two CTF are consistent if the phase (wave aberration function) of the two CTFs are closer than 90 degrees.
The reported consensusResolution is the resolution at which the two CTF phases differ in 90 degrees.'
"ctf consensus tomo" has a "Average equivalent metadata?" parameter that is explained as: If *Yes*, making an average of those metadata present in both CTF estimations (defocus, astigmatism angle...)
 If *No*, the primary estimation metadata will persist.
"ctf consensus tomo" has a "Include all secondary metadata?" parameter that is explained as: If *Yes*, all metadata in the *Secondary CTF* will be included in the resulting CTF.
 If *No*, only the primary metadata (plus consensus scores) will be in the resulting CTF.

The protocol named "ctf validate" can be found in the tomo plugin.
"ctf validate" protocol help is as follows:
 
     Validate a set of CTF tomo series and separate into two sets (good and
     bad tomo series )
    .
"ctf validate" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"ctf validate" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"ctf validate" has a "Input ctf tomo series" parameter that is explained as: None
"ctf validate" has a "Validation type" parameter that is explained as: Global mode: the series with at least one image that does not satisfy the criteria are rejected 
Per tilt mode: the series containing a certain number of images that does not satisfy the criteria are rejected
"ctf validate" has a "Number of images to rejected" parameter that is explained as: Number of images taking into account to rejected a ctf series
"ctf validate" has a "Defocus tolerance" parameter that is explained as: Validate the defocus deviation taking into account a threshold(tolerance) respect to a defocus expected value.
"ctf validate" has a "Expected value (Å)" parameter that is explained as: Defocus expected value in Å
"ctf validate" has a "Tolerance value (Å)" parameter that is explained as: Defocus tolerance value in Å
"ctf validate" has a "Astigmatism" parameter that is explained as: Validate the astigmatism taking into account a tolerance value.
"ctf validate" has a "Tolerance value" parameter that is explained as: Astigmatism tolerance value
"ctf validate" has a "Resolution" parameter that is explained as: Validate the resolution taking into account a expected resolution.
"ctf validate" has a "Expected value" parameter that is explained as: Expected resolution value

The protocol named "Compose Tilt Series" can be found in the tomo plugin.
"Compose Tilt Series" protocol help is as follows:
  Compose in streaming a set of tilt series based on a set of micrographs and mdoc files.
    Two time parameters are available for the streaming behaviour:
    Time to next tilt and time to next tilt series
    .
"Compose Tilt Series" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Compose Tilt Series" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Compose Tilt Series" has a "Input micrographs" parameter that is explained as: Select the SetOfMicrographs to import
"Compose Tilt Series" has a "Path with the *.mdoc files for each tilt series" parameter that is explained as: Root directory of the tilt-series. Use of * will work for multiple characters or ? for a single one. Also [] can specify ranges.
"Compose Tilt Series" has a "Mdoc pattern" parameter that is explained as: Pattern that should match for mdoc files.Use of * will work for multiple characters or ? for a single one. Also [] can specify ranges.
"Compose Tilt Series" has a "Exclusion words" parameter that is explained as: Space separated words that will be used to exclude mdoc files that could be listed with the above parameters.
"Compose Tilt Series" has a "mdoc bug Correction" parameter that is explained as: Setting True, the mdoc generated by SerialEM will be read considering the bug
"Compose Tilt Series" has a "Process data in streaming?" parameter that is explained as: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
"Compose Tilt Series" has a "Time for next Tilt (secs)" parameter that is explained as: Delay (in seconds) until the next tilt is registered in the mdoc file. After timeout, if there is no new tilt, the tilt series is considered as completed.Minimum time recommended 20 secs
"Compose Tilt Series" has a "Time for next tilt series (secs)" parameter that is explained as: Interval of time (in seconds) after which, if no new tilt series is detected, the protocol will end. The default value is  high (30 min) to avoid the protocol finishes during the acq of the microscope. You can also stop it from right click and press STOP_STREAMING.

"Compose Tilt Series" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Compose Tilt Series" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"Compose Tilt Series" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Tilt-series consensus alignment" can be found in the tomo plugin.
"Tilt-series consensus alignment" protocol help is as follows:
 
    Perform a consensus of a set of alignments for the same tilt series. Returns the average alignment matrix of the
    consensus alignments and its standard deviation of shift and angle.
    .
"Tilt-series consensus alignment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Tilt-series consensus alignment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Tilt-series consensus alignment" has a "Input tilt series" parameter that is explained as: Select several sets of tilt-series where to evaluate the consensus in their alignment. Output set will bring the information from the first selected set.
"Tilt-series consensus alignment" has a "Shift tolerance (A)" parameter that is explained as: Maximum shift difference between alignments to consider them as equal. it is measured in Angstroms.
"Tilt-series consensus alignment" has a "Angle tolerance (degrees)" parameter that is explained as: Maximum angle difference between alignments to consider them as equal. It is measured in degrees
"Tilt-series consensus alignment" has a "Consensus" parameter that is explained as: Criteria for consensus alignment. If local, consensus will be performed to the tilt-images individually (different consensus applied individually) and if there is no consensus in some image the series will be discarded. If global, consensus will be performed at the level o tilt-series (the whole pair of alignments must agree).

The protocol named "consensus classes subtomo" can be found in the tomo plugin.
"consensus classes subtomo" protocol help is as follows:
  Compare several SetOfClassesSubTomograms.
        Return the intersection of the input classes.
    .
"consensus classes subtomo" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"consensus classes subtomo" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"consensus classes subtomo" has a "Input Classes" parameter that is explained as: Select several sets of classes where to evaluate the intersections.

The protocol named "import coordinates 3D" can be found in the tomo plugin.
"import coordinates 3D" protocol help is as follows:
 Protocol to import a set of tomograms to the project.
"import coordinates 3D" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import coordinates 3D" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import coordinates 3D" has a "Import from" parameter that is explained as: Select the type of import.
"import coordinates 3D" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import coordinates 3D" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import coordinates 3D" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import coordinates 3D" has a "Coordinates sampling rate [Å/pix] (opt.)" parameter that is explained as: If empty, the coordinates' sampling rate will be considered to be the same as the tomograms'.
*IMPORTANT*: If a value is provided, the ratio of both tomograms and coordinates sampling rate will be used to scale the coordinates properly to the tomograms introduced.
"import coordinates 3D" has a "Box Size [pix]" parameter that is explained as: It will be re-scaled to the tomogram size considering the coordinates and tomograms ratio between their corresponding sampling rates.
"import coordinates 3D" has a "Input tomograms" parameter that is explained as: Select the tomograms to which the coordinates should be referred to.
The file names of the tomogram and coordinate files must be the same.

The protocol named "import 3D coordinates from scipion" can be found in the tomo plugin.
"import 3D coordinates from scipion" protocol help is as follows:
 Protocol to import a set of 3d coordinates from Scipion sqlite file.
"import 3D coordinates from scipion" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import 3D coordinates from scipion" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import 3D coordinates from scipion" has a "Scipion sqlite file" parameter that is explained as: None
"import 3D coordinates from scipion" has a "Input tomograms" parameter that is explained as: Select the tomograms to which the coordinates should be referred to. The matching between coordinates and tomograms is made checking the tsId/tomoId attribute. If no matches are found, then it tries to do it comparing the filenames. *IMPORTANT*: the coordinates will be assumed to be at the same sampling rate as the introduced tomograms.
"import 3D coordinates from scipion" has a "Box Size [pix]" parameter that is explained as: None

The protocol named "import subtomograms" can be found in the tomo plugin.
"import subtomograms" protocol help is as follows:
 Protocol to import a set of tomograms to the project.
"import subtomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import subtomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import subtomograms" has a "" parameter that is explained as: Select the type of import.
"import subtomograms" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import subtomograms" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import subtomograms" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import subtomograms" has a "Pixel size (sampling rate) Å/px" parameter that is explained as: None
"import subtomograms" has a "Import from" parameter that is explained as: Select the type of import.
"import subtomograms" has a "Acquisition parameters file" parameter that is explained as: File with the acquisition parameters for each tomogram or subtomogram to import. File must be in plain format. The file must contain a row per file to be imported and have the following parameters in order: 

'File_name AcquisitionAngleMin AcquisitionAngleMax Step TiltAxisAngle' 

An example would be:
subtomo1.em -40 40 3 85
subtomo2.em -45 50 2 85

"import subtomograms" has a "Acquisition angle max" parameter that is explained as: Enter the positive limit of the acquisition angle
"import subtomograms" has a "Acquisition angle min" parameter that is explained as: Enter the negative limit of the acquisition angle
"import subtomograms" has a "Step" parameter that is explained as: Enter the step size for the import
"import subtomograms" has a "Tilt axis angle (deg.)" parameter that is explained as: The rotation angle is the angle from the vertical to the axis of tilting, where counterclockwise is positive.
 See https://bio3d.colorado.edu/imod/doc/tomoguide.html#UnknownAxisAngle
"import subtomograms" has a "Microscope voltage (kV)" parameter that is explained as: Microscope voltage
"import subtomograms" has a "Spherical aberration (mm)" parameter that is explained as: Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
"import subtomograms" has a "Amplitude Contrast" parameter that is explained as: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.

The protocol named "import tilt-series coordinates" can be found in the tomo plugin.
"import tilt-series coordinates" protocol help is as follows:
 Protocol to import a set of tilt-series coordinates 3D.
"import tilt-series coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import tilt-series coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import tilt-series coordinates" has a "Import from" parameter that is explained as: Select the type of import.
"import tilt-series coordinates" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import tilt-series coordinates" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import tilt-series coordinates" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import tilt-series coordinates" has a "Input set of tilt-series" parameter that is explained as: None

The protocol named "import tomograms" can be found in the tomo plugin.
"import tomograms" protocol help is as follows:
 Protocol to import a set of tomograms to the project.
"import tomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import tomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import tomograms" has a "" parameter that is explained as: Select the type of import.
"import tomograms" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import tomograms" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import tomograms" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import tomograms" has a "Pixel size (sampling rate) Å/px" parameter that is explained as: None
"import tomograms" has a "Import from" parameter that is explained as: Select the type of import.
"import tomograms" has a "Acquisition parameters file" parameter that is explained as: File with the acquisition parameters for each tomogram or subtomogram to import. File must be in plain format. The file must contain a row per file to be imported and have the following parameters in order: 

'File_name AcquisitionAngleMin AcquisitionAngleMax Step TiltAxisAngle' 

An example would be:
subtomo1.em -40 40 3 85
subtomo2.em -45 50 2 85

"import tomograms" has a "Acquisition angle max" parameter that is explained as: Enter the positive limit of the acquisition angle
"import tomograms" has a "Acquisition angle min" parameter that is explained as: Enter the negative limit of the acquisition angle
"import tomograms" has a "Step" parameter that is explained as: Enter the step size for the import
"import tomograms" has a "Tilt axis angle (deg.)" parameter that is explained as: The rotation angle is the angle from the vertical to the axis of tilting, where counterclockwise is positive.
 See https://bio3d.colorado.edu/imod/doc/tomoguide.html#UnknownAxisAngle
"import tomograms" has a "Microscope voltage (kV)" parameter that is explained as: Microscope voltage
"import tomograms" has a "Spherical aberration (mm)" parameter that is explained as: Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
"import tomograms" has a "Amplitude Contrast" parameter that is explained as: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
"import tomograms" has a "Set origin of coordinates" parameter that is explained as: Option YES:
A new volume will be created with the given ORIGIN of coordinates. This ORIGIN will be set in the map file header.
The ORIGIN of coordinates will be placed at the center of the whole volume if you select n(x)/2, n(y)/2, n(z)/2 as x, y, z coordinates (n(x), n(y), n(z) are the dimensions of the whole volume). However, selecting 0, 0, 0 as x, y, z coordinates, the volume will be placed at the upper right-hand corner.

Option NO:
The ORIGIN of coordinates will be placed at the center of the whole volume (coordinates n(x)/2, n(y)/2, n(z)/2 by default). This ORIGIN will NOT be set in the map file header.

WARNING: In case you want to process the volume with programs requiring a specific symmetry regarding the origin of coordinates, for example the protocol extract unit cell, check carefully that the coordinates of the origin preserve the symmetry of the whole volume. This is particularly relevant for loading fragments/subunits of the whole volume.

"import tomograms" has a "From mrc header" parameter that is explained as: Use origin information in mrc headers of the tomograms.
"import tomograms" has a "x" parameter that is explained as: offset along x axis (Angstroms)
"import tomograms" has a "y" parameter that is explained as: offset along y axis (Angstroms)
"import tomograms" has a "z" parameter that is explained as: offset along z axis (Angstroms)

The protocol named "import tomomasks (segmentations)" can be found in the tomo plugin.
"import tomomasks (segmentations)" protocol help is as follows:
 Protocol to import a set of tomomasks (segmentations) to the project.
"import tomomasks (segmentations)" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import tomomasks (segmentations)" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import tomomasks (segmentations)" has a "" parameter that is explained as: Select the type of import.
"import tomomasks (segmentations)" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import tomomasks (segmentations)" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import tomomasks (segmentations)" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import tomomasks (segmentations)" has a "Tomograms" parameter that is explained as: Select the tomograms to be assigned to the input tomo masks.

The protocol named "import tilt-series" can be found in the tomo plugin.
"import tilt-series" protocol help is as follows:
 Protocol to import tilt series..
"import tilt-series" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import tilt-series" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import tilt-series" has a "Files directory" parameter that is explained as: Root directory of the tilt-series (or movies) files.
"import tilt-series" has a "Pattern" parameter that is explained as: This determines if the tilt series / movies are going to be imported using the mdoc files or the tilt series files. To import from the mdoc files, the word '.mdoc' must appear in the pattern, if not, a tilt series pattern is expected. In the first case, the angular and acquisition data are read from the corresponding mdoc files, while in the second case they are read from the name of the matching files.

*IMPORTING WITH MDOC FILES*

For *tilt series movies*, ONE mdoc per tilt series is expected. The movie files must be located in the same folder as the mdocs. The filenames will be fetched from the _SubFramePath_ value in mdoc. 
Example pattern: _TS*.mdoc_

For *tilt series*, ONE _mrcs_ stack should match ONE mdoc file per each tilt series. To import unstacked images use the filename pattern (see below) instead of mdoc.

*IMPORTING WITH A FILENAME PATTERN (tilt series and movies)*

The pattern can contain wildcards such as *, ?, etc. It should also contain the following special tags:

   *{TS}*: tilt series identifier, which can be any UNIQUE part of the path. This must be an alpha-numeric sequence (avoid dash (-) symbol) and can not start with a number.
   *{TO}*: acquisition order, an integer value (important for dose information).
   *{TA}*: tilt angle, a positive or negative float value.

Example:

To import a set of images (tilt-series or tilt-series movies) like: 
TiltSeries_a_001_0.0.mrc
TiltSeries_a_002_3.0.mrc
TiltSeries_a_003_-3.0.mrc
...
TiltSeries_b_001_0.0.mrc
TiltSeries_b_002_3.0.mrc
TiltSeries_b_003_-3.0.mrc
...
Use pattern TiltSeries_{TS}_{TO}_{TA}.mrc, which will identify:
{TS} as a, b, ...
{TO} as 001, 002, 003, ...
{TA} as 0.0, 3.0, -3.0, ...

"import tilt-series" has a "Tomo5 mdoc?" parameter that is explained as: If these mdocs were generated by the Tomography 5 software, check this box to ensure that the tilt axis angle is converted properly: -1 * TiltAxisAngle - 90
"import tilt-series" has a "Exclusion words:" parameter that is explained as: List of words separated by a space that the path should not have
"import tilt-series" has a "Acquisition values provided below will override the corresponding mdoc values" parameter that is explained as: None
"import tilt-series" has a "Import angles from" parameter that is explained as: Choose how the tilt angles will be inferred. They can be taken from a range (Min, Max, Step) or from the image header, or from anmdoc or tlt file (should have the SAME filename but with the .mdoc or .tlt or .rawtlt extension at the end). If a tlt or rawtlt file is used, it is optional to pass the accumulated dose as second column beside each angle separated by space
"import tilt-series" has a "min" parameter that is explained as: None
"import tilt-series" has a "max" parameter that is explained as: None
"import tilt-series" has a "step" parameter that is explained as: None
"import tilt-series" has a "Have images been CTF corrected?" parameter that is explained as: Select Yes if images have been CTF corrected
"import tilt-series" has a "Have images been aligned?" parameter that is explained as: Select Yes if images have been rotated/interpolated using alignment information.
"import tilt-series" has a "Import action on files" parameter that is explained as: This parameters determine how the project will deal with imported files. It can be: 
*Copy files*: Input files will be copied into your project. (this will duplicate the raw data).*Absolute symlink*: Create symbolic links to the absolute path of the files.*Relative symlink*: Create symbolic links as relative path from the protocol run folder. 
"import tilt-series" has a "Microscope voltage (kV)" parameter that is explained as: Microscope voltage
"import tilt-series" has a "Spherical aberration (mm)" parameter that is explained as: Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
"import tilt-series" has a "Amplitude Contrast" parameter that is explained as: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
"import tilt-series" has a "Magnification rate" parameter that is explained as: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
"import tilt-series" has a "Pixel size (sampling rate) Å/px" parameter that is explained as: Pixel size
"import tilt-series" has a "Tilt axis angle (deg.)" parameter that is explained as: The rotation angle is the angle from the vertical to the axis of tilting, where counterclockwise is positive.
 See https://bio3d.colorado.edu/imod/doc/tomoguide.html#UnknownAxisAngle
"import tilt-series" has a "Initial dose" parameter that is explained as: None
"import tilt-series" has a "Dose per tilt image" parameter that is explained as: None

The protocol named "import tomo CTFs" can be found in the tomo plugin.
"import tomo CTFs" protocol help is as follows:
 Common protocol to import CTF estimation of a tilt-series. .
"import tomo CTFs" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import tomo CTFs" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import tomo CTFs" has a "Import from" parameter that is explained as: Select the type of import.
"import tomo CTFs" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import tomo CTFs" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import tomo CTFs" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import tomo CTFs" has a "Exclusion words:" parameter that is explained as: List of words separated by a space that the path should not have
"import tomo CTFs" has a "Input tilt-series" parameter that is explained as: Select the corresponding tilt-series for which you want to update the CTF parameters.

The protocol named "import tilt-series movies" can be found in the tomo plugin.
"import tilt-series movies" protocol help is as follows:
 Protocol to import tilt series movies..
"import tilt-series movies" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import tilt-series movies" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import tilt-series movies" has a "Files directory" parameter that is explained as: Root directory of the tilt-series (or movies) files.
"import tilt-series movies" has a "Pattern" parameter that is explained as: This determines if the tilt series / movies are going to be imported using the mdoc files or the tilt series files. To import from the mdoc files, the word '.mdoc' must appear in the pattern, if not, a tilt series pattern is expected. In the first case, the angular and acquisition data are read from the corresponding mdoc files, while in the second case they are read from the name of the matching files.

*IMPORTING WITH MDOC FILES*

For *tilt series movies*, ONE mdoc per tilt series is expected. The movie files must be located in the same folder as the mdocs. The filenames will be fetched from the _SubFramePath_ value in mdoc. 
Example pattern: _TS*.mdoc_

For *tilt series*, ONE _mrcs_ stack should match ONE mdoc file per each tilt series. To import unstacked images use the filename pattern (see below) instead of mdoc.

*IMPORTING WITH A FILENAME PATTERN (tilt series and movies)*

The pattern can contain wildcards such as *, ?, etc. It should also contain the following special tags:

   *{TS}*: tilt series identifier, which can be any UNIQUE part of the path. This must be an alpha-numeric sequence (avoid dash (-) symbol) and can not start with a number.
   *{TO}*: acquisition order, an integer value (important for dose information).
   *{TA}*: tilt angle, a positive or negative float value.

Example:

To import a set of images (tilt-series or tilt-series movies) like: 
TiltSeries_a_001_0.0.mrc
TiltSeries_a_002_3.0.mrc
TiltSeries_a_003_-3.0.mrc
...
TiltSeries_b_001_0.0.mrc
TiltSeries_b_002_3.0.mrc
TiltSeries_b_003_-3.0.mrc
...
Use pattern TiltSeries_{TS}_{TO}_{TA}.mrc, which will identify:
{TS} as a, b, ...
{TO} as 001, 002, 003, ...
{TA} as 0.0, 3.0, -3.0, ...

"import tilt-series movies" has a "Tomo5 mdoc?" parameter that is explained as: If these mdocs were generated by the Tomography 5 software, check this box to ensure that the tilt axis angle is converted properly: -1 * TiltAxisAngle - 90
"import tilt-series movies" has a "Exclusion words:" parameter that is explained as: List of words separated by a space that the path should not have
"import tilt-series movies" has a "Acquisition values provided below will override the corresponding mdoc values" parameter that is explained as: None
"import tilt-series movies" has a "" parameter that is explained as: Angles will be parsed from the filename pattern.The special token {TA} should be specified as  part of the pattern.
"import tilt-series movies" has a "Import action on files" parameter that is explained as: This parameters determine how the project will deal with imported files. It can be: 
*Copy files*: Input files will be copied into your project. (this will duplicate the raw data).*Absolute symlink*: Create symbolic links to the absolute path of the files.*Relative symlink*: Create symbolic links as relative path from the protocol run folder. 
"import tilt-series movies" has a "Microscope voltage (kV)" parameter that is explained as: Microscope voltage
"import tilt-series movies" has a "Spherical aberration (mm)" parameter that is explained as: Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
"import tilt-series movies" has a "Amplitude Contrast" parameter that is explained as: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
"import tilt-series movies" has a "Magnification rate" parameter that is explained as: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
"import tilt-series movies" has a "Pixel size (sampling rate) Å/px" parameter that is explained as: Pixel size
"import tilt-series movies" has a "Tilt axis angle (deg.)" parameter that is explained as: The rotation angle is the angle from the vertical to the axis of tilting, where counterclockwise is positive.
 See https://bio3d.colorado.edu/imod/doc/tomoguide.html#UnknownAxisAngle
"import tilt-series movies" has a "Initial dose" parameter that is explained as: None
"import tilt-series movies" has a "Dose per tilt image" parameter that is explained as: None
"import tilt-series movies" has a "Gain image" parameter that is explained as: A gain reference related to a set of movies for gain correction
"import tilt-series movies" has a "Dark image" parameter that is explained as: A dark image related to a set of movies

The protocol named "meshes from tomoMask" can be found in the tomo plugin.
"meshes from tomoMask" protocol help is as follows:
 
    Creates meshes based on segmentations (TomoMasks) voxels values.
    .
"meshes from tomoMask" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"meshes from tomoMask" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"meshes from tomoMask" has a "Tomo Masks" parameter that is explained as: Set of tomo mask from which the meshes will be created
"meshes from tomoMask" has a "Lowest" parameter that is explained as: None
"meshes from tomoMask" has a "Highest" parameter that is explained as: None
"meshes from tomoMask" has a "Percentage of density " parameter that is explained as: This parameter goes from 0 - 100 and defines the percentage of voxel of the tomoMask thatwill be considered as points of the mesh.

The protocol named "Astigmatism rotation" can be found in the tomo plugin.
"Astigmatism rotation" protocol help is as follows:
 
    Rotate the astigmatism of a set of ctf tilt-series estimation given a set of transformation matrices coming from
    a set of tilt series.
    .
"Astigmatism rotation" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Astigmatism rotation" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Astigmatism rotation" has a "Set of tilt-series from which get transform" parameter that is explained as: Set of tilt-series from which transformation matrices will be obtained.
"Astigmatism rotation" has a "input tilt-series CTF estimation" parameter that is explained as: Select the CTF estimation whose astigmatism estimation will be rotated.

The protocol named "split even/odd tomos/subtomos" can be found in the tomo plugin.
"split even/odd tomos/subtomos" protocol help is as follows:
  Protocol to split set of tomograms or subtomograms in even/odd sets by element id.
    .
"split even/odd tomos/subtomos" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"split even/odd tomos/subtomos" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"split even/odd tomos/subtomos" has a "Set to split" parameter that is explained as: Select the set of tomograms or subtomograms that you want to split in even/odd sets.

The protocol named "extract 3D coordinates" can be found in the tomo plugin.
"extract 3D coordinates" protocol help is as follows:
 
    Extract the coordinates information from a set of subtomograms.

    This protocol is useful when we want to re-extract the subtomograms
    (maybe resulting from classification) with the
    original dimensions. It can be also handy to visualize the resulting
    subtomograms in their location on the tomograms.
    .
"extract 3D coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"extract 3D coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"extract 3D coordinates" has a "Subtomograms or 3D coordinates" parameter that is explained as: Select the subtomograms from which you want
to extract the coordinates. The coordinate belonging to each subtomogram should be already associated to an initial tomogram.
"extract 3D coordinates" has a "Tomograms" parameter that is explained as: Select the tomograms to which you want to
associate the coordinates from the subtomograms.
"extract 3D coordinates" has a "Box Size" parameter that is explained as: Determine the box size of the extracted coordinates. By default, the program assigns the box size directly from the coordinates associated to the subtomograms.
"extract 3D coordinates" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.

The protocol named "Landmarks to 2D coordinates" can be found in the tomo plugin.
"Landmarks to 2D coordinates" protocol help is as follows:
  Converts a set of landmark models into SPA 2d objects. Landmarks will become
    a SetOfCoordinates2D and the tilt series associated will become a micrograph set associated
    to the coordinates. Since SPA methods will not handle micrograph in stacks, tilt series files will
    be unstacked..
"Landmarks to 2D coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Landmarks to 2D coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Landmarks to 2D coordinates" has a "Landmarks" parameter that is explained as: Set of Landmarks to convert

The protocol named "misalign tilt-series " can be found in the tomo plugin.
"misalign tilt-series " protocol help is as follows:
 
    Introduce misalignment in the transformation matrix of a tilt-series.
    NOTE: The Interpolated tilt series in this case resembles a not aligned tilt series
    or an aligned one in case you want to apply the inverse of the misalignment
    transformation matrix.
    .
"misalign tilt-series " has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"misalign tilt-series " has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"misalign tilt-series " has a "Input set of tilt-series" parameter that is explained as: None
"misalign tilt-series " has a "Introduce misalignment in shift X?" parameter that is explained as: Introduce noise in the shift alignment value in the X axis. Characterize the noise behaviour through the parameters in the following formula:

dx = a0 + a1 * i + a2 * sin((i + a3) / S * pi) + a4 * sin((i + a5) / S * 2 * pi) + N(0,a6)

Being i the index position of the image inside the tilt-series, S the size of it and N a normal distribution.These parameters characterize the following behaviours:
- Constant (a0): an offset error (a0) is introduced in every image of the tilt-series.
- Incremental (a1): a constant incremental error (a1) is propagated through the tilt-series.
- Sine lobe (a2, a3): the introduced error presents a half sine shape, characterized by the error amplitude (a2) and the phase to displace the error function a given number of images inside the tilt-series (a3).
- Sine cycle (a4, a5): the introduced error presents a full sine cycle shape, characterized by the error amplitude (a4) and the phase to displace the error function a given number of images inside the tilt-series (a5).
- Random (a6): a random error is introduced in every image of the tilt-series given a sigma value (a6).

"misalign tilt-series " has a "Offset error (a0)" parameter that is explained as: Offset shift error introduced in the X axis for every image of the tilt-series.
"misalign tilt-series " has a "Incremental error (a1)" parameter that is explained as: Incremental shift error introduced in the X axis for every image of the tilt-series.
"misalign tilt-series " has a "Sine lobe error amplitude (a2)" parameter that is explained as: Maximum amplitude of the sine lobe error function introduced in the X axis.
"misalign tilt-series " has a "Sine lobe error phase (a3)" parameter that is explained as: Phase (displacement) of the sine lobe error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
"misalign tilt-series " has a "Sine error amplitude (a4)" parameter that is explained as: Maximum amplitude of the sine error function introduced in the X axis.
"misalign tilt-series " has a "Sine error phase (a5)" parameter that is explained as: Phase (displacement) of the sine error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
"misalign tilt-series " has a "Random error sigma (a6)" parameter that is explained as: Sigma value for the random error introduced in the shift X.
"misalign tilt-series " has a "Introduce misalignment in shift Y?" parameter that is explained as: Introduce noise in the shift alignment value in the Y axis. Characterize the noise behaviour through the parameters in the following formula:

dY = b0 + b1 * i + b2 * sin((i + b3) / S * pi) + b4 * sin((i + b5) / S * 2 * pi) + N(0,b6)

Being i the index position of the image inside the tilt-series, S the size of it and N a normal distribution.These parameters characterize the following behaviours:
- Constant (b0): an offset error (b0) is introduced in every image of the tilt-series.
- Incremental (b1): a constant incremental error (b1) is propagated through the tilt-series.
- Sine lobe (b2, b3): the introduced error presents a half sine shape, characterized by the error amplitude (b2) and the phase to displace the error function a given number of images inside the tilt-series (b3).
- Sine cycle (b4, b5): the introduced error presents a full sine cycle shape, characterized by the error amplitude (b4) and the phase to displace the error function a given number of images inside the tilt-series (b5).
- Random (b6): a random error is introduced in every image of the tilt-series given a sigma value (b6).

"misalign tilt-series " has a "Offset error (b0)" parameter that is explained as: Offset shift error introduced in the Y axis for every image of the tilt-series.
"misalign tilt-series " has a "Incremental error (b1)" parameter that is explained as: Incremental shift error introduced in the Y axis for every image of the tilt-series.
"misalign tilt-series " has a "Sine lobe error amplitude (b2)" parameter that is explained as: Maximum amplitude of the sine lobe error function introduced in the Y axis.
"misalign tilt-series " has a "Sine lobe error phase (b3)" parameter that is explained as: Phase (displacement) of the sine lobe error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
"misalign tilt-series " has a "Sine error amplitude (b4)" parameter that is explained as: Maximum amplitude of the sine error function introduced in the Y axis.
"misalign tilt-series " has a "Sine error phase (b5)" parameter that is explained as: Phase (displacement) of the sine error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
"misalign tilt-series " has a "Random error sigma (b6)" parameter that is explained as: Sigma value for the random error introduced in the shift Y.
"misalign tilt-series " has a "Introduce misalignment in angle?" parameter that is explained as: Introduce noise in the angle alignment value. Characterize the noise behaviour through the parameters in the following formula:

dA = c0 + c1 * i + c2 * sin((i + c3) / S * pi) + c4 * sin((i + c5) / S * 2 * pi) + N(0,c6)

Being i the index position of the image inside the tilt-series, S the size of it and N a normal distribution.These parameters characterize the following behaviours:
- Constant (c0): an offset error (c0) is introduced in every image of the tilt-series.
- Incremental (c1): a constant incremental error (c1) is propagated through the tilt-series.
- Sine lobe (c2, c3): the introduced error presents a half sine shape, characterized by the error amplitude (c2) and the phase to displace the error function a given number of images inside the tilt-series (c3).
- Sine cycle (c4, c5): the introduced error presents a full sine cycle shape, characterized by the error amplitude (c4) and the phase to displace the error function a given number of images inside the tilt-series (c5).
- Random (c6): a random error is introduced in every image of the tilt-series given a sigma value (c6).

"misalign tilt-series " has a "Offset error (c0)" parameter that is explained as: Constant angle error to add for every image of the tilt-series. Angles are measured in degrees.
"misalign tilt-series " has a "Incremental error (c1)" parameter that is explained as: Initial angle error value for the first image (lowest angle) of the tilt-series. Angles are measured in degrees.
"misalign tilt-series " has a "Sine lobe error amplitude (c2)" parameter that is explained as: Maximum amplitude of the sine lobe error function introduced in the angle. Angles are measured in degrees.
"misalign tilt-series " has a "Sine lobe error phase (c3)" parameter that is explained as: Phase (displacement) of the sine lobe error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
"misalign tilt-series " has a "Sine error amplitude (c4)" parameter that is explained as: Maximum amplitude of the sine error function introduced in the angle. Angles are measured in degrees.
"misalign tilt-series " has a "Sine error phase (c5)" parameter that is explained as: Phase (displacement) of the sine error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
"misalign tilt-series " has a "Random error sigma (c6)" parameter that is explained as: Sigma value for random error introduced in the angle. Angles are measured in degrees.
"misalign tilt-series " has a "Generate interpolated tilt-series" parameter that is explained as: Generate tilt-series applying theobtained misalignment transformation matrix.
"misalign tilt-series " has a "With inverted matrix" parameter that is explained as: Save the inverse of the misalignment transformation matrix in the interpolated set.

The protocol named "tomograms to micrographs" can be found in the tomo plugin.
"tomograms to micrographs" protocol help is as follows:
  Turns tomograms into set of micrographs to apply SPA picking methods..
"tomograms to micrographs" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"tomograms to micrographs" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"tomograms to micrographs" has a "Tomograms" parameter that is explained as: Select the tomograms to be turned into micrographs
"tomograms to micrographs" has a "Slices gap" parameter that is explained as: Number of slices to skip when turning tomogram slices into micrographs.
"tomograms to micrographs" has a "No. slices to sum" parameter that is explained as: For each slice corresponding to the slices gap introduced, the introduced number of adjacent slices will be considered to sum. For example, if the number is 5, the slices considered for each sum will be the corresponding to the slice gap indices plus 2 slices above and 2 slices below. If set to 1, no sum will be performed.

The protocol named "average tilt-series movies" can be found in the tomo plugin.
"average tilt-series movies" protocol help is as follows:
 
    Simple protocol to average TiltSeries movies as basic
    motion correction. It is used mainly for testing purposes.
    .
"average tilt-series movies" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"average tilt-series movies" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"average tilt-series movies" has a "Input Tilt-Series (movies)" parameter that is explained as: Select input tilt-series movies that you wantto correct for beam-induced motion. 
"average tilt-series movies" has a "from" parameter that is explained as: None
"average tilt-series movies" has a "to" parameter that is explained as: None
"average tilt-series movies" has a "Use ALIGN frames range to SUM?" parameter that is explained as: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
"average tilt-series movies" has a "from" parameter that is explained as: None
"average tilt-series movies" has a "to" parameter that is explained as: None
"average tilt-series movies" has a "Binning factor" parameter that is explained as: 1x or 2x. Bin stack before processing.
"average tilt-series movies" has a "X" parameter that is explained as: None
"average tilt-series movies" has a "Y" parameter that is explained as: None
"average tilt-series movies" has a "X" parameter that is explained as: None
"average tilt-series movies" has a "Y" parameter that is explained as: None
"average tilt-series movies" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"average tilt-series movies" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"average tilt-series movies" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Tilt-series convert coords3D" can be found in the tomo plugin.
"Tilt-series convert coords3D" protocol help is as follows:
 
    Scipion protocol to convert a set of tilt-series coordinates 3d to a set of coordinates 3d associated to a set of
    tomograms.
    .
"Tilt-series convert coords3D" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Tilt-series convert coords3D" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Tilt-series convert coords3D" has a "Input set of coordinates 3D" parameter that is explained as: Set of 3D coordinates indicating the position in space of the fiducials. This set should be obtained from the previous alignment step of the tilt-series.
"Tilt-series convert coords3D" has a "Input set of tomograms" parameter that is explained as: None

The protocol named "fit vesicles" can be found in the tomo plugin.
"fit vesicles" protocol help is as follows:
  This protocol adjust a SetOfSubtomograms with coordinates assigned or a SetOfCoordinates3D, to a vesicle
    (ellipsoid), defining regions of interest (SetOfMeshes) for each vesicle as output..
"fit vesicles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"fit vesicles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"fit vesicles" has a "Subtomograms/Coordinates3D" parameter that is explained as: Subtomograms or coordinates3D picked in vesicles. If there are more than one vesicle per tomogram, input subtomograms or coordinates should have assigned groupId.

The protocol named "align transformations" can be found in the xmipptomo plugin.
"align transformations" protocol help is as follows:
 Protocol to rotate a series of alignments to a common reference defined by a
    Subtomogram Average.
"align transformations" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"align transformations" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"align transformations" has a "Reference Subtomogram Average" parameter that is explained as: None
"align transformations" has a "Moving Subtomogram Average" parameter that is explained as: None
"align transformations" has a "Moving Subtomograms" parameter that is explained as: None

The protocol named "apply alignment subtomo" can be found in the xmipptomo plugin.
"apply alignment subtomo" protocol help is as follows:
  Apply alignment matrix and produce a new setOfSubtomograms, with each subtomogram aligned to its reference. .
"apply alignment subtomo" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"apply alignment subtomo" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"apply alignment subtomo" has a "Set of subtomograms" parameter that is explained as: Set of subtomograms to be alignment

The protocol named "apply alignment tilt-series" can be found in the xmipptomo plugin.
"apply alignment tilt-series" protocol help is as follows:
 
    Compute the interpolated tilt-series from its transform matrix.
    .
"apply alignment tilt-series" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"apply alignment tilt-series" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"apply alignment tilt-series" has a "Input set of tilt-series" parameter that is explained as: None

The protocol named "connected components to ROIs" can be found in the xmipptomo plugin.
"connected components to ROIs" protocol help is as follows:
  This protocol adjust a SetOfCoordinates (which usually will come from a
    connected componnent) to a ROI (region of interest) previously defined.
"connected components to ROIs" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"connected components to ROIs" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"connected components to ROIs" has a "Connected components" parameter that is explained as: Select the Connected components (SetOfCoordinates3D).
"connected components to ROIs" has a "ROIs" parameter that is explained as: Select the ROIs (Regions Of Interest) they are SetOfMeshes
"connected components to ROIs" has a "Selection" parameter that is explained as: Selection options:
*Connected component*: It takes the whole connected component (cc) if a percentage of the points (introduced in the next field) in the cc belongs to the ROI. 
*Points*: It takes just the points of the cc which belongs to the roi
"connected components to ROIs" has a "Percentage of coordinates in ROI" parameter that is explained as: Percentage of coordinates from a connected component that should be inside the ROI to consider that connected component.
"connected components to ROIs" has a "Distance" parameter that is explained as: Maximum euclidean distance (in pixels) between ROI vertex and a coordinate to consider that it belongs to the ROI.

The protocol named "cltomo" can be found in the xmipptomo plugin.
"cltomo" protocol help is as follows:
  Averages a set of subtomograms taking into account the missing edge. .
"cltomo" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"cltomo" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"cltomo" has a "Set of volumes" parameter that is explained as: Set of volumes to align
"cltomo" has a "Number of references" parameter that is explained as: How many references are computed at the end of the process
"cltomo" has a "Number of iterations" parameter that is explained as: How many iterations at each of the Clustering levels
"cltomo" has a "Generate aligned subvolumes" parameter that is explained as: If set to true, it will be created a new set of volumes with all of them aligned
"cltomo" has a "Align" parameter that is explained as: Do not align if volumes are already aligned, only classify
"cltomo" has a "Generate initial volume" parameter that is explained as: Let CLTomo to automatically generate the initial references
"cltomo" has a "Number of initial references" parameter that is explained as: How many initial volumes. If set to 1, all subvolumes are aligned to a single reference, and then they are classified
"cltomo" has a "Randomize orientation" parameter that is explained as: Use this option if all the input volumes have the same missing wedge or if they have not been previously aligned.
"cltomo" has a "Set of initial volumes" parameter that is explained as: Set of initial volumes
"cltomo" has a "Symmetry group" parameter that is explained as: See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format.If no symmetry is present, give c1
"cltomo" has a "Spatial mask" parameter that is explained as: None
"cltomo" has a "Maximum resolution (pixels^-1)" parameter that is explained as: The maximum (Nyquist) resolution is 0.5. Use smaller values, e.g. 0.45, to prevent high-resolution artifacts.
"cltomo" has a "Sparsity in Fourier space" parameter that is explained as: A value of 90 drops 90% of the smallest Fourier coefficients
"cltomo" has a "Sparsity in wavelet space" parameter that is explained as: A value of 95 drops 95% of the smallest wavelet coefficients
"cltomo" has a "Maximum rotational angle" parameter that is explained as: In degrees
"cltomo" has a "Maximum tilt angle" parameter that is explained as: In degrees
"cltomo" has a "Maximum in-plane angle" parameter that is explained as: In degrees
"cltomo" has a "Maximum shift X" parameter that is explained as: In voxels
"cltomo" has a "Maximum shift Y" parameter that is explained as: In voxels
"cltomo" has a "Maximum shift Z" parameter that is explained as: In voxels
"cltomo" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"cltomo" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "local confidence maps" can be found in the xmipptomo plugin.
"local confidence maps" protocol help is as follows:
 
    This protocol can be used with tilt series or with tomograms
    Tilt series: The algorithm estimates the local probabilities of each signal
    Tomograms:
    .
"local confidence maps" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"local confidence maps" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"local confidence maps" has a "Has odd-even associated?" parameter that is explained as: (True) The odd-even SetOfTiltSeries or the SetOfTomograms are internally associatedto the input SetOfTiltSeries or SetOfTomograms. (False) The user have to provide in the input the odd and even sets.
"local confidence maps" has a "Input TiltSeres/Tomograms" parameter that is explained as: Select the odd tomogram for estimating the confidence tomogram.
"local confidence maps" has a "Odd tilt series/tomogram" parameter that is explained as: Select the odd tilt series/tomogram for estimating the confidence tomogram.
"local confidence maps" has a "Even tilt series/tomogram" parameter that is explained as: Select the even tilt series/tomogram for estimating the  confidence map.
"local confidence maps" has a "median filter" parameter that is explained as: The mask determines which points are specimen and which are not.
"local confidence maps" has a "Locality" parameter that is explained as: Edge of the square local windows where local distribution of noise will be measured.
"local confidence maps" has a "sigma" parameter that is explained as: The mask determines which points are specimen and which are not.
"local confidence maps" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"local confidence maps" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "connected components" can be found in the xmipptomo plugin.
"connected components" protocol help is as follows:
  This protocol takes a set of coordinates and identifies connected
    components among the picked particles..
"connected components" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"connected components" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"connected components" has a "Coordinates" parameter that is explained as: Select the SetOfCoordinates3D.
"connected components" has a "Distance" parameter that is explained as: Maximum radial distance (in voxels) between particles to consider that they are in the same connected component. Wizard returns three times the box size of the input coordinates.

The protocol named "crop tomograms" can be found in the xmipptomo plugin.
"crop tomograms" protocol help is as follows:
 
    Protocol to crop tomograms using xmipp_transform_window.
    The protocol allows to change the size of a tomogram/s, by removing the
    borders defined by the users
    .
"crop tomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"crop tomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"crop tomograms" has a "Input set of tomograms" parameter that is explained as: Select a set of tomograms to be cropped.
"crop tomograms" has a "from" parameter that is explained as: None
"crop tomograms" has a "to" parameter that is explained as: None
"crop tomograms" has a "from" parameter that is explained as: None
"crop tomograms" has a "to" parameter that is explained as: None
"crop tomograms" has a "from" parameter that is explained as: None
"crop tomograms" has a "to" parameter that is explained as: None

The protocol named "detect misalignment from fiducials" can be found in the xmipptomo plugin.
"detect misalignment from fiducials" protocol help is as follows:
 
    Wrapper protocol to Xmipp xmipp_deep_misalignment_detection for misalignment detection
    in tomographic reconstructions based on artifacted landmarks
    .
"detect misalignment from fiducials" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"detect misalignment from fiducials" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"detect misalignment from fiducials" has a "Fiducial 3D coordinates" parameter that is explained as: 3D coordinates indicating the location of the fiducials (gold beads) in the tomogram. These fiducails will be the ones used to study misalignment artifacts over them. The coordinate denotes the center of the subtomogram
"detect misalignment from fiducials" has a "Tomogram source" parameter that is explained as: By default the subtomograms will be extracted from the tomogram used in the picking step ( _same as picking_ option ). 
If you select _other_ option, you must provide a different tomogram to extract from. 
*Note*: In the _other_ case, ensure that provided tomogram and coordinates are related 
"detect misalignment from fiducials" has a "Input tomograms" parameter that is explained as: Tomograms from which extract the fiducials (gold beads) at the specified coordinates locations.
"detect misalignment from fiducials" has a "Use misalignment threshold?" parameter that is explained as: Threshold to settle if a tomogram presents weak or strong misalignment. If this value is not provided two output set of tomograms are generated, those discarded which present strong misalignment and those which do not. If this value is provided the second group of tomograms is splitted into two, using this threshold to settle if the tomograms presentor not a weak misalignment.
"detect misalignment from fiducials" has a "Misalignment threshold" parameter that is explained as: Threshold value to settle if a tomogram presents weak or strong misalignment. Value ranged between (0, 1).
"detect misalignment from fiducials" has a "Model for weak misalignment estimation" parameter that is explained as: Choose model for weak misalignment estimation. By default, strict model is picked in order to avoid false positives. In case loose model is chosen, less good aligned tomograms are lost. As a tradeoff, the number of false positives will increase.
"detect misalignment from fiducials" has a "Misalignment criteria" parameter that is explained as: Criteria used for making a decision on the presence of misalignment on the tomogram based on the individual scores of each subtomogram. By default the mean of this scores is calculated. The other option is to implement a voting system based on if each subtomo score is closer to 0 o 1.

The protocol named "Dose filter" can be found in the xmipptomo plugin.
"Dose filter" protocol help is as follows:
 
    Tilt-series' dose filtering based on  T. Grant, N. Grigorieff, eLife 2015
    More info:
        https://doi.org/10.7554/eLife.06980
    .
"Dose filter" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Dose filter" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Dose filter" has a "Input set of tilt-series to be filtered." parameter that is explained as: None
"Dose filter" has a "Initial dose (e/sq A)" parameter that is explained as: Dose applied before any of the images in the input file were taken; this value will be added to all the prior dose values, however they were obtained.

The protocol named "extract particle stacks" can be found in the xmipptomo plugin.
"extract particle stacks" protocol help is as follows:
 
    Extract a set of particle stacks from a set of tilt series given a set of coordinates in the tomogram.
    .
"extract particle stacks" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"extract particle stacks" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"extract particle stacks" has a "Coordinates" parameter that is explained as: 3D coordinates to use in the extraction process.The coordinate denotes the center of the particle stack (subtomogram position)
"extract particle stacks" has a "Tilt Series" parameter that is explained as: The particle stacks will be extracted from this set.
"extract particle stacks" has a "Box size" parameter that is explained as: The particle stack are extracted as squares. The box size defines the edge of the square
"extract particle stacks" has a "Invert Contrast" parameter that is explained as: Normally, tilt series has the contrast inverted with respect to standard for tilt series particles. It means, in the tomograms/recosntructions the structure is black and the noise is white. Generally, thetilt series particles are white with a black background. This means that the tilt series particles have the contrast inverted with respect to the tilt series. Put this flag as True if the contrastneed to be inverted.
"extract particle stacks" has a "Extract as SPA particles" parameter that is explained as: False for a pure tilt series particles averaging treatment of the problem. True if the extractted particles will be used ina single Particle Analysis workflow.

The protocol named "extract subtomos" can be found in the xmipptomo plugin.
"extract subtomos" protocol help is as follows:
 
    Extract a set of subtomograms from a set of tomograms given a set of coordinates.
    .
"extract subtomos" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"extract subtomos" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"extract subtomos" has a "Coordinates" parameter that is explained as: 3D coordinates to use in the extraction process.The coordinate denotes the center of the subtomogram
"extract subtomos" has a "Tomograms (Optional)" parameter that is explained as: The subtomograms will be extracted from this set.
"extract subtomos" has a "Box size" parameter that is explained as: The subtomograms are extracted as a cube. The box size defines the edge of the cube. This is the final size of the boxsize if downsampling is applied. The wizard selects same box size as picking
"extract subtomos" has a "Dowsampling factor" parameter that is explained as: The subtomograms are extracted as a cube. The box size defines the edge of the cubeThe wizard selects same box size as picking
"extract subtomos" has a "Invert Contrast" parameter that is explained as: Normally, tomograms has the contrast inverted with respect to standard for subtomograms. It means, in the tomograms the structure is black and the noise is white. Generally, thesubtomograms are white with a black background. This means that the subtomograms has the contrast inverted with respect to the tomograms. Put this flag as True if the contrastneed to be inverted.

The protocol named "Filter coordinates by map" can be found in the xmipptomo plugin.
"Filter coordinates by map" protocol help is as follows:
 Filter coordinate by map both given a mask or a resolucion map from a tomogram.
"Filter coordinates by map" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Filter coordinates by map" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Filter coordinates by map" has a "Input 3D coordinates" parameter that is explained as: Select the set of 3D coordinates to be filtered
"Filter coordinates by map" has a "Input Tomogram" parameter that is explained as: Select the Set Of Tomograms to be used. The coordinatesmake references to their corresponding tomograms, then, thestatistics of the the enviroment of each coordinates willbe calculated. Thus it is possible to associate a mean, anda standard deviation to each coordinate.
"Filter coordinates by map" has a "Radius" parameter that is explained as: Radius of the ball with center at the coordinate
"Filter coordinates by map" has a "Filter option" parameter that is explained as: Select an option to filter the coordinates: 
 _Average_: Filter by Average value. 
_StandardDeviation_: Filter by Standard deviation value.
"Filter coordinates by map" has a "Average" parameter that is explained as: Average value as threshold
"Filter coordinates by map" has a "std" parameter that is explained as: std value as threshold
"Filter coordinates by map" has a "keep greater than the threshold" parameter that is explained as: Set true if you want to keep values greater than the threshold. And set falseif the values lesser than the threshold will be discarded

The protocol named "half maps" can be found in the xmipptomo plugin.
"half maps" protocol help is as follows:
  Create half maps from a SetOfSubtomograms and its alignment .
"half maps" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"half maps" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"half maps" has a "Set of subtomograms" parameter that is explained as: Set of subtomograms to be split into even and odd stacks

The protocol named "local Resolution MonoTomo" can be found in the xmipptomo plugin.
"local Resolution MonoTomo" protocol help is as follows:
 
    Given a tomogram the protocol assigns local resolutions to each voxel of the tomogram.
    To do that, thje protocol makes use of two half tomograms, called odd and even.
    These tomograms are reconstructed with the same alignment parameter but using the
    half of the data. For instance, the odd/even-images of the tilt series, or much
    better usign the odd/even frames of the movies (recommended). The result is a
    tomogram with the values of local resolution.
    .
"local Resolution MonoTomo" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"local Resolution MonoTomo" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"local Resolution MonoTomo" has a "Odd tomogram" parameter that is explained as: Select the odd tomogram for determining the local resolution tomogram.
"local Resolution MonoTomo" has a "Even Tomogram" parameter that is explained as: Select the even tomogram for determining the  local resolution tomogram.
"local Resolution MonoTomo" has a "Use mask?" parameter that is explained as: The mask determines which points are specimen and which are not.
"local Resolution MonoTomo" has a "Binary Mask" parameter that is explained as: The mask determines which points are specimen and which are not
"local Resolution MonoTomo" has a "Significance" parameter that is explained as: Relution is computed using hypothesis tests, this value determines the significance of that test
"local Resolution MonoTomo" has a "High" parameter that is explained as: None
"local Resolution MonoTomo" has a "Low" parameter that is explained as: None
"local Resolution MonoTomo" has a "Step" parameter that is explained as: None
"local Resolution MonoTomo" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"local Resolution MonoTomo" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "peak high contrast" can be found in the xmipptomo plugin.
"peak high contrast" protocol help is as follows:
 
    Wrapper protocol to Xmipp image peak high contrast applied to any volume
    .
"peak high contrast" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"peak high contrast" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"peak high contrast" has a "Input set of tomograms" parameter that is explained as: Select a set of volumes to peak high contrast regions.
"peak high contrast" has a "Fiducial size (nm)" parameter that is explained as: Size of the fiducial markers (or any other object) to be peaked in nanometers.
"peak high contrast" has a "Box size" parameter that is explained as: Size of the box containing the high contrast feature in pixels.
"peak high contrast" has a "Run in relaxed mode?" parameter that is explained as: If this option is selected coordinates are kept when none of them pass the mirror correlation filter. If not, and empty output is possible. This second case might happen if the tomogram does not present any gold bead or if it presents misalignment
"peak high contrast" has a "Relaxed mode threshold" parameter that is explained as: Minimum number of surviving coordinates to enter in relaxed mode.
"peak high contrast" has a "Number of sampling slices" parameter that is explained as: Number of slices used as a sample to calculate the threshold pixel value, for posterior high contrast regions detection.
"peak high contrast" has a "Threshold for initial coordinates (SD)" parameter that is explained as: Number of standard deviations (SD) that a coordinate value must be over the mean in other to consider it a member of a high contrast feature.
"peak high contrast" has a "Number of coordinates threshold" parameter that is explained as: Number of coordinates that must be attracted by a center of mass to consider it a plausible high contrast feature.
"peak high contrast" has a "Minimum mirror correlation" parameter that is explained as: Minimum correlation between a feature and its mirror to consider it a fiducial.
"peak high contrast" has a "Mahalanobis distance threshold" parameter that is explained as: Maximum Mahalanobis distance of the radial average of the gold bead between all the peaked coordinates.
"peak high contrast" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"peak high contrast" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"peak high contrast" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "phantom create subtomo" can be found in the xmipptomo plugin.
"phantom create subtomo" protocol help is as follows:
  Create subtomogram phantoms .
"phantom create subtomo" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"phantom create subtomo" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"phantom create subtomo" has a " " parameter that is explained as: Import a volume or create 'base' phantom manually
"phantom create subtomo" has a "Input volume" parameter that is explained as: Volume used as 'base' phantom
"phantom create subtomo" has a "Phantom description" parameter that is explained as: create a phantom description: x y z backgroundValue geometry(cyl, sph...) +(superimpose) density value origin radius height rot tilt psi. More info at https://web.archive.org/web/20180813105422/http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/FileFormats#Phantom_metadata_file
"phantom create subtomo" has a "Simulating tilt series" parameter that is explained as: None
"phantom create subtomo" has a "Sampling rate (A/px)" parameter that is explained as: None
"phantom create subtomo" has a "Number of subtomograms" parameter that is explained as: How many phantom subtomograms
"phantom create subtomo" has a "Apply missing wedge?" parameter that is explained as: Apply a filter to simulate the missing wedge along Y axis.
"phantom create subtomo" has a "Missing wedge angle" parameter that is explained as: Missing wedge (along y) for data between +- this angle.
"phantom create subtomo" has a "Force a randomization seed" parameter that is explained as: Activate to force same random results (useful for tests).
"phantom create subtomo" has a "Apply rotation?" parameter that is explained as: Apply a random rotation to the generated subtomograms. The subtomograms will present a randomorientation.
"phantom create subtomo" has a "Randomly distributed?" parameter that is explained as: Apply a random rotation to the generated subtomograms. The subtomograms will present a randomorientation.
"phantom create subtomo" has a "Introduce random error with std" parameter that is explained as: It introduces angular assignment errors with standard deviation given by the introduced valueIt is assumed that the errors are Gaussian.
"phantom create subtomo" has a "std" parameter that is explained as: It introduces angular assignment errors with standard deviation given by the introduced valueIt is assumed that the errors are Gaussian.
"phantom create subtomo" has a "Min" parameter that is explained as: None
"phantom create subtomo" has a "Max" parameter that is explained as: None
"phantom create subtomo" has a "Min" parameter that is explained as: None
"phantom create subtomo" has a "Max" parameter that is explained as: None
"phantom create subtomo" has a "Min" parameter that is explained as: None
"phantom create subtomo" has a "Max" parameter that is explained as: None
"phantom create subtomo" has a "Apply random shift?" parameter that is explained as: Apply a random shit to the generated subtomograms. The subtomograms will present a randomdisplacement from the center of the box.
"phantom create subtomo" has a "Min (px)" parameter that is explained as: None
"phantom create subtomo" has a "Max (px)" parameter that is explained as: None
"phantom create subtomo" has a "Min (px)" parameter that is explained as: None
"phantom create subtomo" has a "Max (px)" parameter that is explained as: None
"phantom create subtomo" has a "Min (px)" parameter that is explained as: None
"phantom create subtomo" has a "Max (px)" parameter that is explained as: None
"phantom create subtomo" has a "Assign random coordinates?" parameter that is explained as: Create random x, y, z coordinates for each subtomogram.
"phantom create subtomo" has a "Tomograms" parameter that is explained as: Tomograms to get dimension for random creation of coordinates
"phantom create subtomo" has a "Add gaussian noise to subtomograms?" parameter that is explained as: Select true to generate noisy subtomograms, and False to obtain clean subtomograms.
"phantom create subtomo" has a "Add variable gaussian noise to subtomograms?" parameter that is explained as: (False) Each subtomogram will follow a different noise distribution. All distribution are Gaussian, the noise of twodifferent subtomograms will follow two different Gaussian distributions. It means, given two subtomogramsA and B, the noise of the subtomogram A will follow a Gaussian distribution with mean mu_A, and std s_A,in contrast, the subtomograms B will follow also a Gaussian distribution but with different mean, mu_B, and different standard deviation s_B. If True, the noise of both subtomograms will follow the same Gaussiandistribution
"phantom create subtomo" has a "Min" parameter that is explained as: None
"phantom create subtomo" has a "Max" parameter that is explained as: None
"phantom create subtomo" has a "mean" parameter that is explained as: None
"phantom create subtomo" has a "std" parameter that is explained as: None

The protocol named "phantom tomograms" can be found in the xmipptomo plugin.
"phantom tomograms" protocol help is as follows:
  Create phantom tomograms with phantom particles and its coordinates with the right Scipion transformation matrix .
"phantom tomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"phantom tomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"phantom tomograms" has a "Tomogram dimensions" parameter that is explained as: Tomogram dimensions: X, Y, Z
"phantom tomograms" has a "Sampling rate" parameter that is explained as: None
"phantom tomograms" has a "Number of particles" parameter that is explained as: How many particles in each tomogram
"phantom tomograms" has a "Number of tomograms" parameter that is explained as: How many tomograms
"phantom tomograms" has a "Missing wedge angle" parameter that is explained as: Missing wedge (along y) for data between +- this angle.
"phantom tomograms" has a "Add noise to the tomogram." parameter that is explained as: Add noise using xmipp_transform.
"phantom tomograms" has a "2 particles?" parameter that is explained as: Add 2 different particles to allow for 3d classification
"phantom tomograms" has a "Min rot angle" parameter that is explained as: Minimum and maximum range for each Euler angle in degrees
"phantom tomograms" has a "Max rot angle" parameter that is explained as: None
"phantom tomograms" has a "Min tilt angle" parameter that is explained as: None
"phantom tomograms" has a "Max tilt angle" parameter that is explained as: None
"phantom tomograms" has a "Min psi angle" parameter that is explained as: None
"phantom tomograms" has a "Max psi angle" parameter that is explained as: None

The protocol named "project subtomograms" can be found in the xmipptomo plugin.
"project subtomograms" protocol help is as follows:
 Extracts proyections from subtomograms.
"project subtomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"project subtomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"project subtomograms" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"project subtomograms" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"project subtomograms" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"project subtomograms" has a "Set of subtomograms" parameter that is explained as: Set of subtomograms whose projections will be generated.
"project subtomograms" has a "Clean temporary files: " parameter that is explained as: Clean temporary files after finishing the execution.
This is useful to reduce unnecessary disk usage.
"project subtomograms" has a "Transform method: " parameter that is explained as: Select the algorithm that will be used to obtain the projections.
"project subtomograms" has a "Tilt range start:" parameter that is explained as: The initial value of the range of angles the projection will be produced on.
Defaults to -60º.
"project subtomograms" has a "Tilt range end:" parameter that is explained as: The final value of the range of angles the projection will be produced on.
Defaults to 60º.
"project subtomograms" has a "Type of sample generation: " parameter that is explained as: Select either the number of samples to be taken or the separation in degrees between each sample.
"project subtomograms" has a "Number of samples:" parameter that is explained as: Number of samples to be produced.
It has to be 1 or greater.
"project subtomograms" has a "Step:" parameter that is explained as: Number of degrees each sample will be separated from the next.
It has to be greater than 0.

The protocol named "reconstruct tomogram" can be found in the xmipptomo plugin.
"reconstruct tomogram" protocol help is as follows:
 
    Given a set of Tilt series with the corresponding alignment parameters. This protocol
    will reconstruct the tomograms associated to the tilt series..
"reconstruct tomogram" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"reconstruct tomogram" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"reconstruct tomogram" has a "Tilt Series" parameter that is explained as: Select the Set of Tilt Series that will be used to reconstruct the tomograms.
"reconstruct tomogram" has a "Reconstruction Algorithm" parameter that is explained as: Select an option to reconstruct tomograms: 
 _ART_: Arithmetic reconstruction technique. 
_SIRT_: (only with MPI) Simultaneous Iterative Reconstruction Technique. 
 
"reconstruct tomogram" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"reconstruct tomogram" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "resize tilt-series" can be found in the xmipptomo plugin.
"resize tilt-series" protocol help is as follows:
 
    Wrapper protocol to Xmipp image resize applied on tilt-series
    .
"resize tilt-series" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"resize tilt-series" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"resize tilt-series" has a "Input set of tilt-series" parameter that is explained as: Select a set of tilt-series to be resized.
"resize tilt-series" has a "Resize option" parameter that is explained as: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Factor_: Set a resize factor to resize. 
 _Pyramid_: Use positive level value to expand and negative to reduce. 
Pyramid uses spline pyramids for the interpolation. All the rest uses normally 
interpolation (cubic B-spline or bilinear interpolation).
"resize tilt-series" has a "Resize sampling rate (Å/px)" parameter that is explained as: Set the new output sampling rate.
"resize tilt-series" has a "Resize factor" parameter that is explained as: New size is the old one x resize factor.
"resize tilt-series" has a "Pyramid level" parameter that is explained as: Use positive value to expand and negative to reduce.
"resize tilt-series" has a "Huge file" parameter that is explained as: If the file is huge, very likely you may have problems doing the antialiasing filter (because there is no memory for the input and its Fourier transform). This option removes the antialiasing filter (meaning you will get aliased results), and performs a bilinear interpolation (to avoid having to produce the B-spline coefficients).

The protocol named "resize tomograms" can be found in the xmipptomo plugin.
"resize tomograms" protocol help is as follows:
 
    Protocol to to resize tomograms using xmipp_image_resize.
    The protocol allows to change the size of a tomogram/s by means
    of different methods
    .
"resize tomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"resize tomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"resize tomograms" has a "Input set of tomograms" parameter that is explained as: Select a set of tomograms to be resized.
"resize tomograms" has a "Resize option" parameter that is explained as: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Factor_: Set a resize factor to resize. 
 _Pyramid_: Use positive level value to expand and negative to reduce. 
Pyramid uses spline pyramids for the interpolation. All the rest uses normally 
interpolation (cubic B-spline or bilinear interpolation).
"resize tomograms" has a "Resize sampling rate (Å/px)" parameter that is explained as: Set the new output sampling rate.
"resize tomograms" has a "Resize factor" parameter that is explained as: New size is the old one x resize factor.
"resize tomograms" has a "Pyramid level" parameter that is explained as: Use positive value to expand and negative to reduce.
"resize tomograms" has a "Huge file" parameter that is explained as: If the file is huge, very likely you may have problems doing the antialiasing filter (because there is no memory for the input and its Fourier transform). This option removes the antialiasing filter (meaning you will get aliased results), and performs a bilinear interpolation (to avoid having to produce the B-spline coefficients).

The protocol named "imagej roi" can be found in the xmipptomo plugin.
"imagej roi" protocol help is as follows:
  Tomogram ROI selection in IJ .
"imagej roi" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"imagej roi" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"imagej roi" has a "Input Tomograms" parameter that is explained as: Select tomograms.

The protocol named "score/filter coordinates" can be found in the xmipptomo plugin.
"score/filter coordinates" protocol help is as follows:
 Scoring and (optional) filtering of coordinates based on different scoring
    functions (carbon distance, neighbour distance).
"score/filter coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"score/filter coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"score/filter coordinates" has a "Input 3D coordinates" parameter that is explained as: Select the set of 3D coordinates to compare
"score/filter coordinates" has a "Operation mode" parameter that is explained as: Determine whether to retrieve all the coordinates scored or to filter out unwanted coordinates based on a threshold
"score/filter coordinates" has a "Score outluiers?" parameter that is explained as: None
"score/filter coordinates" has a "Outliers distance threshold" parameter that is explained as: Z-Score value from 0 to infinite. Only coordinates with a Z-Score smaller than or equal to the threshold will be kept in the output
"score/filter coordinates" has a "Score carbon closeness?" parameter that is explained as: None
"score/filter coordinates" has a "Carbon distance threshold" parameter that is explained as: Score value between 0 and 1. Only coordinates with a score larger than or equal to the threshold will be kept in the output

The protocol named "subtomo alignment consensus" can be found in the xmipptomo plugin.
"subtomo alignment consensus" protocol help is as follows:
 Protocol to score a series of alignments stored in a SetOfSubtomograms by
    quaternion distance analysis.

    xmipp_alignmentDistance ranges from 0º to 180º. Therefore, a 0º distance is the best and means alignment is the same.
    The lower the score the more similar is the alignment.
    .
"subtomo alignment consensus" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"subtomo alignment consensus" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"subtomo alignment consensus" has a "First Subtomograms to compare" parameter that is explained as: None
"subtomo alignment consensus" has a "Second Subtomograms to compare" parameter that is explained as: None

The protocol named "split tilt-series" can be found in the xmipptomo plugin.
"split tilt-series" protocol help is as follows:
 
    Wrapper protocol to Xmipp split Odd Even on tilt-series
    .
"split tilt-series" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"split tilt-series" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"split tilt-series" has a "Input set of tilt-series" parameter that is explained as: Select a set of tilt-series to be split into two sets (odd and even).It means, the set of tilt-series is split in two subsets.

The protocol named "map back subtomos" can be found in the xmipptomo plugin.
"map back subtomos" protocol help is as follows:
  This protocol takes a tomogram, a reference subtomogram and a metadata with geometrical parameters
   (x,y,z) and places the reference subtomogram on the tomogram at the designated locations (map back).
   It has different representation options..
"map back subtomos" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"map back subtomos" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"map back subtomos" has a "Select input type" parameter that is explained as: Class: input is a class generated previously in Scipion.
Subtomograms: input is a set of subtomograms previously aligned.
"map back subtomos" has a "Class" parameter that is explained as: Subtomogram class from which the coordinates of the subtomograms and the reference will be used. It should be a SetOfClassesSubTomograms with just 1 item.
"map back subtomos" has a "Subtomograms/coordinates" parameter that is explained as: Subtomograms to be mapped back, they should have alignment and coordinates.
"map back subtomos" has a "Reference" parameter that is explained as: Subtomogram reference, average, representative or initial model of the subtomograms.
"map back subtomos" has a "Original tomograms" parameter that is explained as: Original tomograms from which the subtomograms were extracted
"map back subtomos" has a "Invert reference contrast" parameter that is explained as: Invert the contrast if the reference is black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background. 
"map back subtomos" has a "Painting mode" parameter that is explained as: The program has several painting options:
*Copy*: Copying the reference onto the tomogram.
*Average*: Setting the region occupied by the reference in the tomogram to the average value of that region.
*Highlight*: Add the reference multiplied by a constant to the location specified.
*Binarize*: Copy a binarized version of the reference onto the tomogram.
"map back subtomos" has a "Remove background" parameter that is explained as: Set tomogram to 0
"map back subtomos" has a "Threshold" parameter that is explained as: threshold applied to tomogram
"map back subtomos" has a "Multiplier" parameter that is explained as: constant to multiply the reference
"map back subtomos" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"map back subtomos" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"map back subtomos" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "subtomo projection" can be found in the xmipptomo plugin.
"subtomo projection" protocol help is as follows:
 
    Project a set of volumes or subtomograms to obtain their X, Y or Z projection of the desired range of slices.
    .
"subtomo projection" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"subtomo projection" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"subtomo projection" has a "Input Volumes" parameter that is explained as: This protocol can *not* work with .em files *if* the input is a set of tomograms or a set of volumes, 
"subtomo projection" has a "Compute radial average?" parameter that is explained as: Compute the radial average with respect to Z of the input volumes and from them, it computes their projections in the desired direction
"subtomo projection" has a "Projection direction" parameter that is explained as: None
"subtomo projection" has a "Range of slices" parameter that is explained as: Range of slices used to compute the projection, where 0 is the central slice.
"subtomo projection" has a "Slices" parameter that is explained as: Crop this amount of voxels in each side of the selected direction.
"subtomo projection" has a "Ignore orientations" parameter that is explained as: Activate to ignore particle orientation information.

The protocol named "subtomo subtraction" can be found in the xmipptomo plugin.
"subtomo subtraction" protocol help is as follows:
  This protocol subtracts a subtomogram average to a SetOfSubtomograms, which are internally aligned and
    numerically adjusted in order to obtain reliable results. The adjustment and subtraction is perfomed by
    xmipp_volume_subtraction program. A mask can be provided if the user wants to perform the subtraction in a
    determined region..
"subtomo subtraction" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"subtomo subtraction" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"subtomo subtraction" has a "Subtomograms " parameter that is explained as: Select the SetOfSubTomograms with transform matrix which will be subtracted.
"subtomo subtraction" has a "Average subtomogram " parameter that is explained as: Select an average subtomogram to be subtracted.
"subtomo subtraction" has a "Mask subtomograms?" parameter that is explained as: The mask are not mandatory but highly recommendable.
"subtomo subtraction" has a "Average mask" parameter that is explained as: Specify a mask for the average.
"subtomo subtraction" has a "Subtraction mask" parameter that is explained as: Optional, specify a mask for the region of subtraction
"subtomo subtraction" has a "Filter at resolution: " parameter that is explained as: Resolution (A) at which subtraction will be performed, filtering the input volumes.Value 0 implies no filtering.
"subtomo subtraction" has a "Decay of the filter (sigma): " parameter that is explained as: Decay of the filter (sigma parameter) to smooth the mask transition
"subtomo subtraction" has a "Number of iterations: " parameter that is explained as: None
"subtomo subtraction" has a "Relaxation factor (lambda): " parameter that is explained as: Relaxation factor for Fourier amplitude projector (POCS), it should be between 0 and 1, being 1 no relaxation and 0 no modification of volume 2 amplitudes
"subtomo subtraction" has a "Save intermediate files?" parameter that is explained as: Save input volume 1 (first subtomogram of the set) filtered and input volume 2 (average) adjusted, which are the volumes that are really subtracted.

The protocol named "tiltseries FlexAlign" can be found in the xmipptomo plugin.
"tiltseries FlexAlign" protocol help is as follows:
 
    Simple protocol to average TiltSeries movies as basic
    motion correction. It is used mainly for testing purposes.
    .
"tiltseries FlexAlign" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"tiltseries FlexAlign" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"tiltseries FlexAlign" has a "Input Tilt-Series (movies)" parameter that is explained as: Select input tilt-series movies that you wantto correct for beam-induced motion. 
"tiltseries FlexAlign" has a "from" parameter that is explained as: None
"tiltseries FlexAlign" has a "to" parameter that is explained as: None
"tiltseries FlexAlign" has a "Use ALIGN frames range to SUM?" parameter that is explained as: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
"tiltseries FlexAlign" has a "from" parameter that is explained as: None
"tiltseries FlexAlign" has a "to" parameter that is explained as: None
"tiltseries FlexAlign" has a "Binning factor" parameter that is explained as: 1x or 2x. Bin stack before processing.
"tiltseries FlexAlign" has a "X" parameter that is explained as: None
"tiltseries FlexAlign" has a "Y" parameter that is explained as: None
"tiltseries FlexAlign" has a "X" parameter that is explained as: None
"tiltseries FlexAlign" has a "Y" parameter that is explained as: None
"tiltseries FlexAlign" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"tiltseries FlexAlign" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"tiltseries FlexAlign" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"tiltseries FlexAlign" has a "Save aligned micrograph" parameter that is explained as: None
"tiltseries FlexAlign" has a "Save movie" parameter that is explained as: Save Aligned movie
"tiltseries FlexAlign" has a "Split & sum odd/even frames?" parameter that is explained as: Generate odd and even sums using odd and even frames respectively when this option is enabled.
"tiltseries FlexAlign" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
"tiltseries FlexAlign" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"tiltseries FlexAlign" has a "Maximum resolution (A)" parameter that is explained as: Maximum resolution in A that will be preserved during correlation.
"tiltseries FlexAlign" has a "Compute PSD?" parameter that is explained as: If Yes, the protocol will compute PSD for each movie before and after the alignment
"tiltseries FlexAlign" has a "Maximum shift (A)" parameter that is explained as: Maximum allowed distance (in A) that each frame can be shifted with respect to the next.
"tiltseries FlexAlign" has a "Compute local alignment?" parameter that is explained as: If Yes, the protocol will try to determine local shifts, similarly to MotionCor2.
"tiltseries FlexAlign" has a "Auto control points" parameter that is explained as: If on, protocol will automatically determine necessary number of control points.
"tiltseries FlexAlign" has a "X" parameter that is explained as: None
"tiltseries FlexAlign" has a "Y" parameter that is explained as: None
"tiltseries FlexAlign" has a "t" parameter that is explained as: None
"tiltseries FlexAlign" has a "Auto patches" parameter that is explained as: If on, protocol will automatically determine necessary number of patches.
"tiltseries FlexAlign" has a "X" parameter that is explained as: None
"tiltseries FlexAlign" has a "Y" parameter that is explained as: None
"tiltseries FlexAlign" has a "Min size of the patch (A)" parameter that is explained as: How many A should contain each patch?
"tiltseries FlexAlign" has a "Group N frames" parameter that is explained as: Group every specified number of frames by adding them together.                         The alignment is then performed on the summed frames.
"tiltseries FlexAlign" has a "Rotate gain reference:" parameter that is explained as: Rotate gain reference counter-clockwise.
"tiltseries FlexAlign" has a "Flip gain reference:" parameter that is explained as: Flip gain reference after rotation. For tiff movies, gain is automatically upside-down flipped

The protocol named "Apply transformation" can be found in the imod plugin.
"Apply transformation" protocol help is as follows:
 
    Compute the interpolated tilt-series from its transform matrix.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/newstack.html
    .
"Apply transformation" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Apply transformation" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Apply transformation" has a "Input set of tilt-series" parameter that is explained as: None
"Apply transformation" has a "Binning" parameter that is explained as: Binning to be applied to the interpolated tilt-series in IMOD convention. Images will be binned by the given factor. Must be an integer bigger than 1
"Apply transformation" has a "Apply to odd/even" parameter that is explained as: If True, the full tilt series and the associated odd/even tilt series will be processed. The transformations applied to the odd/even tilt series will be exactly the same.

The protocol named "CTF estimation (auto)" can be found in the imod plugin.
"CTF estimation (auto)" protocol help is as follows:
 
    CTF estimation of a set of input tilt-series using the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/ctfplotter.html
    .
"CTF estimation (auto)" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"CTF estimation (auto)" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"CTF estimation (auto)" has a "Input set of tilt-series" parameter that is explained as: This should be a *raw stack*, not an aligned stack, because the interpolation used to make an aligned stack attenuates high frequencies and the noise power spectra would no longer match.
"CTF estimation (auto)" has a "Defocus tolerance (nm)" parameter that is explained as: Defocus tolerance in nanometers defining the center strips. The center strips are taken from the central region of a view that has defocus difference less than this tolerance. These kind of center strips from all views within AngleRange are considered to have a constant defocus and are used to compute the initial CTF after being further tessellated into tiles.
"CTF estimation (auto)" has a "Input expected defocus as:" parameter that is explained as: None
"CTF estimation (auto)" has a "Expected defocus value (nm)" parameter that is explained as: This value will be applied as the expected defocus in nanometers for every tilt-series from the set.
"CTF estimation (auto)" has a "Expected defocus file" parameter that is explained as: File containing the expected defocus in nanometers for each tilt-series belonging to the set.

The format of the text file must be two columns, the first one being the tilt series ID and the second the defocus value.

An example of this file comes as follows:
TS_01 4000
TS_02 1500
...
"CTF estimation (auto)" has a "Left defocus tolerance (nm)" parameter that is explained as: Defocus tolerance in nanometers for strips to the left of the center strip.
"CTF estimation (auto)" has a "Right defocus tolerance (nm)" parameter that is explained as: Defocus tolerance in nanometers for strips to the right of the center strip.
"CTF estimation (auto)" has a "Tile size (px)" parameter that is explained as: The tile size each strip will be tessellated into. The size is in pixels and the tiles are square. Each view is first divided into strips that are considered to have constant defocus.
"CTF estimation (auto)" has a "Angle step" parameter that is explained as: Step size between ranges. A value of zero for the step will make it fit to each single image separately, regardless of the value for the range.
"CTF estimation (auto)" has a "Angle range" parameter that is explained as: Size of the angle range for which the CTF is estimated.
"CTF estimation (auto)" has a "Start" parameter that is explained as: Starting frequency (X1 starts)
"CTF estimation (auto)" has a "End" parameter that is explained as: Ending frequency (X2 ends)
"CTF estimation (auto)" has a "Extra zeros to fit" parameter that is explained as: By default, the ending frequency of the fitting range is set to the expected location of the second zero. With this entry, the range will be extended by the given multiple of the interval between first and seconds zeros. For example, entries of 1 and 2 will fit approximately to the third and fourth zeros, respectively. An entry of more than 0.5 will trigger fitting to two exponentials, which is important for fitting multiple peaks between zeros.
"CTF estimation (auto)" has a "Skip astigmatic phase views?" parameter that is explained as: Skip or break views only when finding astigmatism or phase shift
"CTF estimation (auto)" has a "Search astigmatism?" parameter that is explained as: Search for astigmatism when fitting.
"CTF estimation (auto)" has a "Maximum astigmatism (um)" parameter that is explained as: Maximum astigmatism, in microns. During the fitting to wedge spectra, the defocus is allowed to vary from the global value by more than half of this amount.
"CTF estimation (auto)" has a "Number of sectors" parameter that is explained as: Number of sectors for astigmatism analysis.  A power spectrum is stored separately for each sector; spectra can then be computed fairly quickly for wedges of any size that is a multiple of the sector size. The default is 36, giving 5 degree sectors.
"CTF estimation (auto)" has a "Minimum views astigmatism" parameter that is explained as: Minimum number of views for finding astigmatism.
"CTF estimation (auto)" has a "Search phase shift?" parameter that is explained as: Search for phase shift when fitting.
"CTF estimation (auto)" has a "Minimum views phase shift" parameter that is explained as: Minimum number of views for finding phase shift.
"CTF estimation (auto)" has a "Search cut-on frequency?" parameter that is explained as: Search for cut-on frequency when finding phase shift.
"CTF estimation (auto)" has a "Maximum astigmatism (1/nm)" parameter that is explained as: Maximum frequency to test when searching for cut-on frequency, in reciprocal nanometers.  The default is the frequency of the first zero at the expected defocus and phase shift. To use the default value set box to -1.

The protocol named "CTF correction" can be found in the imod plugin.
"CTF correction" protocol help is as follows:
 
    CTF correction of a set of input tilt-series using the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/ctfphaseflip.html
    .
"CTF correction" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"CTF correction" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"CTF correction" has a "Input tilt-series" parameter that is explained as: Select the set of tilt-series to be CTF corrected. Usually this will be the tilt-series with alignment information.
"CTF correction" has a "Input CTF estimation" parameter that is explained as: Select the CTF estimation for the set of tilt-series.
"CTF correction" has a "Defocus tolerance (nm)" parameter that is explained as: The value introduced must be the same used for CTF estimation with IMOD.

Defocus tolerance in nanometers defining the center strips. The center strips are taken from the central region of a view that has defocus difference less than this tolerance. These kind of center strips from all views within AngleRange are considered to have a constant defocus and are used to compute the initial CTF after being further tessellated into tiles.
"CTF correction" has a "Interpolation width (px)" parameter that is explained as: The distance in pixels between the center lines of two consecutive strips. A pixel inside the region between those two center lines resides in both strips. As the two strips are corrected separately, that pixel will have 2 corrected values. The final value for that pixel is a linear interpolation of the 2 corrected values. If a value of 1 is entered, there is no such interpolation. For a value greater than one, the entered value will be used whenever the strip width is less than 256 (i.e., at high tilt), and the value will be scaled proportional to the strip width for widths above 256.  This scaling keeps the computational time down and is reasonable because the defocus difference between adjacent wide strips at wider intervals is still less than that between the narrower strips at high tilt. However, strips at constant spacing can still be obtained by entering the negative of the desired spacing, which disables the scaling of the spacing.
"CTF correction" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation.Select the one you want to use.
"CTF correction" has a "" parameter that is explained as: GPU ID. To pick the best available one set 0. For a specific GPU set its number ID (starting from 1).
"CTF correction" has a "Correct odd/even" parameter that is explained as: If True, the full tilt series and the associated odd/even tilt series will be processed. The CTF correction applied to the odd/even tilt series will be exactly the same.

The protocol named "Dose filter" can be found in the imod plugin.
"Dose filter" protocol help is as follows:
 
    Tilt-series dose filtering based on the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/mtffilter.html
    .
"Dose filter" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Dose filter" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Dose filter" has a "Input set of tilt-series" parameter that is explained as: None
"Dose filter" has a "Initial dose (e/sq. Å)" parameter that is explained as: Dose applied before any of the images in the input file were taken; this value will be added to all the dose values.
"Dose filter" has a "Input dose source" parameter that is explained as: Where to find the dose information:
- Scipion import: use the dose provided during import of the tilt-series
- Fixed dose: manually input fixed dose for each image of the input file, in electrons/square Ångstrom.
"Dose filter" has a "Fixed dose (e/sq Å)" parameter that is explained as: Fixed dose for each image of the input file, in electrons/square Ångstrom.
"Dose filter" has a "Filter odd/even" parameter that is explained as: If True, the full tilt series and the associated odd/even tilt series will be processed. The applied dose for the odd/even tilt series will be exactly the same.

The protocol named "Etomo interactive" can be found in the imod plugin.
"Etomo interactive" protocol help is as follows:
 
    Simple wrapper around etomo to manually reconstruct a Tomogram.

    More info:
        https://bio3d.colorado.edu/imod/doc/etomoTutorial.html
    .
"Etomo interactive" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Etomo interactive" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Etomo interactive" has a "Input set of tilt-series" parameter that is explained as: Input set of tilt-series to be processed with eTomo.
"Etomo interactive" has a "Fiducial markers diameter (nm)" parameter that is explained as: Diameter of gold beads in nanometers.
"Etomo interactive" has a "Apply transformation matrix?" parameter that is explained as: Apply the transformation matrix if inputtilt series have it.
"Etomo interactive" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Etomo interactive" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Exclude views" can be found in the imod plugin.
"Exclude views" protocol help is as follows:
 
    excludeviews - Reversibly remove views from a tilt series stack

    By default, the protocol will remove disabled tilt images from the input TS.
    Alternatively, you can provide a text file with a list of tilts to exclude.

    If you use this protocol, make sure this output tilt series is use for everything else
    CTF estimation, per particle per tilt, tomogram reconstruction....
    More info:
        https://bio3d.colorado.edu/imod/doc/man/excludeviews.html
    .
"Exclude views" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Exclude views" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Exclude views" has a "Input set of tilt-series" parameter that is explained as: None
"Exclude views" has a "Exclude views file" parameter that is explained as: File containing the views to be excluded for each tilt-series belonging to the set.

The format of the text file must be two columns, the first one being the tilt series ID of the series from which the views will be excluded and the second the views to exclude, numbered from 1. The syntax for this exclude list is a comma separated list of ranges with no spaces between them (e.g., 1,4-5,60-70). 

An example of this file comes as follows:
TS_01 1,4-6,8,44-47
TS_02 3,10-12,24
...

The protocol named "Fiducial alignment" can be found in the imod plugin.
"Fiducial alignment" protocol help is as follows:
 
    Construction of a fiducial model and alignment of tilt-series based
    on the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/tiltalign.html
        https://bio3d.colorado.edu/imod/doc/man/model2point.html
        https://bio3d.colorado.edu/imod/doc/man/imodtrans.html
        https://bio3d.colorado.edu/imod/doc/man/newstack.html
        https://bio3d.colorado.edu/imod/doc/man/ccderaser.html
    .
"Fiducial alignment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Fiducial alignment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Fiducial alignment" has a "Input set of fiducial models." parameter that is explained as: None
"Fiducial alignment" has a "Find beads on two surfaces?" parameter that is explained as: Track fiducials differentiating in which side of the sample are located.
IMPORTANT: It is highly recommended to match the option selected in the generation of the fiducial models. In case they do not match, it is not intended to fail but could be missing the whole potential of the algorithm. In case the algorithm used fot he calculationof the fiducial models does not consider this option it is algo recomended to set this option to 'No'.
"Fiducial alignment" has a "Generate interpolated tilt-series?" parameter that is explained as: Generate and save the interpolated tilt-series applying the obtained transformation matrices.
"Fiducial alignment" has a "Binning" parameter that is explained as: Binning to be applied to the interpolated tilt-series in IMOD convention. Images will be binned by the given factor. Must be an integer bigger than 1
"Fiducial alignment" has a "Rotation solution type" parameter that is explained as: Type of rotation solution.
"Fiducial alignment" has a "Group size" parameter that is explained as: Size of the rotation group
"Fiducial alignment" has a "Magnification solution type" parameter that is explained as: Type of magnification solution.
"Fiducial alignment" has a "Group size" parameter that is explained as: Size of the magnification group
"Fiducial alignment" has a "Tilt angle solution type" parameter that is explained as: Type of tilt angle solution.
"Fiducial alignment" has a "Group size" parameter that is explained as: Size of the tilt angle group
"Fiducial alignment" has a "Distortion solution type" parameter that is explained as: Type of distortion solution.
"Fiducial alignment" has a "X stretch group size" parameter that is explained as: Basic grouping size for X stretch
"Fiducial alignment" has a "Skew group size" parameter that is explained as: Size of the skew group
"Fiducial alignment" has a "Erase gold beads" parameter that is explained as: Remove the gold beads detected during fiducial alignment with *ccderaser* program. This option will generate an interpolated tilt series with the gold beads erased and interpolated with the calculated transformation matrices form the alignment.
"Fiducial alignment" has a "Bead diameter (px)" parameter that is explained as: For circle objects, this entry specifies a radius to use for points without an individual point size instead of the object's default sphere radius. This entry is floating point and can be used to overcome the limitations of having an integer default sphere radius. If there are multiple circle objects, enter one value to apply to all objects or a value for each object.

The protocol named "Generate fiducial model" can be found in the imod plugin.
"Generate fiducial model" protocol help is as follows:
 
    Construction of a fiducial model and alignment of tilt-series based
    on the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/autofidseed.html
        https://bio3d.colorado.edu/imod/doc/man/beadtrack.html
        https://bio3d.colorado.edu/imod/doc/man/model2point.html
    .
"Generate fiducial model" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Generate fiducial model" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Generate fiducial model" has a "Input set of tilt-series" parameter that is explained as: None
"Generate fiducial model" has a "Fiducial diameter (nm)" parameter that is explained as: Fiducials diameter to be tracked for alignment.
"Generate fiducial model" has a "Find beads on two surfaces?" parameter that is explained as: Track fiducials differentiating in which side of the sample are located.
"Generate fiducial model" has a "Number of fiducials" parameter that is explained as: Number of fiducials to be tracked for alignment.
"Generate fiducial model" has a "Track with fiducial model as seed" parameter that is explained as: Turn the tracked model into new seed and repeat tracking.
"Generate fiducial model" has a "Shifts near zero fraction" parameter that is explained as: Fraction of the tracking box size above which to supply shifts near zero tilt to Beadtrack. The dominant net shifts in the bead positions between views are found as described above, and if one of the shifts is larger than this fraction of the -BoxSizeXandY entry to Beadtrack, then the shifts are provided when running Beadtrack on the initial seed models. Also, a command file will be written with modified parameters, named as the root name of the input command file followed by '_adjusted' and its extension. Enter 0 or a large value to disable this analysis.
"Generate fiducial model" has a "Refine center with Sobel filter?" parameter that is explained as: Use edge-detecting Sobel filter to refine the bead positions.
"Generate fiducial model" has a "Sobel sigma relative to bead size" parameter that is explained as: Sigma for gaussian kernel filtering of single beads before Sobel filtering, as fraction of bead diameter. The default sigma is 0.5 pixels regardless of bead size. A value of around 0.12 diameters is needed for higher noise (eg. cryo) data.

The protocol named "Gold bead picker 3D" can be found in the imod plugin.
"Gold bead picker 3D" protocol help is as follows:
 
    3-dimensional gold bead picker using the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/findbeads3d.html
    .
"Gold bead picker 3D" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Gold bead picker 3D" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Gold bead picker 3D" has a "Input set of tomograms" parameter that is explained as: Input set of tomograms from which gold beads will be picked. A tomogram needs to be thicker than normal because the program cannot find beads too close to the surfaces of a tomogram.
"Gold bead picker 3D" has a "Fiducials diameter (px)" parameter that is explained as: Diameter of beads in pixels.
"Gold bead picker 3D" has a "Bead contrast" parameter that is explained as: Contrast of the gold beads:
-Dark: beads are dark on light background.
-Light: beads are light on dark background.
"Gold bead picker 3D" has a "Minimum relative strength" parameter that is explained as: Minimum relative peak strength for keeping a peak in the analysis.  The square root of the specified value is used for comparing with the square root of peak strength, for compatibility with existing command files. The default is 0.05, which corresponds to a relative square root peak strength of 0.22. Too many weak peaks can prevent a dip from showing up in the smoothed histogram of strengths.  If the program fails to find a histogram dip, one strategy is to try raising this value.
"Gold bead picker 3D" has a "Minimum spacing" parameter that is explained as: Minimum spacing between peaks as a fraction of the bead size. When two peaks are closer than this distance apart, the weaker one is eliminated unless the -both option is entered. The default is 0.9. A value less than 1 is helpful for picking both beads in a pair.

The protocol named "Import transformation matrix" can be found in the imod plugin.
"Import transformation matrix" protocol help is as follows:
 
    Import the transformation matrices assigned to an input set of tilt-series
    .
"Import transformation matrix" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Import transformation matrix" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Import transformation matrix" has a "" parameter that is explained as: Select the type of import.
"Import transformation matrix" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"Import transformation matrix" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"Import transformation matrix" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"Import transformation matrix" has a "Exclusion words:" parameter that is explained as: List of words separated by a space that the path should not have
"Import transformation matrix" has a "Input set of tilt-series" parameter that is explained as: Set of tilt-series on which transformation matrices will be assigned.
"Import transformation matrix" has a "Transformation matrix binning" parameter that is explained as: Binning of the tilt series at which the transformation matrices were calculated.
"Import transformation matrix" has a "Tilt-series binning" parameter that is explained as: Binning of the tilt-series.

The protocol named "CTF estimation (manual)" can be found in the imod plugin.
"CTF estimation (manual)" protocol help is as follows:
 
    CTF estimation of a set of input tilt-series using the IMOD procedure.
    Runs the protocol through the interactive GUI. The resulting defocus values
    MUST BE SAVED manually by the user.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/ctfplotter.html

    .
"CTF estimation (manual)" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"CTF estimation (manual)" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"CTF estimation (manual)" has a "Input set of tilt-series" parameter that is explained as: This should be a *raw stack*, not an aligned stack, because the interpolation used to make an aligned stack attenuates high frequencies and the noise power spectra would no longer match.
"CTF estimation (manual)" has a "Defocus tolerance (nm)" parameter that is explained as: Defocus tolerance in nanometers defining the center strips. The center strips are taken from the central region of a view that has defocus difference less than this tolerance. These kind of center strips from all views within AngleRange are considered to have a constant defocus and are used to compute the initial CTF after being further tessellated into tiles.
"CTF estimation (manual)" has a "Input expected defocus as:" parameter that is explained as: None
"CTF estimation (manual)" has a "Expected defocus value (nm)" parameter that is explained as: This value will be applied as the expected defocus in nanometers for every tilt-series from the set.
"CTF estimation (manual)" has a "Expected defocus file" parameter that is explained as: File containing the expected defocus in nanometers for each tilt-series belonging to the set.

The format of the text file must be two columns, the first one being the tilt series ID and the second the defocus value.

An example of this file comes as follows:
TS_01 4000
TS_02 1500
...
"CTF estimation (manual)" has a "Left defocus tolerance (nm)" parameter that is explained as: Defocus tolerance in nanometers for strips to the left of the center strip.
"CTF estimation (manual)" has a "Right defocus tolerance (nm)" parameter that is explained as: Defocus tolerance in nanometers for strips to the right of the center strip.
"CTF estimation (manual)" has a "Tile size (px)" parameter that is explained as: The tile size each strip will be tessellated into. The size is in pixels and the tiles are square. Each view is first divided into strips that are considered to have constant defocus.

The protocol named "Tilt-series preprocess" can be found in the imod plugin.
"Tilt-series preprocess" protocol help is as follows:
 
    Normalize input tilt-series and change its storing formatting.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/newstack.html
    .
"Tilt-series preprocess" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Tilt-series preprocess" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Tilt-series preprocess" has a "Input set of tilt-series" parameter that is explained as: None
"Tilt-series preprocess" has a "Binning" parameter that is explained as: Binning to be applied to the normalized tilt-series in IMOD convention. Images will be binned by the given factor. Must be an integer bigger than 1
"Tilt-series preprocess" has a "Apply transformation matrix" parameter that is explained as: Apply the tilt series transformation matrix if tilt series have them
"Tilt-series preprocess" has a "Adjust densities mode" parameter that is explained as: Adjust densities of sections individually:
-Default: no adjustment performed
-Mode 1: sections fill the data range
-Mode 2: sections scaled to common mean and standard deviation.
-Mode 3: sections shifted to a common mean without scaling
-Mode 4: sections shifted to a common mean and then rescale the resulting minimum and maximum densities to the Min and Max values specified
"Tilt-series preprocess" has a "Storage data type" parameter that is explained as: Apply one density scaling to all sections to map current min and max to the given Min and Max. The storage mode of the output file. The default is the mode of the first input file, except for a 4-bit input file, where the default is to output as bytes
"Tilt-series preprocess" has a "Set scaling range values?" parameter that is explained as: This option will rescale the densities of all sections by the same factors so that the original minimum and maximum density will be mapped to the Min and Max values that are entered
"Tilt-series preprocess" has a "Max." parameter that is explained as: Maximum value for the rescaling
"Tilt-series preprocess" has a "Min." parameter that is explained as: Minimum value for the rescaling
"Tilt-series preprocess" has a "Antialias method:" parameter that is explained as: Type of antialiasing filter to use when reducing images.
The available types of filters are:

None
Blackman - fast but not as good at antialiasing as slower filters
Triangle - fast but smooths more than Blackman
Mitchell - good at antialiasing, smooths a bit
Lanczos 2 lobes - good at antialiasing, less smoothing than Mitchell
Lanczos 3 lobes - slower, even less smoothing but more risk of ringing
The default is Lanczos 3 as of IMOD 4.7. Although many people consider Lanczos 2 the best compromise among the various factors, that sentiment may be based on images of natural scenes where there are sharp edges.
"Tilt-series preprocess" has a "Set mean and SD?" parameter that is explained as: Set mean and SD values
"Tilt-series preprocess" has a "Mean" parameter that is explained as: Mean value for the rescaling
"Tilt-series preprocess" has a "SD" parameter that is explained as: Standard deviation value for the rescaling
"Tilt-series preprocess" has a "Max." parameter that is explained as: Maximum value for the rescaling
"Tilt-series preprocess" has a "Min." parameter that is explained as: Minimum value for the rescaling
"Tilt-series preprocess" has a "Apply to odd/even" parameter that is explained as: If True, the full tilt series and the associated odd/even tilt series will be processed. The transformations applied to the odd/even tilt series will be exactly the same.

The protocol named "Tomo preprocess" can be found in the imod plugin.
"Tomo preprocess" protocol help is as follows:
 
    Normalize input tomogram and change its storing formatting.
    More info:
        https://bio3D.colorado.edu/imod/doc/newstack.html
        https://bio3D.colorado.edu/imod/doc/binvol.html
    .
"Tomo preprocess" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Tomo preprocess" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Tomo preprocess" has a "Input set of tomograms" parameter that is explained as: None
"Tomo preprocess" has a "Binning" parameter that is explained as: Binning to be applied to the normalized tomograms in IMOD convention. Volumes will be binned by the given factor. Must be an integer bigger than 1
"Tomo preprocess" has a "Adjust densities mode" parameter that is explained as: Adjust densities of sections individually:
-Default: no adjustment performed
-Mode 1: sections fill the data range
-Mode 2: sections scaled to common mean and standard deviation.
-Mode 3: sections shifted to a common mean without scaling
-Mode 4: sections shifted to a common mean and then rescale the resulting minimum and maximum densities to the Min and Max values specified
"Tomo preprocess" has a "Storage data type" parameter that is explained as: Apply one density scaling to all sections to map current min and max to the given Min and Max. The storage mode of the output file. The default is the mode of the first input file, except for a 4-bit input file, where the default is to output as bytes
"Tomo preprocess" has a "Set scaling range values?" parameter that is explained as: This option will rescale the densities of all sections by the same factors so that the original minimum and maximum density will be mapped to the Min and Max values that are entered
"Tomo preprocess" has a "Max." parameter that is explained as: Maximum value for the rescaling
"Tomo preprocess" has a "Min." parameter that is explained as: Minimum value for the rescaling
"Tomo preprocess" has a "Antialias method:" parameter that is explained as: Type of antialiasing filter to use when reducing images.
The available types of filters are:

None
Blackman - fast but not as good at antialiasing as slower filters
Triangle - fast but smooths more than Blackman
Mitchell - good at antialiasing, smooths a bit
Lanczos 2 lobes - good at antialiasing, less smoothing than Mitchell
Lanczos 3 lobes - slower, even less smoothing but more risk of ringing
The default is Lanczos 3 as of IMOD 4.7. Although many people consider Lanczos 2 the best compromise among the various factors, that sentiment may be based on images of natural scenes where there are sharp edges.
"Tomo preprocess" has a "Set mean and SD?" parameter that is explained as: Set mean and SD values
"Tomo preprocess" has a "Mean" parameter that is explained as: Mean value for the rescaling
"Tomo preprocess" has a "SD" parameter that is explained as: Standard deviation value for the rescaling
"Tomo preprocess" has a "Max." parameter that is explained as: Maximum value for the rescaling
"Tomo preprocess" has a "Min." parameter that is explained as: Minimum value for the rescaling
"Tomo preprocess" has a "Process odd/even?" parameter that is explained as: If True, the full tilt series and the associated odd/even tilt series will be processed. The transformations applied to the odd/even tilt series will be exactly the same.

The protocol named "Tomo projection" can be found in the imod plugin.
"Tomo projection" protocol help is as follows:
 
    Re-project a tomogram given a geometric description (axis and angles).
    More info:
        https://bio3d.colorado.edu/imod/doc/man/xyzproj.html
    .
"Tomo projection" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Tomo projection" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Tomo projection" has a "Input set of tomograms" parameter that is explained as: None
"Tomo projection" has a "Minimum angle of rotation" parameter that is explained as: Minimum angle of the projection range
"Tomo projection" has a "Maximum angle of rotation" parameter that is explained as: Maximum angle of the projection range
"Tomo projection" has a "Step angle" parameter that is explained as: Step angle of the projection range
"Tomo projection" has a "Rotation axis for projection" parameter that is explained as: Axis to tilt around (X, Y, or Z). Y axis usually corresponds to the typical rotation axis acquisition.

The protocol named "Tomo reconstruction" can be found in the imod plugin.
"Tomo reconstruction" protocol help is as follows:
 
    Tomogram reconstruction procedure based on the IMOD procedure.

    More info:
        https://bio3d.colorado.edu/imod/doc/man/tilt.html
    .
"Tomo reconstruction" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Tomo reconstruction" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Tomo reconstruction" has a "Input set of tilt-series" parameter that is explained as: None
"Tomo reconstruction" has a "Tomogram thickness (voxels)" parameter that is explained as: Size in voxels of the tomogram in the z axis (beam direction).
"Tomo reconstruction" has a "Tomogram shift in X" parameter that is explained as: This entry allows one to shift the reconstructed slice in X before it is output.  If the X shift is positive, the slice will be shifted to the right, and the output will contain the left part of the whole potentially reconstructable area.
"Tomo reconstruction" has a "Tomogram width (voxels)" parameter that is explained as: Number of pixels to cut out in X, centered on the middle in X. Leave 0 for default X.
"Tomo reconstruction" has a "Tomogram shift in Z" parameter that is explained as: This entry allows one to shift the reconstructed slice in Z before it is output. If the Z shift is positive, the slice is shifted upward. The Z entry is optional and defaults to 0 when omitted.
"Tomo reconstruction" has a "Angle offset" parameter that is explained as: Apply an angle offset in degrees to all tilt angles. This offset positively rotates the reconstructed sections anticlockwise.
"Tomo reconstruction" has a "Tilt axis offset" parameter that is explained as: Apply an offset to the tilt axis in a stack of full-sized projection images, cutting the X-axis at  NX/2. + offset instead of NX/2. The DELXX entry is optional and defaults to 0 when omitted.
"Tomo reconstruction" has a "Super-sampling factor" parameter that is explained as: Compute slices in pixels smaller by this factor to reduce artifacts.
"Tomo reconstruction" has a "Iterations of a SIRT-like equivalent filter" parameter that is explained as: Modify the radial filter to produce a reconstruction equivalent to the one produced by the given number of iterations of SIRT. The Gaussian filter is applied at the high-frequency end of the filter. The functioning of this filter is described in: 
	https://bio3d.colorado.edu/imod/doc/man/tilt.html
"Tomo reconstruction" has a "First parameter" parameter that is explained as: Linear region value
"Tomo reconstruction" has a "Second parameter" parameter that is explained as: Gaussian fall-off parameter
"Tomo reconstruction" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation. Select the one you want to use.
"Tomo reconstruction" has a "" parameter that is explained as: GPU ID. To pick the best available one set 0. For a specific GPU set its number ID (starting from 1).
"Tomo reconstruction" has a "Reconstruct odd/even?" parameter that is explained as: If True, the full tilt series and the associated odd/even tilt series will be reconstructed. The alignment applied to the odd/even tilt series will be exactly the same.

The protocol named "Coarse prealignment" can be found in the imod plugin.
"Coarse prealignment" protocol help is as follows:
 
    Tilt-series cross correlation alignment based on the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/tiltxcorr.html
    .
"Coarse prealignment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Coarse prealignment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Coarse prealignment" has a "Input set of tilt-series" parameter that is explained as: None
"Coarse prealignment" has a "Use cumulative correlation?" parameter that is explained as: With this option, the program will take the image at zero tilt as the firstreference, and correlate it with the image at the next most negative tilt.It will then add the aligned image to the first reference to make the reference for the next tilt.  At each tilt, the reference will be the sum of images that have already been aligned. When the most negative tilt angle is reached, the procedure is repeated from the zero-tilt view to more positive tilt angles.
"Coarse prealignment" has a "Generate interpolated tilt-series?" parameter that is explained as: Generate and save the interpolated tilt-series applying the obtained transformation matrices.
"Coarse prealignment" has a "Binning for the interpolated" parameter that is explained as: Binning to be applied to the interpolated tilt-series in IMOD convention. Images will be binned by the given factor. Must be an integer bigger than 1
"Coarse prealignment" has a "Tilt axis angle detected from import. In case another value is desired please adjust the number below" parameter that is explained as: None
"Coarse prealignment" has a "Tilt axis angle (degrees)" parameter that is explained as: The tilt axis angle is the tilt axis rotation relative to the Y axis of the image.If it was not properly set in the import of the tilt series, or the importedinformation is not correct you have the chance to correct at in this point.Usually, it will be 90 degrees less than the RotationAngle in a system with no axis inversions
"Coarse prealignment" has a "left" parameter that is explained as: None
"Coarse prealignment" has a "right" parameter that is explained as: None
"Coarse prealignment" has a "top" parameter that is explained as: None
"Coarse prealignment" has a "botton" parameter that is explained as: None
"Coarse prealignment" has a "Filter radius 1" parameter that is explained as: None
"Coarse prealignment" has a "Filter sigma 1" parameter that is explained as: None
"Coarse prealignment" has a "Filter radius 2" parameter that is explained as: None
"Coarse prealignment" has a "Filter sigma 2" parameter that is explained as: None

The protocol named "X-rays eraser" can be found in the imod plugin.
"X-rays eraser" protocol help is as follows:
 
    Erase X-rays from aligned tilt-series based on the IMOD procedure.
    More info:
            https://bio3d.colorado.edu/imod/doc/man/ccderaser.html
    .
"X-rays eraser" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"X-rays eraser" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"X-rays eraser" has a "Input set of tilt-series" parameter that is explained as: None
"X-rays eraser" has a "Peak criterion" parameter that is explained as: Criterion # of SDs above local mean for erasing peak based on intensity (the default is 8 SDs)
"X-rays eraser" has a "Difference criterion" parameter that is explained as: Criterion # of SDs above mean pixel-to-pixel difference for erasing a peak based on differences (the default is 6 SDs).
"X-rays eraser" has a "Maximum radius (px)" parameter that is explained as: Maximum radius of peak area to erase (the default is 4.2 pixels).
"X-rays eraser" has a "Big difference criterion" parameter that is explained as: An extra-large peak will be erased only if the value for the maximum difference between adjacent pixels, averaged over the most extreme one-fourth of the pixels in the patch, exceeds this criterion, evaluated as the number of SDs above the mean absolute difference between adjacent pixels in the scan area. The default is 19.  This high a value is needed to prevent gold erasure on low-noise data sets with small gold particles, and a lower value may be needed to make extra-large peak removal useful.
"X-rays eraser" has a "Apply to odd/even" parameter that is explained as: If True, the full tilt series and the associated odd/even tilt series will be processed. The filter applied to the odd/even tilt series will be exactly the same.

The protocol named "import 3D coordinates" can be found in the reliontomo plugin.
"import 3D coordinates" protocol help is as follows:
 Protocol to import a 3D coordinates from a relion star file as the one provided in the tutorial.
"import 3D coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import 3D coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import 3D coordinates" has a "Star file" parameter that is explained as: None
"import 3D coordinates" has a "Tomograms" parameter that is explained as: Tomograms to which the coordinates will be referred.
"import 3D coordinates" has a "Coordinates sampling rate [Å/pix] (opt.)" parameter that is explained as: If empty, the protocol will try to read it from the label "_rrlnDetectorPixelSize" if it is present in the introduced star file. If not find, it will be considered to be the same as the tomograms. The ratio of both tomograms and coordinates sampling rate will be used to scale the coordinates properly to the tomograms introduced if they are different
"import 3D coordinates" has a "Box Size [pix]" parameter that is explained as: None

The protocol named "import subtomograms from a star file" can be found in the reliontomo plugin.
"import subtomograms from a star file" protocol help is as follows:
 Protocol to import a set of subtomograms from a star file.
"import subtomograms from a star file" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import subtomograms from a star file" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import subtomograms from a star file" has a "Star file" parameter that is explained as: None
"import subtomograms from a star file" has a "Tomograms" parameter that is explained as: Tomograms to which the coordinates will be referred.
"import subtomograms from a star file" has a "Coordinates sampling rate [Å/pix] (opt.)" parameter that is explained as: If empty, the protocol will try to read it from the label "_rrlnDetectorPixelSize" if it is present in the introduced star file. If not find, it will be considered to be the same as the tomograms. The ratio of both tomograms and coordinates sampling rate will be used to scale the coordinates properly to the tomograms introduced if they are different
"import subtomograms from a star file" has a "Box Size [pix]" parameter that is explained as: None

The protocol named "3D Classification of subtomograms" can be found in the reliontomo plugin.
"3D Classification of subtomograms" protocol help is as follows:
 3D Classification of subtomograms..
"3D Classification of subtomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"3D Classification of subtomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"3D Classification of subtomograms" has a "Relion particles" parameter that is explained as: None
"3D Classification of subtomograms" has a "Reference volume" parameter that is explained as: Initial reference 3D map, it should have the same dimensions and the same pixel size as your input particles.
"3D Classification of subtomograms" has a "Reference mask (optional)" parameter that is explained as: A volume mask containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask. If no mask is given, a soft spherical mask based on the <radius> of the mask for the experimental images will be applied.

In some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. Check _Advaced_ parameters to select another volume mask.
"3D Classification of subtomograms" has a "Second reference mask (optional)" parameter that is explained as: For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas.
"3D Classification of subtomograms" has a "Is initial 3D map on absolute greyscale?" parameter that is explained as: Perform CC-calculation in the first iteration (use this if references are not on the absolute intensity scale). See detailed explanation below:

 Probabilities are calculated based on a Gaussian noise model,which contains a squared difference term between the reference and the experimental image.

 This has a consequence that the reference needs to be on the same absolute intensity greyscale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity greyscale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. But, if the map wasreconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No.

If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent map refinement. Therefore, if in doubt it is recommended to set this option to No.
"3D Classification of subtomograms" has a "Initial low-pass filter (A)" parameter that is explained as: It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s).
"3D Classification of subtomograms" has a "Symmetry group" parameter that is explained as: Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
"3D Classification of subtomograms" has a "Do CTF-correction?" parameter that is explained as: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
"3D Classification of subtomograms" has a "Ignore CTFs until first peak?" parameter that is explained as: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
"3D Classification of subtomograms" has a "Number of classes to be defined" parameter that is explained as: None
"3D Classification of subtomograms" has a "Regularisation parameter T" parameter that is explained as: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. If it's set to 0, no regularisation will be applied. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D initial model calculations.
"3D Classification of subtomograms" has a "Number of iterations" parameter that is explained as: Number of iterations to be performed. Note that the current implementation of 2D class averaging and 3D classification does NOT comprise a convergence criterium. Therefore, the calculations will need to be stopped by the user if further iterations do not yield improvements in resolution or classes.
"3D Classification of subtomograms" has a "Use fast subsets (for large data sets)?" parameter that is explained as: If set to Yes, the first 5 iterations will be done with random subsets of only K*1500 particles (K being the number of classes); the next 5 with K*4500 particles, the next 5 with 30% of the data set; and the final ones with all data. This was inspired by a cisTEM implementation by Niko Grigorieff et al.
"3D Classification of subtomograms" has a "Circular mask diameter (Å)" parameter that is explained as: Diameter of the circular mask that will be applied to the experimental images (in Angstroms)
"3D Classification of subtomograms" has a "Mask individual particles with zeros?" parameter that is explained as: If set to Yes, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform.

This will remove noise and therefore increase sensitivity in the alignment and classification.

However, it will also introduce correlations between the Fourier components that are not modelled. When set to No, then the solvent area is filled with random noise, which prevents introducing correlations.

High-resolution refinements (e.g. ribosomes or other large complexes in 3D auto-refine) tend to work better when filling the solvent area with random noise (i.e. setting this option to No), refinements of smaller complexes and most classifications go better when using zeros (i.e. setting this option to Yes).
"3D Classification of subtomograms" has a "Limit resolution E-step to (Å)" parameter that is explained as: If set to a positive number, then the expectation step (i.e. the alignment) will be done only including the Fourier components up to this resolution (in Angstroms).

This is useful to prevent overfitting, as the classification runs in RELION are not guaranteed to be 100% overfitting-free (unlike the 3D auto-refine with its gold-standard FSC). In particular for very difficult data sets, e.g. of very small or featureless particles, this has been shown to give much better class averages. 

In such cases, values in the range of 7-12 Angstroms have proven useful.
"3D Classification of subtomograms" has a "Perform image alignment?" parameter that is explained as: If set to No, then rather than performing both alignment and classification, only classification will be performed. This allows the use of very focused masks. It requires that the optimal orientations of all particles are already stored in the input STAR file.
"3D Classification of subtomograms" has a "Initial angular sampling interval (deg)" parameter that is explained as: There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
"3D Classification of subtomograms" has a "Initial offset range (pix.)" parameter that is explained as: Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
"3D Classification of subtomograms" has a "Initial offset step (pix.)" parameter that is explained as: Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluatedon a 2x coarser grid.
"3D Classification of subtomograms" has a "Perform local angular searches?" parameter that is explained as: If set to Yes, then rather than performing exhaustive angular searches, local searches within the range given below will be performed.

A prior Gaussian distribution centered at the optimal orientation in the previous iteration and with a stddev of 1/3 of the range given below will be enforced.
"3D Classification of subtomograms" has a "Local angular search range (deg.)" parameter that is explained as: Local angular searches will be performed within +/- the given amount (in degrees) from the optimal orientation in the previous iteration.

A Gaussian prior (also see previous option) will be applied, so that orientations closer to the optimal orientation in the previous iteration will get higher weights than those further away.
"3D Classification of subtomograms" has a "Symmetry to be relaxed" parameter that is explained as: With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020 cited in the About dialog.

Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
"3D Classification of subtomograms" has a "Allow coarser sampling?" parameter that is explained as: If set to Yes, the program will use coarser angular and translational samplings if the estimated accuracies of the assignments are still low in the earlier iterations. This may speed up the calculations.
"3D Classification of subtomograms" has a "Use parallel disc I/O?" parameter that is explained as: If set to Yes, all MPI followers will read their own images from disc. Otherwise, only the leader will read images and send them through the network to the followers. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many followers reading in parallel. If your datasets contain particles with different box sizes, you have to say Yes.
"3D Classification of subtomograms" has a "Number of pooled particles" parameter that is explained as: Particles are processed in individual batches by MPI followers. During each batch, a stack of particle images is only opened and closed once to improve disk access times.

All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. This parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together.

This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
"3D Classification of subtomograms" has a "Skip griding?" parameter that is explained as: Skip gridding in the Maximization step in the Expectation-Maximization algorithm. If this option is set to Yes, more memory will be consumed during the protocol execution, but it will be faster.
"3D Classification of subtomograms" has a "Pre-read all particles into RAM?" parameter that is explained as: If set to Yes, the leader process read all particles into memory. Be careful you have enough RAM for large data sets!
"3D Classification of subtomograms" has a "Combine iterations through disc?" parameter that is explained as: If set to Yes, the large arrays of summed weights will be sent through the MPI network instead of writing large files to disc.
"3D Classification of subtomograms" has a "Copy particles to scratch directory" parameter that is explained as: If provided, particle stacks will be copied to this local scratch disk prior for refinement.
"3D Classification of subtomograms" has a "Skip padding?" parameter that is explained as: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
"3D Classification of subtomograms" has a "Use GPU acceleration?" parameter that is explained as: If set to Yes, it will use available gpu resources for some calculations.
"3D Classification of subtomograms" has a "GPUs to use:" parameter that is explained as: It can be used to provide a list of which GPUs (e. g. "0:1:2:3") to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
"3D Classification of subtomograms" has a "Keep only files from last iteration?" parameter that is explained as: If Yes is chosen, only the files which correspond to the last iteration will be saved in the protocol's extra directory. Otherwise, files corresponding to each iteration will be kept.
"3D Classification of subtomograms" has a "Over-sampling" parameter that is explained as: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
"3D Classification of subtomograms" has a "Consider alignment as priors?" parameter that is explained as: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
"3D Classification of subtomograms" has a "Additional arguments" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--verb 1
--pad 2

"3D Classification of subtomograms" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"3D Classification of subtomograms" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"3D Classification of subtomograms" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Tomo CTF refine" can be found in the reliontomo plugin.
"Tomo CTF refine" protocol help is as follows:
 Tomo CTF refine.
"Tomo CTF refine" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Tomo CTF refine" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Tomo CTF refine" has a "Relion particles" parameter that is explained as: None
"Tomo CTF refine" has a "Volume to get the halves" parameter that is explained as: None
"Tomo CTF refine" has a "Input reference mask" parameter that is explained as: None
"Tomo CTF refine" has a "Box size for estimation (pix)" parameter that is explained as: Box size to be used for the estimation. Note that this can be larger than the box size of the reference map. A sufficiently large box size allows more of the high-frequency signal to be captured that has been delocalized by the CTF.
"Tomo CTF refine" has a "Refine defocus?" parameter that is explained as: If set to Yes, then estimate the defoci of the individual tilt images.
"Tomo CTF refine" has a "Defocus search range (Å)" parameter that is explained as: None
"Tomo CTF refine" has a "Do defocus regularisation?" parameter that is explained as: Apply defocus regularisation.

High-tilt images do not offer enough signal to recover the defocus value precisely. The regularisation forces the estimated defoci to assume similar values within a given tilt series, which prevents those high-tilt images from overfitting.
"Tomo CTF refine" has a "Defocus regularisation scale" parameter that is explained as: None
"Tomo CTF refine" has a "Refine contrast scale?" parameter that is explained as: If set to Yes, then estimate the signal scale or ice thickness.
"Tomo CTF refine" has a "Refine scale per frame?" parameter that is explained as: If set to Yes, then estimate the signal-scale parameter independently for each tilt. If not specified, the ice thickness, beam luminance and surface normal are estimated instead. Those three parameters then imply the signal intensity for each frame. Due to the smaller number of parameters, the ice thickness model is more robust to noise. By default, the ice thickness and surface normal will be estimated per tilt-series, and the beam luminance globally.
"Tomo CTF refine" has a "Refine scale per tomogram?" parameter that is explained as: If set to Yes, then the beam luminance will be estimated separately for each tilt series. This is not recommended.
"Tomo CTF refine" has a "Refine even aberrations?" parameter that is explained as: If set to Yes, then even higher-order aberrations will be estimated.
"Tomo CTF refine" has a "Max order of even aberrations" parameter that is explained as: None
"Tomo CTF refine" has a "Refine odd aberrations?" parameter that is explained as: If set to Yes, then odd higher-order aberrations will be estimated.
"Tomo CTF refine" has a "Max order of odd aberrations" parameter that is explained as: None
"Tomo CTF refine" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Tomo CTF refine" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"Tomo CTF refine" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "De novo 3D initial model" can be found in the reliontomo plugin.
"De novo 3D initial model" protocol help is as follows:
 Generate a de novo 3D initial model from the pseudo-subtomograms..
"De novo 3D initial model" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"De novo 3D initial model" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"De novo 3D initial model" has a "Relion particles" parameter that is explained as: None
"De novo 3D initial model" has a "Do CTF-correction?" parameter that is explained as: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
"De novo 3D initial model" has a "Ignore CTFs until first peak?" parameter that is explained as: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
"De novo 3D initial model" has a "Number of VDAM mini-batches" parameter that is explained as: How many iterations (i.e. mini-batches) to perform with the VDAM ((variable metric gradient descent with adaptive moments) algorithm. Using 200 (default) has given good results for many data sets. Using 100 will run faster, at the expense of some quality in the results.
"De novo 3D initial model" has a "Regularisation parameter T" parameter that is explained as: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. If it's set to 0, no regularisation will be applied. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D initial model calculations.
"De novo 3D initial model" has a "Number of classes to be defined" parameter that is explained as: None
"De novo 3D initial model" has a "Circular mask diameter (Å)" parameter that is explained as: Diameter of the circular mask that will be applied to the experimental images (in Angstroms)
"De novo 3D initial model" has a "Flatten and enforce non-negative solvent?" parameter that is explained as: If set to Yes, the job will apply a spherical mask and enforce all values in the reference to be non-negative.
"De novo 3D initial model" has a "Symmetry group" parameter that is explained as: Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
"De novo 3D initial model" has a "Run in C1 and apply symmetry later?" parameter that is explained as: If set to Yes, the gradient-driven optimisation is run in C1 and the symmetry orientation is searched and applied later. If set to No, the entire optimisation is run in the symmetry point group indicated above.
"De novo 3D initial model" has a "Initial angular sampling interval (deg)" parameter that is explained as: There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
"De novo 3D initial model" has a "Initial offset range (pix.)" parameter that is explained as: Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
"De novo 3D initial model" has a "Initial offset step (pix.)" parameter that is explained as: Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluatedon a 2x coarser grid.
"De novo 3D initial model" has a "Use parallel disc I/O?" parameter that is explained as: If set to Yes, all MPI followers will read their own images from disc. Otherwise, only the leader will read images and send them through the network to the followers. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many followers reading in parallel. If your datasets contain particles with different box sizes, you have to say Yes.
"De novo 3D initial model" has a "Number of pooled particles" parameter that is explained as: Particles are processed in individual batches by MPI followers. During each batch, a stack of particle images is only opened and closed once to improve disk access times.

All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. This parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together.

This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
"De novo 3D initial model" has a "Skip griding?" parameter that is explained as: Skip gridding in the Maximization step in the Expectation-Maximization algorithm. If this option is set to Yes, more memory will be consumed during the protocol execution, but it will be faster.
"De novo 3D initial model" has a "Pre-read all particles into RAM?" parameter that is explained as: If set to Yes, the leader process read all particles into memory. Be careful you have enough RAM for large data sets!
"De novo 3D initial model" has a "Combine iterations through disc?" parameter that is explained as: If set to Yes, the large arrays of summed weights will be sent through the MPI network instead of writing large files to disc.
"De novo 3D initial model" has a "Copy particles to scratch directory" parameter that is explained as: If provided, particle stacks will be copied to this local scratch disk prior for refinement.
"De novo 3D initial model" has a "Use GPU acceleration?" parameter that is explained as: If set to Yes, it will use available gpu resources for some calculations.
"De novo 3D initial model" has a "GPUs to use:" parameter that is explained as: It can be used to provide a list of which GPUs (e. g. "0:1:2:3") to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
"De novo 3D initial model" has a "Keep only files from last iteration?" parameter that is explained as: If Yes is chosen, only the files which correspond to the last iteration will be saved in the protocol's extra directory. Otherwise, files corresponding to each iteration will be kept.
"De novo 3D initial model" has a "Over-sampling" parameter that is explained as: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
"De novo 3D initial model" has a "Consider alignment as priors?" parameter that is explained as: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
"De novo 3D initial model" has a "Additional arguments" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--verb 1
--pad 2

"De novo 3D initial model" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"De novo 3D initial model" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"De novo 3D initial model" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Apply operation to Relion particles" can be found in the reliontomo plugin.
"Apply operation to Relion particles" protocol help is as follows:
 Operate on the particles star file.
"Apply operation to Relion particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Apply operation to Relion particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Apply operation to Relion particles" has a "Relion particles" parameter that is explained as: None
"Apply operation to Relion particles" has a "Perform centering of particles" parameter that is explained as: Perform centering of particles according to a position in the reference.
"Apply operation to Relion particles" has a "Average of subtomogram (optional)" parameter that is explained as: None
"Apply operation to Relion particles" has a "Reference mask (optional)" parameter that is explained as: None
"Apply operation to Relion particles" has a "X (pix.)" parameter that is explained as: X-coordinate in the reference to center particles on (in pix)
"Apply operation to Relion particles" has a "Y (pix.)" parameter that is explained as: Y-coordinate in the reference to center particles on (in pix)
"Apply operation to Relion particles" has a "Z (pix.)" parameter that is explained as: Z-coordinate in the reference to center particles on (in pix)
"Apply operation to Relion particles" has a "Choose operation" parameter that is explained as: None
"Apply operation to Relion particles" has a "Value to operate the selected labels" parameter that is explained as: None
"Apply operation to Relion particles" has a "Operate with" parameter that is explained as: None
"Apply operation to Relion particles" has a "X (pix.)" parameter that is explained as: None
"Apply operation to Relion particles" has a "Y (pix.)" parameter that is explained as: None
"Apply operation to Relion particles" has a "Z (pix.)" parameter that is explained as: None
"Apply operation to Relion particles" has a "Shift X (pix.)" parameter that is explained as: None
"Apply operation to Relion particles" has a "Shift Y (pix.)" parameter that is explained as: None
"Apply operation to Relion particles" has a "Shift Z (pix.)" parameter that is explained as: None
"Apply operation to Relion particles" has a "Rot (deg.)" parameter that is explained as: None
"Apply operation to Relion particles" has a "Tilt (deg.)" parameter that is explained as: None
"Apply operation to Relion particles" has a "Psi (deg.)" parameter that is explained as: None

The protocol named "Make pseudo-subtomograms" can be found in the reliontomo plugin.
"Make pseudo-subtomograms" protocol help is as follows:
 Make pseudo-subtomograms.
"Make pseudo-subtomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Make pseudo-subtomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Make pseudo-subtomograms" has a "Relion particles" parameter that is explained as: None
"Make pseudo-subtomograms" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Make pseudo-subtomograms" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"Make pseudo-subtomograms" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"Make pseudo-subtomograms" has a "Box size (pix.)" parameter that is explained as: Box size, in pixels,  of the reconstruction. Note that this is independent of the box size used to refine the particle. This allows the user to construct a 3D map of arbitrary size to gain an overview of the structure surrounding the particle. A sufficiently large box size also allows more of the high-frequency signal to be captured that has been delocalized by the CTF.
"Make pseudo-subtomograms" has a "Cropped box size (pix.)" parameter that is explained as: Cropped box size in pixels. If set, the program will output an additional set of maps that have been cropped to this size. This is useful if a map is desired that is smaller than the box size required to retrieve the CTF-delocalized signal.
"Make pseudo-subtomograms" has a "Binning factor" parameter that is explained as: Downsampling (binning) factor. Note that this does not alter the box size. The reconstructed region instead becomes larger.
"Make pseudo-subtomograms" has a "Apply cone weight?" parameter that is explained as: Down weight a cone in Fourier space along the Z axis (as defined by the coordinate system of the particle). This is useful for particles embedded in a membrane, as it can prevent the alignment from being driven by the membrane signal (the signal of a planar membrane is localised within one line in 3D Fourier space). Note that the coordinate system of a particle is given by both the subtomogram orientation (if defined) and the particle orientation. This allows the user to first obtain a membrane-driven alignment, and to then specifically suppress the signal in that direction.
"Make pseudo-subtomograms" has a "Cone angle (deg.)" parameter that is explained as: It is the (full) opening angle of the cone to be suppressed, given in degrees. This angle should  include both the uncertainty about the membrane orientation and its variation across the region represented in the subtomogram.
"Make pseudo-subtomograms" has a "Write output in float16?" parameter that is explained as: If set to Yes, this program will write output images in float16 MRC format. This will save a factor of two in disk space compared to the default of writing in float32. Note that RELION and CCPEM will read float16 images, but other programs may not (yet) do so.

The protocol named "postprocessing" can be found in the reliontomo plugin.
"postprocessing" protocol help is as follows:
 Sharpen a 3D reference map and estimate the gold-standard FSC curves for subtomogram averaging.
"postprocessing" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"postprocessing" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"postprocessing" has a "Relion particles" parameter that is explained as: None
"postprocessing" has a "Use halves from this refined volume" parameter that is explained as: It will provide the two unfiltered half-reconstructions that were output upon convergence of a 3D auto-refine run.
"postprocessing" has a "Solvent mask" parameter that is explained as: Provide a soft mask where the protein is white (1) and the solvent is black (0). Often, the softer the mask the higher resolution estimates you will get. A soft edge of 5-10 pixels is often a good edge width.
"postprocessing" has a "Calibrated pixel size (Å/pix)" parameter that is explained as: Provide the final, calibrated pixel size in Angstroms. This value may be different from the pixel-size used thus far, e.g. when you have recalibrated the pixel size using the fit to a PDB model. The X-axis of the output FSC plot will use this calibrated value.
"postprocessing" has a "Estimate B-factor automatically?" parameter that is explained as: If set to Yes, then the program will use the automated procedure described by Rosenthal and Henderson (2003, JMB) to estimate an overall B-factor for your map, and sharpen it accordingly. Note that your map must extend well beyond the lowest resolution included in the procedure below, which should not be set to resolutions much lower than 10 Angstroms. 
"postprocessing" has a "Lowest resolution for auto-B fit" parameter that is explained as: This is the lowest frequency (in Angstroms) that will be included in the linear fit of the Guinier plot as described in Rosenthal and Henderson (2003, JMB). Dont use values much lower or higher than 10 Angstroms. If your map does not extend beyond 10 Angstroms, then instead of the automated procedure use your own B-factor.
"postprocessing" has a "Use your own B-factor?" parameter that is explained as: Instead of using the automated B-factor estimation, provide your own value. Use negative values for sharpening the map. This option is useful if your map does not extend beyond the 10A needed for the automated procedure, or when the automated procedure does not give a suitable value (e.g. in more disordered parts of the map).
"postprocessing" has a "User-provided B-factor" parameter that is explained as: Use negative values for sharpening. Be careful: if you over-sharpen your map, you may end up interpreting noise for signal!
"postprocessing" has a "Skip FSC-weighting?" parameter that is explained as: If set to No, then the output map will be low-pass filtered according to the mask-corrected, gold-standard FSC-curve. Sometimes, it is also useful to provide an ad-hoc low-pass filter, as due to local resolution variations some parts of the map may be better and other parts may be worse than the overall resolution as measured by the FSC. In such cases, set this option to Yes and provide an ad-hoc filter as described below.
"postprocessing" has a "Ad-hoc low-pass filter (Å)" parameter that is explained as: This option allows one to low-pass filter the map at a user-provided frequency (in Angstroms). When using a resolution that is higher than the gold-standard FSC-reported resolution, take care not to interpret noise in the map for signal.
"postprocessing" has a "MTF of the detector" parameter that is explained as: User-provided STAR-file with the MTF-curve of the detector. Use the wizard to load one of the predefined ones provided at:
- [[https://www3.mrc-lmb.cam.ac.uk/relion/index.php/FAQs#Where_can_I_find_MTF_curves_for_typical_detectors.3F][Relion's Wiki FAQs]]
 - [[https://www.gatan.com/techniques/cryo-em#MTF][Gatan's website]]

Relion param: *--mtf*
"postprocessing" has a "Original detector pixel size ((Å)/pix)" parameter that is explained as: This is the original pixel size (in Angstroms) in the raw (non-super-resolution!) micrographs.

The protocol named "Prepare data for Relion 4" can be found in the reliontomo plugin.
"Prepare data for Relion 4" protocol help is as follows:
 Prepare data for Relion 4
    .
"Prepare data for Relion 4" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Prepare data for Relion 4" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Prepare data for Relion 4" has a "Input CTF tomo series" parameter that is explained as: None
"Prepare data for Relion 4" has a "Does focus decrease with Z distance?" parameter that is explained as: It is the handedness of the tilt geometry and it is used to describe whether the focus increases or decreases as a function of Z distance.
"Prepare data for Relion 4" has a "Input coordinates" parameter that is explained as: None
"Prepare data for Relion 4" has a "Input tilt series" parameter that is explained as: Tilt series with alignment (non interpolated) used in the tomograms reconstruction.
"Prepare data for Relion 4" has a "Flip Z coordinate?" parameter that is explained as: This option is generally False if your coordinates are displayed correctly in Scipion. You may want to check this to True only if you see that the extracted subtomograms are wrong.
"Prepare data for Relion 4" has a "Has tomogram been flipped along Y and Z?" parameter that is explained as: This option is generally True if the slices of your tomogram are displayed on slice Z in Imod. Usually, a tomogram is flipped along Y and Z (i.e. rotated around X with 90 degrees) after the reconstruction and before the particles have been picked. This will tell Relion to apply the same transformation to the coordinate system.
"Prepare data for Relion 4" has a "Has the Z axis been flipped?" parameter that is explained as: This option is generally True when you apply reconstrucion in Imod. This is usually used together with the flipYZ option.
"Prepare data for Relion 4" has a "Swap X with Y dimensions of the tilt series" parameter that is explained as: This may be a trial and error parameter. Depending of the reconstruction path of your tomograms we you may need to deactivate this option to get good results. This option will be deprecated in the future

The protocol named "Average from tilt series" can be found in the reliontomo plugin.
"Average from tilt series" protocol help is as follows:
 Reconstructs/averages from the tilt series projected particles.
"Average from tilt series" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Average from tilt series" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Average from tilt series" has a "Relion particles" parameter that is explained as: None
"Average from tilt series" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Average from tilt series" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"Average from tilt series" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"Average from tilt series" has a "Box size (pix.)" parameter that is explained as: Box size, in pixels,  of the reconstruction. Note that this is independent of the box size used to refine the particle. This allows the user to construct a 3D map of arbitrary size to gain an overview of the structure surrounding the particle. A sufficiently large box size also allows more of the high-frequency signal to be captured that has been delocalized by the CTF.
"Average from tilt series" has a "Cropped box size (pix.)" parameter that is explained as: Cropped box size in pixels. If set, the program will output an additional set of maps that have been cropped to this size. This is useful if a map is desired that is smaller than the box size required to retrieve the CTF-delocalized signal.
"Average from tilt series" has a "Binning factor" parameter that is explained as: Downsampling (binning) factor. Note that this does not alter the box size. The reconstructed region instead becomes larger.
"Average from tilt series" has a "Symmetry group" parameter that is explained as: Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
"Average from tilt series" has a "FSC solvent mask (opt.)" parameter that is explained as: Provide a soft mask to automatically estimate the postprocess FSC.
"Average from tilt series" has a "Apply a Wiener filter with this SNR" parameter that is explained as: If set to a positive value, apply a Wiener filter with this signal-to-noise ratio. If omitted, the reconstruction will use a heuristic to prevent divisions by excessively small numbers. Please note that using a low (even though realistic) SNR might wash out the higher frequencies, which could make the map unsuitable to be used for further refinement.

The protocol named "Auto-refinement of subtomograms" can be found in the reliontomo plugin.
"Auto-refinement of subtomograms" protocol help is as follows:
 Auto-refinement of subtomograms..
"Auto-refinement of subtomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Auto-refinement of subtomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Auto-refinement of subtomograms" has a "Relion particles" parameter that is explained as: None
"Auto-refinement of subtomograms" has a "Reference volume" parameter that is explained as: Initial reference 3D map, it should have the same dimensions and the same pixel size as your input particles.
"Auto-refinement of subtomograms" has a "Reference mask (optional)" parameter that is explained as: A volume mask containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask. If no mask is given, a soft spherical mask based on the <radius> of the mask for the experimental images will be applied.

In some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. Check _Advaced_ parameters to select another volume mask.
"Auto-refinement of subtomograms" has a "Second reference mask (optional)" parameter that is explained as: For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas.
"Auto-refinement of subtomograms" has a "Is initial 3D map on absolute greyscale?" parameter that is explained as: Perform CC-calculation in the first iteration (use this if references are not on the absolute intensity scale). See detailed explanation below:

 Probabilities are calculated based on a Gaussian noise model,which contains a squared difference term between the reference and the experimental image.

 This has a consequence that the reference needs to be on the same absolute intensity greyscale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity greyscale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. But, if the map wasreconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No.

If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent map refinement. Therefore, if in doubt it is recommended to set this option to No.
"Auto-refinement of subtomograms" has a "Initial low-pass filter (A)" parameter that is explained as: It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s).
"Auto-refinement of subtomograms" has a "Symmetry group" parameter that is explained as: Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
"Auto-refinement of subtomograms" has a "Do CTF-correction?" parameter that is explained as: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
"Auto-refinement of subtomograms" has a "Ignore CTFs until first peak?" parameter that is explained as: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
"Auto-refinement of subtomograms" has a "Circular mask diameter (Å)" parameter that is explained as: Diameter of the circular mask that will be applied to the experimental images (in Angstroms)
"Auto-refinement of subtomograms" has a "Mask individual particles with zeros?" parameter that is explained as: If set to Yes, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform.

This will remove noise and therefore increase sensitivity in the alignment and classification.

However, it will also introduce correlations between the Fourier components that are not modelled. When set to No, then the solvent area is filled with random noise, which prevents introducing correlations.

High-resolution refinements (e.g. ribosomes or other large complexes in 3D auto-refine) tend to work better when filling the solvent area with random noise (i.e. setting this option to No), refinements of smaller complexes and most classifications go better when using zeros (i.e. setting this option to Yes).
"Auto-refinement of subtomograms" has a "Use solvent-flattened FSCs?" parameter that is explained as: If set to Yes, then instead of using unmasked maps to calculate the gold-standard FSCs during refinement, masked half-maps are used and a post-processing-like correction of the FSC curves (with phase-randomisation) is performed every iteration.

This only works when a reference mask is provided. This may yield higher-resolution maps, especially when the mask contains only a relatively small volume inside the box.
"Auto-refinement of subtomograms" has a "Initial angular sampling interval (deg)" parameter that is explained as: There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
"Auto-refinement of subtomograms" has a "Initial offset range (pix.)" parameter that is explained as: Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
"Auto-refinement of subtomograms" has a "Initial offset step (pix.)" parameter that is explained as: Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluatedon a 2x coarser grid.
"Auto-refinement of subtomograms" has a "Local searches from auto-sampling" parameter that is explained as: Minimum healpix order (before oversampling) from which autosampling procedure will use local searches.

In the automated procedure to increase the angular samplings, local angular searches of -6/+6 times the sampling rate will be used from this angular sampling rate onwards. For most lower-symmetric particles a value of 1.8 degrees will be sufficient. Perhaps icosahedral symmetries may benefit from a smaller value such as 0.9 degrees.
"Auto-refinement of subtomograms" has a "Symmetry to be relaxed" parameter that is explained as: With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020 cited in the About dialog.

Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
"Auto-refinement of subtomograms" has a "Use finer angular sampling faster?" parameter that is explained as: If set to Yes, then let auto-refinement proceed faster with finer angular samplings. Two additional conditions will be considered:

 	-Angular sampling will go down despite changes still happening in the angles.
	-Angular sampling will go down if the current resolution already requires that sampling
	 at the edge of the particle.

This option will make the computation faster, but hasn't been tested for many cases for potential loss in reconstruction quality upon convergence.
"Auto-refinement of subtomograms" has a "Use parallel disc I/O?" parameter that is explained as: If set to Yes, all MPI followers will read their own images from disc. Otherwise, only the leader will read images and send them through the network to the followers. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many followers reading in parallel. If your datasets contain particles with different box sizes, you have to say Yes.
"Auto-refinement of subtomograms" has a "Number of pooled particles" parameter that is explained as: Particles are processed in individual batches by MPI followers. During each batch, a stack of particle images is only opened and closed once to improve disk access times.

All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. This parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together.

This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
"Auto-refinement of subtomograms" has a "Skip griding?" parameter that is explained as: Skip gridding in the Maximization step in the Expectation-Maximization algorithm. If this option is set to Yes, more memory will be consumed during the protocol execution, but it will be faster.
"Auto-refinement of subtomograms" has a "Pre-read all particles into RAM?" parameter that is explained as: If set to Yes, the leader process read all particles into memory. Be careful you have enough RAM for large data sets!
"Auto-refinement of subtomograms" has a "Combine iterations through disc?" parameter that is explained as: If set to Yes, the large arrays of summed weights will be sent through the MPI network instead of writing large files to disc.
"Auto-refinement of subtomograms" has a "Copy particles to scratch directory" parameter that is explained as: If provided, particle stacks will be copied to this local scratch disk prior for refinement.
"Auto-refinement of subtomograms" has a "Skip padding?" parameter that is explained as: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
"Auto-refinement of subtomograms" has a "Use GPU acceleration?" parameter that is explained as: If set to Yes, it will use available gpu resources for some calculations.
"Auto-refinement of subtomograms" has a "GPUs to use:" parameter that is explained as: It can be used to provide a list of which GPUs (e. g. "0:1:2:3") to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
"Auto-refinement of subtomograms" has a "Keep only files from last iteration?" parameter that is explained as: If Yes is chosen, only the files which correspond to the last iteration will be saved in the protocol's extra directory. Otherwise, files corresponding to each iteration will be kept.
"Auto-refinement of subtomograms" has a "Over-sampling" parameter that is explained as: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
"Auto-refinement of subtomograms" has a "Consider alignment as priors?" parameter that is explained as: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
"Auto-refinement of subtomograms" has a "Additional arguments" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--verb 1
--pad 2

"Auto-refinement of subtomograms" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Auto-refinement of subtomograms" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"Auto-refinement of subtomograms" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Average from subtomograms" can be found in the reliontomo plugin.
"Average from subtomograms" protocol help is as follows:
  This protocol reconstructs a volume using Relion.
    Reconstruct a volume from a given set of subtomograms.
    The alignment parameters will be converted to a Relion star file
    and used as direction projections to reconstruct.
    .
"Average from subtomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Average from subtomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Average from subtomograms" has a "Input subtomograms" parameter that is explained as: Select the input subtomograms from the project.
"Average from subtomograms" has a "Symmetry group" parameter that is explained as: See [[Relion Symmetry][http://www2.mrc-lmb.cam.ac.uk/relion/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Relion
"Average from subtomograms" has a "Maximum resolution (A)" parameter that is explained as: Maximum resolution (in Angstrom) to consider 
in Fourier space (default Nyquist).
"Average from subtomograms" has a "Padding factor" parameter that is explained as: None
"Average from subtomograms" has a "Subset to reconstruct" parameter that is explained as: Subset of images to consider.
"Average from subtomograms" has a "Use only this class" parameter that is explained as: Consider only this class (-1: use all classes)
"Average from subtomograms" has a "Extra parameters: " parameter that is explained as: Extra parameters to *relion_reconstruct* program. Address to Relion to see full list of options.
"Average from subtomograms" has a "Apply CTF correction?" parameter that is explained as: None
"Average from subtomograms" has a "Leave CTFs intact until first peak?" parameter that is explained as: None
"Average from subtomograms" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Average from subtomograms" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Tomo frame align" can be found in the reliontomo plugin.
"Tomo frame align" protocol help is as follows:
 Tomo frame align.
"Tomo frame align" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Tomo frame align" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Tomo frame align" has a "Relion particles" parameter that is explained as: None
"Tomo frame align" has a "Volume to get the halves" parameter that is explained as: None
"Tomo frame align" has a "Input reference mask" parameter that is explained as: None
"Tomo frame align" has a "Box size for estimation (pix)" parameter that is explained as: Box size to be used for the estimation. Note that this can be larger than the box size of the reference map. A sufficiently large box size allows more of the high-frequency signal to be captured that has been delocalized by the CTF.
"Tomo frame align" has a "Max position error (pix)" parameter that is explained as: Maximal assumed error in the initial 2D particle-positions (distances between the projected 3D positions and their true positions in the images), given in pixels.
"Tomo frame align" has a "Align by shift only?" parameter that is explained as: If set to Yes, tilt series projection shifts are refined based on cross-correlation. Useful for very badly aligned frames. No iterative optimisation.
"Tomo frame align" has a "Alignment model" parameter that is explained as: If set to "Only particles", it estimates rigid shift by aligning only the particles instead of by predicting entire micrographs. In this case, only misalignments smaller than half the box size of the particle can be corrected.
"Tomo frame align" has a "Fit per particle motion?" parameter that is explained as: If set to Yes, then the subtomogram version of Bayesian polishing will be used to fit per-particle (3D) motion tracks, besides the rigid part of the motion in the tilt series.
"Tomo frame align" has a "Sigma for velocity (Å/dose)" parameter that is explained as: The expected amount of motion (i.e. the std. deviation of particle positions in Angstroms after 1 electron per A^2 of radiation).
"Tomo frame align" has a "Sigma for divergence (Å)" parameter that is explained as: The expected spatial smoothness of the particle trajectories in angstroms (a greater value means spatially smoother motion.
"Tomo frame align" has a "Use Gaussian decay?" parameter that is explained as: If set to Yes, then it is assumed that the correlation of the velocities of two particles decays as a Gaussian over their distance, instead of as an exponential. This will produce spatially smoother motion and result in a shorter program runtime.
"Tomo frame align" has a "Estimate 2D deformations?" parameter that is explained as: If set to Yes, then the subtomogram version of Bayesian polishing will be used to fit per-particle (3D) motion tracks, besides the rigid part of the motion in the tilt series.
"Tomo frame align" has a "Horizontal sampling points" parameter that is explained as: Number of horizontal sampling points for the deformation grid.
"Tomo frame align" has a "Vertical sampling points" parameter that is explained as: Number of vertical sampling points for the deformation grid.
"Tomo frame align" has a "Alignment model" parameter that is explained as: Type of model to use (linear, spline or Fourier).
"Tomo frame align" has a "Deformation regularisation scale" parameter that is explained as: None
"Tomo frame align" has a "Refine deformations per frame?" parameter that is explained as: If set to Yes, it models deformations per tilt frame instead of per tilt series.
"Tomo frame align" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Tomo frame align" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"Tomo frame align" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Reconstruct tomograms from prepare data prot" can be found in the reliontomo plugin.
"Reconstruct tomograms from prepare data prot" protocol help is as follows:
  This protocol reconstructs a single tomogram using Relion. It is very useful
    to check if the protocol "Prepare data" has been applied correctly (in terms of flip
    options, for example).
    .
"Reconstruct tomograms from prepare data prot" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Reconstruct tomograms from prepare data prot" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Reconstruct tomograms from prepare data prot" has a "Prepare Data protocol" parameter that is explained as: It is very usefulto check if the protocol "Prepare data" has been applied correctly (in terms of flip options, for example)
"Reconstruct tomograms from prepare data prot" has a "Choose a reconstruction option" parameter that is explained as: None
"Reconstruct tomograms from prepare data prot" has a "Tomogram to be reconstructed" parameter that is explained as: None
"Reconstruct tomograms from prepare data prot" has a "Binning factor" parameter that is explained as: The binning will be applied concerning the size of the tomograms used for the picking.
"Reconstruct tomograms from prepare data prot" has a "Width" parameter that is explained as: If -1, the width considered will be of the original tilt series after having applied the introduced binning factor.
"Reconstruct tomograms from prepare data prot" has a "Height" parameter that is explained as: If -1, the height considered will be of the original tilt series after having applied the introduced binning factor.
"Reconstruct tomograms from prepare data prot" has a "Thickness" parameter that is explained as: If -1, the thickness considered will be of the original tilt series after having applied the introduced binning factor.
"Reconstruct tomograms from prepare data prot" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Reconstruct tomograms from prepare data prot" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Matching coordinates" can be found in the reliontomo plugin.
"Matching coordinates" protocol help is as follows:
 
    Protocol to generate a set of pseudosubtomograms taking into account the
    intersection of  a set of 3D coordinates and a set of pseudosubtomograms
    as input.
    .
"Matching coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Matching coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Matching coordinates" has a "Input pseudoubtomograms" parameter that is explained as: Select the input pseudosubtomograms from the project.
"Matching coordinates" has a "Subtomograms or 3D coordinates" parameter that is explained as: Select the subtomograms or 3D coordinates that we want to match with the pseudosubtomogram

The protocol named "ctf estimation" can be found in the emantomo plugin.
"ctf estimation" protocol help is as follows:
 
    Protocol for CTF estimation from tilt series using e2spt_tomoctf.py
    .
"ctf estimation" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"ctf estimation" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"ctf estimation" has a "Tilt Series" parameter that is explained as: None
"ctf estimation" has a "min" parameter that is explained as: None
"ctf estimation" has a "max" parameter that is explained as: None
"ctf estimation" has a "Step" parameter that is explained as: None
"ctf estimation" has a "Do phase shift search?" parameter that is explained as: None
"ctf estimation" has a "min" parameter that is explained as: None
"ctf estimation" has a "max" parameter that is explained as: None
"ctf estimation" has a "Step" parameter that is explained as: None
"ctf estimation" has a "Size of tile to calculate FFT" parameter that is explained as: None
"ctf estimation" has a "Number of references" parameter that is explained as: Using N tilt images near the center tilt to estimate the range of defocus for all images.
"ctf estimation" has a "Step in X direction" parameter that is explained as: Number of tiles to generate on x-axis (different defocus)
"ctf estimation" has a "Step in Y direction" parameter that is explained as: Number of tiles to generate on y-axis (same defocus)
"ctf estimation" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"ctf estimation" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Multi-reference classification pppt" can be found in the emantomo plugin.
"Multi-reference classification pppt" protocol help is as follows:
 
    This protocol wraps *e2spt_refinemulti_new.py* EMAN2 program.
    Multi-reference classification for the new (2021) SPT refinement protocol.
    .
"Multi-reference classification pppt" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Multi-reference classification pppt" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Multi-reference classification pppt" has a "Aligned particles" parameter that is explained as: None
"Multi-reference classification pppt" has a "Mask the references prior to to classif. (opt.)" parameter that is explained as: None
"Multi-reference classification pppt" has a "Max. resolution (Å)" parameter that is explained as: Maximum resolution (the smaller number) to consider in alignment (in Å).
Since gold-standard validation is not used here, setting this parameter is mandatory.
"Multi-reference classification pppt" has a "Min. resolution (Å)" parameter that is explained as: Minimum resolution (the larger number) to consider in alignment (in Å).
"Multi-reference classification pppt" has a "Number of classes" parameter that is explained as: None
"Multi-reference classification pppt" has a "Reference volume (opt.)" parameter that is explained as: None
"Multi-reference classification pppt" has a "No. iterations" parameter that is explained as: None
"Multi-reference classification pppt" has a "Sym. to apply to the average" parameter that is explained as: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
"Multi-reference classification pppt" has a "Break specified symmetry" parameter that is explained as: If empty, no symmetry will be broken.
"Multi-reference classification pppt" has a "Do alignment?" parameter that is explained as: If set to No (default), it will skip the alignment entirely when aligned particles are provided. Otherwise a local orientation search will still be performed.
"Multi-reference classification pppt" has a "Apply mask to the 3D alignment ref. in each iter. (opt.)" parameter that is explained as: Not applied to the average, which will follow normal EMAN's masking routine.
"Multi-reference classification pppt" has a "Maximum angular diff. (deg.)" parameter that is explained as: maximum angle difference for local alignment (in degrees)
"Multi-reference classification pppt" has a "Maximum shift (px)" parameter that is explained as: If set to -1, it will be estimated as maxShift=boxSize/6.
"Multi-reference classification pppt" has a "Threads for post-processing" parameter that is explained as: None
"Multi-reference classification pppt" has a "Do make3d in threading mode with shared memory?" parameter that is explained as: Safer for large boxes.
"Multi-reference classification pppt" has a "Extra params" parameter that is explained as: Here you can add any extra parameters to run Eman's  new subtomogram refinement. Parameters should be written in Eman's command line format (--param val)
"Multi-reference classification pppt" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Multi-reference classification pppt" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "average subtomograms" can be found in the emantomo plugin.
"average subtomograms" protocol help is as follows:
 
    This protocol wraps *e2spt_average.py* EMAN2 program.
    Computes the average a selected subset of a SetOfSubtomograms in the predetermined orientation
    .
"average subtomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"average subtomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"average subtomograms" has a "Input SubTomograms" parameter that is explained as: Select the set of subtomograms to perform the reconstruction.
"average subtomograms" has a "Symmetry" parameter that is explained as: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
"average subtomograms" has a "Missing wedge threshold" parameter that is explained as: Threshold for identifying missing data in Fourier space in terms of standard deviation of each Fourier shell. Default 3.0. If set to 0.0, missing wedge correction will be skipped
"average subtomograms" has a "Skip post process steps (fsc, mask and filters)" parameter that is explained as: None
"average subtomograms" has a "Keep hdf files?" parameter that is explained as: If set to Yes, the generated files will be saved in both HDF and MRC formats. They are generated in HDF and then converted into MRC. The HDF files are deleted by default to save storage.
"average subtomograms" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"average subtomograms" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Extraction from TS" can be found in the emantomo plugin.
"Extraction from TS" protocol help is as follows:
 Extract 2D subtilt particles from the tilt series, and reconstruct 3D subvolumes..
"Extraction from TS" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Extraction from TS" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Extraction from TS" has a "Coordinates or 3D particles" parameter that is explained as: The corresponding tomograms data will be accessed from the provided coordinates or the coordinates associated to the 3D particles.
"Extraction from TS" has a "CTF tomo series" parameter that is explained as: Estimated CTF for the tilt series associates to the tomograms used to pick the input coordinates. The corresponding tilt series data will be also accessed through them.
"Extraction from TS" has a "Tilt series" parameter that is explained as: Tilt series with alignment (non interpolated) used in the tomograms reconstruction.
"Extraction from TS" has a "Flip Z axis in tomogram?" parameter that is explained as: If the reconstruction was carried out with EMAN, it would be set to No.
"Extraction from TS" has a "Box size unbinned (px)" parameter that is explained as: The subtomograms are extracted as a cubic box of this size.
"Extraction from TS" has a "Particles binning factor" parameter that is explained as: For example, if the unbinned box size is 160 pix and the particles binning factor introduced is 4, the 2D tilt particles will be cropped on the tilt series with a box of 160 x 160 pix, and then shrink to 160 / 4 = 40 pix. Thus, both resulting 2D and 3D sets of particles will be of size 40 pix.
"Extraction from TS" has a "Max tilt" parameter that is explained as: None
"Extraction from TS" has a "Tilt fraction to keep" parameter that is explained as: Keep a fraction of tilt images with good score determined from tomogram reconstruction
"Extraction from TS" has a "Contrast threshold for 2D particle removal" parameter that is explained as: Remove 2d particles with high contrast object beyond N sigma at 100Å. Note that this may result in generating fewer particles than selected. Default is -1 (include all particles). 0.5 might be a good choice for removing gold beads.
"Extraction from TS" has a "Padding factor" parameter that is explained as: If set to 0, no padding will be considered. If your particles are deeply buried in other densities, using a bigger padtwod may help, but doing so may significantly increase the memory usage and slow down the process.
"Extraction from TS" has a "Minimum distance between particles (Å)" parameter that is explained as: None
"Extraction from TS" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Extraction from TS" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Template matching picking" can be found in the emantomo plugin.
"Template matching picking" protocol help is as follows:
 
    This protocol wraps *e2spt_tempmatch.py* EMAN2 program.
    It is a reference-based picking (template matching).
    .
"Template matching picking" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Template matching picking" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Template matching picking" has a "Tomograms" parameter that is explained as: Specify tomograms containing reference-like particles to be exctracted. These should be "dark contrast".
"Template matching picking" has a "Reference volume" parameter that is explained as: This should be 'light contrast'.
"Template matching picking" has a "Maximum no. particles picked among the tomograms" parameter that is explained as: If a higher number of particles is detected, the program will take the best N, being N the value of the current parameter.
"Template matching picking" has a "Anglular sampling to rotate the reference (deg." parameter that is explained as: The lower value, the higher number of orientations that will be checked.
"Template matching picking" has a "Distance threshold (Å)" parameter that is explained as: Particles closer than the value introduced will be removed. If default =-1, it will be considered as half of the box size of the reference.
"Template matching picking" has a "Template matching threshold (n sigma)" parameter that is explained as: Particles with score lower than the introduced value will be removed. Admitted values are [1, 10], where 1 means very insensitive picking (pick a lot of particles with a high probability of having a a high number of false positives) and 10 means very sensitive picking (strict picking, with less particles picked and very low presence of false positives, but with high probability of some or even a lot of particles not to be picked.
"Template matching picking" has a "Minimum peak volume" parameter that is explained as: If default=-1, this filter is not applied.
"Template matching picking" has a "Maximum peak volume" parameter that is explained as: If default=-1, this filter is not applied.
"Template matching picking" has a "Symmetry of the reference" parameter that is explained as: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
"Template matching picking" has a "Remove particles on the edge?" parameter that is explained as: None
"Template matching picking" has a "Remove particles near gold fiducials?" parameter that is explained as: None
"Template matching picking" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Template matching picking" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Manual picking" can be found in the emantomo plugin.
"Manual picking" protocol help is as follows:
  Manual picker for Tomo. Uses EMAN2 e2spt_boxer.py.
    .
"Manual picking" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Manual picking" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Manual picking" has a "Input Tomograms" parameter that is explained as: Select the Tomogram to be used during picking.
"Manual picking" has a "Modify previous coordinates?" parameter that is explained as: This option allows to add and/or remove coordinates to a previous SetOfCoordinates
"Manual picking" has a "Input Coordinates" parameter that is explained as: Select the previous SetOfCoordinates you want to modify

The protocol named "clip tomograms" can be found in the emantomo plugin.
"clip tomograms" protocol help is as follows:
 Make the output have this size by padding/clipping and re-centered using e2proc3d.py. Both
    new center and new dimensions are referred to the original position and dimensions, respectively..
"clip tomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"clip tomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"clip tomograms" has a "Input tomograms" parameter that is explained as: None
"clip tomograms" has a "cx" parameter that is explained as: None
"clip tomograms" has a "cy" parameter that is explained as: None
"clip tomograms" has a "cz" parameter that is explained as: None
"clip tomograms" has a "dx" parameter that is explained as: None
"clip tomograms" has a "dy" parameter that is explained as: None
"clip tomograms" has a "dz" parameter that is explained as: None

The protocol named "Subtomograms extraction from tomogram" can be found in the emantomo plugin.
"Subtomograms extraction from tomogram" protocol help is as follows:
  Extraction for Tomo. Uses EMAN2 e2spt_boxer_old.py..
"Subtomograms extraction from tomogram" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Subtomograms extraction from tomogram" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Subtomograms extraction from tomogram" has a "Coordinates/Subtomograms" parameter that is explained as: Choose coordinates or subtomograms derived from 3d coordinates.
"Subtomograms extraction from tomogram" has a "Tomogram source" parameter that is explained as: By default the subtomograms will be extracted from the tomogram used in the picking step ( _same as picking_ option ). 
If you select _other_ option, you must provide a different tomogram to extract from. 
*Note*: In the _other_ case, ensure that provided tomogram and coordinates are related 
"Subtomograms extraction from tomogram" has a "Input tomogram" parameter that is explained as: Select the tomogram from which to extract.
"Subtomograms extraction from tomogram" has a "Box size" parameter that is explained as: The subtomograms are extracted as a cubic box of this size. The wizard will select the box size considering the sampling rate ratio between the introduced coordinates and the tomograms that will br used for the extraction.
"Subtomograms extraction from tomogram" has a "Invert contrast?" parameter that is explained as: Invert the contrast if your tomogram is black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background. Frealign (up to v9.07) requires black particles over a white background
"Subtomograms extraction from tomogram" has a "Normalize subtomogram?" parameter that is explained as: Normalization processor applied to subtomograms before extraction.
"Subtomograms extraction from tomogram" has a "Normalize method" parameter that is explained as: Use normalize.edgemean if the particles have a clear solvent background (i.e., they are not part of a larger complex or embeded in a membrane)

The protocol named "Initial model" can be found in the emantomo plugin.
"Initial model" protocol help is as follows:
 
    This protocol wraps *e2spt_sgd.py* EMAN2 program.

    It will take a set of subtomograms (particles) and a subtomogram(reference)
    and build a subtomogram suitable for use as initial models in tomography.
    It also builds a set of subtomograms that contains the original particles
    plus the score, coverage and align matrix per subtomogram .
    .
"Initial model" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Initial model" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Initial model" has a "Particles" parameter that is explained as: Select the set of subtomograms to build an initial model
"Initial model" has a "Reference volume" parameter that is explained as: Specify a 3D volume
"Initial model" has a "Mask" parameter that is explained as: Select a 3D Mask to be applied to the initial model
"Initial model" has a "Symmetry" parameter that is explained as: Specify the symmetry.
Choices are: c(n), d(n), h(n), tet, oct, icos.
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry
for a detailed description of symmetry in Eman.
"Initial model" has a "Filterto" parameter that is explained as: Filter map to frequency after each iteration. Default is 0.02
"Initial model" has a "Fourier" parameter that is explained as: Gradient descent in fourier space
"Initial model" has a "Batch Size" parameter that is explained as: SGD batch size. Increasing batchsize will use more cores (if you have more than 12), and may cause it to converge to the correct answer in fewer iterations, but each iteration will not become faster.
"Initial model" has a "Learn Rate" parameter that is explained as: Learning Rate. Default is 0.1
"Initial model" has a "Number of iterations to perform" parameter that is explained as: The total number of refinement iterations to perform.
"Initial model" has a "Number of batches" parameter that is explained as: Number of batches per iteration
"Initial model" has a "Shrink factor" parameter that is explained as: Using a box-size >64 is not optimal for making initial models. Suggest using this option to shrink the input particles by an integer amount prior to reconstruction. Default = 1, no shrinking
"Initial model" has a "Apply Symmetry" parameter that is explained as: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.

The protocol named "Initial model pppt" can be found in the emantomo plugin.
"Initial model pppt" protocol help is as follows:
 
    This protocol wraps *e2spt_sgd_new.py* EMAN2 program.
    It generates an initial model from subtomograms using stochastic gradient descent.
    .
"Initial model pppt" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Initial model pppt" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Initial model pppt" has a "Particles" parameter that is explained as: Select the set of subtomograms to build an initial model
"Initial model pppt" has a "Reference volume (opt.)" parameter that is explained as: None
"Initial model pppt" has a "Binning factor" parameter that is explained as: This option can be used to shrink the input particles by an integer amount prior to reconstruction, making them smaller. Default = 1 means no shrinking
"Initial model pppt" has a "No. iterations" parameter that is explained as: None
"Initial model pppt" has a "No. classes" parameter that is explained as: None
"Initial model pppt" has a "Symmetry" parameter that is explained as: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
"Initial model pppt" has a "Target resolution (Å)" parameter that is explained as: None
"Initial model pppt" has a "Batch Size" parameter that is explained as: SGD batch size. Increasing batch size will use more cores (if you have more than 12), and may cause it to converge to the correct answer in fewer iterations, but each iteration will not become faster.
"Initial model pppt" has a "Fraction of particles to keep" parameter that is explained as: It will actually align more particles and use the number of particles specified by the batch size parameter. Default = 1 means that all the particles are kept.
"Initial model pppt" has a "Learning Rate" parameter that is explained as: In the context of stochastic gradient descent (SGD), the learning rate is a hyperparameter that determines the step size at each iteration when updating the model's parameters.

In other words, the learning rate controls how much the parameters are adjusted in the direction of the gradient, which is the direction of steepest descent of the loss function. A higher learning rate leads to larger updates and faster convergence, but it may also cause the algorithm to overshoot the optimal solution and fail to converge. On the other hand, a lower learning rate leads to smaller updates and slower convergence, but it may also help the algorithm avoid overshooting and find a more precise optimum.

Choosing an appropriate learning rate is important for achieving good performance in SGD. It typically involves a trade-off between convergence speed and accuracy, and may require tuning through trial and error or more advanced optimization techniques such as adaptive learning rate methods.
"Initial model pppt" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Initial model pppt" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "subtomogram refinement" can be found in the emantomo plugin.
"subtomogram refinement" protocol help is as follows:
 
    This protocol wraps *e2spt_refine.py* EMAN2 program.

    Protocol to performs a conventional iterative subtomogram averaging
    using the full set of particles.
    It will take a set of subtomograms (particles) and a subtomogram(reference,
    potentially coming from the initial model protocol)
    and 3D reconstruct a subtomogram.
    It also builds a set of subtomograms that contains the original particles
    plus the score, coverage and align matrix per subtomogram .
    .
"subtomogram refinement" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"subtomogram refinement" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"subtomogram refinement" has a "Input SubTomograms" parameter that is explained as: Select the set of subtomograms to perform the reconstruction.
"subtomogram refinement" has a "Input Ref SubTomogram" parameter that is explained as: 3D reference for initial model generation.No reference is used by default.
"subtomogram refinement" has a "Number of iterations" parameter that is explained as: The number of iterations to perform.
"subtomogram refinement" has a "Mass:" parameter that is explained as: Mass normalization. Default=-1 Ignores mass
"subtomogram refinement" has a "Particle keep:" parameter that is explained as: Fraction of particles to keep
"subtomogram refinement" has a "Gold standard:" parameter that is explained as: initial resolution for gold standard refinement
"subtomogram refinement" has a "Gold continue" parameter that is explained as: continue from an existing gold standard refinement
"subtomogram refinement" has a "Mask file" parameter that is explained as: Mask file to be applied to initial model
"subtomogram refinement" has a "Structure factor" parameter that is explained as: Select the structure factor
"subtomogram refinement" has a "Symmetry" parameter that is explained as: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
"subtomogram refinement" has a "Local filter" parameter that is explained as: use tophat local
"subtomogram refinement" has a "maxtilt" parameter that is explained as: Explicitly zeroes data beyond specified tilt angle.Assumes tilt axis exactly on Y and zero tilt in X-Yplane. Default 90 (no limit).
"subtomogram refinement" has a "Use previous alignments?" parameter that is explained as: None
"subtomogram refinement" has a "Maximum angular change" parameter that is explained as: Maximum anglular difference in refine mode (in degrees)
"subtomogram refinement" has a "Extra params" parameter that is explained as: Here you can add any extra parameters to run Eman subtomogram refinement. Parameters should be written in Eman command line format (--param=val)
"subtomogram refinement" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"subtomogram refinement" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "subtomogram refinement pppt" can be found in the emantomo plugin.
"subtomogram refinement pppt" protocol help is as follows:
 
    This protocol wraps *e2spt_refine_new.py* EMAN2 program.
    This refinement protocol performs subtomogram, subtilt and defocus refinement. The 2D subtilt particles are used
    instead of 3D subvolumes in the subtomogram refinement step. Moreover, this program now can model the localized 2D
    particle motion by considering the motion trajectory of each particle along with its neighbor.
    .
"subtomogram refinement pppt" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"subtomogram refinement pppt" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"subtomogram refinement pppt" has a "Particles" parameter that is explained as: None
"subtomogram refinement pppt" has a "Reference volume (opt.)" parameter that is explained as: None
"subtomogram refinement pppt" has a "Refinement initial resolution (Å)" parameter that is explained as: This will be the maximum resolution considered for the first iteration. In later iterations, the maximum resolution is calculated from the FSC of the previous iteration (unless the parameter max. resolution is specified).
"subtomogram refinement pppt" has a "Iteration information" parameter that is explained as: Input types of refinement separated by comma:

	- *p*: 3d particle translation-rotation.
	- *t*: subtilt translation.
	- *r*: subtilt translation-rotation.
	- *d*: subtilt defocus.

Default is p,p,p,t,p,p,t,r,d. Character followed by number is also acceptable. p3 = p,p,p.
"subtomogram refinement pppt" has a "Symmetry" parameter that is explained as: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
"subtomogram refinement pppt" has a "Particle keep" parameter that is explained as: Fraction of particles to keep. Note that this is controlled at three separate steps.
When default = 0.95, it removes:

	- The worst 5% 3D particles.
	- The 5% 2D subtilt with the worst score.
	- The 5% of subtilt with the largest drift.

Also accept comma separated values 0.9,0.5,0.5 to set different keep thresholds for the three removal operations described before.
"subtomogram refinement pppt" has a "3D map filtering" parameter that is explained as: Options to filter the 3D maps:

	- wiener: wiener filter based on FSC curve. default mode in most programs.
	- global: tophat filter across the map at the resolution cutoff 0.143 from fsc_masked_xx.txt.
	- localwiener: wiener filter based on the fsc curve of local regions from the even/odd maps.
	- local: tophat filter based on local resolution calculated from the even/odd maps at 0.143 cutoff.
"subtomogram refinement pppt" has a "Max. resolution in alignment (Å)" parameter that is explained as: The program will determine maximum resolution each round from the FSC of the previous round by default.
"subtomogram refinement pppt" has a "Min. resolution in alignment (Å)" parameter that is explained as: None
"subtomogram refinement pppt" has a "Do local refine? (only for p iterations)" parameter that is explained as: Perform only local search around the solution from the previous alignment.
"subtomogram refinement pppt" has a "Maximum angular diff. (deg.)" parameter that is explained as: maximum angle difference from starting point for local refine (in degrees)
"subtomogram refinement pppt" has a "Maximum shift (px)" parameter that is explained as: If set to -1, it will be estimated as maxShift= boxSize/6.
"subtomogram refinement pppt" has a "Smooth motion factor" parameter that is explained as: Controls how many of its neighbors are considered to model the local motion. Smoother local motion with larger numbers.
"subtomogram refinement pppt" has a "No. neighboring particles used for smoothing" parameter that is explained as: Used to control how many of its neighbors are considered to model the local motion.
"subtomogram refinement pppt" has a "Threads for post-processing" parameter that is explained as: None
"subtomogram refinement pppt" has a "Do make3d in threading mode with shared memory?" parameter that is explained as: Safer for large boxes.
"subtomogram refinement pppt" has a "Extra params" parameter that is explained as: Here you can add any extra parameters to run Eman's  new subtomogram refinement. Parameters should be written in Eman's command line format (--param val)
"subtomogram refinement pppt" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"subtomogram refinement pppt" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Alignment and reconstruction" can be found in the emantomo plugin.
"Alignment and reconstruction" protocol help is as follows:
 
    This protocol wraps *e2tomogram.py* EMAN2 program.

    Tilt series alignment and tomogram reconstruction.
    Tomograms are not normally reconstructed at full resolution, generally limited to 1k x 1k or 2k x 2k,
    but the tilt-series are aligned at full resolution. For high resolution subtomogram averaging, the raw
    tilt-series data is used, based on coordinates from particle picking in the downsampled tomograms.
    On a typical workstation reconstruction takes about 4-5 minutes per tomogram.
    .
"Alignment and reconstruction" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Alignment and reconstruction" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Alignment and reconstruction" has a "Tilt Series" parameter that is explained as: Select the set of tilt series to be aligned and/or to reconstruct the corresponding tomograms.
"Alignment and reconstruction" has a "Bit compression" parameter that is explained as: Number of bits of precision in outputs with lossless compression. Value -1 means uncompressed float
"Alignment and reconstruction" has a "Keep hdf files?" parameter that is explained as: If set to Yes, the generated files will be saved in both HDF and MRC formats. They are generated in HDF and then converted into MRC. The HDF files are deleted by default to save storage.
"Alignment and reconstruction" has a "Align the tilt series?" parameter that is explained as: None
"Alignment and reconstruction" has a "Generated the interpolated tilt series?" parameter that is explained as: If set to Yes, an additional set of tilt series with the transformation matrix applied will be generated. It can be used to check if the alignment was correctly calculated.

*NOTE*: Depending on the combination of parameters "Align the tilt series" and "Reconstruct the tomogram", the interpolated tilt series generated may be different in terms of size and sampling rate.
The interpolated tilt series generated when the tomogram is requested to be reconstructed is different from the one generated if only align TS is selected (It is part of the reconstruction functionality in the first case, and a temp file part of the alignment step in the second case).
"Alignment and reconstruction" has a "No. landmarks to use" parameter that is explained as: None
"Alignment and reconstruction" has a "Fraction of landmarks to keep in the tracking" parameter that is explained as: None
"Alignment and reconstruction" has a "No. patch tracking iterations" parameter that is explained as: use patch tracking before landmark based alignment. input 0/1/2 as the number of patch tracking iterations.
"Alignment and reconstruction" has a "Box size of the particles for tracking (px)" parameter that is explained as: It may be helpful to use a larger one for fiducial-less cases.
"Alignment and reconstruction" has a "Should Eman estimate the tilt angles?" parameter that is explained as: If set to No, a .tlt file will be generated containing the tilt angles read from Scipion imported tilt series metadata and passed to Eman. Default=True will let Eman to estimate the tilt angles, following the Eman original default behavior.
"Alignment and reconstruction" has a "Index of the center tilt" parameter that is explained as: If set -1, it will be estimated by EMAN.
"Alignment and reconstruction" has a "Tilt axis angle" parameter that is explained as: If not provided, it will be read from the tilt series metadata. If it is not contained in the metadata, it will be estimated by EMAN.
"Alignment and reconstruction" has a "Write intermediate results?" parameter that is explained as: They will be generated always the interpolated tilt series are requested.
"Alignment and reconstruction" has a "Reconstruct the tomograms?" parameter that is explained as: None
"Alignment and reconstruction" has a "Size of the output tomograms" parameter that is explained as: None
"Alignment and reconstruction" has a "No. iterations for 500, 1K, 2K, and 8K images" parameter that is explained as: None
"Alignment and reconstruction" has a "Thickness (px)" parameter that is explained as: Z thickness of the final tomogram output. default is -1, (5/16 of tomogram length).
"Alignment and reconstruction" has a "Fraction of tilts to keep in the reconstruction" parameter that is explained as: None
"Alignment and reconstruction" has a "Make final tomogram by tiles?" parameter that is explained as: None
"Alignment and reconstruction" has a "Sample more tiles during rec.?" parameter that is explained as: If set to Yes, the processing time will be greater, but it can be useful to reduce the boundary artifacts when the sample is thick.
"Alignment and reconstruction" has a "Correct rotation" parameter that is explained as: Correct for global rotation and position sample flat in tomogram.
"Alignment and reconstruction" has a "Correct drifting along the X axis?" parameter that is explained as: None
"Alignment and reconstruction" has a "Filter final tomogram to target resolution (Å)" parameter that is explained as: None
"Alignment and reconstruction" has a "Density value threshold for removing beads" parameter that is explained as: "Density value threshold (of sigma) for removing beads. High contrast objects beyond this value will be removed. Default is -1 for not removing.
"Alignment and reconstruction" has a "Extra pad" parameter that is explained as: Use extra padding for tilted reconstruction. It is slower and costs more memory, but reduces the boundary artifacts when the sample is thick.
"Alignment and reconstruction" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Alignment and reconstruction" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "boxer auto" can be found in the eman2 plugin.
"boxer auto" protocol help is as follows:
  Automated particle picker for SPA. Uses EMAN2 (versions 2.2+) e2boxer.py
    .
"boxer auto" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"boxer auto" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"boxer auto" has a "Input Micrographs" parameter that is explained as: Select the SetOfMicrographs to be used during picking.
"boxer auto" has a "" parameter that is explained as: Set to Yes if you want to run Neural Net boxer on GPU. Default is CPU.
"boxer auto" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Eman boxer can use only one GPU.
"boxer auto" has a "Box size (px)" parameter that is explained as: Box size in pixels. See http://eman2.org/BoxSize
"boxer auto" has a "Particle size (px)" parameter that is explained as: Longest axis of particle in pixels (diameter, not radius).
"boxer auto" has a "Autopicker mode:" parameter that is explained as: Choose autopicker mode:

 _local search_ - Reference based search by downsampling and 2-D alignment to references.
 _by ref_ - simple reference-based cross-correlation picker with exhaustive rotational search.
 _neural net_ - convolutional neural network boxer.
 _gauss_ - simple reference-free picker.
"boxer auto" has a "Threshold" parameter that is explained as: None
"boxer auto" has a "Threshold2" parameter that is explained as: None
"boxer auto" has a "Threshold low" parameter that is explained as: None
"boxer auto" has a "Threshold high" parameter that is explained as: None
"boxer auto" has a "Gaussian width" parameter that is explained as: None
"boxer auto" has a "Previous e2boxer protocol" parameter that is explained as: Provide previously executed e2boxer protocol that has all 3 types of references and pre-trained neural network.
"boxer auto" has a "Good references" parameter that is explained as: Good particle references.
"boxer auto" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"boxer auto" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "boxer" can be found in the eman2 plugin.
"boxer" protocol help is as follows:
  Semi-automated particle picker for SPA. Uses EMAN2 e2boxer.py.
    .
"boxer" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"boxer" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"boxer" has a "Input Micrographs" parameter that is explained as: Select the SetOfMicrographs to be used during picking.
"boxer" has a "Box size (px)" parameter that is explained as: Box size in pixels.
"boxer" has a "Particle size (px)" parameter that is explained as: Longest axis of particle in pixels (diameter, not radius).
"boxer" has a "Device" parameter that is explained as: For Convnet training only.
Pick a device to use. Choose from cpu, gpu, or gpuX (X=0,1,...) when multiple gpus are available. Default is cpu.
"boxer" has a "Invert Y coordinates" parameter that is explained as: In some cases, using dm3 or tiff Y coordinates must be flipped. Check output and activate this if needed.
"boxer" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"boxer" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "ctf auto" can be found in the eman2 plugin.
"ctf auto" protocol help is as follows:
 
    This protocol wraps *e2ctf_auto.py* EMAN2 program.
    It automates the CTF fitting and structure factor
    generation process.
    .
"ctf auto" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"ctf auto" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"ctf auto" has a "Input Particles" parameter that is explained as: None
"ctf auto" has a "type" parameter that is explained as: Performs CTF processing targeting different resolution:
*hires* - 2-6 Angstrom
*midres* - 7-15 Angstrom
*lores* - 15-30 Angstrom
"ctf auto" has a "Min" parameter that is explained as: None
"ctf auto" has a "Max" parameter that is explained as: None
"ctf auto" has a "Fit from scratch" parameter that is explained as: Force refitting of CTF from scratch, ignoring any previous fits.
"ctf auto" has a "Estimate astigmatism" parameter that is explained as: Includes astigmatism in automatic fitting.
"ctf auto" has a "Estimate phase shift" parameter that is explained as: Include phase/amplitude contrast in CTF estimation. For use with hole-less phase plates.
"ctf auto" has a "Extra padding" parameter that is explained as: If particles were boxed more tightly than EMAN requires, this will add some extra padding.
"ctf auto" has a "Invariant type" parameter that is explained as: Which type of invariants to generate
"ctf auto" has a "High density " parameter that is explained as: If particles are very close together, this will interfere with SSNR estimation. If set uses an alternative strategy, but may over-estimate SSNR.
"ctf auto" has a "Invert contrast" parameter that is explained as: Invert the contrast of the particles in output files (default false)
"ctf auto" has a "Constant B-factor" parameter that is explained as: Set B-factor to a fixed value, negative value enables autofitting.
"ctf auto" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"ctf auto" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "initial model" can be found in the eman2 plugin.
"initial model" protocol help is as follows:
 
    This protocol wraps *e2initialmodel.py* EMAN2 program.

    It will take a set of class-averages/projections and build a set
    of 3-D models suitable for use as initial models in single
    particle reconstruction. The output set is theoretically sorted
    in order of quality (best one is numbered 1), though it's best
    to look at the other answers as well.

    See more details in:
    http://blake.bcm.edu/emanwiki/EMAN2/Programs/e2initialmodel
    .
"initial model" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"initial model" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"initial model" has a "Input averages" parameter that is explained as: Select the your class averages to build your 3D model.
You can select SetOfAverages or SetOfClasses2D as input.
"initial model" has a "Symmetry group" parameter that is explained as: Specify the symmetry.
Choices are: c(n), d(n), h(n), tet, oct, icos.
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry
for a detailed description of symmetry in Eman.
"initial model" has a "Number of iterations to perform" parameter that is explained as: The total number of refinement to perform.
"initial model" has a "Number of different initial models" parameter that is explained as: The number of different initial models to generate in search of a good one.
"initial model" has a "Shrink factor" parameter that is explained as: Using a box-size >64 is not optimal for making initial models. Suggest using this option to shrink the input particles by an integer amount prior to reconstruction. Default = 1, no shrinking
"initial model" has a "Use random orientations?" parameter that is explained as: Instead of seeding with a random volume, seeds by randomizing input orientations
"initial model" has a "Automask expand (px)" parameter that is explained as: Number of voxels of post-threshold expansion in the mask, for use when peripheral features are truncated (default=shrunk boxsize/20)
"initial model" has a "Additional arguments:" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "e2initialmodel.py -h" will print a list of possible options.
"initial model" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"initial model" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"initial model" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "initial model SGD" can be found in the eman2 plugin.
"initial model SGD" protocol help is as follows:
 
    This protocol wraps *e2initialmodel_sgd.py* EMAN2 program.

    This program makes initial models using a (kind of) stochastic gradient
    descent approach. It is recommended that the box size of
    particles is around 100.
    .
"initial model SGD" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"initial model SGD" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"initial model SGD" has a "Select input type" parameter that is explained as: You can choose either class averages or particles as input.
"initial model SGD" has a "Input averages" parameter that is explained as: Select the class averages to build your 3D model.
You can select SetOfAverages or SetOfClasses2D as input.
"initial model SGD" has a "Input particles" parameter that is explained as: Select the particles to build your 3D model.
"initial model SGD" has a "Symmetry group" parameter that is explained as: Specify the symmetry.
Choices are: c(n), d(n), h(n), tet, oct, icos.
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry
for a detailed description of symmetry in Eman.
"initial model SGD" has a "Batch size" parameter that is explained as: Batch size of stochastic gradient descent. N particles are randomly selected to generate an initial model at each step.
"initial model SGD" has a "Number of iterations to perform" parameter that is explained as: The total number of refinement to perform.
"initial model SGD" has a "Number of different initial models" parameter that is explained as: The number of different initial models to generate in search of a good one.
"initial model SGD" has a "Target resolution (A)" parameter that is explained as: Target resolution in A of the model.
"initial model SGD" has a "Shrink factor" parameter that is explained as: Using a box-size >64 is not optimal for making initial models. Suggest using this option to shrink the input particles by an integer amount prior to reconstruction. Default = 1, no shrinking
"initial model SGD" has a "Learning rate" parameter that is explained as: Learning rate is how much the initial model changes toward the gradient direction in each iteration. Ranges from 0.0 to 1.0. Default is 0.3
"initial model SGD" has a "Learning decay" parameter that is explained as: Learning rate multiplier after each iteration.
"initial model SGD" has a "Add noise" parameter that is explained as: Add noise on particles at each iteration. Stablize convergence for some reason.
"initial model SGD" has a "Full coverage" parameter that is explained as: Assume the input particles covers most of the orientation of the model. This gives better performance when the model is relatively featureless, but is more likely to fail when there are incorrect particles in the input.
"initial model SGD" has a "Write tmp output?" parameter that is explained as: Write output for each iteration.
"initial model SGD" has a "Additional arguments:" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "e2initialmodel_sgd.py -h" will print a list of possible options.
"initial model SGD" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"initial model SGD" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "reconstruct" can be found in the eman2 plugin.
"reconstruct" protocol help is as follows:
 
    This protocol wraps *e2make3d.py* EMAN2 program.

    Reconstructs 3D volumes using a set of 2D images.
    Euler angles are extracted from the 2D image headers
    and symmetry is imposed. Several reconstruction methods
    are available. The fourier method is the default and
    recommended reconstructor.
    .
"reconstruct" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"reconstruct" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"reconstruct" has a "Input particles" parameter that is explained as: Select the input images from the project.
"reconstruct" has a "Skip ctf estimation?" parameter that is explained as: Use this if you want to skip running e2ctf.py. It is not recommended to skip this step unless CTF estimation was already done with EMAN2.
"reconstruct" has a "Use old e2make3d?" parameter that is explained as: Use the traditional e2make3d program instead of the new e2make3dpar program.
"reconstruct" has a "Number of iterations:" parameter that is explained as: Set the number of iterations. Iterative reconstruction improves the overall normalization of the 2D images as they are inserted into the reconstructed volume, and allows for the exclusion of the poorer quality images.
"reconstruct" has a "Symmetry group" parameter that is explained as: Set the symmetry; if no value is given then the model is assumed to have no symmetry. 
Choices are: *i, c, d, tet, icos, or oct* 
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry 
for a detailed description of symmetry in Eman.
"reconstruct" has a "X " parameter that is explained as: None
"reconstruct" has a "Y " parameter that is explained as: None
"reconstruct" has a "X" parameter that is explained as: None
"reconstruct" has a "Y" parameter that is explained as: None
"reconstruct" has a "Z" parameter that is explained as: None
"reconstruct" has a "X" parameter that is explained as: None
"reconstruct" has a "Y" parameter that is explained as: None
"reconstruct" has a "Z" parameter that is explained as: None
"reconstruct" has a "Reconstruction Method:" parameter that is explained as: Reconstructor to use. See e2help.py reconstructors -v 9. Default is fourier:mode=gauss_2.
"reconstruct" has a "Mode to Fourier method:" parameter that is explained as: Fourier pixel insertion mode. See e2help.py reconstructors fourier -v 9. Default mode is gauss_2.
"reconstruct" has a "Sense of keep:" parameter that is explained as: If *percentage* is selected, *keep* parameter will be interpreted as a percentage. It is the default option.
If *standard deviation* is selected, *keep* parameter will be interpreted as a standard deviation coefficient instead of as a percentage.
If *absolute quality* is selected, *keep* parameter will refer to the absolute quality of the class-average, not a local quality relative to other similar sized classes.
"reconstruct" has a "Fraction of slices to keep" parameter that is explained as: The fraction of slices to keep, in fraction, based on quality scores (1.0 = use all slices).
"reconstruct" has a "Disable automatic weighting?" parameter that is explained as: This argument turns automatic weighting off causing all images to be weighted by 1. If this argument is False images inserted into the reconstructed volume are weighted by the number of particles that contributed to them (i.e. as in class averages), which is extracted from the image header.
"reconstruct" has a "Additional parameters" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. See e2make3dpar.py -h.
"reconstruct" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"reconstruct" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "refine easy" can be found in the eman2 plugin.
"refine easy" protocol help is as follows:
 
    This protocol wraps *e2refine_easy.py* EMAN2 program.

This is the primary single particle refinement program in EMAN2.1+.
It replaces earlier programs such as e2refine.py and e2refine_evenodd.py.

Major features of this program:

 * While a range of command-line options still exist. You should not
 normally specify more than a few basic requirements. The rest will
 be auto-selected for you.
 * This program will split your data in half and automatically
 refine the halves independently to produce a gold standard resolution
 curve for every step in the refinement.
 * An HTML report file will be generated as this program runs,
 telling you exactly what it decided to do and why, as well as giving
 information about runtime, etc while the job is still running.
 * The gold standard FSC also permits us to automatically filter the
 structure at each refinement step. The resolution you specify is
 a target, NOT the filter resolution.
    .
"refine easy" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"refine easy" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"refine easy" has a "Continue from a previous run?" parameter that is explained as: If you set to *Yes*, you should select a previous run of type *EmanProtRefine* class and most of the input parameters will be taken from it.
"refine easy" has a "Select previous run" parameter that is explained as: Select a previous run to continue from.
"refine easy" has a "Input particles" parameter that is explained as: Select the input particles.
"refine easy" has a "Initial 3D reference volume" parameter that is explained as: Input 3D reference reconstruction.
"refine easy" has a "Skip ctf estimation?" parameter that is explained as: Use this if you want to skip running e2ctf.py. It is not recommended to skip this step unless CTF estimation was already done with EMAN2.
"refine easy" has a "Number of iterations" parameter that is explained as: The total number of refinement iterations to perform.
"refine easy" has a "Tophat filter?" parameter that is explained as: Instead of imposing a final Wiener filter (tophat = none)), use a tophat filter (global similar to Relion). local determines local resolution and filters. Danger of feature exaggeration.
"refine easy" has a "Symmetry group" parameter that is explained as: Set the symmetry; if no value is given then the model is assumed to have no symmetry. 
Choices are: c(n), d(n), tet, icos, or oct.
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
"refine easy" has a "Break symmetry?" parameter that is explained as: If set True, reconstruction will be asymmetric with *Symmetry group* parameter specifying a known pseudosymmetry, not an imposed symmetry.
"refine easy" has a "Target resolution (A)" parameter that is explained as: Target resolution in A of this refinement run. Usually works best in at least two steps (low/medium) resolution, then final resolution) when starting with a poor starting model. Usually 3-4 iterations is sufficient.
"refine easy" has a "Molecular mass (kDa)" parameter that is explained as: Approximate molecular mass of the particle, in kDa. This is used to run normalize.bymass. Due to resolution effects, not always the true mass.
"refine easy" has a "Use old e2make3d?" parameter that is explained as: Use the traditional e2make3d program instead of the new e2make3dpar program.
"refine easy" has a "Expand mask by (px)" parameter that is explained as: Default=boxsize/20. Specify number of voxels to expand mask before soft edge. Use this if low density peripheral features are cut off by the mask.
"refine easy" has a "Supress phase randomization" parameter that is explained as: Suppress independent phase randomization of input map. Only appropriate if input map has been preprocessed in some suitable fashion.
"refine easy" has a "Speed" parameter that is explained as: Balances speed vs precision. Larger values sacrifice a bit of potential resolution for significant speed increases. Set to 1 when really pushing resolution. Set to 7 for initial refinements.
"refine easy" has a "Fraction of particles to use in final average" parameter that is explained as: The fraction of particles to keep in each class,based on the similarity score.
"refine easy" has a "Fraction of class-averages to use in 3-D map" parameter that is explained as: The fraction of slices to keep in reconstruction.
"refine easy" has a "Use bispectra? (experimental)" parameter that is explained as: Will use bispectra for orientation determination (EXPERIMENTAL).
"refine easy" has a "Use the setsfref option in class averaging?" parameter that is explained as: This matches the filtration of the class-averages to the projections for easier comparison. May also improve convergence. Disabled when ampcorrect=flatten is used.
"refine easy" has a "Do automask to the class-average?" parameter that is explained as: This will apply an automask to the class-average during iterative alignment for better accuracy. The final class averages are unmasked.
"refine easy" has a "Apply threshold before project the volume?" parameter that is explained as: Applies a threshold to the volume just before generating projections. A sort of aggressive solvent flattening for the reference.
"refine easy" has a "Postprocess parameters" parameter that is explained as: <name>:<parm>=<value>:...  An arbitrary processor (e2help.py processors -v2) to apply to the 3-D map after each iteration. Default=none
"refine easy" has a "Amplitude correction:" parameter that is explained as: Will perform amplitude correction via the specified method. 'flatten' requires a target resolution better than 8 angstroms (experimental). 'none' will disable amplitude correction (experimental).
"refine easy" has a "Additional parameters" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. See e2refine_easy.py -h.
"refine easy" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"refine easy" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"refine easy" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "refine 2D" can be found in the eman2 plugin.
"refine 2D" protocol help is as follows:
 
    This protocol wraps *e2refine2d.py* EMAN2 program.

    This program is used to produce reference-free class averages
    from a population of mixed, unaligned particle images. These averages
    can be used to generate initial models or assess the structural
    variability of the data. They are not normally themselves used as part
    of the single particle reconstruction refinement process, which
    uses the raw particles in a reference-based classification
    approach. However, with a good structure, projections of the
    final 3-D model should be consistent with the results of
    this reference-free analysis.

    This program uses a fully automated iterative alignment/MSA approach.
    You should normally target a minimum of 10-20 particles per
    class-average, though more is fine.

    Default parameters should give a good start, but are likely not
    optimal for any given system.

    Note that it does have the --parallel option, but a few steps of the
    iterative process are not parallellised, so don't be surprised if
    multiple cores are not always active.
.
"refine 2D" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"refine 2D" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"refine 2D" has a "Continue from a previous run?" parameter that is explained as: If you set to *Yes*, you should select a previous run of type *EmanProtRefine2D* class. The refinement will resume after the last completed iteration. It is ok to alter other parameters.
"refine 2D" has a "Select previous run" parameter that is explained as: Select a previous run to continue from.
"refine 2D" has a "Input particles" parameter that is explained as: Select the input particles.
"refine 2D" has a "Input class averages" parameter that is explained as: Select starting class averages. If not provided, they will be generated automatically.
"refine 2D" has a "Skip ctf estimation?" parameter that is explained as: Use this if you want to skip running e2ctf.py. It is not recommended to skip this step unless CTF estimation was already done with EMAN2.
"refine 2D" has a "Number of class-averages" parameter that is explained as: Number of class-averages to generate. Normally you would want a minimum of ~10-20 particles per class on average, but it is fine to have 100-200 for a large data set. If you plan on making a large number (>100) of classes, you should use the *Fast seed* option. Note that these averages are not used for final 3-D refinement, so generating a very large number is not useful in most situations.
"refine 2D" has a "Number of iterations" parameter that is explained as: Number of iterations of the overall 2-D refinement process to run. For high contrast data, 4-5 iterations may be more than enough, but for low contrast data it could take 10-12 iterations to converge well.
If running in Continue mode, provide here a number of additional iterations to run.
"refine 2D" has a "Number of MSA vectors to use" parameter that is explained as: Number of MSa basis vectors to use when classifying particles.
"refine 2D" has a "Number of alignment references" parameter that is explained as: The number of alignment references to use in each iteration. You can look at this as the number of different highly distinct views your particle has. With something like GroEL with mostly side views and top views, 3-4 is sufficient. With something like a ribosome something more like 10-15 would be appropriate.
"refine 2D" has a "Normalize projected vectors?" parameter that is explained as: Normalizes each projected vector into the MSA subspace. Note that this is different from normalizing the input images since the subspace is not expected to fully span the image
"refine 2D" has a "Use fast seed?" parameter that is explained as: Will seed the k-means loop quickly, but may produce less consistent results. Always use this when generating >~ 100 classes.
"refine 2D" has a "Automask class-averages?" parameter that is explained as: This will perform a 2-D automask on class-averages to help with centering. May be useful for negative stain data particularly.
"refine 2D" has a "" parameter that is explained as: None
"refine 2D" has a "params" parameter that is explained as: None
"refine 2D" has a "Additional arguments:" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "e2refine2d.py -h" will print a list of possible options.
"refine 2D" has a "These parameters are for advanced users only!
" parameter that is explained as: For help please address to EMAN2 [[http://blake.bcm.edu/emanwiki/EMAN2][Wiki]] or run:
*scipion run e2help.py cmp -v 2* or
*scipion run e2help.py aligners -v 2*
"refine 2D" has a "Shrink particles" parameter that is explained as: Optionally shrink the input particles by an integer amount prior to computing similarity scores. For speed purposes.
"refine 2D" has a "" parameter that is explained as: None
"refine 2D" has a "params" parameter that is explained as: None
"refine 2D" has a "" parameter that is explained as: None
"refine 2D" has a "params" parameter that is explained as: None
"refine 2D" has a "" parameter that is explained as: None
"refine 2D" has a "params" parameter that is explained as: None
"refine 2D" has a "" parameter that is explained as: None
"refine 2D" has a "params" parameter that is explained as: None
"refine 2D" has a "" parameter that is explained as: None
"refine 2D" has a "params" parameter that is explained as: None
"refine 2D" has a "These parameters are for advanced users only!
" parameter that is explained as: For help please address to EMAN2 [[http://blake.bcm.edu/emanwiki/EMAN2][Wiki]] or run:
*scipion run e2help.py cmp -v 2* or
*scipion run e2help.py averagers -v 2*
"refine 2D" has a "Number of iterations for class-averages" parameter that is explained as: Number of iterations to use when making class-averages (default=5)
"refine 2D" has a "Fraction of particles to keep" parameter that is explained as: The fraction of particles to keep in each class, based on the similarity score generated by cmp (default=0.85)
"refine 2D" has a "Keep particles based on sigma?" parameter that is explained as: Change the *keep* criterion from fraction-based to sigma-based
"refine 2D" has a "Filter class-averages?" parameter that is explained as: Use setsfref option in class averaging to produce better class averages
"refine 2D" has a "Class averager: " parameter that is explained as: The averager used to generated class-averages
"refine 2D" has a "" parameter that is explained as: None
"refine 2D" has a "params" parameter that is explained as: None
"refine 2D" has a "" parameter that is explained as: None
"refine 2D" has a "params" parameter that is explained as: The name of a cmp to be used in class averaging (default=ccc)
"refine 2D" has a "" parameter that is explained as: None
"refine 2D" has a "params" parameter that is explained as: None
"refine 2D" has a "" parameter that is explained as: None
"refine 2D" has a "params" parameter that is explained as: None
"refine 2D" has a "" parameter that is explained as: None
"refine 2D" has a "params" parameter that is explained as: None
"refine 2D" has a "" parameter that is explained as: None
"refine 2D" has a "params" parameter that is explained as: None
"refine 2D" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"refine 2D" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"refine 2D" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "refine 2D bispec" can be found in the eman2 plugin.
"refine 2D bispec" protocol help is as follows:
 
    This protocol wraps *e2refine2d_bispec.py* EMAN2 program.

    This program is used to produce reference-free class averages
    from a population of mixed, unaligned particle images. These averages
    can be used to generate initial models or assess the structural
    variability of the data. They are not normally themselves used as part
    of the single particle reconstruction refinement process, which
    uses the raw particles in a reference-based classification
    approach. However, with a good structure, projections of the
    final 3-D model should be consistent with the results of
    this reference-free analysis.

    This variant of the program uses rotational/translational
    invariants derived from the bispectrum of each particle.
.
"refine 2D bispec" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"refine 2D bispec" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"refine 2D bispec" has a "Choose e2ctf auto protocol" parameter that is explained as: Select EMAN CTF auto protocol that has generated bispectra.
"refine 2D bispec" has a "Number of class-averages" parameter that is explained as: Number of class-averages to generate. Normally you would want a minimum of ~10-20 particles per class on average, but it is fine to have 100-200 for a large data set. If you plan on making a large number (>100) of classes, you should use the *Fast seed* option. Note that these averages are not used for final 3-D refinement, so generating a very large number is not useful in most situations.
"refine 2D bispec" has a "Number of MSA vectors to use" parameter that is explained as: Number of MSa basis vectors to use when classifying particles.
"refine 2D bispec" has a "Normalize projected vectors?" parameter that is explained as: Normalizes each projected vector into the MSA subspace. Note that this is different from normalizing the input images since the subspace is not expected to fully span the image
"refine 2D bispec" has a "Align and sort?" parameter that is explained as: This will align and sort the final class-averages based on mutual similarity.
"refine 2D bispec" has a "" parameter that is explained as: None
"refine 2D bispec" has a "params" parameter that is explained as: None
"refine 2D bispec" has a "Additional arguments:" parameter that is explained as: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "e2refine2d_bispec.py -h" will print a list of possible options.
"refine 2D bispec" has a "These parameters are for advanced users only!
" parameter that is explained as: For help please address to EMAN2 [[http://blake.bcm.edu/emanwiki/EMAN2][Wiki]] or run:
*scipion run e2help.py cmp -v 2* or
*scipion run e2help.py averagers -v 2*
"refine 2D bispec" has a "Number of iterations for class-averages" parameter that is explained as: Number of iterations to use when making class-averages (default=5)
"refine 2D bispec" has a "Fraction of particles to keep" parameter that is explained as: The fraction of particles to keep in each class, based on the similarity score generated by cmp (default=0.8)
"refine 2D bispec" has a "Keep particles based on sigma?" parameter that is explained as: Change the *keep* criterion from fraction-based to sigma-based
"refine 2D bispec" has a "Class averager: " parameter that is explained as: The averager used to generated class-averages
"refine 2D bispec" has a "" parameter that is explained as: None
"refine 2D bispec" has a "params" parameter that is explained as: None
"refine 2D bispec" has a "" parameter that is explained as: None
"refine 2D bispec" has a "params" parameter that is explained as: The name of a cmp to be used in class averaging (default=ccc)
"refine 2D bispec" has a "" parameter that is explained as: None
"refine 2D bispec" has a "params" parameter that is explained as: None
"refine 2D bispec" has a "" parameter that is explained as: None
"refine 2D bispec" has a "params" parameter that is explained as: None
"refine 2D bispec" has a "" parameter that is explained as: None
"refine 2D bispec" has a "params" parameter that is explained as: None
"refine 2D bispec" has a "" parameter that is explained as: None
"refine 2D bispec" has a "params" parameter that is explained as: None
"refine 2D bispec" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"refine 2D bispec" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"refine 2D bispec" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tilt validate" can be found in the eman2 plugin.
"tilt validate" protocol help is as follows:
 
    This protocol wraps the *e2tiltvalidate.py* EMAN2 program.
    It performs tilt validation using
    the method described in Rosenthal and Henderson, JMB (2003).
    .
"tilt validate" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"tilt validate" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"tilt validate" has a "Input volume" parameter that is explained as: Select the input volume that will be validated.
"tilt validate" has a "Input tilt pair particles" parameter that is explained as: Select the input set of tilt pair particles.
"tilt validate" has a "Symmetry group" parameter that is explained as: Set the symmetry; if no value is given then the model is assumed to have no symmetry. 
Choices are: *i, c, d, tet, icos, or oct* 
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry
for a detailed description of symmetry in Eman.
"tilt validate" has a "Max tilt angle" parameter that is explained as: Maximum tilt angle permitted when finding tilt distances.
"tilt validate" has a "Use quaternions" parameter that is explained as: Use quaternions for tilt distance computation
"tilt validate" has a "Projection step (deg.)" parameter that is explained as: Angular step size for alignment
"tilt validate" has a "Shrink particles" parameter that is explained as: Optionally shrink the input particles by an integer amount prior to computing similarity scores. For speed purposes.
"tilt validate" has a "Do contour plot?" parameter that is explained as: Also make a contour plot similar to fig. 6 in Henderson paper
"tilt validate" has a "Tilt range" parameter that is explained as: The angular tilt range to search
"tilt validate" has a "Verbose level" parameter that is explained as: Verbose level from 0 to 9. 
"tilt validate" has a "These parameters are for advanced users only!
" parameter that is explained as: For help please address to EMAN2 [[http://blake.bcm.edu/emanwiki/EMAN2][Wiki]] or run:
*e2help.py cmp -v 2* or
*e2help.py aligners -v 2*
"tilt validate" has a "type" parameter that is explained as: None
"tilt validate" has a "params" parameter that is explained as: None
"tilt validate" has a "type" parameter that is explained as: None
"tilt validate" has a "params" parameter that is explained as: None
"tilt validate" has a "type" parameter that is explained as: None
"tilt validate" has a "params" parameter that is explained as: None
"tilt validate" has a "type" parameter that is explained as: None
"tilt validate" has a "params" parameter that is explained as: None
"tilt validate" has a "type" parameter that is explained as: None
"tilt validate" has a "params" parameter that is explained as: None
"tilt validate" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"tilt validate" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "bin tomograms" can be found in the dynamo plugin.
"bin tomograms" protocol help is as follows:
 Reduce the size of a SetOfTomograms by a binning factor.
"bin tomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"bin tomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"bin tomograms" has a "Input Tomograms" parameter that is explained as: None
"bin tomograms" has a "Binning Factor" parameter that is explained as: A Binning Factor of 1 means that no binning will be carried out.
"bin tomograms" has a "Number of slices kept in memory" parameter that is explained as: Maximum number of Z slices that are kept simultaneously in the memory during the binning process. This parameter might be important for larger size tomograms, making possible to process them in vertical slabs of thickness = value introduced in the  current parameter. This procedure can be accelerated using the multiple threads to engage several cores in parallel. However, this will only make sense if the total memory occupied by all the slabs simultaneously in memory in a given time fits in the RAM of the machine.
"bin tomograms" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"bin tomograms" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "vectorial picking" can be found in the dynamo plugin.
"vectorial picking" protocol help is as follows:
 Manual vectorial picker from Dynamo. After choosing the Tomogram to be picked, the tomo slicer from Dynamo will
     be direclty loaded with all the models previously saved in the disk (if any).
     This picking will save the "user points" defined in a set of models and generate a set of meshes with them. In case
     the user carries out the workflow model for each of the models from the Dynamo GUI, a set of coordinates will be
     also created, containing all the interpolated coordinates, and the calculated orientation. It is possible to
     create several models at once in a given tomogram. Once the coordinates are defined, the models are automatically
     saved in the catalogue and registered..
"vectorial picking" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"vectorial picking" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"vectorial picking" has a "Input Tomograms" parameter that is explained as: Select the Tomogram to be used during picking.
"vectorial picking" has a "Box Size" parameter that is explained as: None
"vectorial picking" has a "Remove the .m files generated after the execution?" parameter that is explained as: It can be useful for developers to check exactly what was .m files were generated by Scipion and executed by Dynamo.

The protocol named "subtomogram extraction" can be found in the dynamo plugin.
"subtomogram extraction" protocol help is as follows:
 Extraction of subtomograms using Dynamo.
"subtomogram extraction" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"subtomogram extraction" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"subtomogram extraction" has a "Input Coordinates" parameter that is explained as: None
"subtomogram extraction" has a "Tomogram source" parameter that is explained as: By default the subtomograms will be extracted from the tomogram used in the picking step ( _same as picking_ option ).
If you select _other_ option, you must provide a different tomogram to extract from.
*Note*: In the _other_ case, ensure that provided tomogram and coordinates are related 
"subtomogram extraction" has a "Input tomogram" parameter that is explained as: Select the tomogram from which to extract.
"subtomogram extraction" has a "Box size" parameter that is explained as: The subtomograms are extracted as a cubic box of this size. The wizard will select the box size considering the sampling rate ratio between the introduced coordinates and the tomograms that will br used for the extraction.
"subtomogram extraction" has a "Invert contrast?" parameter that is explained as: Invert the contrast if your tomogram is black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background.
"subtomogram extraction" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"subtomogram extraction" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "import subtomograms from tbl files" can be found in the dynamo plugin.
"import subtomograms from tbl files" protocol help is as follows:
  This protocol imports subtomograms with metadata generated from Dynamo tables.
    The subtomograms files are generated in the same directory as the .tbl file, one for each tomogram..
"import subtomograms from tbl files" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import subtomograms from tbl files" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import subtomograms from tbl files" has a "" parameter that is explained as: Select the type of import.
"import subtomograms from tbl files" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import subtomograms from tbl files" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import subtomograms from tbl files" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import subtomograms from tbl files" has a "Tomograms (opt.)" parameter that is explained as: If not provided, the subtomograms won't be referred to any tomogram. If provided, the sampling rate value will be read from them.
"import subtomograms from tbl files" has a "Sampling rate [Å/px] (opt.)" parameter that is explained as: None

The protocol named "model workflow" can be found in the dynamo plugin.
"model workflow" protocol help is as follows:
 
    Apply a model workflow to a SetOfMeshes generated by Dynamo Boxing protocol.
    This workflow will use the models created by the user to create the
    corresponding cropping meshes needed to extract the crop points.
    Considerations:
        1. The geometry will be automatically approximated from the clicked points.
        2. The meshes for the general models will be calculated treating them as surface models.
    .
"model workflow" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"model workflow" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"model workflow" has a "Input Meshes" parameter that is explained as: Input Meshes that will be used to create the cropping geometry and to extract the crop points
"model workflow" has a "Box size" parameter that is explained as: None
"model workflow" has a "Mesh parameter" parameter that is explained as: Intended mesh parameter for the "mesh" that supports the depiction of the model. It governs the number or triangles.
"model workflow" has a "Maximun number of triangles" parameter that is explained as: Maximum number of triangles allowed during generation of a depiction mesh
"model workflow" has a "Refine mesh?" parameter that is explained as: If set to Yes, it will refine both the mesh and the cropped mesh, which means that the depiction grid will be subdivided (each triangle will generate four children). Hence, a higher number of points will be generated, but the computation time will be significantly increased.
"model workflow" has a "Subdivision iterations" parameter that is explained as: Specify the number of times the Mesh geometry will be subdivided. This will increase the number of triangles in the mesh, making it smoother. However, it will also increase the number of cropping points
"model workflow" has a "Cropping parameter" parameter that is explained as: Intended mesh parameter for the "crop_mesh" that defined a cropping geometry on a surface

The protocol named "Average subtomograms" can be found in the dynamo plugin.
"Average subtomograms" protocol help is as follows:
 None.
"Average subtomograms" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Average subtomograms" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Average subtomograms" has a "Subtomograms" parameter that is explained as: None
"Average subtomograms" has a "Do implicit rotation masking? (opt.)" parameter that is explained as: If set to Yes, in the rotated particles, the material outside a spherical mask will not be computed. The particles will de facto appear with a spherical mask.
"Average subtomograms" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Average subtomograms" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Subtomogram alignment" can be found in the dynamo plugin.
"Subtomogram alignment" protocol help is as follows:
 This protocol will align subtomograms using Dynamo.
"Subtomogram alignment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Subtomogram alignment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Subtomogram alignment" has a "" parameter that is explained as: This protocol has both CPU and GPU implementation. Select the one you want to use.
"Subtomogram alignment" has a "" parameter that is explained as: Add a list of GPU devices that can be used
"Subtomogram alignment" has a "Set of subtomograms" parameter that is explained as: Set of subtomograms to align with dynamo
"Subtomogram alignment" has a "Template" parameter that is explained as: The size of the template should be equal or smaller than the size of the particles.
"Subtomogram alignment" has a "Iterations (R)" parameter that is explained as: Number of iterations per round (R). Used to identify the number of rounds desired to be carried out.
"Subtomogram alignment" has a "Particle dimensions (R)" parameter that is explained as: If only one round, leave 0 to use the size of your particle. If working with multiple rounds, the size of the particles for each round is expected to be explicitly specified. If not, the size of the input particles will be used for all the rounds. This option can be used, for example, to reduce the particles size for a particular round and increase the speed. E.g.: 64 128 128.
"Subtomogram alignment" has a "Launch dynamo GUI" parameter that is explained as: Launches Dynamo's alignment project GUI. Do not 'Run' the project, Scipion will do it for you.
"Subtomogram alignment" has a "Alignment mask (opt)" parameter that is explained as: This is the MOST important mask from the different types that can be used by Dynamo. It is used for the local correlation. The template is rotated and shifted (virtually, through fourier acceleration). At each posible combination of rotation angles and shift, the mask is also rotated and shifted, defining a moving region inside the template. The rotated and shifted template is compared to the data particle only inside this moving region. See more details in https://wiki.dynamo.biozentrum.unibas.ch/w/index.php/Alignment_mask.
"Subtomogram alignment" has a "Fourier mask on template (opt)" parameter that is explained as: Used in very few special cases. The Fourier Mask that you define on a template during an alignment project describes the Fourier content of the template, not the one of the data particles. It does not reflect directly the missing wedge of the tomogram. See more details in https://wiki.dynamo.biozentrum.unibas.ch/w/index.php/Fourier_mask_on_template.
"Subtomogram alignment" has a "Fourier Shell Correlation mask (opt)" parameter that is explained as: Used in the context of adaptive bandpass filtering. This procedure needs an automatic evaluation of the attained resolution at each iteration step. This is performed through and FSC computation of the averages computed independently in the different channels of the odd/even computation. See more details in https://wiki.dynamo.biozentrum.unibas.ch/w/index.php/Smoothing_mask
"Subtomogram alignment" has a "Cone aperture (R)" parameter that is explained as: The ‘cone_’ parameters define a set of orientations that will be sampled around a previously determined old orientation. Here we speak of orientations of the vertical axis of the template, not full unconstrained rotations. Allowing this axis to move inside a cone involves only two Euler angles (tdrot and tilt).

‘cone_range’, is the extent of this cone in degrees (360 being the full possible range of axis orientations).
"Subtomogram alignment" has a "Cone sampling (R)" parameter that is explained as: The ‘cone_’ parameters define a set of orientations that will be sampled around a previously determined old orientation. Here we speak of orientations of the vertical axis of the template, not full unconstrained rotations. Allowing this axis to move inside a cone involves only two Euler angles (tdrot and tilt).

’cone_sampling’ is the step inside the cone defined by ´cone_range´, also in degrees. The orientations are generated so as to provide an uniform coverage.
"Subtomogram alignment" has a "Cone flip (R)" parameter that is explained as: Generates a mirrored scanning geometry: the "cone" of directions is complemented with the diametrally oposed cone.
This is useful when averaging elongated particles in the case in which the direction of each one is not certain, i.e., the initial table catches the overall orientation of each particle, but it is not certain on which end is the "head" and which is the "tail", so that the refinement should allow "flippling" the particles (but still produce a scanning set of angles concentrated along the axis of the particle). Values:

	* 0:  No inversion of the cone (default!)
	* 1:  The cone is inverted only for the coarsest level of the multigrid refinement
	* 2:  The cone is inverted for all refinement levels
"Subtomogram alignment" has a "Azimuth rotation range (R)" parameter that is explained as: The ‘inplane_’ parameters complete the set of scanned Euler triplets. After each of the axis reorentations defined by the ‘cone_’ parameters, the template will be rotated about the new orientation of its axis. This involves only the ‘narot’ angle.

‘inplane_range’ defines the angular interval to be scanned around the old value of narot.
"Subtomogram alignment" has a "Azimuth rotation sampling (R)" parameter that is explained as: The ‘inplane_’ parameters complete the set of scanned Euler triplets. After each of the axis reorentations defined by the ‘cone_’ parameters, the template will be rotated about the new orientation of its axis. This involves only the ‘narot’ angle.

The project parameter ‘inplane_range’ defines the angular interval to be scanned around the old value of narot, and ‘inplane_sampling’ defines the interval.
"Subtomogram alignment" has a "Azimuth flip (R)" parameter that is explained as: Flips the set of inplane rotations.
The set of inplane rotations to scan will be the original set plus the flipped orientations.
This is useful when the particles have a directionality, but it is not very well defined. For instance, if you have decorations on a microtubule, you might expect that most of them will have similar orientations along the direction of the tube. However, this direction might not be obvious: if you have particles coming from two different tubes, reducing the span of azimuthal rotations to a narrow set along the estimated direction of the tube might be dangerous, as the particles from the two tubes might be oriented in different directions.Values:

	* 0  :  no flip (default).
	* 1  :  flips the coarsest level  in the multilevel grid.
	* 2  :  flips the full set (all levels).
"Subtomogram alignment" has a "Refine iterations per particle (R)" parameter that is explained as: How many refinement iterations are carried out on each single particle. This refinement when comparing rotations of the reference against the data, takes the best orientation and looks again with a finer sampling. The sampling in the refined search will be half of the sampling used in the original one.  The range of the refined search encompasses all the orientations that neighobur the best orientation found in the original search.
"Subtomogram alignment" has a "Refine factor (R)" parameter that is explained as: Controls the size of the angular neighborhood during the local refinement of the angular grid.
"Subtomogram alignment" has a "Shift limits (R)" parameter that is explained as: Restricts the search area to an sphere of the given radius centered and oriented in the last found position (Ellipsoid will be implemented soon).
"Subtomogram alignment" has a "Shift limiting way (R)" parameter that is explained as: States how exactly the shifts (area search) will be interpreted:

	* 0:  no limitations (can easily produce artifacts if the initial reference is bad).
	* 1:  limits are understood from the center of the particle cube.
	* 2:  limits are understood from the previous estimation on the particle position (i.e., the shifts available) With this option, the origin of the shifts changes at every iteration.
	* 3:  limis are understood from the estimation provided for the first iteration of the round. The origin of the shifts will change at each round.
	* 4:  limis are understood from the estimation provided for the first iteration of the project. The origin of the shifts is thus defined for the full project, and stays static all during the full computation.

Note that options 3 and 4 are useful to avoid particles gradually shifting away from the initially user-entered locations.
"Subtomogram alignment" has a "Separation in tomogram [pix.] (R)" parameter that is explained as: When tuned to  positive number, it will check the relative positions (positions in the tomogram+shifts) of all the particles in each tomogram separately. Whenever two particles are closer together than "separation_in_tomogram", only the particle with the higher correlation will stay.
"Subtomogram alignment" has a "Threshold parameter (R)" parameter that is explained as: Different thresholding policies can be used in order to select which particles are averaged in view of their CC (cross correlation value) . The value of the thresholding parameter defined here  will be interpreted differently depending on the "threshold_modus"
"Subtomogram alignment" has a "Threshold modus (R)" parameter that is explained as: Specify which particles contribute to the average at the end of each iteration. Different thresholding policies can be used to select particles according to their CC value. Thus value of the "threshold" parameter you input  (denoted as THRESHOLD below) will be interpreted differently depending on the "threshold_modus" defined here.

Possible values of the thresholding policy "threshold_modus":

	* 0: no thresholding policy
	* 1: THRESHOLD is an absolute threshold (only particles with CC above this value are selected).
	* 2: effective threshold = mean(CC) * THRESHOLD.
	* 3: effective threshold = mean(CC) + std(CC) * THRESHOLD.
	* 4: THRESHOLD is the total number of particles (ordered by CC ).
	* 5: THRESHOLD ranges between 0 and 1  and sets the fraction of particles.
"Subtomogram alignment" has a "Second threshold parameter (R)" parameter that is explained as: Thresholding II is operated against the average produced by the particles that survivedthe first thresholding.
"Subtomogram alignment" has a "Second threshold modus (R)" parameter that is explained as: Thresholding II is operated against the average produced by the particles that survived the first thresholding. It uses the same syntax as Threshold I
"Subtomogram alignment" has a "High pass (R)" parameter that is explained as: Cut off frequency for high pass filtering. The units are pixels in the Fourier space of the particle (if your template is smaller than the data, the bandpass parameters will be rescaled). The bandpass works with a soft mask, allowing a smoothing window of two pixels around the cut frequency.
"Subtomogram alignment" has a "Low frequency (R)" parameter that is explained as: Cut off frequency for low pass filtering. The units are pixels in the Fourier space of the particle (if your template is smaller than the data, the bandpass parameters will be rescaled). The bandpass works with a soft mask, allowing a smothing window of two pixels around the cut frequency.
"Subtomogram alignment" has a "Symmetry group (R)" parameter that is explained as: Symmetrization is applied at the beginning of the round to the input reference. It is also used during the computation of the [eo_fsc] or the iteration.
First chars in string indicate thetype of symmetry operator:

	* 'c'  rotational symmetry around z.
	* 'h'  helical symmetry around z  (parameters: dpsi; dz).
	* 'ico'  icosahedral symmetry.
	* 'cbo' for cuboctahedral symmetry.
The rest of the string contains the respective parameters. Examples: 'c1', 'h60,5' ,'h[60,5]','h[-60,5]'
"Subtomogram alignment" has a "Cross-correlation matrix batch" parameter that is explained as: Number of particles to be kept in memory simultaneously during the computation of the ccmatrix. The larger this number, the more efficient the algorithm performance, as more computations can be kept for reuse.However, trying to keep all the particles in memory can lead to saturate it,blocking the CPU. Additionally, a small batch allows to divide the matrix in more blocks. This might be useful in parallel computations.
"Subtomogram alignment" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Subtomogram alignment" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "ctffind4" can be found in the cistem plugin.
"ctffind4" protocol help is as follows:
  Estimate CTF for a set of micrographs with ctffind4.
    
    To find more information about ctffind4 visit:
    https://grigoriefflab.umassmed.edu/ctffind4
    .
"ctffind4" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"ctffind4" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"ctffind4" has a "Do recalculate ctf?" parameter that is explained as: None
"ctffind4" has a "Input previous run" parameter that is explained as: None
"ctffind4" has a "" parameter that is explained as: None
"ctffind4" has a "" parameter that is explained as: None
"ctffind4" has a "Input micrographs" parameter that is explained as: None
"ctffind4" has a "Input movies" parameter that is explained as: None
"ctffind4" has a "No. movie frames to average" parameter that is explained as: When estimating parameters from movie frames, enter how many frames should be included in the sub-averages used to calculate the amplitude spectra.
"ctffind4" has a "Use power spectra?" parameter that is explained as: If set to Yes, the CTF estimation will be done using power spectra calculated during Relion motion correction.
"ctffind4" has a "FFT box size (px)" parameter that is explained as: The dimensions (in pixels) of the amplitude spectrum CTFfind will compute. Smaller box sizes make the fitting process significantly faster, but sometimes at the expense of fitting accuracy. If you see warnings regarding CTF aliasing, consider increasing this parameter.
"ctffind4" has a "Min" parameter that is explained as: None
"ctffind4" has a "Max" parameter that is explained as: None
"ctffind4" has a "Min" parameter that is explained as: None
"ctffind4" has a "Max" parameter that is explained as: None
"ctffind4" has a "Defocus step (A)" parameter that is explained as: Step size for the defocus search.
"ctffind4" has a "Slower, more exhaustive search?" parameter that is explained as: Select this option if CTF determination fails on images that show clear Thon rings and should therefore yield good CTF parameters, or if you expect noticeably elliptical Thon rings and high noise.
"ctffind4" has a "Restrain astigmatism?" parameter that is explained as: Should the amount of astigmatism be restrained during the parameter search and refinement? This option should be selected when astigmatism is expected to be small to produce more reliable fits. Disable this option if you expect large astigmatism.
"ctffind4" has a "Tolerated astigmatism (A)" parameter that is explained as: When restraining astigmatism, astigmatism values much larger than this will be penalized. Set to negative to remove this restraint. In cases where the amplitude spectrum is very noisy, such a restraint can help achieve more accurate results.
"ctffind4" has a "Find additional phase shift?" parameter that is explained as: Was the data recorded using a phase plate with variable phase shift that must be determined together with the defocus parameters?
"ctffind4" has a "Minimum phase shift (deg)" parameter that is explained as: If finding an additional phase shift, this value sets the lower bound for the search.
"ctffind4" has a "Maximum phase shift (deg)" parameter that is explained as: If finding an additional phase shift, this value sets the upper bound for the search.
"ctffind4" has a "Phase shift search step (deg)" parameter that is explained as: If finding an additional phase shift, this value sets the step size for the search.
"ctffind4" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"ctffind4" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"ctffind4" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"ctffind4" has a "The following params are related to how streaming is done in Scipion." parameter that is explained as: None
"ctffind4" has a "Sleep when waiting (secs)" parameter that is explained as: If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
"ctffind4" has a "Batch size" parameter that is explained as: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.

The protocol named "find particles" can be found in the cistem plugin.
"find particles" protocol help is as follows:
  Protocol to pick particles (ab-initio or reference-based) using cisTEM. .
"find particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"find particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"find particles" has a "Input Micrographs" parameter that is explained as: Select the SetOfMicrographs to be used during picking.
"find particles" has a "CTF estimation" parameter that is explained as: Choose some CTF estimation related to the input micrographs.
"find particles" has a "Picking algorithm" parameter that is explained as: None
"find particles" has a "Input references" parameter that is explained as: Provide a set of 2D templates to use in the search.
"find particles" has a "Max particle radius (A)" parameter that is explained as: In Angstroms, the maximum radius of the particles to be found. This also determines the minimum distance between picks.
"find particles" has a "Characteristic particle radius (A)" parameter that is explained as: In Angstroms, the radius within which most of the density is enclosed. The template for picking is a soft-edge disc, where the edge is 5 pixels wide and this parameter defines the radius at which the cosine-edge template reaches 0.5.
"find particles" has a "Threshold peak height" parameter that is explained as: Particle coordinates will be defined as the coordinates of any peak in the search function which exceeds this threshold. In numbers of standard deviations above expected noise variations in the scoring function. See Sigworth (2004) for definition.
"find particles" has a "Avoid high variance areas" parameter that is explained as: Avoid areas with abnormally high local variance. This can be effective in avoiding edges of support films or contamination.
"find particles" has a "Particles are white on a dark background?" parameter that is explained as: None
"find particles" has a "Highest resolution used in picking (A)" parameter that is explained as: The template and micrograph will be resampled (by Fourier cropping) to a pixel size of half the resolution given here. Note that the information in the corners of the Fourier transforms (beyond the Nyquist frequency) remains intact, so that there is some small risk of bias beyond this resolution.
"find particles" has a "Minimum distance from edges (px)" parameter that is explained as: No particle shall be picked closer than this distance from the edges of the micrograph. In pixels.
"find particles" has a "Use radial averages of templates" parameter that is explained as: Say yes if the templates should be rotationally averaged
"find particles" has a "Rotate each template this many times" parameter that is explained as: If > 0, each template image will be rotated this number of times and the micrograph will be searched for the rotated template.
"find particles" has a "Avoid areas with abnormal local mean" parameter that is explained as: Avoid areas with abnormally low or high local mean. This can be effective to avoid picking from, e.g., contaminating ice crystals, support film.
"find particles" has a "Number of background boxes" parameter that is explained as: Number of background areas to use in estimating the background spectrum. The larger the number of boxes, the more accurate the estimate should be, provided that none of the background boxes contain any particles to be picked.
"find particles" has a "Algorithm to find background areas" parameter that is explained as: Testing so far suggests that areas of lowest variance in experimental micrographs should be used to estimate the background spectrum. However, when using synthetic micrographs this can lead to bias in the spectrum estimation and the alternative (areas with local variances near the mean of the distribution of local variances) seems to perform better
"find particles" has a "The following params are related to how streaming is done in Scipion." parameter that is explained as: None
"find particles" has a "Sleep when waiting (secs)" parameter that is explained as: If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
"find particles" has a "Batch size" parameter that is explained as: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
"find particles" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"find particles" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"find particles" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "classify 2D" can be found in the cistem plugin.
"classify 2D" protocol help is as follows:
  Protocol to run 2D classification in cisTEM. .
"classify 2D" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"classify 2D" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"classify 2D" has a "Continue from a previous run?" parameter that is explained as: If you set to *Yes*, you should select a previous run of type *CistemProtRefine2D* class. The refinement will resume after the last completed iteration. It is ok to alter other parameters.
"classify 2D" has a "Select previous run" parameter that is explained as: Select a previous run to continue from.
"classify 2D" has a "Continue from iteration" parameter that is explained as: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
"classify 2D" has a "Input particles" parameter that is explained as: Select the input particles.
"classify 2D" has a "Input class averages" parameter that is explained as: Select starting class averages. If not provided, they will be generated automatically.
"classify 2D" has a "Are the particles black?" parameter that is explained as: cisTEM requires particles to be black on white.
"classify 2D" has a "Number of classes" parameter that is explained as: The number of classes that should be generated. This input is only available when starting a fresh classification run.
"classify 2D" has a "Number of cycles ro run" parameter that is explained as: The number of refinement cycles to run. If the option "Auto Percent Used" is selected, 20 cycles are usually sufficient to generate good class averages. If the user decides to set parameters manually, 5 to 10 cycles are usually sufficient for a particular set of parameters. Several of these shorter runs should be used to obtain final class averages, updating parameters as needed (e.g. Percent Used, see example above).
"classify 2D" has a "Low resolution limit (A)" parameter that is explained as: The data used for classification is usually bandpass-limited to exclude spurious low-resolution features in the particle background. It is therefore good practice to set the low-resolution limit to 2.5x the approximate particle mask radius.
"classify 2D" has a "start" parameter that is explained as: None
"classify 2D" has a "finish" parameter that is explained as: None
"classify 2D" has a "Mask radius (A)" parameter that is explained as: The radius of the circular mask applied to the input class averages before classification starts. This mask should be sufficiently large to include the largest dimension of the particle. The mask helps remove noise outside the area of the particle.
"classify 2D" has a "Angular search step (deg)" parameter that is explained as: The angular step used to generate the search grid when marginalizing over the in-plane rotational alignment parameter. The smaller the value, the finer the search grid and the slower the search. It is often sufficient to set the step to 15deg as the algorithm varies the starting point of the grid in each refinement cycle, thereby covering intermediate in-plane alignment angles. However, users can try to reduce the step to 5deg (smaller is probably not helpful) to see if class averages can be improved further once no further improvement is seen at 15deg.
"classify 2D" has a "X" parameter that is explained as: None
"classify 2D" has a "Y" parameter that is explained as: None
"classify 2D" has a "Smoothing factor [0-1]" parameter that is explained as: A factor that reduces the range of likelihoods used during classification. A reduced range can help prevent the appearance of "empty" classes (no members) early in the classification. Smoothing may also suppress some high-resolution noise. The user should try values between 0.1 and 1 if classification suffers from the disappearance of small classes or noisy class averages.
"classify 2D" has a "Exclude blank edges?" parameter that is explained as: Should particle boxes with blank edges be excluded from classification? Blank edges can be the result of particles selected close to the edges of micrographs. Blank edges can lead to errors in the calculation of the likelihood function, which depends on the noise statistics.
"classify 2D" has a "Auto percent used?" parameter that is explained as: Should the percent of included particles be adjusted automatically? A classification scheme using initially 300 particles/class, then 30% and then 100% is often sufficient to obtain good classes and this scheme will be used when this option is selected.
"classify 2D" has a "Percent used" parameter that is explained as: The fraction of the dataset used for classification. Especially in the beginning, classification proceeds more rapidly when only a small number of particles are used per class, e.g. 300 (see example above). Later runs that refine the class averages should use a higher percentage and the final run(s) should use all the data. This option is only available when "Auto Percent Used" is not selected.
"classify 2D" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"classify 2D" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "resample tomogram" can be found in the cistem plugin.
"resample tomogram" protocol help is as follows:
 
    Resample tomograms by Fourier cropping/padding using cisTEM. This is equivalent to binning/unbinning operations but free of aliasing artifacts.

    More info:
        https://cistem.org
    .
"resample tomogram" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"resample tomogram" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"resample tomogram" has a "Input tomograms" parameter that is explained as: None
"resample tomogram" has a "New X-Size" parameter that is explained as: Volume will be rescaled to this size in X dimension (voxels)
"resample tomogram" has a "New Y-Size" parameter that is explained as: Volume will be rescaled to this size in Y dimension (voxels)
"resample tomogram" has a "New Z-Size" parameter that is explained as: Volume will be rescaled to this size in Z dimension (voxels)

The protocol named "tilt-series ctffind4" can be found in the cistem plugin.
"tilt-series ctffind4" protocol help is as follows:
  CTF estimation on a set of tilt series using CTFFIND4. .
"tilt-series ctffind4" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"tilt-series ctffind4" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"tilt-series ctffind4" has a "Input tilt series" parameter that is explained as: None
"tilt-series ctffind4" has a "" parameter that is explained as: None
"tilt-series ctffind4" has a "" parameter that is explained as: None
"tilt-series ctffind4" has a "" parameter that is explained as: None
"tilt-series ctffind4" has a "" parameter that is explained as: None
"tilt-series ctffind4" has a "FFT box size (px)" parameter that is explained as: The dimensions (in pixels) of the amplitude spectrum CTFfind will compute. Smaller box sizes make the fitting process significantly faster, but sometimes at the expense of fitting accuracy. If you see warnings regarding CTF aliasing, consider increasing this parameter.
"tilt-series ctffind4" has a "Min" parameter that is explained as: None
"tilt-series ctffind4" has a "Max" parameter that is explained as: None
"tilt-series ctffind4" has a "Min" parameter that is explained as: None
"tilt-series ctffind4" has a "Max" parameter that is explained as: None
"tilt-series ctffind4" has a "Defocus step (A)" parameter that is explained as: Step size for the defocus search.
"tilt-series ctffind4" has a "Slower, more exhaustive search?" parameter that is explained as: Select this option if CTF determination fails on images that show clear Thon rings and should therefore yield good CTF parameters, or if you expect noticeably elliptical Thon rings and high noise.
"tilt-series ctffind4" has a "Restrain astigmatism?" parameter that is explained as: Should the amount of astigmatism be restrained during the parameter search and refinement? This option should be selected when astigmatism is expected to be small to produce more reliable fits. Disable this option if you expect large astigmatism.
"tilt-series ctffind4" has a "Tolerated astigmatism (A)" parameter that is explained as: When restraining astigmatism, astigmatism values much larger than this will be penalized. Set to negative to remove this restraint. In cases where the amplitude spectrum is very noisy, such a restraint can help achieve more accurate results.
"tilt-series ctffind4" has a "Find additional phase shift?" parameter that is explained as: Was the data recorded using a phase plate with variable phase shift that must be determined together with the defocus parameters?
"tilt-series ctffind4" has a "Minimum phase shift (deg)" parameter that is explained as: If finding an additional phase shift, this value sets the lower bound for the search.
"tilt-series ctffind4" has a "Maximum phase shift (deg)" parameter that is explained as: If finding an additional phase shift, this value sets the upper bound for the search.
"tilt-series ctffind4" has a "Phase shift search step (deg)" parameter that is explained as: If finding an additional phase shift, this value sets the step size for the search.
"tilt-series ctffind4" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"tilt-series ctffind4" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"tilt-series ctffind4" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "resample tilt series" can be found in the cistem plugin.
"resample tilt series" protocol help is as follows:
 
    Resample tilt series by Fourier cropping/padding using cisTEM. This is equivalent to binning/unbinning operations but free of aliasing artifacts.

    More info:
        https://cistem.org
    .
"resample tilt series" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"resample tilt series" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"resample tilt series" has a "Input tilt series" parameter that is explained as: None
"resample tilt series" has a "New X-Size" parameter that is explained as: Volume will be rescaled to this size in X dimension (voxels)
"resample tilt series" has a "New Y-Size" parameter that is explained as: Volume will be rescaled to this size in Y dimension (voxels)

The protocol named "unblur" can be found in the cistem plugin.
"unblur" protocol help is as follows:
  This protocol wraps unblur movie alignment program. .
"unblur" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"unblur" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"unblur" has a "Input Movies" parameter that is explained as: Select a set of previously imported movies.
"unblur" has a "" parameter that is explained as: None
"unblur" has a "" parameter that is explained as: None
"unblur" has a "from" parameter that is explained as: None
"unblur" has a "to" parameter that is explained as: None
"unblur" has a "Binning factor" parameter that is explained as: 1x or 2x. Bin stack before processing.
"unblur" has a "Compute PSD?" parameter that is explained as: If Yes, the protocol will compute for each aligned micrograph the PSD using EMAN2.
"unblur" has a "Compute micrograph thumbnail?" parameter that is explained as: When using this option, we will compute a micrograph thumbnail with EMAN2 and keep it with the micrograph object for visualization purposes. 
"unblur" has a "Additional protocol parameters" parameter that is explained as: Here you can provide some extra parameters for the protocol, not the underlying unblur program.You can provide many options separated by space. 

*Options:* 

--use_worker_thread 
 Use an extra thread to compute PSD and thumbnail. This will allow requires an extra CPU. 
"unblur" has a "Min shift" parameter that is explained as: None
"unblur" has a "Max shift" parameter that is explained as: None
"unblur" has a "Exposure filter sums?" parameter that is explained as: If selected the resulting aligned movie sums will be calculated using the exposure filter as described in Grant and Grigorieff (2015). Pre-exposure and dose per frame should  be specified during movies import.
"unblur" has a "Restore power? " parameter that is explained as: If selected, and the exposure filter is used to calculate the sum then the sum will be high pass filtered to restore the noise power. This is essentially the denominator of Eq. 9 in Grant and Grigorieff (2015).
"unblur" has a "Termination threshold (A)" parameter that is explained as: The frames will be iteratively aligned until either the maximum number of iterations is reached, or if after an alignment round every frame was shifted by less than this threshold.
"unblur" has a "Max iterations" parameter that is explained as: The maximum number of iterations that can be run for the movie alignment. If reached, the alignment will stop and the current best values will be taken.
"unblur" has a "B-factor (A^2)" parameter that is explained as: This B-Factor is applied to the reference sum prior to alignment. It is intended to low-pass filter the images in order to prevent alignment to spurious noise peaks and detector artifacts.
"unblur" has a "Horiz. mask (px)" parameter that is explained as: None
"unblur" has a "Vert. mask (px)" parameter that is explained as: None
"unblur" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"unblur" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"unblur" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "cryolo tomo picking (manual)" can be found in the sphire plugin.
"cryolo tomo picking (manual)" protocol help is as follows:
  Picks particles or filaments in a set of tomograms using napari_boxmanager. .
"cryolo tomo picking (manual)" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"cryolo tomo picking (manual)" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"cryolo tomo picking (manual)" has a "Input Tomograms" parameter that is explained as: Select the Tomogram to be used during picking.

The protocol named "cryolo picking" can be found in the sphire plugin.
"cryolo picking" protocol help is as follows:
  Picks particles in a set of micrographs with crYOLO.
    .
"cryolo picking" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"cryolo picking" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"cryolo picking" has a "Input Micrographs" parameter that is explained as: Select the SetOfMicrographs to be used during picking.
"cryolo picking" has a "Picking model: " parameter that is explained as: You might use a general network model that consists of
	-cryo: real, simulated, particle free datasets on various grids with contamination
	-negative stain: trained withnegative stain images
and skip training completely,
or,
if you would like to improve the results you can use the model from a previous training step or an imported one.
"cryolo picking" has a "Input model" parameter that is explained as: Select an existing crYOLO trained model.
"cryolo picking" has a "Confidence threshold" parameter that is explained as: If you want to pick less conservatively or more conservatively you might want to change the threshold from the default of 0.3 to a less conservative value like 0.2 or more conservative value like 0.4.
"cryolo picking" has a "Low-pass filter" parameter that is explained as: CrYOLO works on original micrographs but the results will be probably improved by the application of a reasonable low-pass filter.
"cryolo picking" has a "Cut-off frequency" parameter that is explained as: Specifies the absolute cut-off frequency for the low-pass filter.
"cryolo picking" has a "Number of CPUs" parameter that is explained as: *Important!* This is different from number of threads above as threads are used for GPU parallelization. Provide here the number of CPU cores for each cryolo process.
"cryolo picking" has a "Input size" parameter that is explained as: This is the size to which the input is rescaled before passed through the network.For example the default value would be 1024x1024.
"cryolo picking" has a "Box Size (optional)" parameter that is explained as: Box size in pixels. It should be the size of the minimum particle enclosing square in pixel. If introduced value is zero, it is estimated.
"cryolo picking" has a "Maximum box per image" parameter that is explained as: Maximum number of particles in the image. Only for the memory handling. Keep the default value of 700.
"cryolo picking" has a "" parameter that is explained as: Set to True if you want to use GPU implementation.
"cryolo picking" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. crYOLO can use multiple GPUs - in that case set to i.e. *0 1 2*.
"cryolo picking" has a "Adjust estimated box size by" parameter that is explained as: Value to multiply crYOLO estimated box size to be registered with the SetOfCoordinates. It is usually very tight.
"cryolo picking" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"cryolo picking" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"cryolo picking" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"cryolo picking" has a "The following params are related to how streaming is done in Scipion." parameter that is explained as: None
"cryolo picking" has a "Sleep when waiting (secs)" parameter that is explained as: If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
"cryolo picking" has a "Batch size" parameter that is explained as: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.

The protocol named "cryolo tomo picking" can be found in the sphire plugin.
"cryolo tomo picking" protocol help is as follows:
  Picks particles in a set of tomograms. .
"cryolo tomo picking" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"cryolo tomo picking" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"cryolo tomo picking" has a "Input Tomograms" parameter that is explained as: Select the Tomogram to be used during picking.
"cryolo tomo picking" has a "Picking model: " parameter that is explained as: You might use a general network model that consists of
	-cryo: real, simulated, particle free datasets on various grids with contamination
	-negative stain: trained withnegative stain images
and skip training completely,
or,
if you would like to improve the results you can use the model from a previous training step or an imported one.
"cryolo tomo picking" has a "Input model" parameter that is explained as: Select an existing crYOLO trained model.
"cryolo tomo picking" has a "Confidence threshold" parameter that is explained as: If you want to pick less conservatively or more conservatively you might want to change the threshold from the default of 0.3 to a less conservative value like 0.2 or more conservative value like 0.4.
"cryolo tomo picking" has a "Low-pass filter" parameter that is explained as: CrYOLO works on original micrographs but the results will be probably improved by the application of a reasonable low-pass filter.
"cryolo tomo picking" has a "Cut-off frequency" parameter that is explained as: Specifies the absolute cut-off frequency for the low-pass filter.
"cryolo tomo picking" has a "Number of CPUs" parameter that is explained as: *Important!* This is different from number of threads above as threads are used for GPU parallelization. Provide here the number of CPU cores for each cryolo process.
"cryolo tomo picking" has a "Input size" parameter that is explained as: This is the size to which the input is rescaled before passed through the network.For example the default value would be 1024x1024.
"cryolo tomo picking" has a "Box Size (optional)" parameter that is explained as: Box size in pixels. It should be the size of the minimum particle enclosing square in pixel. If introduced value is zero, it is estimated.
"cryolo tomo picking" has a "Maximum box per image" parameter that is explained as: Maximum number of particles in the image. Only for the memory handling. Keep the default value of 700.
"cryolo tomo picking" has a "" parameter that is explained as: Set to True if you want to use GPU implementation.
"cryolo tomo picking" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. crYOLO can use multiple GPUs - in that case set to i.e. *0 1 2*.
"cryolo tomo picking" has a "Search range (px)" parameter that is explained as: Search range in pixel. On default it will choose 25 percent of the box size (default: -1).
"cryolo tomo picking" has a "Minimum length" parameter that is explained as: The minimum number of boxes in one trace to be considered as valid particle (default: 5).
"cryolo tomo picking" has a "Tracing memory" parameter that is explained as: The maximum number of frames during which a particle can vanish, then reappear nearby, and be considered the same particle (default: 0).
"cryolo tomo picking" has a "Activate filament mode?" parameter that is explained as: None
"cryolo tomo picking" has a "Box distance (px)" parameter that is explained as: Distance in pixels between two boxes
"cryolo tomo picking" has a "Minimum number of boxes" parameter that is explained as: Minimum number of boxes per filament
"cryolo tomo picking" has a "Straightness method" parameter that is explained as: Method to measure the straightness of a line.
LINE_STRAIGHTNESS divides the length from start to end by accumulated length between adjacent boxes.
RMSD calculates the root means squared deviation of the line points to line given by start and the endpoint of the filament. Adjust the straightness_method accordingly!
"cryolo tomo picking" has a "Straightness threshold" parameter that is explained as: Threshold value for the straightness method. The default value works good for LINE_STRAIGHTNESS. Lines with a LINE_STRAIGHTNESS lower than this threshold get split. For RMSD, lines with a RMSD higher than this threshold will be split. A good value for RMSD is 20 percent of your filament width
"cryolo tomo picking" has a "Search range factor" parameter that is explained as: The search range for connecting boxes is the box size times this factor
"cryolo tomo picking" has a "Angle delta" parameter that is explained as: Angle delta in degree. This value is good more or less straight filament. More curvy filament might require values around 20
"cryolo tomo picking" has a "Directional method" parameter that is explained as: Directional method
"cryolo tomo picking" has a "Filament width (px)" parameter that is explained as: None
"cryolo tomo picking" has a "Mask width" parameter that is explained as: Mask width in pixel. A gaussian filter mask is usedto estimate the direction of the filaments. This parameter defines how elongated the mask is. The default value typically don't has to be changed
"cryolo tomo picking" has a "Do not merge filaments?" parameter that is explained as: None
"cryolo tomo picking" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"cryolo tomo picking" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"cryolo tomo picking" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "cryolo tomo training" can be found in the sphire plugin.
"cryolo tomo training" protocol help is as follows:
  Train crYOLO picker using a set of 3D coordinates. .
"cryolo tomo training" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"cryolo tomo training" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"cryolo tomo training" has a "Input tomograms" parameter that is explained as: Select the SetOfTomograms to be used during picking.
"cryolo tomo training" has a "Input coordinates 3D" parameter that is explained as: Please select a set of coordinates 3D, obtained from a previous picking run.
"cryolo tomo training" has a "Fine-tune previous model?" parameter that is explained as: Since crYOLO 1.3 you can train a model for your data by fine-tuning the general model.The general model was trained on a lot of particles with a variety of shapes and therefore learned a very good set of generic features.
"cryolo tomo training" has a "Use previous model: " parameter that is explained as: You might use a general network model that consists of real, simulated, particle free datasets on various grids with contamination and skip training completely or if you would like to improve the results you can use the model from a previous training step or an imported one.
"cryolo tomo training" has a "Input model" parameter that is explained as: Select an existing crYOLO trained model.
"cryolo tomo training" has a "Confidence threshold" parameter that is explained as: If you want to pick less conservatively or more conservatively you might want to change the threshold from the default of 0.3 to a less conservative value like 0.2 or more conservative value like 0.4.
"cryolo tomo training" has a "Low-pass filter" parameter that is explained as: CrYOLO works on original micrographs but the results will be probably improved by the application of a reasonable low-pass filter.
"cryolo tomo training" has a "Cut-off frequency" parameter that is explained as: Specifies the absolute cut-off frequency for the low-pass filter.
"cryolo tomo training" has a "Number of CPUs" parameter that is explained as: *Important!* This is different from number of threads above as threads are used for GPU parallelization. Provide here the number of CPU cores for each cryolo process.
"cryolo tomo training" has a "Input size" parameter that is explained as: This is the size to which the input is rescaled before passed through the network.For example the default value would be 1024x1024.
"cryolo tomo training" has a "Box Size (optional)" parameter that is explained as: Box size in pixels. It should be the size of the minimum particle enclosing square in pixel. If introduced value is zero, it is estimated.
"cryolo tomo training" has a "Maximum box per image" parameter that is explained as: Maximum number of particles in the image. Only for the memory handling. Keep the default value of 700.
"cryolo tomo training" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. crYOLO can use multiple GPUs - in that case set to i.e. *0 1 2*.
"cryolo tomo training" has a "Early stop patience" parameter that is explained as: The training stops when the 'loss' metric on the validation data does not improve 10 times in a row. This is typically enough. In case want to give the training more time to find the best model you might increase this parameters to a higher value (e.g 15).
"cryolo tomo training" has a "Maximum number of iterations" parameter that is explained as: Maximum number of epochs the network will train. Basically never reach this number, as crYOLO stops training if it recognize that the validation loss is not improving anymore.
"cryolo tomo training" has a "Learning rates" parameter that is explained as: If the number is too small convergence can be slow.
"cryolo tomo training" has a "Batch size" parameter that is explained as: The number of images crYOLO process in parallel during training.
"cryolo tomo training" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"cryolo tomo training" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "cryolo training" can be found in the sphire plugin.
"cryolo training" protocol help is as follows:
  Train crYOLO picker using a set of coordinates. .
"cryolo training" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"cryolo training" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"cryolo training" has a "Input Micrographs" parameter that is explained as: Select the SetOfMicrographs to be used during picking.
"cryolo training" has a "Input coordinates" parameter that is explained as: Please select a set of coordinates, obtained from a previous picking run. Typically the coordinates from ~ 10 micrographs is a good start.
"cryolo training" has a "Fine-tune previous model?" parameter that is explained as: Since crYOLO 1.3 you can train a model for your data by fine-tuning the general model.The general model was trained on a lot of particles with a variety of shapes and therefore learned a very good set of generic features.
"cryolo training" has a "Use previous model: " parameter that is explained as: You might use a general network model that consists of real, simulated, particle free datasets on various grids with contamination and skip training completely or if you would like to improve the results you can use the model from a previous training step or an imported one.
"cryolo training" has a "Input model" parameter that is explained as: Select an existing crYOLO trained model.
"cryolo training" has a "Confidence threshold" parameter that is explained as: If you want to pick less conservatively or more conservatively you might want to change the threshold from the default of 0.3 to a less conservative value like 0.2 or more conservative value like 0.4.
"cryolo training" has a "Low-pass filter" parameter that is explained as: CrYOLO works on original micrographs but the results will be probably improved by the application of a reasonable low-pass filter.
"cryolo training" has a "Cut-off frequency" parameter that is explained as: Specifies the absolute cut-off frequency for the low-pass filter.
"cryolo training" has a "Number of CPUs" parameter that is explained as: *Important!* This is different from number of threads above as threads are used for GPU parallelization. Provide here the number of CPU cores for each cryolo process.
"cryolo training" has a "Input size" parameter that is explained as: This is the size to which the input is rescaled before passed through the network.For example the default value would be 1024x1024.
"cryolo training" has a "Box Size (optional)" parameter that is explained as: Box size in pixels. It should be the size of the minimum particle enclosing square in pixel. If introduced value is zero, it is estimated.
"cryolo training" has a "Maximum box per image" parameter that is explained as: Maximum number of particles in the image. Only for the memory handling. Keep the default value of 700.
"cryolo training" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. crYOLO can use multiple GPUs - in that case set to i.e. *0 1 2*.
"cryolo training" has a "Early stop patience" parameter that is explained as: The training stops when the 'loss' metric on the validation data does not improve 10 times in a row. This is typically enough. In case want to give the training more time to find the best model you might increase this parameters to a higher value (e.g 15).
"cryolo training" has a "Maximum number of iterations" parameter that is explained as: Maximum number of epochs the network will train. Basically never reach this number, as crYOLO stops training if it recognize that the validation loss is not improving anymore.
"cryolo training" has a "Learning rates" parameter that is explained as: If the number is too small convergence can be slow.
"cryolo training" has a "Batch size" parameter that is explained as: The number of images crYOLO process in parallel during training.
"cryolo training" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"cryolo training" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "cryolo import" can be found in the sphire plugin.
"cryolo import" protocol help is as follows:
  Protocol to import an existing crYOLO training model.
    The model will be registered as an output of this protocol and
    can be used later for further training or picking.
    .
"cryolo import" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"cryolo import" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"cryolo import" has a "Training model path" parameter that is explained as: Provide the path of a previous crYOLO training model.

The protocol named "janni denoising" can be found in the sphire plugin.
"janni denoising" protocol help is as follows:
  Protocol to denoise a set of micrographs. .
"janni denoising" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"janni denoising" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"janni denoising" has a "" parameter that is explained as: JANNI works on a single GPU.
"janni denoising" has a "Input micrographs" parameter that is explained as: None

The protocol named "annotate particles" can be found in the deepfinder plugin.
"annotate particles" protocol help is as follows:
 This protocol allows you to annotate macromolecules in your tomograms, using a visual tool..
"annotate particles" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"annotate particles" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"annotate particles" has a "Input Tomograms" parameter that is explained as: Select the Tomogram to be used during picking.
"annotate particles" has a "Box size" parameter that is explained as: Default box size for the output.

The protocol named "cluster" can be found in the deepfinder plugin.
"cluster" protocol help is as follows:
 This protocol analyses segmentation maps and outputs particle coordinates and class..
"cluster" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"cluster" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"cluster" has a "Segmentation maps" parameter that is explained as: Please select the segmentation maps you would like to analyze.
"cluster" has a "Clustering radius" parameter that is explained as: Should correspond to average radius of target objects (in voxels)
"cluster" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"cluster" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"cluster" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "generate sphere targets" can be found in the deepfinder plugin.
"generate sphere targets" protocol help is as follows:
  This protocol generates segmentation maps from annotations. These segmentation maps will be used as targets
     to train DeepFinder .
"generate sphere targets" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"generate sphere targets" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"generate sphere targets" has a "Input coordinates" parameter that is explained as: 1 coordinate set per class. A set may contain coordinates from different tomograms.
"generate sphere targets" has a "Sphere radius [pix.]" parameter that is explained as: Sphere radius, in voxels, per class. Should be separated by coma as follows: Rclass1,Rclass2, ...
"generate sphere targets" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"generate sphere targets" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"generate sphere targets" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "segment" can be found in the deepfinder plugin.
"segment" protocol help is as follows:
 This protocol segments tomograms, using a trained neural network..
"segment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"segment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"segment" has a "Input Tomograms" parameter that is explained as: Select the Tomogram to be used during picking.
"segment" has a "Neural network model" parameter that is explained as: Select a trained DeepFinder neural network.
"segment" has a "Patch size" parameter that is explained as: It must be a multiple of 4, due to the network architecture.
"segment" has a "" parameter that is explained as: GPU ID, normally it is 0.

The protocol named "train" can be found in the deepfinder plugin.
"train" protocol help is as follows:
  This protocol launches the training procedure .
"train" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"train" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"train" has a "Training TomoMasks" parameter that is explained as: Training dataset. Please select here your TomoMasks. The corresponding tomograms will be loaded automatically.
"train" has a "Use specific set for Validation?" parameter that is explained as: Recommended value as false. The default value (False) will atuomatically split the set of tomo masks according to the "Validation data fraction". If this parameter  is true, the user can provide a certain set of tomoMask for validating the training.
"train" has a "Validation TomoMasks" parameter that is explained as: (Only available when "Use specific set for Validation" is True.) This is the validation set of tomo Masks to ensure that the network learns properly.
"train" has a "Validation data fraction" parameter that is explained as: Fraction of the "Training Tomomasks" that will be used as validation dataset. The admitted values are [0.1, 0.5], which means from 10% to 50% of the introduced training tomo masks. Only applies if "Validation TomoMasks" is empty.
"train" has a "Coordinates" parameter that is explained as: Select coordinate set.
"train" has a "Patch size" parameter that is explained as: Size of patches loaded into memory for training.
"train" has a "Batch size" parameter that is explained as: Number of patches used to compute average loss.
"train" has a "Number of epochs" parameter that is explained as: At the end of each epoch, evaluation on validation set is performed (useful to check if network overfits).
"train" has a "Steps per epoch" parameter that is explained as: Number of batches trained on per epoch.
"train" has a "Steps per validation" parameter that is explained as: Number of batches used for validation.
"train" has a "Bootstrap" parameter that is explained as: Can remain checked. Useful when in presence of unbalanced classes.
"train" has a "Random shift" parameter that is explained as: (in voxels) Applied to positions in object list when sampling patches. Enhances network robustness. Make sure that objects are still contained in patches when applying shift.
"train" has a "" parameter that is explained as: GPU ID, normally it is 0.

The protocol named "import DeepFinder coordinates" can be found in the deepfinder plugin.
"import DeepFinder coordinates" protocol help is as follows:
 Protocol to import a DeepFinder object list as a set of 3D coordinates in Scipion.
"import DeepFinder coordinates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"import DeepFinder coordinates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"import DeepFinder coordinates" has a "" parameter that is explained as: Select the type of import.
"import DeepFinder coordinates" has a "Files directory" parameter that is explained as: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
"import DeepFinder coordinates" has a "Pattern" parameter that is explained as: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
"import DeepFinder coordinates" has a "Copy files?" parameter that is explained as: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
"import DeepFinder coordinates" has a "Input tomograms" parameter that is explained as: Select the tomograms/tomogram for which you want to import coordinates. The file names of the tomogram and coordinate files must be the same.
"import DeepFinder coordinates" has a "Box size" parameter that is explained as: Default box size for the output.

The protocol named "Load Training Model" can be found in the deepfinder plugin.
"Load Training Model" protocol help is as follows:
 Use two data-independent reconstructed tomograms to train a 3D cryo-CARE network..
"Load Training Model" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Load Training Model" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Load Training Model" has a "Model weights file" parameter that is explained as: File which contains the weights for the neural network (.h5 file).
"Load Training Model" has a "Number of classes" parameter that is explained as: Number of classes corresponding to this model.

The protocol named "alphafold prediction" can be found in the chimerax plugin.
"alphafold prediction" protocol help is as follows:
  Protocol to import atomic structures generated by alphafold.

    If you choose the "Execute alphafold Locally" option you will need 
    a local alphafold NO docker instalation as
    described here: https://github.com/kalininalab/alphafold_non_docker
    .
"alphafold prediction" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"alphafold prediction" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"alphafold prediction" has a "Source to retrieve the AlphaFold2 model:" parameter that is explained as: Retrieve the AlphaFold2 model from:
 * EBI database (identical sequence) in case your sequence is already included in the EBI database of AlphaFold2. This database covers the complete human proteome (including fragments for long proteins) and the proteomes of more than 40 other key organisms, as well as the majority of manually curated UniProt entries. Since this database is continuously updating, check the contents in https://alphafold.ebi.ac.uk/.
  If the structure of your sequence is already included in the EBI database you can retrieve it writing the UniProt ID.
 * EBI Database (homologous sequence): In case the structure prediction of your sequence has not been included in the EBI database yet, a Blast will be launched against that database. According to the Blast searching parameters, which you can modify, some homologous sequences of your sequence will be retrieved and you can select one of them as close prediction of your sequence initial model.
* Executing AlphaFold2 in Google-Colab taking advantage of ChimeraX or Phenix notebooks.
* Executing AlphaFold2 Locally (multimer supported)

"alphafold prediction" has a "UniProt name/ID " parameter that is explained as: Write a UniProt ID (six or ten alphanumeric characters; examples: A2BC19, P12345, A0A022YWF9, DGAL_ECOLI).
 You can convert other database identifiers to UniProt accession codes by using the "ID Mapping" tab on https://www.uniprot.org/
"alphafold prediction" has a "Colab Notebook " parameter that is explained as: Execute alphafold in Google-colab.
  Two notebooks are available from
 ChimeraX and Phenix, respectively
 TEST option is for debuging, do not use it
"alphafold prediction" has a "Reference sequence" parameter that is explained as: Input the aminoacid sequence to blast or send to Google-Colab
"alphafold prediction" has a "similarity-matrix" parameter that is explained as: The matrix option indicates which amino acid similarity-matrix to use for scoring the hits: BLOSUM45, BLOSUM50, BLOSUM62 (default), BLOSUM80, BLOSUM90, PAM30, PAM70, PAM250, or IDENTITY
"alphafold prediction" has a "cutoff" parameter that is explained as: The cutoff evalue is the maximum or least significantexpectation value needed to qualify as a hit (default 1e-3).
"alphafold prediction" has a "Use this template" parameter that is explained as: Fill if you want to supply a PDB template to Google-Colab
"alphafold prediction" has a "Skip Amber relaxation" parameter that is explained as: This option allows skipping energy-minimization of the result from alphafold predict, for faster job completion and/or to avoid failures during minimization.
"alphafold prediction" has a "Use templates from PDB" parameter that is explained as: Use this numbers of templates from PDB. If set to -1 no templates are used
"alphafold prediction" has a "Reference sequences" parameter that is explained as: Include here one or more sequences to get the AlphaFold2 prediction of a monomer (one sequence) or a multimer (several sequences). 
"alphafold prediction" has a "Use Template until" parameter that is explained as: Maximum template release date to consider (YYYY-MM-DD)
"alphafold prediction" has a "Is prokaryote?" parameter that is explained as: Optional for multimer system, not used by the single chain system. A boolean specifying true where the target complex is from a prokaryote, and false where it is not, or where the origin is unknown. This value determine the pairing method for the MSA (default: 'None')
"alphafold prediction" has a "Use GPU acceleration?" parameter that is explained as: If set to Yes, the job will try to use GPU acceleration.
"alphafold prediction" has a "Which GPUs to use:" parameter that is explained as: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use.
"alphafold prediction" has a "Extra flags" parameter that is explained as: # -n <openmm_threads>   OpenMM threads (default: all available cores) -c <db_preset>        Choose preset MSA database configuration - smaller genetic database config (reduced_dbs) or full genetic database config (full_dbs) (default: 'full_dbs')
"alphafold prediction" has a "Extra commands for alphafold" parameter that is explained as: Add extra commands in cmd file. Use for testing
"alphafold prediction" has a "Hide help popup window" parameter that is explained as: If set to Yes no help message will be shown in chimera at start up.
"alphafold prediction" has a "Show results in ChimeraX" parameter that is explained as: Show results in ChimeraX.

The protocol named "model from template" can be found in the chimerax plugin.
"model from template" protocol help is as follows:
 Protocol to model three-dimensional structures of proteins using Modeller.
        Execute command *scipionwrite #n [prefix stringAddedToFilename] from command line in order
        to transfer the selected
        pdb to scipion. Default value is model=#0,
        model refers to the pdb file..
"model from template" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"model from template" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"model from template" has a "Do you already have a template?" parameter that is explained as: "Yes": Option by default. Select this option in case you already have a template to model your target sequence.
"No": Select this option if you want to search for a template with which model your target sequence. Generation of multimeric models is not allowed selecting this option.

"model from template" has a "Atomic structure used as template" parameter that is explained as: PDBx/mmCIF file template used as basic atomic structure to model your specific sequence.
"model from template" has a "Chain " parameter that is explained as: Select a particular chain of the atomic structure.
"model from template" has a "Target sequence" parameter that is explained as: Input the aminoacid sequence to align with the structure template sequence.
"model from template" has a "Protein sequence database:" parameter that is explained as: Select a protein sequence database to search for templates:
PDB: Experimentally determined structures in the Protein Data Bank.
NR: NCBI 'non-redundant'database. It contains GenBank translation proteins, PDB sequences, SwissProt proteins + PIR + PRF. Since NR is much larger than PDB, it takes longer to search.

"model from template" has a "Similarity matrix:" parameter that is explained as: Select a similarity matrix to use for alignment scoring.

"model from template" has a "cutoff evalue:" parameter that is explained as: Least significant expectation value needed to qualify the retrieved element as a hit.

"model from template" has a "Maximum number of sequences:" parameter that is explained as: Maximum number of sequences to retrieve from the database.

"model from template" has a "Options to improve the alignment:" parameter that is explained as: None: Option by default. Only the template and the target sequences will be included in the alignment. This option is recommendable when these two sequences are very similar. Otherwise, select any of the two additional options:
Additional sequences to align: Select this option if you want to add some more sequences to accomplish the alignment.
Provide your own sequence alignment: Your alignmentshould include both the target and the template sequences.

"model from template" has a "Sequence alignment input" parameter that is explained as: Input your own sequence alignment.
ChimeraX allowed formats accessible here: https://www.cgl.ucsf.edu/chimerax/docs/user/commands/open.html#sequence 
"model from template" has a "Other sequences to align" parameter that is explained as: In case you need to load more sequences to align, you can load them here.
"model from template" has a "Alignment tool for two sequences:" parameter that is explained as: Select a program to accomplish the sequencealignment:

Biophyton module Bio.pairwise2 (http://biopython.org/DIST/docs/api/Bio.pairwise2-module.html). Built-in program to align two sequences. The global alignment algorithm from the EMBOSS suite has been implemented with match/mismatch scores of 3/-1 and gap penalties (open/extend) of 3/2.

Clustal Omega program (http://www.clustal.org/omega/, https://doi.org/10.1038/msb.2011.75): Multiple sequence alignment tool. Install clustalo if you choose this option for the first time by 'sudo apt-get install clustalo'.

MUSCLE program stands for MUltiple Sequence Comparison by Log- Expectation(http://www.drive5.com/muscle/muscle.html, https://doi.org/10.1093/nar/gkh340). Install muscle if you choose this option for the first time by 'sudo apt install muscle'.
"model from template" has a "Multiple alignment tool:" parameter that is explained as: Select a program to accomplish the sequencealignment:

Clustal Omega program (http://www.clustal.org/omega/, https://doi.org/10.1038/msb.2011.75): Multiple sequence alignment tool. Install clustalo if you choose this option for the first time by 'sudo apt-get install clustalo'.

MUSCLE program stands for MUltiple Sequence Comparison by Log- Expectation(http://www.drive5.com/muscle/muscle.html, https://doi.org/10.1093/nar/gkh340). Install muscle if you choose this option for the first time by 'sudo apt install muscle'.
"model from template" has a "Additional target sequence to include?" parameter that is explained as: Select YES if you want to add an additional target sequence to model according a different chain of the structure template. This option is recommendable when you want to model the two interacting elements of a particular complex at the same time.
"model from template" has a "Chain " parameter that is explained as: Select a particular chain of the atomic structure.
"model from template" has a "Target sequence" parameter that is explained as: Input the aminoacid sequence to align with the structure template sequence.
"model from template" has a "Options to improve the alignment:" parameter that is explained as: None: Option by default. Only the template and the target sequences will be included in the alignment. This option is recommendable when these two sequences are very similar. Otherwise, select any of the two additional options:
Additional sequences to align: Select this option if you want to add some more sequences to accomplish the alignment.
Provide your own sequence alignment: Your alignmentshould include both the target and the template sequences.

"model from template" has a "Sequence alignment input" parameter that is explained as: Input your own sequence alignment.
ChimeraX allowed formats accessible here: https://www.cgl.ucsf.edu/chimerax/docs/user/commands/open.html#sequence 
"model from template" has a "Other sequences to align" parameter that is explained as: In case you need to load more sequences to align, you can load them here.
"model from template" has a "Alignment tool for two sequences:" parameter that is explained as: Select a program to accomplish the sequencealignment:

Biophyton module Bio.pairwise2 (http://biopython.org/DIST/docs/api/Bio.pairwise2-module.html). Built-in program to align two sequences. The global alignment algorithm from the EMBOSS suite has been implemented with match/mismatch scores of 3/-1 and gap penalties (open/extend) of 3/2.

Clustal Omega program (http://www.clustal.org/omega/, https://doi.org/10.1038/msb.2011.75): Multiple sequence alignment tool. Install clustalo if you choose this option for the first time by 'sudo apt-get install clustalo'.

MUSCLE program stands for MUltiple Sequence Comparison by Log- Expectation(http://www.drive5.com/muscle/muscle.html, https://doi.org/10.1093/nar/gkh340). Install muscle if you choose this option for the first time by 'sudo apt install muscle'.
"model from template" has a "Multiple alignment tool:" parameter that is explained as: Select a program to accomplish the sequencealignment:

Clustal Omega program (http://www.clustal.org/omega/, https://doi.org/10.1038/msb.2011.75): Multiple sequence alignment tool. Install clustalo if you choose this option for the first time by 'sudo apt-get install clustalo'.

MUSCLE program stands for MUltiple Sequence Comparison by Log- Expectation(http://www.drive5.com/muscle/muscle.html, https://doi.org/10.1093/nar/gkh340). Install muscle if you choose this option for the first time by 'sudo apt install muscle'.
"model from template" has a "Extra commands for chimera viewer" parameter that is explained as: Add extra commands in cmd file. Use for testing

The protocol named "contacts" can be found in the chimerax plugin.
"contacts" protocol help is as follows:
 Identifies interatomic clashes and contacts based on van der Waals radii
    .
"contacts" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"contacts" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"contacts" has a "Atomic Structure:" parameter that is explained as: Input atomic structure.
"contacts" has a "Chain Labeling" parameter that is explained as: Dictionary that maps chains to labels.
Example: {'A':'h1', 'B':'h1', 'E':'h2'}
Contacts are calculated between two chains with distinct labels. Two chains with the same label are considered as a group. Contacts will be computed between any chain included in this group and any other group/chain. However, no contacts among members of the group will be calculated.
"contacts" has a "Apply symmetry:" parameter that is explained as: 'Symmetry = Yes' indicates that symmetry will be applied, and then contacts will be computed between any two chains of the atomic structure (the unit cell) and between a chain of the unit cell and another chain of a neigbour unit cell. Output results will show only non redundant contatcs, i.e., contacts than you can infer by symmetry will not be shown.
'Symmetry = No' indicates that symmetry will not be applied, and then  contacts will only be calculated between chains within the atomic structure. Output results will show all contacts between any couple of interacting chains.

"contacts" has a "Symmetry" parameter that is explained as: https://scipion-em.github.io/docs/release-2.0.0/docs/developer/symmetries.html?highlight=symmetrySymmetry for a description of the symmetry groups format in CHIMERA.
If no symmetry is present, use _c1_.More information: 
https://www.cgl.ucsf.edu/chimera/current/docs/UsersGuide/midas/sym.html
"contacts" has a "Symmetry Order" parameter that is explained as: Select the order of cyclic or dihedral symmetry.
"contacts" has a "cutoff (Angstroms): " parameter that is explained as: Large positive cutoff identifies the more severe clashes, whereas negative cutoff indicates favorable contacts:
default contact rule: -0.4 (from 0.0 to -1.0)
default clash rule: 0.6 (from 0.4 to 1.0)
More information: 
https://www.cgl.ucsf.edu/chimerax/docs/user/commands/clashes.html#top
"contacts" has a "allowance (Angstroms): " parameter that is explained as: default contact rule: 0.0
default clash rule: 0.4
More information: 
https://www.cgl.ucsf.edu/chimerax/docs/user/commands/clashes.html#top

The protocol named "operate" can be found in the chimerax plugin.
"operate" protocol help is as follows:
 This protocol provides access to Chimera and allows to save the result in Scipion framework.
            Execute command *scipionwrite #n [prefix stringAddedToFilename]
            model refers to the pdb file.
"operate" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"operate" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"operate" has a "Input Volume" parameter that is explained as: Volume to process
"operate" has a "Input additional Volumes" parameter that is explained as: Other Volumes
"operate" has a "Atomic structure" parameter that is explained as: PDBx/mmCIF file that you can save after operating with it.
"operate" has a "Other atomic structures" parameter that is explained as: In case you need to load more PDBx/mmCIF files, you can load them here and save them after operating with them.
"operate" has a "Extra commands for chimera viewer" parameter that is explained as: Add extra commands in cmd file. Use for testing

The protocol named "restore session" can be found in the chimerax plugin.
"restore session" protocol help is as follows:
 This protocol opens Chimera and restores a session
      that has been stored each time a 3Dmap or an atomic structure 
      by using `scipionwrite` or `scipionss` commad.
      Execute command *scipionwrite #n [prefix stringAddedToFilename]
      model refers to the pdb file.
"restore session" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"restore session" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"restore session" has a "Input protocols" parameter that is explained as: protocol to be reloaded
"restore session" has a "Extra commands for chimera viewer" parameter that is explained as: Add extra commands in cmd file. Use for testing

The protocol named "rigid fit" can be found in the chimerax plugin.
"rigid fit" protocol help is as follows:
 Protocol to perform rigid fit using Chimera.
            Execute command *scipionwrite #n [prefix stringAddedToFilename]
            model refers to the pdb file.
"rigid fit" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"rigid fit" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"rigid fit" has a "Input Volume" parameter that is explained as: Volume to process
"rigid fit" has a "Input additional Volumes" parameter that is explained as: Other Volumes
"rigid fit" has a "Atomic structure to be fitted" parameter that is explained as: PDBx/mmCIF file to be fitted. 
"rigid fit" has a "Other reference atomic structures" parameter that is explained as: Other PDBx/mmCIF files used as reference.
"rigid fit" has a "Extra commands for chimera viewer" parameter that is explained as: Add extra commands in cmd file. Use for testing

The protocol named "map subtraction" can be found in the chimerax plugin.
"map subtraction" protocol help is as follows:
 Protocol to subtract two volumes.
        One of these volumes can be derived from an atomic structure.
        Execute command *scipionwrite #n [prefix stringAddedToFilename]*
        from command line in order to transfer the generated maps and models to scipion.
        In addition to maps and models that the protocol saves by default,
        the user can generate and save some others.
"map subtraction" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"map subtraction" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"map subtraction" has a "Input 3D Map" parameter that is explained as: Difference 3D map = minuend − subtrahend.
Input here the minuend of the subtraction.
"map subtraction" has a "Select the operation to perform" parameter that is explained as: You can select "Subtract" to get the result minuend − subtrahend, or "Mask" to mask the minuend.
This mask is created with all those points that belong to the subtrahend and are greater than the level (0 level is not supplied).
"map subtraction" has a "Contour level (subtrahend)" parameter that is explained as: Difference 3D map = minuend − subtrahend.
"Calculation are made for those voxels inside a region created by this contour level
Empty value -> chimera computes the level.
"map subtraction" has a "Subtraction/Mask of" parameter that is explained as: Difference 3D map = minuend − subtrahend.
Subtrahend 3D map may be provided by the user (choose '3D map') or created from an atomic coordinates file (choose 'atomic structure').
 If 3D Map is chosen, the sampling rate of the minuend should be equal to the sampling rate of the subtrahend.
"map subtraction" has a "Map to subtract (subtrahend)" parameter that is explained as: Map that has to be subtracted from the minuend 3D map.
"map subtraction" has a "Map resolution (A):" parameter that is explained as:  The atomic structure file wil be used to create a 3D map.  Each atom is described as a 3D Gaussian distribution of  width proportional to the resolution and amplitude proportional  to the atomic number. We recommend half the value of the resolution obtained by FSC
"map subtraction" has a "Atomic structure" parameter that is explained as: Atomic structure to derive a 3D map that will be subtracted from the minuend map.
"map subtraction" has a "Select a specific chain?" parameter that is explained as: Select 'Yes' if you want to generate the map from a specific chain of the atomic structure.

"map subtraction" has a "Chain of the atomic structure" parameter that is explained as: Select a particular chain of the atomic structure.
"map subtraction" has a "Remove residues from the atomic structure?" parameter that is explained as: Select 'Yes' to remove a certain number of residues of one of the chains of the atomic structure. These removed residues might help you to establish a control of appropriate levels of map density.
In order to better visualize the area of removed residues, 10 residues will be highligthed before and after the first and the last residues selected, respectively.

"map subtraction" has a "Chain " parameter that is explained as: Select a particular chain of the atomic structure.
"map subtraction" has a "Residues to remove " parameter that is explained as: Select the first and last residues of the selected atomic structure chain that you want to remove. 
(Use Ctrl for multiple selection)
"map subtraction" has a "Apply symmetry to the atomic structure:" parameter that is explained as: 'Symmetry = Yes' indicates that symmetry will be applied. This option is recommended if the atomic structure corresponds to the asymmetrical unit and you want to regenerate the structure of the whole map.
'Symmetry = No' indicates that symmetry will not be applied, and then  the map derived from the atomic structure involves only the atomic structure provided as input.

"map subtraction" has a "Symmetry" parameter that is explained as: https://scipion-em.github.io/docs/docs/developer/symmetries
Symmetry for a description of the symmetry groups format in CHIMERA.
If no symmetry is present, use _c1_.More information: 
https://www.cgl.ucsf.edu/chimerax/docs/user/commands/sym.html
"map subtraction" has a "Symmetry Order" parameter that is explained as: Select the order of cyclic or dihedral symmetry.
"map subtraction" has a "Range of distance" parameter that is explained as: This value allows to generate copies with centers within a certain range of distance of the center of the original molecule model. A models's center is defined as the center of its bounding box.
"map subtraction" has a "Other atomic structures" parameter that is explained as: In case you need to load more PDBx/mmCIF files, you can load them here. These structures will NOT be used to create the subtrahend.
"map subtraction" has a "Map fraction around the atomic structure?" parameter that is explained as: Select 'Yes' if you want to limit the map to a certain radius around the atomic structure.

"map subtraction" has a "Atom radius (A)" parameter that is explained as: Set the radius (Angstroms) to select values of grid points farther than that radius from any atom.
"map subtraction" has a "Filter to apply to the differential map" parameter that is explained as: Choose the filter to clean the background noise of the differential map.
"map subtraction" has a "Gaussian filter width" parameter that is explained as: Set the width of the Gaussian filter.
"map subtraction" has a "Extra commands for chimera viewer" parameter that is explained as: Add extra commands in cmd file. Use for testing

The protocol named "2d streamer" can be found in the emfacilities plugin.
"2d streamer" protocol help is as follows:
  This protocol will monitor an input set of particles
    (usually in streaming) and will run/schedule many copies
     of a given 2D classification protocol but using subsets
     of the input particles as the 2D classification input.
    .
"2d streamer" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"2d streamer" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"2d streamer" has a "Input 2D protocol" parameter that is explained as: This protocol will serve as the template runthat will be repeated with subsets of the input particles. 
"2d streamer" has a "Input particles" parameter that is explained as: Input particles that will be used to executemany 2D classification runs based on the 2D protocol template selected. 
"2d streamer" has a "Batch size" parameter that is explained as: How many particles (approximately) you want to group to make the new batch and launch a new 2dclassification job. 
"2d streamer" has a "Starting number" parameter that is explained as: Specify a value greater than 0 if you want to skip this amount of particles from the classification batches (e.g, if you have classified them for the initial 2D classification template. 
"2d streamer" has a "Update interval (min)" parameter that is explained as: After how many minutes the protocol should look for new input data and schedule more 2D classificationjobs if necessary. 

The protocol named "ctf monitor" can be found in the emfacilities plugin.
"ctf monitor" protocol help is as follows:
  check CPU, mem and IO usage.
    .
"ctf monitor" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"ctf monitor" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"ctf monitor" has a "Input protocols" parameter that is explained as: this protocol will be monitorized
"ctf monitor" has a "Sampling Interval (sec)" parameter that is explained as: Take one sample each SamplinInteval seconds
"ctf monitor" has a "Raise Alarm if maximum defocus (A) >" parameter that is explained as: Raise alarm if defocus is greater than given value
"ctf monitor" has a "Raise Alarm if minimum defocus (A) <" parameter that is explained as: Raise alarm if defocus is smaller than given value
"ctf monitor" has a "Raise Alarm if astigmatism (A) >" parameter that is explained as: Raise alarm if astigmatism is greater than given value
"ctf monitor" has a "Total Logging time (min)" parameter that is explained as: Log during this interval
"ctf monitor" has a "Enable Email notification?" parameter that is explained as: Allow monitors to notify via email.
"ctf monitor" has a "From" parameter that is explained as: Provide the sender address for notifications.
"ctf monitor" has a "To" parameter that is explained as: Provide the destination address for notifications.
"ctf monitor" has a "SMTP Mail server" parameter that is explained as: Provide the address of SMTP mail server.

The protocol named "movie gain monitor" can be found in the emfacilities plugin.
"movie gain monitor" protocol help is as follows:
  check CPU, mem and IO usage.
    .
"movie gain monitor" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"movie gain monitor" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"movie gain monitor" has a "Input protocol" parameter that is explained as: This protocol will be monitorized
"movie gain monitor" has a "Raise Alarm if residual gain standard deviation >" parameter that is explained as: Raise alarm if residual gain standard deviation is greater than given value
"movie gain monitor" has a "Raise Alarm if the ratio between the 97.5 and 2.5 percentiles >" parameter that is explained as: Raise alarm if the ratio between the 97.5 and 2.5 percentiles is greater than given value
"movie gain monitor" has a "Raise Alarm if the ratio between the maximum gain value and the 97.5 percentile >" parameter that is explained as: Raise alarm if the ratio between the maximum gain value and the 97.5 percentile is greater than given value
"movie gain monitor" has a "Total Logging time (min)" parameter that is explained as: Log during this interval
"movie gain monitor" has a "Sampling Interval (sec)" parameter that is explained as: Take one sample each SamplinInteval seconds
"movie gain monitor" has a "Enable Email notification?" parameter that is explained as: Allow monitors to notify via email.
"movie gain monitor" has a "From" parameter that is explained as: Provide the sender address for notifications.
"movie gain monitor" has a "To" parameter that is explained as: Provide the destination address for notifications.
"movie gain monitor" has a "SMTP Mail server" parameter that is explained as: Provide the address of SMTP mail server.

The protocol named "monitor summary" can be found in the emfacilities plugin.
"monitor summary" protocol help is as follows:
  Provide some summary of the basic steps of the Scipion-Box:
    - Import movies
    - Align movies (global and/or local)
    - CTF estimation
    - Movie gain estimation.
    .
"monitor summary" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"monitor summary" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"monitor summary" has a "Input protocols" parameter that is explained as: this protocol/s will be monitorized
"monitor summary" has a "Sampling Interval (sec)" parameter that is explained as: Take one sample each *samplingInterval* seconds
"monitor summary" has a "Total Logging time (min)" parameter that is explained as: Log during this interval. 21 days by default
"monitor summary" has a "Raise Alarm if residual gain standard deviation >" parameter that is explained as: Raise alarm if residual gain standard deviation is greater than given value
"monitor summary" has a "Raise Alarm if the ratio between the 97.5 and 2.5 percentiles >" parameter that is explained as: Raise alarm if the ratio between the 97.5 and 2.5 percentiles is greater than given value
"monitor summary" has a "Raise Alarm if the ratio between the maximum gain value and the 97.5 percentile >" parameter that is explained as: Raise alarm if the ratio between the maximum gain value and the 97.5 percentile is greater than given value
"monitor summary" has a "Raise Alarm if maximum defocus (A) >" parameter that is explained as: Raise alarm if defocus is greater than given value
"monitor summary" has a "Raise Alarm if minimum defocus (A) <" parameter that is explained as: Raise alarm if defocus is smaller than given value
"monitor summary" has a "Raise Alarm if astigmatism >" parameter that is explained as: Raise alarm if astigmatism (defocusU-defocusV)is greater than given value
"monitor summary" has a "Raise Alarm if CPU > XX%" parameter that is explained as: Raise alarm if memory allocated is greater than given percentage
"monitor summary" has a "Raise Alarm if Memory > XX%" parameter that is explained as: Raise alarm if cpu allocated is greater than given percentage
"monitor summary" has a "Raise Alarm if Swap > XX%" parameter that is explained as: Raise alarm if swap allocated is greater than given percentage
"monitor summary" has a "Check GPU" parameter that is explained as: Set to true if you want to monitor the GPU
"monitor summary" has a "Which GPUs to use:" parameter that is explained as: Provide a list of GPUs (e.g. "0 1 2 3"). Default is to monitor GPU 0 only
"monitor summary" has a "Check Network" parameter that is explained as: Set to true if you want to monitor the Network
"monitor summary" has a "Interface" parameter that is explained as: Name of the network interface to be checked
"monitor summary" has a "Check Disk IO" parameter that is explained as: Set to true if you want to monitor the Disk Acces
"monitor summary" has a "Enable Email notification?" parameter that is explained as: Allow monitors to notify via email.
"monitor summary" has a "From" parameter that is explained as: Provide the sender address for notifications.
"monitor summary" has a "To" parameter that is explained as: Provide the destination address for notifications.
"monitor summary" has a "SMTP Mail server" parameter that is explained as: Provide the address of SMTP mail server.
"monitor summary" has a "use grafana/influx" parameter that is explained as: Use grafana+influx vs apache for reports
"monitor summary" has a "Publish command" parameter that is explained as: Specify a command to publish the template. You can use the special token %(REPORT_FOLDER)s that will be replaced with the report folder. For example: 
rsync -avL %(REPORT_FOLDER)s scipion@webserver:public_html/

The protocol named "system_monitor" can be found in the emfacilities plugin.
"system_monitor" protocol help is as follows:
  check CPU, mem and IO usage.
    .
"system_monitor" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"system_monitor" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"system_monitor" has a "Input protocols" parameter that is explained as: this protocol/s will be monitorized
"system_monitor" has a "Sampling Interval (sec)" parameter that is explained as: Take one sample each *samplingInterval* seconds
"system_monitor" has a "Total Logging time (min)" parameter that is explained as: Log during this interval
"system_monitor" has a "Raise Alarm if CPU > XX%" parameter that is explained as: Raise alarm if memory allocated is greater than given percentage
"system_monitor" has a "Raise Alarm if Memory > XX%" parameter that is explained as: Raise alarm if cpu allocated is greater than given percentage
"system_monitor" has a "Raise Alarm if Swap > XX%" parameter that is explained as: Raise alarm if swap allocated is greater than given percentage
"system_monitor" has a "Enable Email notification?" parameter that is explained as: Allow monitors to notify via email.
"system_monitor" has a "From" parameter that is explained as: Provide the sender address for notifications.
"system_monitor" has a "To" parameter that is explained as: Provide the destination address for notifications.
"system_monitor" has a "SMTP Mail server" parameter that is explained as: Provide the address of SMTP mail server.
"system_monitor" has a "Check GPU" parameter that is explained as: Set to true if you want to monitor the GPU
"system_monitor" has a "Which GPUs to use:" parameter that is explained as: Providing a list of which GPUs (0,1,2,3, etc). Default is monitor GPU 0 only
"system_monitor" has a "Check Network" parameter that is explained as: Set to true if you want to monitor the Network
"system_monitor" has a "Interface" parameter that is explained as: Name of the network interface to be checked
"system_monitor" has a "Check Disk IO" parameter that is explained as: Set to true if you want to monitor the Disk Access

The protocol named "Track used items" can be found in the emfacilities plugin.
"Track used items" protocol help is as follows:
 
  This protocol will track the items (micrographs, classes2D,...) that has been used in a scipion protocol to
  generate a final volume. If the ids have been maintained, it will also track the not used items.
  .
"Track used items" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Track used items" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Track used items" has a "Input volumes" parameter that is explained as: Select the sets of volumes to track their used items
"Track used items" has a "Save images as JPG" parameter that is explained as: Save micrographs and particles as jpg
"Track used items" has a "Track used particles?" parameter that is explained as: The particles used in the final volume reconstruction will be tracked
"Track used items" has a "Original Particles" parameter that is explained as: Set of Particles containing the complete set of original particles, including the used and filtered particles. If None, the set of particles with same sampling rate and furthest to the used particles will be used.
"Track used items" has a "Track used micrographs?" parameter that is explained as: The micrographs with picked particles used in the final volume reconstruction will be tracked and scored according to the number of used particles in them
"Track used items" has a "Original micrographs" parameter that is explained as: Set of micrographs containing the complete set of original mics, including the used and filtered mics. If None, the first protocol with output micrographs will be used. Each of these micrographs will be scored depending on the number of used particles in them
"Track used items" has a "Track used CTFs?" parameter that is explained as: The CTFs from micrographs with picked particles used in the final volume reconstruction will be tracked and scored according to the number of used particles in them
"Track used items" has a "Track used coordinates?" parameter that is explained as: The coordinates used in the final volume reconstruction will be tracked
"Track used items" has a "Original Coordinates" parameter that is explained as: Set of Coordinates where to get the coordinates parameters. If None, the first protocol with output Coordinates will be used
"Track used items" has a "Pick negative coordinates" parameter that is explained as: Picks noise from the micrographs as negative particle examples
"Track used items" has a "Number of noise particles" parameter that is explained as: Number of noise particles to extract from each micrograph. Set to -1 for extracting the same amount of noise particles as the number true particles for that micrograph
"Track used items" has a "Track used Classes2D?" parameter that is explained as: The Classes2D used in the final volume reconstruction will be tracked
"Track used items" has a "Used Classes2D" parameter that is explained as: Set of Classes2D where to track the used items. If None, the newer protocolwith output Classes2D will be used
"Track used items" has a "Track used Classes3D?" parameter that is explained as: The Classes3D used in the final volume reconstruction will be tracked
"Track used items" has a "Used Classes3D" parameter that is explained as: Set of Classes3D where to track the used items. If None, the newer protocolwith output Classes3D will be used
"Track used items" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"Track used items" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"Track used items" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "fils" can be found in the pyseg plugin.
"fils" protocol help is as follows:
 filter a MbGraphMCF (Mean Cumulative Function) object by extracting a filament network.
"fils" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"fils" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"fils" has a "Graphs" parameter that is explained as: Pointer to graphs protocol.
"fils" has a "Filament area" parameter that is explained as: Source or destination (depending if you are in the Sources or Targets tab) area for the filament calculation.
"fils" has a "Min" parameter that is explained as: None
"fils" has a "Max" parameter that is explained as: None
"fils" has a "range" parameter that is explained as: None
"fils" has a "Min" parameter that is explained as: None
"fils" has a "Max" parameter that is explained as: None
"fils" has a "range" parameter that is explained as: None
"fils" has a "Min" parameter that is explained as: None
"fils" has a "Max" parameter that is explained as: None
"fils" has a "range" parameter that is explained as: None
"fils" has a "Min" parameter that is explained as: None
"fils" has a "Max" parameter that is explained as: None
"fils" has a "range" parameter that is explained as: None
"fils" has a "Filament area" parameter that is explained as: Source or destination (depending if you are in the Sources or Targets tab) area for the filament calculation.
"fils" has a "Min" parameter that is explained as: None
"fils" has a "Max" parameter that is explained as: None
"fils" has a "range" parameter that is explained as: None
"fils" has a "Min" parameter that is explained as: None
"fils" has a "Max" parameter that is explained as: None
"fils" has a "range" parameter that is explained as: None
"fils" has a "Min" parameter that is explained as: None
"fils" has a "Max" parameter that is explained as: None
"fils" has a "range" parameter that is explained as: None
"fils" has a "Min" parameter that is explained as: None
"fils" has a "Max" parameter that is explained as: None
"fils" has a "range" parameter that is explained as: None
"fils" has a "Orientation with respect to the membrane/filament" parameter that is explained as: None
"fils" has a "Euclidean distance (STRAIGHT) range of vertices source-target (nm)" parameter that is explained as: None
"fils" has a "Geodesic distance (CURVED) range of vertices source-target (nm)" parameter that is explained as: None
"fils" has a "Filament sinuosity range (FLEXIBILITY, normally the ratio geoLen / eucLen)" parameter that is explained as: None
"fils" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"fils" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"fils" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "graphs" can be found in the pyseg plugin.
"graphs" protocol help is as follows:
 analyze a GraphMCF (Mean Cumulative Function) from a segmented membrane.
"graphs" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"graphs" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"graphs" has a "Pre segmentation" parameter that is explained as: Pointer to preseg protocol.
"graphs" has a "Vesicles packaging size" parameter that is explained as: The input set of particles will be split into packages of N vesicles. Each package will be processed as a different step, allowing to continue the execution from the last step in case of the protocol fails. On the other hand, more packages implies more calls to PySeg, which can affect to performance.
"graphs" has a "Keep only required files?" parameter that is explained as: If set to No, all the intermediate Disperse program resulting directories will be kept in the extra folder.
"graphs" has a "Sigma for gaussian filtering" parameter that is explained as: Sigma for Gaussian foltering input tomograms. It allows to smooth small and irrelevant features and increases teh signal noise ratio (SNR). Higher values will provide less dense graphs (lower execution time), so they should be used when picking large particles, like ribosomes.
"graphs" has a "Vertex density within membranes (nm³)" parameter that is explained as: Vertex density within membranes. It allows to adjust simplification adaptively for every tomogram.
"graphs" has a "Avg ratio vertex/edge of graph within membrane" parameter that is explained as: Averaged ratio vertex/edge in the graph within membrane.
"graphs" has a "Maximum distance to membrane (Å)" parameter that is explained as: Maximum euclidean distance to membrane in Å.
"graphs" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"graphs" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "picking" can be found in the pyseg plugin.
"picking" protocol help is as follows:
 extract particles from a filament network of a oriented single membrane graph.
"picking" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"picking" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"picking" has a "Fils protocol" parameter that is explained as: Pointer to fils protocol.
"picking" has a "Tomograms to refer the coordinates" parameter that is explained as: Tomograms to which the coordinates should be referred to. If empty, it is assumed that the tomograms are the same from were the vesicles were segmented (pre-seg).
"picking" has a "Box size (pixels)" parameter that is explained as: None
"picking" has a "Segmentation area for picking" parameter that is explained as: Area in which the cutting point or cutting point + projections of the filament will be considered for the picking coordinates.
"picking" has a "Find on two surfaces" parameter that is explained as: Track fiducials differentiating in which side of the sample are located.
"picking" has a "Percentile of points to discard by their density level." parameter that is explained as: None
"picking" has a "Min distance between selected points (nm)." parameter that is explained as: Scale suppression in nm, two selected points cannot be closer than this distance.
"picking" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"picking" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"picking" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "2D classification" can be found in the pyseg plugin.
"2D classification" protocol help is as follows:
 Unsupervised and deterministic classification of membrane-bound particles.
"2D classification" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"2D classification" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"2D classification" has a "Input subtomograms" parameter that is explained as: Select the input subtomograms desired to be classified.
"2D classification" has a "Mask" parameter that is explained as: Mask used for the post processing
"2D classification" has a "Clustering algorithm" parameter that is explained as: None
"2D classification" has a "Filter size (voxels)" parameter that is explained as: A value of n means that the voxels will be grouped in groups of size n.
"2D classification" has a "Do 3D radial compensation?" parameter that is explained as: If "No" is selected, the normalized cross correlation (NCC) is made in 2D, otherwise radial average is compensated for doing a NCC in 3D.
"2D classification" has a "Cross correlation metric" parameter that is explained as: Metric used when computing the cross correlation matrix among the 2D particles. Considerations:
	- Mask normalized similarity is referred to negative squared Euclidean distance.
	- Full cross-correlation (slower than ross-correlation within the mask but allows small disalignments between particles).
"2D classification" has a "PCA components for dim. reduction" parameter that is explained as: Number of components (moments) after the reductions.
If 0 or None, then they will be automatically estimated considering the size ob the input subtomograms.
"2D classification" has a "Number of clusters to find" parameter that is explained as: None
"2D classification" has a "Affinity propagation preference (-inf, inf)" parameter that is explained as: Preference parameter (-inf, inf).
The smaller value the higher number of potential classes.
If None, the median of the affinity class is considered.
"2D classification" has a "Dumping [0.5, 1)" parameter that is explained as: Dumping parameter [0.5, 1), it controls convergence speed.
"2D classification" has a "Maximum number of iterations" parameter that is explained as: None
"2D classification" has a "Iterations for fitting the convergence criteria" parameter that is explained as: None
"2D classification" has a "Reference 2D image used for classes" parameter that is explained as: None
"2D classification" has a "Minimum number of particles per class" parameter that is explained as: Purge classes with less than the specified number of particles. If 0, this filter will not be applied.
"2D classification" has a "Cross-correlation against AP reference filter" parameter that is explained as: Purge classes with the cross correlation against the reference lower than the specified value. If 0, this filter will not be applied.
"2D classification" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"2D classification" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "posrec" can be found in the pyseg plugin.
"posrec" protocol help is as follows:
 post-process already reconstructed particles: rot angle randomization and membrane suppression.
"posrec" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"posrec" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"posrec" has a "Input subtomograms" parameter that is explained as: Select the input subtomograms from the project.
"posrec" has a "Mask" parameter that is explained as: Mask used for the post processing
"posrec" has a "Mask for membrane supression" parameter that is explained as: None
"posrec" has a "Membrane suppression factor [0, 1]" parameter that is explained as: Value 0 suppress the area corresponding to the suppression mask, while higher values up to 1 attenuate it.
"posrec" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"posrec" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "preseg membranes" can be found in the pyseg plugin.
"preseg membranes" protocol help is as follows:
 Segment membranes into membranes, inner surroundings and outer surroundings.
"preseg membranes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"preseg membranes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"preseg membranes" has a "Tomomasks (segmentations)" parameter that is explained as: Pointer to segmented and annotated tomograms within Scipion.
"preseg membranes" has a "Offset voxels" parameter that is explained as: Margin to ensure that the desired entities, e. g. membranes, proteins, are included.
"preseg membranes" has a "Density threshold" parameter that is explained as: All the voxels with density equal to or higher than the threshold are set to 1. The remaining voxels are set to 0.
"preseg membranes" has a "Size threshold (voxels)" parameter that is explained as: It sets the minimal size for a component to be considered as membrane.
"preseg membranes" has a "Segmented membrane thickness (Å)" parameter that is explained as: Value introduced will be divided by 2 internally, because it is expected like that by PySeg.
"preseg membranes" has a "Segmented membrane neighbours (Å)" parameter that is explained as: Thickness around the membrane to represent the in-membrane and out-membrane surroundings desired to be included in the analysis.

The protocol named "picking consensus" can be found in the tomoviz plugin.
"picking consensus" protocol help is as follows:
 
    Protocol to estimate the agreement between different particle picking
    algorithms. The protocol takes several Sets of Coordinates calculated
    by different programs and/or different parameter settings. Let's say:
    we consider N independent pickings. Then, a coordinate is considered
    to be a correct particle if M pickers have selected the same particle
    (within a radius in pixels specified in the form).

    If you want to be very strict, then set M=N; that is, a coordinate
    represents a particle if it has been selected by all particles (this
    is the default behaviour). Then you may relax this condition by setting
    M=N-1, N-2, ...

    If you want to be very flexible, set M=1, in this way it suffices that
    1 picker has selected the coordinate to be considered as a particle. Note
    that in this way, the cleaning of the dataset has to be performed by other
    means (screen particles, 2D and 3D classification, ...).
    .
"picking consensus" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"picking consensus" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"picking consensus" has a "Input 3D coordinates" parameter that is explained as: Select the set of 3D coordinates to compare
"picking consensus" has a "Radius" parameter that is explained as: All coordinates within this radius (in pixels) are presumed to correspond to the same particle
"picking consensus" has a "Consensus" parameter that is explained as: This parameter can take values from 1 to total number of inputs (being -1 a special case).
*Set to -1* to indicate that it needs to be selected by all algorithms: *AND* operation.
*Set to 1* to indicate that it suffices that only 1 algorithm selects the particle: *OR* operation.
Any other value will determine how many times need a particle to be selected to be considered as a consensus particle.
"picking consensus" has a "Consensus mode" parameter that is explained as: If the number of votes to progress to the output must be either (=) strictly speaking equals to the consensus number or (>=) at least equals.

The protocol named "remove duplicates" can be found in the tomoviz plugin.
"remove duplicates" protocol help is as follows:
 
    This protocol removes coordinates that are closer than a given threshold.
    The remaining coordinate is the average of the previous ones.
    .
"remove duplicates" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"remove duplicates" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"remove duplicates" has a "Input coordinates" parameter that is explained as: Select the set of 3D coordinates to compare
"remove duplicates" has a "Radius" parameter that is explained as: All coordinates within this radius (in pixels) are presumed to correspond to the same particle

The protocol named "filter by normal" can be found in the tomoviz plugin.
"filter by normal" protocol help is as follows:
  This protocol takes surfaces or ROIs (SetOfMeshes) and a SetOfSubtomograms or SetOfCoordinates3D with
    transformation matrix and filters them by different criteria related with the normal direction..
"filter by normal" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"filter by normal" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"filter by normal" has a "Subtomograms/Coordinates" parameter that is explained as: Coordinates to filter.
"filter by normal" has a "Vesicles" parameter that is explained as: Select the vesicles in which the subtomograms/coordinates are.
"filter by normal" has a "Filter by tilt angle" parameter that is explained as: Remove items depending on their tilt angle.
"filter by normal" has a "Maximum allowed tilt" parameter that is explained as: Remove the items that have a tilt angle bigger than the one specified in here, considering tilt angle between 0 and 180 degrees.
"filter by normal" has a "Minimum allowed tilt" parameter that is explained as: Remove the items that have a tilt angle smaller than the one specified in here, considering tilt angle between 0 and 180 degrees.
"filter by normal" has a "Filter by normal" parameter that is explained as: Remove the items that have a normal direction not equal to the normal direction of the vesicle in the coordinate of the particle.
"filter by normal" has a "Tolerance in degrees" parameter that is explained as: Tolerance (in degrees) when comparing between subtomogram/coordinate and mesh normal directions.

The protocol named "movie alignment" can be found in the motioncorr plugin.
"movie alignment" protocol help is as follows:
  This protocol wraps motioncor movie alignment program developed at UCSF.

    Motioncor performs anisotropic drift correction and dose weighting
        (written by Shawn Zheng @ David Agard lab)
    .
"movie alignment" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"movie alignment" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"movie alignment" has a "Input Movies" parameter that is explained as: Select a set of previously imported movies.
"movie alignment" has a "" parameter that is explained as: None
"movie alignment" has a "" parameter that is explained as: None
"movie alignment" has a "from" parameter that is explained as: None
"movie alignment" has a "to" parameter that is explained as: None
"movie alignment" has a "Binning factor" parameter that is explained as: 1x or 2x. Bin stack before processing.
"movie alignment" has a "X" parameter that is explained as: None
"movie alignment" has a "Y" parameter that is explained as: None
"movie alignment" has a "X" parameter that is explained as: None
"movie alignment" has a "Y" parameter that is explained as: None
"movie alignment" has a "Split & sum odd/even frames?" parameter that is explained as: Generate odd and even sums using odd and even frames respectively when this option is enabled.
"movie alignment" has a "Save aligned movie?" parameter that is explained as: None
"movie alignment" has a "Compute PSD?" parameter that is explained as: If Yes, the protocol will compute for each aligned micrograph the PSD using EMAN2.
"movie alignment" has a "Compute micrograph thumbnail?" parameter that is explained as: When using this option, we will compute a micrograph thumbnail with EMAN2 and keep it with the micrograph object for visualization purposes. 
"movie alignment" has a "Additional protocol parameters" parameter that is explained as: Here you can provide some extra parameters for the protocol, not the underlying motioncor program.You can provide many options separated by space. 

*Options:* 

--dont_use_worker_thread 
 Now by default we use a separate thread to compute PSD and thumbnail (if is required). This allows  more effective use of the GPU card, but requires  an extra CPU. Use this option (NOT RECOMMENDED) if  you want to prevent this behaviour
"movie alignment" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. Motioncor can use multiple GPUs - in that case set to i.e. *0 1 2*.
"movie alignment" has a "Apply dose filter" parameter that is explained as: Apply a dose-dependent filter to frames before summing them. Pre-exposure and dose per frame should be specified during movies import.
"movie alignment" has a "X" parameter that is explained as: None
"movie alignment" has a "Y" parameter that is explained as: None
"movie alignment" has a "Patches overlap (%)" parameter that is explained as: Specify the overlapping between patches. 
For example, overlap=20 means that each patch will have a 20% overlapping 
with its neighboring patches in each dimension.
"movie alignment" has a "global align" parameter that is explained as: None
"movie alignment" has a "local align" parameter that is explained as: None
"movie alignment" has a "Tolerance (px)" parameter that is explained as: Tolerance for iterative alignment, default *0.2px*.
"movie alignment" has a "Save unweighted images?" parameter that is explained as: Aligned but non-dose weighted images are sometimes useful in CTF estimation, although there is no difference in most cases.
"movie alignment" has a "Additional parameters" parameter that is explained as: Extra command line parameters. See MotionCor help.
"movie alignment" has a "Rotate gain reference:" parameter that is explained as: Rotate gain reference counter-clockwise.
"movie alignment" has a "Flip gain reference:" parameter that is explained as: Flip gain reference after rotation.
"movie alignment" has a "Camera defects file" parameter that is explained as: Defect file that stores entries of defects on camera.
Each entry corresponds to a rectangular region in image. The pixels in such a region are replaced by neighboring good pixel values. Each entry contains 4 integers x, y, w, h representing the x, y coordinates, width, and height, respectively.
"movie alignment" has a "Camera defects map" parameter that is explained as: 1. Defect map is a binary (0 or 1) map where defective  pixels are assigned value of 1 and good pixels have value of 0.
2. The defective pixels are corrected with a random pick of good pixels in its neighborhood. 
3. This is map must have the same dimension and orientation as the input movie frame.
4. This map can be provided as either MRC or TIFF file that has MRC mode of 0 or 5 (unsigned 8 bit).
"movie alignment" has a "These options are ignored for non-EER movies." parameter that is explained as: None
"movie alignment" has a "EER fractionation" parameter that is explained as: The number of hardware frames to group into one fraction. This option is relevant only for Falcon 4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
"movie alignment" has a "EER upsampling" parameter that is explained as: EER upsampling (1x = 4K, 2x = 8K, 3x=16K)
"movie alignment" has a "Correct anisotropic magnification?" parameter that is explained as: Correct anisotropic magnification by stretching image along the major axis, the axis where the lower magnification is detected.
"movie alignment" has a "Major scale factor" parameter that is explained as: None
"movie alignment" has a "Minor scale factor" parameter that is explained as: None
"movie alignment" has a "Distortion angle (deg)" parameter that is explained as: None
"movie alignment" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"movie alignment" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"movie alignment" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tasks" can be found in the motioncorr plugin.
"tasks" protocol help is as follows:
  This protocol wraps motioncor movie alignment program developed at UCSF.

    Motioncor performs anisotropic drift correction and dose weighting
        (written by Shawn Zheng @ David Agard lab)
    .
"tasks" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"tasks" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"tasks" has a "Input Movies" parameter that is explained as: Select a set of previously imported movies.
"tasks" has a "" parameter that is explained as: None
"tasks" has a "" parameter that is explained as: None
"tasks" has a "from" parameter that is explained as: None
"tasks" has a "to" parameter that is explained as: None
"tasks" has a "Binning factor" parameter that is explained as: 1x or 2x. Bin stack before processing.
"tasks" has a "X" parameter that is explained as: None
"tasks" has a "Y" parameter that is explained as: None
"tasks" has a "X" parameter that is explained as: None
"tasks" has a "Y" parameter that is explained as: None
"tasks" has a "Split & sum odd/even frames?" parameter that is explained as: Generate odd and even sums using odd and even frames respectively when this option is enabled.
"tasks" has a "Save aligned movie?" parameter that is explained as: None
"tasks" has a "Compute PSD?" parameter that is explained as: If Yes, the protocol will compute for each aligned micrograph the PSD using EMAN2.
"tasks" has a "Compute micrograph thumbnail?" parameter that is explained as: When using this option, we will compute a micrograph thumbnail with EMAN2 and keep it with the micrograph object for visualization purposes. 
"tasks" has a "Additional protocol parameters" parameter that is explained as: Here you can provide some extra parameters for the protocol, not the underlying motioncor program.You can provide many options separated by space. 

*Options:* 

--dont_use_worker_thread 
 Now by default we use a separate thread to compute PSD and thumbnail (if is required). This allows  more effective use of the GPU card, but requires  an extra CPU. Use this option (NOT RECOMMENDED) if  you want to prevent this behaviour
"tasks" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. Motioncor can use multiple GPUs - in that case set to i.e. *0 1 2*.
"tasks" has a "Apply dose filter" parameter that is explained as: Apply a dose-dependent filter to frames before summing them. Pre-exposure and dose per frame should be specified during movies import.
"tasks" has a "X" parameter that is explained as: None
"tasks" has a "Y" parameter that is explained as: None
"tasks" has a "Patches overlap (%)" parameter that is explained as: Specify the overlapping between patches. 
For example, overlap=20 means that each patch will have a 20% overlapping 
with its neighboring patches in each dimension.
"tasks" has a "global align" parameter that is explained as: None
"tasks" has a "local align" parameter that is explained as: None
"tasks" has a "Tolerance (px)" parameter that is explained as: Tolerance for iterative alignment, default *0.2px*.
"tasks" has a "Save unweighted images?" parameter that is explained as: Aligned but non-dose weighted images are sometimes useful in CTF estimation, although there is no difference in most cases.
"tasks" has a "Additional parameters" parameter that is explained as: Extra command line parameters. See MotionCor help.
"tasks" has a "Rotate gain reference:" parameter that is explained as: Rotate gain reference counter-clockwise.
"tasks" has a "Flip gain reference:" parameter that is explained as: Flip gain reference after rotation.
"tasks" has a "Camera defects file" parameter that is explained as: Defect file that stores entries of defects on camera.
Each entry corresponds to a rectangular region in image. The pixels in such a region are replaced by neighboring good pixel values. Each entry contains 4 integers x, y, w, h representing the x, y coordinates, width, and height, respectively.
"tasks" has a "Camera defects map" parameter that is explained as: 1. Defect map is a binary (0 or 1) map where defective  pixels are assigned value of 1 and good pixels have value of 0.
2. The defective pixels are corrected with a random pick of good pixels in its neighborhood. 
3. This is map must have the same dimension and orientation as the input movie frame.
4. This map can be provided as either MRC or TIFF file that has MRC mode of 0 or 5 (unsigned 8 bit).
"tasks" has a "These options are ignored for non-EER movies." parameter that is explained as: None
"tasks" has a "EER fractionation" parameter that is explained as: The number of hardware frames to group into one fraction. This option is relevant only for Falcon 4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
"tasks" has a "EER upsampling" parameter that is explained as: EER upsampling (1x = 4K, 2x = 8K, 3x=16K)
"tasks" has a "Correct anisotropic magnification?" parameter that is explained as: Correct anisotropic magnification by stretching image along the major axis, the axis where the lower magnification is detected.
"tasks" has a "Major scale factor" parameter that is explained as: None
"tasks" has a "Minor scale factor" parameter that is explained as: None
"tasks" has a "Distortion angle (deg)" parameter that is explained as: None
"tasks" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"tasks" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"tasks" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"tasks" has a "The following params are related to how streaming is done in Scipion." parameter that is explained as: None
"tasks" has a "Sleep when waiting (secs)" parameter that is explained as: If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
"tasks" has a "Batch size" parameter that is explained as: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.

The protocol named "align tilt-series movies" can be found in the motioncorr plugin.
"align tilt-series movies" protocol help is as follows:
  This protocol wraps motioncor movie alignment program developed at UCSF.

    Motioncor performs anisotropic drift correction
        (written by Shawn Zheng @ David Agard lab)
    .
"align tilt-series movies" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"align tilt-series movies" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"align tilt-series movies" has a "Input Tilt-Series (movies)" parameter that is explained as: Select input tilt-series movies that you wantto correct for beam-induced motion. 
"align tilt-series movies" has a "from" parameter that is explained as: None
"align tilt-series movies" has a "to" parameter that is explained as: None
"align tilt-series movies" has a "Use ALIGN frames range to SUM?" parameter that is explained as: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
"align tilt-series movies" has a "from" parameter that is explained as: None
"align tilt-series movies" has a "to" parameter that is explained as: None
"align tilt-series movies" has a "Binning factor" parameter that is explained as: 1x or 2x. Bin stack before processing.
"align tilt-series movies" has a "X" parameter that is explained as: None
"align tilt-series movies" has a "Y" parameter that is explained as: None
"align tilt-series movies" has a "X" parameter that is explained as: None
"align tilt-series movies" has a "Y" parameter that is explained as: None
"align tilt-series movies" has a "Split & sum odd/even frames?" parameter that is explained as: (Used for denoising data preparation). If set to Yes, 2 additional movies/tilt series will be generated, one generated from the even frames and the other from the odd ones using the same alignment for the whole stack of frames.
"align tilt-series movies" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"align tilt-series movies" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"align tilt-series movies" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"align tilt-series movies" has a "" parameter that is explained as: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. Motioncor can use multiple GPUs - in that case set to i.e. *0 1 2*.
"align tilt-series movies" has a "X" parameter that is explained as: None
"align tilt-series movies" has a "Y" parameter that is explained as: None
"align tilt-series movies" has a "Patches overlap (%)" parameter that is explained as: Specify the overlapping between patches. 
For example, overlap=20 means that each patch will have a 20% overlapping 
with its neighboring patches in each dimension.
"align tilt-series movies" has a "global align" parameter that is explained as: None
"align tilt-series movies" has a "local align" parameter that is explained as: None
"align tilt-series movies" has a "Tolerance (px)" parameter that is explained as: Tolerance for iterative alignment, default *0.2px*.
"align tilt-series movies" has a "Additional parameters" parameter that is explained as: Extra command line parameters. See MotionCor help.
"align tilt-series movies" has a "Rotate gain reference:" parameter that is explained as: Rotate gain reference counter-clockwise.
"align tilt-series movies" has a "Flip gain reference:" parameter that is explained as: Flip gain reference after rotation.
"align tilt-series movies" has a "Camera defects file" parameter that is explained as: Defect file that stores entries of defects on camera.
Each entry corresponds to a rectangular region in image. The pixels in such a region are replaced by neighboring good pixel values. Each entry contains 4 integers x, y, w, h representing the x, y coordinates, width, and height, respectively.
"align tilt-series movies" has a "Camera defects map" parameter that is explained as: 1. Defect map is a binary (0 or 1) map where defective  pixels are assigned value of 1 and good pixels have value of 0.
2. The defective pixels are corrected with a random pick of good pixels in its neighborhood. 
3. This is map must have the same dimension and orientation as the input movie frame.
4. This map can be provided as either MRC or TIFF file that has MRC mode of 0 or 5 (unsigned 8 bit).
"align tilt-series movies" has a "These options are ignored for non-EER movies." parameter that is explained as: None
"align tilt-series movies" has a "EER fractionation" parameter that is explained as: The number of hardware frames to group into one fraction. This option is relevant only for Falcon 4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
"align tilt-series movies" has a "EER upsampling" parameter that is explained as: EER upsampling (1x = 4K, 2x = 8K, 3x=16K)
"align tilt-series movies" has a "Correct anisotropic magnification?" parameter that is explained as: Correct anisotropic magnification by stretching image along the major axis, the axis where the lower magnification is detected.
"align tilt-series movies" has a "Major scale factor" parameter that is explained as: None
"align tilt-series movies" has a "Minor scale factor" parameter that is explained as: None
"align tilt-series movies" has a "Distortion angle (deg)" parameter that is explained as: None

The protocol named "annotate segmented membranes" can be found in the tomosegmemtv plugin.
"annotate segmented membranes" protocol help is as follows:
  Manual annotation tool for segmented membranes
    .
"annotate segmented membranes" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"annotate segmented membranes" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"annotate segmented membranes" has a "Input Tomo Masks" parameter that is explained as: Select the Tomogram Masks (segmented tomograms) for the membrane annotation.

The protocol named "Resize segmented or annotated volume" can be found in the tomosegmemtv plugin.
"Resize segmented or annotated volume" protocol help is as follows:
 Resize segmented volumes or annotated (TomoMasks)..
"Resize segmented or annotated volume" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"Resize segmented or annotated volume" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"Resize segmented or annotated volume" has a "Input segmentations (TomoMasks)" parameter that is explained as: None
"Resize segmented or annotated volume" has a "Input tomograms" parameter that is explained as: These tomograms will be used to be the ones to which the resized TomoMasks will be referred to. Thus, the resized segmentations will be of the same size of those tomograms.

The protocol named "tomogram segmentation" can be found in the tomosegmemtv plugin.
"tomogram segmentation" protocol help is as follows:
 Segment membranes in tomograms.
"tomogram segmentation" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"tomogram segmentation" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"tomogram segmentation" has a "Input tomograms" parameter that is explained as: None
"tomogram segmentation" has a "Membrane thickness (voxels)" parameter that is explained as: It basically represents the standard deviation of a Gaussian filtering. In general, any value in a range around that thickness works well. Too low values may make spurious details produce false positives at the local membrane detector while too high values may excessively smear out the membranes, which in turn may produce discontinuities in the segmentation results.
"tomogram segmentation" has a "Membrane scale factor (voxels)" parameter that is explained as: This defines the effective neighborhood involved in the voting process. Depending on the thickness of the membranes in the tomogram, lower (for thinner membranes) or higher values (for thicker ones) may be more appropriate.
"tomogram segmentation" has a "Is black over white?" parameter that is explained as: None
"tomogram segmentation" has a "Membrane-strength threshold" parameter that is explained as: Allow the user tune the amount of output membrane points and remove false positives. Only voxels with values of membrane-strength threshold higher than this value will be considered as potential membrane points, and planarity descriptors will be calculated for them. Higher values will generate less membrane points, at the risk of producing gaps in the membranes. Lower values will provide more membrane points, at the risk of generating false positives.
"tomogram segmentation" has a "Sigma for the initial gaussian filtering" parameter that is explained as: The input tomogram is subjected to an initial Gaussian filtering aiming at reducing the noise so as to determine the derivatives more robustly. By default, a standard deviation of 1.0 voxel is considered. This option allows fine-tuning of this parameter. If the membranes are very thin or are very close to each other, use lower values (e.g. 0.5)
"tomogram segmentation" has a "Sigma for the post-processing gaussian filtering" parameter that is explained as: This option refers to the post-processing Gaussian filtering that is applied to the output tomogram. If sigma is set to 0, no such filtering will be applied and the program will produce 1-voxel-thick membranes. If the filter is desired to be applied, use lower values (e.g 0.5) for membranes that are very thin or are very close to each other.
"tomogram segmentation" has a "Keep all the generated files?" parameter that is explained as: If set to Yes, a file will be kept for each step carried out in the protocol. If set to No, only the file corresponding to the last step will be kept. Steps followed and the corresponding generated files are listed below:

   - Scale-space --> *filename_s2.mrc*
   - First tensor voting --> *filename_tv.mrc*
   - Surfaceness --> *filename_surf.mrc*
   - Second tensor voting --> *filename_tv2.mrc*
   - Saliency --> *filename_flt.mrc*
"tomogram segmentation" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"tomogram segmentation" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"tomogram segmentation" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "compute defocus array" can be found in the novactf plugin.
"compute defocus array" protocol help is as follows:
 
    Compute defocus array for each tilt-image with novaCTF.

    More info:
            https://github.com/turonova/novaCTF
    .
"compute defocus array" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"compute defocus array" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"compute defocus array" has a "Input set of tilt-series" parameter that is explained as: None
"compute defocus array" has a "Input tilt-series CTF estimation" parameter that is explained as: Select the CTF estimation for the input tilt-series.
"compute defocus array" has a "Tomogram thickness (voxels)" parameter that is explained as: Size of the tomogram in voxels in the Z direction.
"compute defocus array" has a "Tomogram shift (voxels)" parameter that is explained as: Shift of the tomogram in voxels in the Z direction. The shift should be set to zero even if for reconstruction we want to shift the tomogram in z! We assume the defocus to be estimated at the center of mass which should correspond to the shifted tomogram and thus here the shift should be zero.
"compute defocus array" has a "Defocus step (nm)" parameter that is explained as: The space between min and max in Z is sliced by defocus step. 15 nm is default step size. See Fig. 2 in Turonova et al., 2017 for optimal number.
"compute defocus array" has a "Correction type" parameter that is explained as: CTF correction type to be applied for the tilt-series.
"compute defocus array" has a "Correct astigmatism" parameter that is explained as: Correct for astigmatism in reconstruction.
"compute defocus array" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"compute defocus array" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"compute defocus array" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "3D CTF correction and reconstruction" can be found in the novactf plugin.
"3D CTF correction and reconstruction" protocol help is as follows:
 
    Tomogram reconstruction with 3D CTF correction by novaCTF.

    More info:
            https://github.com/turonova/novaCTF
    .
"3D CTF correction and reconstruction" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"3D CTF correction and reconstruction" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"3D CTF correction and reconstruction" has a "NovaCTF compute defocus run" parameter that is explained as: None
"3D CTF correction and reconstruction" has a "Apply tilt-series alignment?" parameter that is explained as: None
"3D CTF correction and reconstruction" has a "Erase gold beads" parameter that is explained as: Remove the gold beads from the tilt-series.
"3D CTF correction and reconstruction" has a "Input set of fiducial models" parameter that is explained as: Set of fid. models with no gaps after alignment
"3D CTF correction and reconstruction" has a "Bead diameter (px)" parameter that is explained as: For circle objects, this entry specifies a radius to use for points without an individual point size instead of the object's default sphere radius. This entry is floating point and can be used to overcome the limitations of having an integer default sphere radius. If there are multiple circle objects, enter one value to apply to all objects or a value for each object.
"3D CTF correction and reconstruction" has a "Linear region" parameter that is explained as: None
"3D CTF correction and reconstruction" has a "Gaussian fall-off" parameter that is explained as: None
"3D CTF correction and reconstruction" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"3D CTF correction and reconstruction" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"3D CTF correction and reconstruction" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "auto-picking" can be found in the gautomatch plugin.
"auto-picking" protocol help is as follows:
  Automated particle picker for SPA.

    Gautomatch is a GPU accelerated program for accurate, fast, flexible and
    fully automatic particle picking from cryo-EM micrographs with or without
    templates.
    .
"auto-picking" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"auto-picking" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"auto-picking" has a "Input Micrographs" parameter that is explained as: Select the SetOfMicrographs to be used during picking.
"auto-picking" has a "Input References" parameter that is explained as: Template images (2D class averages or reprojections from a reference volume) to be used in picking.
 If not provided, references will be auto-generated. This is fine for *spherical particles* like virus or ribosome.
"auto-picking" has a "References have inverted contrast" parameter that is explained as: Set to Yes to indicate that the reference have inverted contrast with respect to the particles in the micrographs.
Keep in mind that auto-generated templates will be WHITE.
"auto-picking" has a "Angular step size" parameter that is explained as: Angular step size for picking, in degrees
"auto-picking" has a "Micrographs for wizard" parameter that is explained as: Select which micrographs will be used for optimizing the parameters in the wizard. By default, ALL micrograph are used. You can select to use a subset based on defocus values (where micrographs will be taken from different defocus). 
"auto-picking" has a "Micrographs for optimization:" parameter that is explained as: Select the number of micrographs that you want to be used for the parameters optimization. 
"auto-picking" has a "CTF estimation" parameter that is explained as: Choose some CTF estimation related to the input micrographs to create the subset by defocus values.
"auto-picking" has a "Threshold" parameter that is explained as: Particles with CCC above the threshold will be picked
"auto-picking" has a "Particle radius (A)" parameter that is explained as: Particle radius in Angstrom. Default -1 means it will be equal to 75% of references size if they were provided, otherwise 250 A.
"auto-picking" has a "" parameter that is explained as: None
"auto-picking" has a "Guess advanced parameters?" parameter that is explained as: By default, the program will optimize advanced parameters by itself, however if you want to modify them, select No
"auto-picking" has a "Box size (pix)" parameter that is explained as: Box size, in pixels; a suggested value will be automatically calculated using pixel size and particle size
"auto-picking" has a "Min inter-particle distance (A)" parameter that is explained as: Minimum distance between particles in Angstrom
 Use value of 0.9~1.1X diameter; can be 0.3~0.5X for filament-like particle
"auto-picking" has a "Speed" parameter that is explained as: Speed level {0,1,2,3,4}. The bigger the faster, but less accurate.
Suggested values: 2 for >1 MDa complex, 1 for <500 kD complex, 1 or 2 for 500~1000 kD.
0 is not suggested, because the accuracy is simply fitting noise, unless for special noise-free micrographs. Use 3 for huge viruses, but 2 is still preferred. Probably do not use 4 at all, it is not accurate in general.
"auto-picking" has a "To adjust these parameters, select "No" for the "Guess advanced parameters?" on the Advanced tab." parameter that is explained as: None
"auto-picking" has a "Local sigma cut-off" parameter that is explained as: Local sigma cut-off (relative value), 1.2~1.5 should be a good range
Normally a value >1.2 will be ice, protein aggregation or contamination.
This option is designed to get rid of sharp carbon/ice edges or sharp metal particles.
"auto-picking" has a "Local sigma diameter (A)" parameter that is explained as: Diameter for estimation of local sigma, in Angstrom.
Usually this diameter could be 0.5-2x of your particle diameter according to several factors. When using bigger values, normally you should decrease *Local sigma cut-off*. For smaller and sharper high density contamination/ice/metal particles you could use a smaller diameter and larger *Local sigma cut-off*
"auto-picking" has a "Min" parameter that is explained as: None
"auto-picking" has a "Max" parameter that is explained as: None
"auto-picking" has a "Local average diameter (A)" parameter that is explained as: Diameter for estimation of local average, in Angstrom. 1.5~2.0X particle diameter suggested.
However, if you have sharp/small ice or any dark/bright dots, using a smaller value will be much better to get rid of these areas
"auto-picking" has a "Min" parameter that is explained as: None
"auto-picking" has a "Max" parameter that is explained as: None
"auto-picking" has a "Pre-filter micrographs?" parameter that is explained as: This band-pass pre-filter is normally not suggested, because it can affect ice/carbon detection. Use it only if you have a severe ice gradient.
"auto-picking" has a "Min" parameter that is explained as: None
"auto-picking" has a "Max" parameter that is explained as: None
"auto-picking" has a "Detect ice/aggregates/carbon?" parameter that is explained as: None
"auto-picking" has a "Template normalization type" parameter that is explained as: Template normalization: 1, 2 or 3 allowed.
"auto-picking" has a "Do band-pass?" parameter that is explained as: Choose No to skip band-pass filtering.
"auto-picking" has a "Exclusive picking?" parameter that is explained as: Exclude user-provided areas. This can be useful in the following cases:

(a) Another cycle of auto-picking after 2D classification: in this case, usually you are pretty sure that some of the particles are completely rubbish, it will be much better to exclude them during picking.
(b) Picking for partial structure: sometimes, you might have two/multiple domain complex, one is severely dominant and affect picking of the other (the rest). If you want to focus on another domain, it might be quite helpful to exclude such good particles from 2D classification.
(c) Strong orientation preference: if your templates were severely biased and mainly picked the preferred views, then it might be nice to exclude the preferred views and focused on rare views.
"auto-picking" has a "Coordinates to be excluded" parameter that is explained as: Coordinates can be imported beforehand or generated from particles using scipion - extract coordinates protocol.
"auto-picking" has a "Detector defects coordinates" parameter that is explained as: Occasionally you might have detector defects, e.g. a black/white stripe. This will help to get rid of these bad areas.
"auto-picking" has a "Write CC files?" parameter that is explained as: Specify to write out cross-correlation files in MRC stack
"auto-picking" has a "Write pre-filtered micrographs?" parameter that is explained as: Specify to write out pre-filted micrographs
"auto-picking" has a "Write estimated background?" parameter that is explained as: Specify to write out estimated background of the micrographs
"auto-picking" has a "Write background-subtracted micrographs?" parameter that is explained as: Specify to write out background-subtracted micrographs
"auto-picking" has a "Write local sigma?" parameter that is explained as: Specify to write out local sigma micrographs
"auto-picking" has a "Write detected mask?" parameter that is explained as: Specify to write out the auto-detected mask (ice, contamination, aggregation, carbon edges etc.)
"auto-picking" has a "The following params are related to how streaming is done in Scipion." parameter that is explained as: None
"auto-picking" has a "Sleep when waiting (secs)" parameter that is explained as: If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
"auto-picking" has a "Batch size" parameter that is explained as: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
"auto-picking" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"auto-picking" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"auto-picking" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tomo reconstruction" can be found in the isonet plugin.
"tomo reconstruction" protocol help is as follows:
 
     Isotropic Reconstruction of Electron Tomograms with Deep Learning
    .
"tomo reconstruction" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"tomo reconstruction" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"tomo reconstruction" has a "Tomograms" parameter that is explained as: Select the input tomogram for restoring the missing wedge.
"tomo reconstruction" has a "CTF tomo series" parameter that is explained as: Select the CTF estimation for the set of tilt-series.
"tomo reconstruction" has a "Acceleration voltage" parameter that is explained as: Acceleration voltage in kV
"tomo reconstruction" has a "Spherical aberration" parameter that is explained as: Spherical aberration in mm.
"tomo reconstruction" has a "SNR fall rate" parameter that is explained as: SNR fall rate with the frequency. High values means losing more high frequency.If this value is not set, the program will look for the parameter in the star file.If this value is not set and not found in star file, the default value 1.0 will be used.
"tomo reconstruction" has a "Strength of the deconvolution" parameter that is explained as: SNR fall rate with the frequency. High values means losing more high frequency.If this value is not set, the program will look for the parameter in the star file.If this value is not set and not found in star file, the default value 1.0 will be used.
"tomo reconstruction" has a "Highpass filter" parameter that is explained as: Highpass filter for at very low frequency. We suggest to keep this default value.
"tomo reconstruction" has a "The overlapping rate" parameter that is explained as: The overlapping rate for adjecent chunks.
"tomo reconstruction" has a "Highpass filter" parameter that is explained as: Highpass filter for at very low frequency. We suggest to keep this default value.
"tomo reconstruction" has a "Pixel size (Å)" parameter that is explained as: Pixel size in Anstroms. Usually you want to bin your tomograms to about 10Å pixel size.Too large or too small pixel sizes are not recommanded, since the target resolution on Z-axis of corrected tomograms should be about 30Å.
"tomo reconstruction" has a "Generate mask?" parameter that is explained as: Generate a mask that include sample area and exclude "empty" area of the tomogram. The masks do not need to be precise. In general, the number of subtomograms (a value in star file) should be lesser if you masked out larger area.
"tomo reconstruction" has a "Patch size" parameter that is explained as:  The size of the box from which the max-filter and std-filter are calculated.
"tomo reconstruction" has a "Density percentage" parameter that is explained as: The approximate percentage of pixels to keep based on their local pixel density.If this value is not set, the program will look for the parameter in the star file.If this value is not set and not found in star file, the default value 50 will be used.
"tomo reconstruction" has a "Std percentage" parameter that is explained as: The approximate percentage of pixels to keep based on their local standard deviation.If this value is not set, the program will look for the parameter in the star file.If this value is not set and not found in star file, the default value 50 will be used.
"tomo reconstruction" has a "Z_crop" parameter that is explained as: If exclude the top and bottom regions of tomograms along z axis. For example, "0.2" will mask out the top 20% and bottom 20% region along z axis.
"tomo reconstruction" has a "Tomo index" parameter that is explained as:  If this value is set, process only the tomograms listed in this index. e.g. 1,2,4 or 5-10,15,16
"tomo reconstruction" has a "Number of subtomograms to be extracted per tomogram" parameter that is explained as: Number of subtomograms to be extracted
"tomo reconstruction" has a "Size of cubes" parameter that is explained as: Size of cubes for training, should be divisible by 8, eg. 32, 64. The actual sizes of extracted subtomograms are this value adds 16.This is the size of the cubic volumes used for training. This values should be smaller than the size of subtomogram. And the cube_size should be divisible by 8. If this value isnt set, cube_size is automatically determined as int(subtomo_size / 1.5 + 1)//16 * 16
"tomo reconstruction" has a "Crop size" parameter that is explained as: The size of subtomogram, should be larger than the cube_size The default value should be 16+cube_size.
"tomo reconstruction" has a "Training model path" parameter that is explained as: A trained neural network model in ".h5" format to start with.
"tomo reconstruction" has a "Number of training iterations" parameter that is explained as: Number of training iterations
"tomo reconstruction" has a "Number of epoch" parameter that is explained as: Number of epoch for each iteraction
"tomo reconstruction" has a "Batch size" parameter that is explained as: Size of the minibatch.If None, batch_size will be the max(2 * number_of_gpu,4). batch_size should be divisible by the number of gpu.
"tomo reconstruction" has a "Steps per epoch" parameter that is explained as: Step per epoch. If not defined, the default value will be min(num_of_subtomograms * 6 / batch_size , 200
"tomo reconstruction" has a "Level of noise" parameter that is explained as: Level of noise STD(added noise)/STD(data) after the iteration defined in noise_start_iter.
"tomo reconstruction" has a "Noise start iter" parameter that is explained as: Iteration that start to add noise of corresponding noise level.
"tomo reconstruction" has a "Filter names" parameter that is explained as: Filter names when generating noise volumes, can be 'ramp', 'hamming' and 'noFilter'
"tomo reconstruction" has a "Drop out rate" parameter that is explained as: Drop out rate to reduce overfitting
"tomo reconstruction" has a "Learning rate" parameter that is explained as: Learning rate for network training.
"tomo reconstruction" has a "Number of convolution layer" parameter that is explained as: Number of convolution layer for each depth
"tomo reconstruction" has a "Depth of UNet" parameter that is explained as: Depth of UNet.
"tomo reconstruction" has a "Kernel for convolution" parameter that is explained as: Kernel for convolution
"tomo reconstruction" has a "Filter base" parameter that is explained as: The base number of channels after convolution.
"tomo reconstruction" has a "Use batch normalization layer?" parameter that is explained as: Use Batch Normalization layer
"tomo reconstruction" has a "Use pooling layer?" parameter that is explained as: Use pooling layer instead of stride convolution layer
"tomo reconstruction" has a "Normalize percentile?" parameter that is explained as: Normalize the 5 percent and 95 percent pixel intensity to 0 and 1 respectively. If this is set to False, normalize the input to 0 mean and 1 standard deviation.
"tomo reconstruction" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"tomo reconstruction" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
"tomo reconstruction" has a "Choose GPU IDs:" parameter that is explained as: This argument is necessary. By default, the protocol will attempt to launch on GPU 0. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. GPU are separated by ",". For example: "0,1,5"

The protocol named "tilt-series align and reconstruct" can be found in the aretomo plugin.
"tilt-series align and reconstruct" protocol help is as follows:
  Protocol for fiducial-free tilt series alignment, tomogram reconstruction and CTF estimation all in one..
"tilt-series align and reconstruct" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"tilt-series align and reconstruct" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"tilt-series align and reconstruct" has a "Input set of Tilt-Series" parameter that is explained as: If you choose to skip alignment, the input tilt-series are expected to be already aligned.
"tilt-series align and reconstruct" has a "Skip alignment?" parameter that is explained as: You can skip alignment if you just want to reconstruct a tomogram from already aligned tilt-series.
"tilt-series align and reconstruct" has a "Reconstruct the tomograms?" parameter that is explained as: You can skip tomogram reconstruction, so that input tilt-series will be only aligned.
"tilt-series align and reconstruct" has a "Save interpolated aligned TS?" parameter that is explained as: Choose No to discard aligned stacks.
"tilt-series align and reconstruct" has a "Use alignment from previous AreTomo run?" parameter that is explained as: None
"tilt-series align and reconstruct" has a "Previous AreTomo run" parameter that is explained as: Use alignment from a previous AreTomo run. The match is made using *tsId*. This option is useful when working with odd/even tilt-series sets. All other input alignment parameters will be ignored.
"tilt-series align and reconstruct" has a "Binning" parameter that is explained as: Binning for aligned output tilt-series / volume.
"tilt-series align and reconstruct" has a "Volume height for alignment (voxels)" parameter that is explained as: Specifies Z height (*unbinned*) of the temporary volume reconstructed for projection matching as part of the alignment process. This value plays an important role in alignment accuracy. This Z height should be always smaller than tomogram thickness and should be close to the sample thickness.
"tilt-series align and reconstruct" has a "Tomogram thickness unbinned (voxels)" parameter that is explained as: Z height of the reconstructed volume in *unbinned* voxels.
"tilt-series align and reconstruct" has a "Refine tilt angles?" parameter that is explained as: You have three options:
a) Disable measure and correction
b) Measure only (default). Correction is done during alignment but not for final reconstruction
c) Measure and correct

Occasionally, the measurement is erroneous and can impair the alignment accuracy. Please note that the orientation of the missing wedge will be changed as a result of the correction of tilt offset. For subtomogram averaging, tomograms reconstructed from tilt series collected within the same tilt range may have different orientations of missing wedges.
"tilt-series align and reconstruct" has a "Refine tilt axis angle?" parameter that is explained as: Tilt axis determination is a two-step processing in AreTomo. A single tilt axis is first calculated followed by the determination of how tilt axis varies over the entire tilt range. The initial value lets users enter their estimate and AreTomo refines the estimate in [-3º, 3º] range.
"tilt-series align and reconstruct" has a "Generate extra IMOD output?" parameter that is explained as: 0 - No
1 - generate IMOD files for Relion 4
2 - generate IMOD files for Warp
3 - generate global and local-aligned tilt series stack. High frequencies are enhanced to alleviate the attenuation due to interpolation.
"tilt-series align and reconstruct" has a "Estimate the CTF?" parameter that is explained as: Activate to make aretomo estimate the CTF.
"tilt-series align and reconstruct" has a "Do phase shift estimation?" parameter that is explained as: None
"tilt-series align and reconstruct" has a "min" parameter that is explained as: None
"tilt-series align and reconstruct" has a "max" parameter that is explained as: None
"tilt-series align and reconstruct" has a "Do dose-weighting?" parameter that is explained as: None
"tilt-series align and reconstruct" has a "Reconstruction method" parameter that is explained as: Choose either SART or weighted back projection (WBP).
"tilt-series align and reconstruct" has a "iterations" parameter that is explained as: None
"tilt-series align and reconstruct" has a "projections per subset" parameter that is explained as: None
"tilt-series align and reconstruct" has a "Flip intensity?" parameter that is explained as: By default, the reconstructed volume and the input tilt series use the same grayscale that makes dense structures dark.
"tilt-series align and reconstruct" has a "Flip volume?" parameter that is explained as: Set to Yes when making a tomogram and No when making a tilt-series. This way the output orientation will be similar to IMOD.
"tilt-series align and reconstruct" has a "ROI for focused alignment" parameter that is explained as: By default AreTomo assumes the region of interest at the center of 0º projection image. A circular mask is employed to down-weight the area outside ROI during the alignment. When the structures of interest are far away from the tilt axis, the angular error in the determination of tilt axis will significantly amplify the translational error. ROI function can effectively improve the alignment accuracy for the distant structures.
Here you can provide *a pair of x and y coordinates*, representing the center of the region of interest.
The region of interest should be selected from 0º projection image with the origin at the lower left corner. IMOD's Pixel View is a good tool to select the center of region of interest.
"tilt-series align and reconstruct" has a "Sample type" parameter that is explained as: AreTomo provides two means to correct the local motion, one for isolated sample and the other for well distributed across the field of view.
"tilt-series align and reconstruct" has a "Coordinate file" parameter that is explained as: A list of x and y coordinates should be put into a two-column text file, one column for x and the other for y. Each pair defines a region of interest (ROI). The origin of the coordinate system is at the image's lower left corner.
"tilt-series align and reconstruct" has a "X" parameter that is explained as: None
"tilt-series align and reconstruct" has a "Y" parameter that is explained as: None
"tilt-series align and reconstruct" has a "Dark tolerance" parameter that is explained as: Set tolerance for removing dark images. The range is in (0, 1). The default value is 0.7. The higher value is more restrictive.
"tilt-series align and reconstruct" has a "Additional parameters" parameter that is explained as: Extra command line parameters. See AreTomo help.
"tilt-series align and reconstruct" has a "" parameter that is explained as: None
"tilt-series align and reconstruct" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"tilt-series align and reconstruct" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"tilt-series align and reconstruct" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tomo blik" can be found in the blik plugin.
"tomo blik" protocol help is as follows:
 
    Tool for visualising and interacting with cryo-ET and subtomogram averaging
    data using napari viewer
    .
"tomo blik" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"tomo blik" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"tomo blik" has a "Tomograms" parameter that is explained as: Select the input tomograms

The protocol named "tomogram membrane segmentation" can be found in the membrain plugin.
"tomogram membrane segmentation" protocol help is as follows:
 
    Segment membranes in tomograms using MemBrain-seg.

    More info:
        https://github.com/teamtomo/membrain-seg
    .
"tomogram membrane segmentation" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"tomogram membrane segmentation" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"tomogram membrane segmentation" has a "Input tomograms" parameter that is explained as: None
"tomogram membrane segmentation" has a "Threshold for segmentation" parameter that is explained as: Threshold for the membrane segmentation. Only voxels with a membrane score higher than this threshold will be segmented.
"tomogram membrane segmentation" has a "Sliding window size" parameter that is explained as: Sliding window size used for inference. Smaller values than 160 consume less GPU, but also lead to worse segmentation results!
"tomogram membrane segmentation" has a "Label connected components?" parameter that is explained as: Segmentation will be stored as labelled connected components (automatic annotation).
"tomogram membrane segmentation" has a "Threshold for connected components" parameter that is explained as: Components smaller than this size (in voxels) will be removed from the segmentation. A negative value disables this parameter.
"tomogram membrane segmentation" has a "Do test-time augmentation?" parameter that is explained as: Use 8-fold test-time augmentation? This improves segmentation quality, but also increases runtime.
"tomogram membrane segmentation" has a "Output probability maps?" parameter that is explained as: Stores probability maps obtained from 8-fold test-time augmentation in addition to the segmentations.
"tomogram membrane segmentation" has a "" parameter that is explained as: GPU device to be used. If no GPU is found, MemBrain-seg will run on CPU using the number of threads specified (much slower)
"tomogram membrane segmentation" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"tomogram membrane segmentation" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"tomogram membrane segmentation" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "OFM Corrector" can be found in the ofmcorrection plugin.
"OFM Corrector" protocol help is as follows:
 
    Corrects optical fluorecence microscopy images/channels based on calibration images
    .
"OFM Corrector" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"OFM Corrector" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"OFM Corrector" has a "Beads file pattern" parameter that is explained as: Pattern of the beads file name. Must contain this text.
"OFM Corrector" has a "OFM Root folder" parameter that is explained as: Path to the OFM sample images
"OFM Corrector" has a "File finished after" parameter that is explained as: File will be considered finished if it has not been modified for this time. Duration format example: 1d 20h 30m 30s --> 1 day 20 hours 30 minutes and 30 seconds
"OFM Corrector" has a "Scanning waiting time" parameter that is explained as: Time to wait for the next folder scan. Duration format example: 1d 20h 30m 30s --> 1 day 20 hours 30 minutes and 30 seconds
"OFM Corrector" has a "Execution host" parameter that is explained as: Select in which of the available do you want to launch this protocol.
"OFM Corrector" has a "Threads" parameter that is explained as: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
"OFM Corrector" has a "MPI processes" parameter that is explained as: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "AI training" can be found in the tomonet plugin.
"AI training" protocol help is as follows:
 
    Trains an AI model using a set of Coordinates. Producing a AI model that
    can be used in a later TomoNet tomogram picking step.
    .
"AI training" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"AI training" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"AI training" has a "Coordinates" parameter that is explained as: Coordinates to be used in the training
"AI training" has a "Epochs" parameter that is explained as: Number of "iterations" to run over the training data.

The protocol named "test output" can be found in the pyworkflowtests plugin.
"test output" protocol help is as follows:
  Protocol to test scalar output and input linking.
"test output" has a "Run name:" parameter that is explained as: Select run name label to identify this run.
"test output" has a "Run mode" parameter that is explained as: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
"test output" has a "Input box size as Integer" parameter that is explained as: None
"test output" has a "Nullable Integer" parameter that is explained as: None
Scipion v3.4.0 - Eugenius
