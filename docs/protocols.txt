
The protocol named "optical alignment" can be found at the xmipp3 plugin.
Its help description is:
 
    Wrapper protocol to Xmipp Movie Alignment by Optical Flow
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
from: None
to: None
Use ALIGN frames range to SUM?: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Save aligned micrograph: None
Save movie: Save Aligned movie
: Set to true if you want the GPU implementation of Optical Flow
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Window size: Window size (shifts are assumed to be constant within this window).
Group Size: The number of frames in each group at the last step
Use previous movie alignment to SUM frames?: Input movies could have alignment information froma previous protocol. If you select *Yes*, the previous alignment will be taken into account.
Compute PSD (before/after)?: If Yes, the protocol will compute for each movie the PSD of the average micrograph (without OF alignement) and after that, to compare each PSDs
Keep images in RAM ?: If True, the protocol will increase the demand of RAM, decreasing disc access
Apply Dose filter: Apply a dose-dependent filter to frames before summing them. Pre-exposure and dose per frame should  be specified during movies import.
Save unweighted micrographs?: Yes by default, if you have selected to apply a dose-dependent filter to the frames
Apply Dose filter before alignment?: if *True*, you apply dose filter before perform the alignment; else will apply after alignment.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "apply deformation field - Zernike3D" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for PDB deformation based on Zernike3D basis. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Zernike3D volume(s): Volume(s) with Zernike3D coefficients assigned.
Input volume mask: None
Zernike Degree: Degree Zernike Polynomials of the deformation=1,2,3,...
Harmonical Degree: Degree Spherical Harmonics of the deformation=1,2,3,...
Apply to structure?: If True, you will be able to provide an atomic structure to be deformed based on the Zernike3D coefficients associated to the input volume(s). If False, the coefficients will be applied to the volume(s) directly.
Input PDB: Atomic structure to apply the deformation fields defined by the Zernike3D coefficients associated to the input volume. For better results, the volume(s) and structure should be aligned
Move structure to box origin?: If PDB has been aligned inside Scipion, set to False. Otherwise, this option will correctly place the PDB in the origin of the volume.

The protocol named "metaprotocol heterogeneity subset" can be found at the xmipp3 plugin.
Its help description is:
  Metaprotocol to select a set of particles from a 3DClasses and a
    Volume from a SetOfVolumes
     .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of 3D classes: Select the set of 3D classes to select an specific set of particles.
Input Idx: Identifier of the volume and particles selected

The protocol named "metaprotocol golden highres" can be found at the xmipp3 plugin.
Its help description is:
  Metaprotocol to run golden version of highres.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Full-size Images: Select a set of images at full resolution
Initial volumes: Select a set of volumes with 2 volumes or a single volume
Radius of particle (px): This is the radius (in pixels) of the spherical mask covering the particle in the input images
Symmetry group: If no symmetry is present, give c1
Initial resolution: In Angstroms. The minimum resolution to be used in the first step of the protocol. Then, the resolution will be automatically adjusted.
Maximum resolution: In Angstroms. The maximum resolution to be used along the protocol. Set it to -1 for automatic adjustment.
Discard particles?: Discard particles when two distributions are estimated?
Split method: When discard particles is allowed, choose the method between hypothesis testing or Otsu thresholding
Adaptive threshold HT: Choose if you want to use an adaptive threshold for the hypothesis testing.
Max. shift (%): Maximum shift as a percentage of the image size
Min.: Side views are around 90 degrees, top views around 0
Max.: You may generate redudant galleries by setting this angle to 180, this may help if c1 symmetry is considered
Mask: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
Symmetrize volume within mask?: None
Mask symmetry: If no symmetry is present, give c1
Mask: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
Apply helical symmetry?: None
Radius: In Angstroms
Dihedral symmetry: None
Min. Rotation: In degrees
Max. Rotation: In degrees
Min. Z shift: In angstroms
Max. Z shift: In angstroms
Post-processing command: A command template that is used to post-process the reconstruction. The following variables can be used %(sampling)s %(dim)s %(volume)s %(iterDir)s. The command should read Spider volumes and modify the input volume.the command should be accessible either from the PATH or provide the absolute path.
Examples: 
xmipp_transform_filter -i %(volume)s --fourier low_pass 15 --sampling %(sampling)s
/home/joe/myScript %(volume)s sampling=%(sampling)s dim=%(dim)s
Significant denoising Real space: None
Significant denoising Fourier space: None
Laplacian denoising: It can only be used if there is a mask
Blind deconvolution: None
Attenuate undershooting: None
Attenuate undershooting (K): Values below avg-K*sigma are attenuated
Evaluate difference: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "auto-picking (step 2)" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to pick particles automatically in a set of
    micrographs using previous training .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Model source: The files model_* can be copied from a previous protocol execution within this project or copied from an external directory. This latter option is useful incases in which the same kind of molecule is processed many times.
Xmipp particle picking run: Select the previous xmipp particle picking run.
Xmipp particle picking model directory: The directory must contain the files model_*, config.xmd and templates.stk
Micrographs to pick: Select from which set of micrographs to pick using the training from supervised run.If you use Same as supervised, the same set of micrographs used for training the picker will be used at this point. If you select Other, you can select another set of micrograph (normally from the same specimen) and pick them completely automatic using the trained picker.
Micrographs: Select other set of micrographs to pick using the trained picker.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "add noise particles" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a set of particles, the protocol will add noise to them 
    The types of noise are Uniform, Student and Gaussian.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select a set of particles.
Noise Type: None
Standard Deviation: Please, introduce the standard deviation value.Mean value can be changed in advanced mode.
Mean: Please, introduce the mean value (default = 0).
Degree of Freedom: Please, introduce the Degree of Freedom.Mean value can be changed in advanced mode.
Standard Deviation: Please, introduce the standard deviation value.Mean value can be changed in advanced mode.
Mean: Please, introduce the mean value (default = 0).
Minimum Value: Please, introduce the minimum value. (default = 0)
Maximum Value: Please, introduce the maximum value (default = 1).
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "add noise volume/s" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a set of volumes, or a volume the protocol will add noise to them 
    The types of noise are Uniform, Student and Gaussian.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume/s: Select a volume or Set of volumes.
Noise Type: None
Standard Deviation: Please, introduce the standard deviation value.Mean value can be changed in advanced mode.
Mean: Please, introduce the mean value (default = 0).
Degree of Freedom: Please, introduce the Degree of Freedom.Mean value can be changed in advanced mode.
Standard Deviation: Please, introduce the standard deviation value.Mean value can be changed in advanced mode.
Mean: Please, introduce the mean value (default = 0).
Minimum Value: Please, introduce the minimum value. (default = 0)
Maximum Value: Please, introduce the maximum value (default = 1).
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "align volume" can be found at the xmipp3 plugin.
Its help description is:
  
    Aligns a set of volumes using cross correlation 
    or a Fast Fourier method. 

     .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Reference volume: Reference volume to be used for the alignment.
Input volume(s): Select one or more volumes (Volume or SetOfVolumes)
to be aligned againt the reference volume.
Apply mask?: Apply a 3D Binary mask to the volumes
Mask type: Select the type of mask you want to apply
Mask radius: Insert the radius for the mask
Mask file: Select the volume mask object
Alignment algorithm: Exhaustive searches all possible combinations within a search space.Local searches around a given position.Be aware that the Fast Fourier algorithm requires a special compilationof Xmipp (--cltomo flag). It performs the same job as the  exhaustive method but much faster.
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Rot: None
Tilt: None
Psi: None
X: None
Y: None
Z: None
Optimize scale: Choose YES if you want to optimize the scale of input volume/s based on the reference
Initial scale: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "align volume web" can be found at the xmipp3 plugin.
Its help description is:
  Aligns a set of volumes using cross correlation.
    Based on Xmipp protocol for aligning volumes, but
    the parameters are restricted for ease of use.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Reference volume: Reference volume to be used for the alignment.
Input volume(s): Select one or more volumes (Volume or SetOfVolumes)
to be aligned againt the reference volume.
Apply mask?: Apply a 3D Binary mask to the volumes
Mask type: Select the type of mask you want to apply
Mask radius: Insert the radius for the mask
Mask file: Select the volume mask object
Alignment algorithm: Exhaustive searches all possible combinations within a search space.Local searches around a given position.Be aware that the Fast Fourier algorithm requires a special compilationof Xmipp (--cltomo flag). It performs the same job as the  exhaustive method but much faster.
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Rot: None
Tilt: None
Psi: None
X: None
Y: None
Z: None
Optimize scale: Choose YES if you want to optimize the scale of input volume/s based on the reference
Initial scale: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "align volume and particles" can be found at the xmipp3 plugin.
Its help description is:
  
    Aligns a volume (inputVolume) using a Fast Fourier method
    with respect to a reference one (inputReference).
     The obtained alignment parameters are used to align the set of particles or subtomograms
     (inputParticles) that generated the input volume.
     .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Reference volume: Reference volume to be used for the alignment.
Input volume: Select one volume to be aligned against the reference volume.
Input particles: Select one set of particles to be aligned against the reference set of particles using the transformation calculated with the reference and input volumes.
Alignment mode: None
Symmetry group: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] page for a description of the symmetries accepted by Xmipp
Wrap: Wrap the input volume when aligning to the reference
Apply mask?: Apply a 3D Binary mask to the volumes
Mask type: Select the type of mask you want to apply
Mask radius: Insert the radius for the mask
Mask file: Select the volume mask object
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "analyze local defocus" can be found at the xmipp3 plugin.
Its help description is:
 Assigns to each micrograph a coefficient (R2) which evaluates the result of the
        local defocus adjustment and displays the local defocus for all the particles in each micrograph..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: None
Input images: Set of particles with assigned local defocus

The protocol named "break symmetry" can be found at the xmipp3 plugin.
Its help description is:
 
    Given an input set of particles with angular assignment, find an
    equivalent angular assignment for a given symmetry.

    Be aware that input symmetry values follows Xmipp conventions as described in:
    http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Symmetry group: See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format in Xmipp.
If no symmetry is present, use _c1_.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "angular graph consistency" can be found at the xmipp3 plugin.
Its help description is:
 
    Performs soft alignment validation of a set of particles previously aligned
    confronting them using Graph filtered correlations representation. This
    protocol produces an histogram with two groups of particles.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: Select the input volume(s).
Input particles: Select the input projection images.
Symmetry group: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
Angular Sampling (degrees): Angular distance (in degrees) between neighboring projection points 
correlation level for validation: threshold correlation to be used in validation. Keep this value in the range [0.90 -- 0.97]
Minimum allowed tilt angle: Tilts below this value will not be considered for the alignment
Maximum allowed tilt angle without mirror check: Tilts above this value will not be considered for the alignment without mirror check
Target resolution (A): Low pass filter the particles to this resolution. This usually helps a lot obtaining good alignment. You should have a good reason to modify this value outside the range  [8-10] A
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "apply alignment 2d" can be found at the xmipp3 plugin.
Its help description is:
  Apply alignment parameters and produce a new set of images. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: Select the particles that you want to apply thealignment parameters.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "apply transformation matrix" can be found at the xmipp3 plugin.
Its help description is:
  
    Apply transformation matrix  of an aligned volume on 
    a set of particles to modify their angular assignment.
    Note:
    These particles are practically related to the 
    aligned volume (but before alignment).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Aligned particles that their  angular assignment needs to be modified.
Input volume: Volume that we want to use its transformation matrix to modify angular assignment of input particles. (This is normally the output volume of protocol_align_volume)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "assign tiltpairs" can be found at the xmipp3 plugin.
Its help description is:
     
    From two sets of points (tilted and untilted) the protocol determines
    the affine transformation between these sets.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Micrograph tilt pair: Select micrographs tilt pair.
Input type: Select a Set of Coordinates or a Set or Particles.
Untilted input: Select the untilted input set, it can be either coordinates or particles (that contains coordinates.
Tilted input: Select the tilted input set, it can be either coordinates or particles (that contains coordinates. It should be of the same type of the input untilted.
Tilt angle: Tilt angle estimation, the method will look for the assignment in the interval of [tilt_angle-15, tilt_angle+15].
 By default: tilt angle = -1, if there is not any information about the tilt angle
Threshold value: Parameter between 0 and 1 that allows to define if 
a tilt point can be matched with a certain untilt point.
The matching is performed only if the distance is lesser
than threshold * particlesize.
Maximum shift (pixels): Maximum allowed distance (in pixels) that the tilt micrograph can be shifted respect to the untilted micrograph
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "boost particles" can be found at the xmipp3 plugin.
Its help description is:
  This protocol tries to boost the frequencies of the particles to imporve them, based on an adjustment on its correspondent projections from a reference volume. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particles : Specify a SetOfParticles
Reference volume : Specify a volume.
Circular mask radius: : Radius of the circular mask to avoid edge artifacts. If -1 it is half the X dimension of the input particles
Maximum resolution: : Maximum resolution (in A) of the data 
Ignore particles with negative beta0 or R2?: : Particles with negative beta0 or R2 will not appear in the output set as they are considered bad particles. Moreover, negative betas will not contribute to mean beta if "mean" option is selected
Limit frequency?: : Limit frequency in the adjustment process to the frequency correspondent to the resolution indicated in "Maximum resolution" field above
Decay of the filter (sigma): : Decay of the filter (sigma) to smooth the mask transition
Fourier padding factor: : The volume is zero padded by this factor to produce projections
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "cl2d" can be found at the xmipp3 plugin.
Its help description is:
  Classifies a set of images using a clustering algorithm to subdivide
    the original dataset into a given number of classes. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input images: Select the input images to be classified.
Number of classes:: Number of classes (or references) to be generated.
Random initialization of classes:: Initialize randomly the first classes. If you don't initialize randomly, you must supply a set of initial classes
Initial classes: Set of initial classes to start the classification
Number of initial classes:: Initial number of classes used in the first level.
Number of iterations:: Maximum number of iterations within each level.
Comparison method: Use correlation or correntropy
Clustering method: Use the classical clustering criterion or the robust
Additional parameters: Additional parameters for classify_CL2D: 
 --verbose, --corrSplit, ...
Perform core analysis: An image belongs to the core if it is close (see Junk Zscore and PCA Zscore) to the class center
Junk Zscore: Which is the average Z-score to be considered as junk. Typical values go from 1.5 to 3. For the Gaussian distribution 99.5% of the data is within a Z-score of 3. Lower Z-scores reject more images. Higher Z-scores accept more images.
PCA Zscore: Which is the PCA Z-score to be considered as junk. Typical values go from 1.5 to 3. For the Gaussian distribution 99.5% of the data is within a Z-score of 3. Lower Z-scores reject more images. Higher Z-scores accept more images.
Perform stable core analysis: Two images belong to the stable core if they have been essentially together along the classification process
Tolerance: An image belongs to the stable core if it has been with other images in the same class in all the previous levels except possibly a few of them. Tolerance defines how few is few. Tolerance=0 means that an image must be in all previous levels with the rest of images in the core.
Compute class hierarchy: None
Analyze rejected particles: To see the analysis you need to browse the execution directory and go into the different levels
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "align with cl2d" can be found at the xmipp3 plugin.
Its help description is:
  Aligns a set of particles using the CL2D algorithm. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Use a Reference Image ?: If you set to *Yes*, you should provide a reference image.
If *No*, the default generation is done by averaging subsets of the input images.
Reference image: Image that will serve as class reference. If the input is a set, then the first image will be used as reference.
Maximum shift (px):: None
Number of iterations:: Maximum number of iterations
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "2D classes mapping" can be found at the xmipp3 plugin.
Its help description is:
  Create a low dimensional mapping from a SetOfClasses2D with interactive selection of classes.
    Use mouse left-click to select/deselect classes individually or mouse right-click to select/deselect
    several classes..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input 2D classes: Select the input classes to be mapped.
Interactive class selection?: None
Dimension reduction method: None
Distance metric to compare images: None

The protocol named "ctf consensus" can be found at the xmipp3 plugin.
Its help description is:
 
    Protocol to make a selection of meaningful CTFs in basis of the defocus
    values, the astigmatism, the resolution, other Xmipp parameters, and
    the agreement with a secondary CTF for the same set of micrographs.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input CTF: Select the estimated CTF to evaluate
Use Defocus for selection: Use this button to decide if carry out the selection taking into account or not the defocus values.
Min: None
Max: None
Use Astigmatism for selection: Use this button to decide if carry out the selection taking into account or not the astigmatism value.
Astigmatism (A): Maximum value allowed for astigmatism in Angstroms. If the evaluated CTF has a larger Astigmatism, it will be discarded.
Use Astigmatism percentage for selection: Use this button to decide if carry out the selection taking into account or not the astigmatism value.
Astigmatism percentage: Maximum value allowed for astigmatism percentage (|defocus_U-defocus_V|/mean_defocus). If the evaluated CTF has a larger Astigmatism Percentage, it will be discarded.
Use Resolution for selection: Use this button to decide if carry out the selection taking into account or not the resolution value.
Resolution (A): Minimum value for resolution in Angstroms. If the evaluated CTF has not reached that minimum, it will be discarded.
Use Xmipp criteria for selection: Use this button to decide if carrying out the selection taking into account the Xmipp parameters.
Only available when Xmipp CTF estimation was used for the _Input CTF_ or for the _Secondary CTF_.
Minimum 1st zero: Minimun value of CritFirstZero
Min: None
Max: None
Correlation 1st-3rd zero: Minimum value of correlation between 1st and 3rd zeros
CTF Margin: Minimum value of CritCtfMargin
CritIceness: Minimum value of the iceness.
Min: None
Max: None
Calculate Consensus Resolution: Option for calculating consensus resolution. The algorithm assumes that two CTF are consistent if the phase (wave aberration function) of the two CTFs are closer than 90 degrees.
The reported consensusResolution is the resolution at which the two CTF phases differ in 90 degrees.
Secondary CTF: CTF to be compared with reference CTF
Minimum consensus resolution (A).: Minimum value for the consensus resolution in Angstroms.
If there are noticeable discrepancies between the two estimations below this resolution, it will be discarded.
Average equivalent metadata?: If *Yes*, making an average of those metadata present in both CTF estimations (defocus, astigmatism angle...)
 If *No*, the primary estimation metadata will persist.
Include all secondary metadata?: If *Yes*, all metadata in the *Secondary CTF* will be included in the resulting CTF.
 If *No*, only the primary metadata (plus consensus scores) will be in the resulting CTF.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "ctf_correct_wiener2d" can be found at the xmipp3 plugin.
Its help description is:
     
    Perform CTF correction by Wiener filtering.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input projection images .
Isotropic Correction: If true, Consider that there is not astigmatism and then it is performed an isotropic correction.
Padding factor: Padding factor for Wiener correction 
Wiener constant:  Wiener-filter constant (if < 0: use FREALIGN default)
Correct for CTF envelope:  Only in cases where the envelope is well estimated correct for it
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "defocus group" can be found at the xmipp3 plugin.
Its help description is:
 
    Given a set of CTFs group them by defocus value.
    The output is a metadata file containing 
     a list of defocus values that delimite 
    each defocus group.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles with CTF: Select the input particles. 
 they should have information about the CTF (hasCTF=True)
Error for grouping: Maximum error when grouping, the higher the more groupsThis is a 1D program, only defocus U is used
 The frequency at which the phase difference between the CTFs
belonging to 2 particles is equal to Pi/2 is computed 
 If this difference is less than 1/(2*factor*sampling_rate)
then images are placed in different groups

The protocol named "ctf estimation" can be found at the xmipp3 plugin.
Its help description is:
  Protocol to estimate CTF on a set of micrographs using Xmipp. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Do recalculate ctf?: None
Input previous run: None
: None
Input Micrographs: None
Automatic Downsampling Factor: Recommended value to downsample
Manual CTF Downsampling factor: Set to 1 for no downsampling. Non-integer downsample factors are possible. This downsampling is only used for estimating the CTF and it does not affect any further calculation. Ideally the estimation of the CTF is optimal when the Thon rings are not too concentrated at the origin (too small to be seen) and not occupying the whole power spectrum (since this downsampling might entail aliasing).
Use defoci from a previous CTF estimation: None
Previous CTF estimation: Choose some CTF estimation related to input micrographs, in case you want to use the defocus values found previously
Optimize defocus: If set to False, then the previous defocus is taken
Find additional phase shift?: If the data was collected with phase plate, this will find additional phase shift due to phase plate
Automatic CTF downsampling detection: If this option is chosen, the algorithm automatically tries by default the suggested Downsample factor; and if it fails, +1; and if it fails, -1.
Allow amplitude constrast refinement: The amplitude contrast is normally kept fixed, but insome experiments it has been found that refining it might result in some improvement in the final FSC. This is not a standard practice, and should be used with caution
Skip borders: Remove the borders of the micrograph. If True, two times the window size will be cropped.
Lowest: None
Highest: None
Min: None
Max: None
Window size: The PSD is estimated from small patches of this size. Bigger patches allow identifying more details. However, since there are fewer windows, estimations are noisier.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "center particles" can be found at the xmipp3 plugin.
Its help description is:
  Realignment of un-centered particles. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Classes: Set of classes to be read
Set of micrographs: Set of micrographs related to the selected input classes
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "compare angles" can be found at the xmipp3 plugin.
Its help description is:
     
    Compare two sets of angles. The output is a list of all common particles with
    the angular difference between both assignments. The output is constructed by 
    keeping the information from the Set 1 and adding the shiftDiff and angularDiff.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles 1: Select the input experimental images with an angular assignment.
Input particles 2: Select the input experimental images with an angular assignment.
Symmetry group: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] page for a description of the symmetries accepted by Xmipp

The protocol named "compare reprojections" can be found at the xmipp3 plugin.
Its help description is:
 Compares a set of classes or averages with the corresponding projections of a reference volume.
    The set of images must have a 3D angular assignment and the protocol computes the residues
    (the difference between the experimental images and the reprojections). The zscore of the mean
    and variance of the residues are computed. Large values of these scores may indicate outliers.
    The protocol also analyze the covariance matrix of the residual and computes the logarithm of
    its determinant [Cherian2013]. The extremes of this score (called zScoreResCov), that is
    values particularly low or high, may indicate outliers..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input images: None
Volume to compare images to: Volume to be used for class comparison
Use input angular assignment (if available): None
Optimize gray scale: None
Ignore CTF: By ignoring the CTF you will create projections more similar to what a person expects, while by using the CTF you will create projections more similar to what the microscope sees
Evaluate residuals: If this option is chosen, then the residual covariance matrix is calculated and characterized. But this option takes time and disk space
Symmetry group: See http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format. If no symmetry is present, give c1
Angular sampling rate: In degrees. This sampling defines how fine the projection gallery from the volume is explored.
Filter at resolution: : Resolution (A) at which subtraction will be performed, filtering the volume projections.Value 0 implies no filtering.
Decay of the filter (sigma): : Decay of the filter (sigma parameter) to smooth the mask transition
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "consensus classes" can be found at the xmipp3 plugin.
Its help description is:
  Compare several SetOfClasses.
        Return the consensus clustering based on a objective function
        that uses the similarity between clusters intersections and
        the entropy of the clustering formed.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input classes: Select several sets of classes where to evaluate the intersections.
Minimum class size: Minimum output class size. If set to zero it will not have any effect
Metric: Distance metric used when comparing clusters

The protocol named "consensus local defocus" can be found at the xmipp3 plugin.
Its help description is:
 This protocol compares the estimations of local defocus computed by different protocols for a set of particles.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles to assign the consensus defocus: Particle set of interest to estimate the defocus
Input defocus estimations: Sets of particles with different local defocus estimations to compare

The protocol named "picking consensus" can be found at the xmipp3 plugin.
Its help description is:
 
    Protocol to estimate the agreement between different particle picking
    algorithms. The protocol takes several Sets of Coordinates calculated
    by different programs and/or different parameter settings. Let's say:
    we consider N independent pickings. Then, a coordinate is considered
    to be a correct particle if M pickers have selected the same particle
    (within a radius in pixels specified in the form).

    If you want to be very strict, then set M=N; that is, a coordinate
    represents a particle if it has been selected by all particles (this
    is the default behaviour). Then you may relax this condition by setting
    M=N-1, N-2, ...

    If you want to be very flexible, set M=1, in this way it suffices that
    1 picker has selected the coordinate to be considered as a particle. Note
    that in this way, the cleaning of the dataset has to be performed by other
    means (screen particles, 2D and 3D classification, ...).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the set of coordinates to compare
Radius: All coordinates within this radius (in pixels) are presumed to correspond to the same particle
Consensus: How many times need a particle to be selected to be considered as a consensus particle.
*Set to -1* to indicate that it needs to be selected by all algorithms: *AND* operation.
*Set to 1* to indicate that it suffices that only 1 algorithm selects the particle: *OR* operation.
Consensus mode: If the number of votes to progress to the output must be either (=) strictly speaking equals to the consensus number or (>=) at least equals.

The protocol named "convert pdbs to volumes" can be found at the xmipp3 plugin.
Its help description is:
  Convert atomic structure(s) into volume(s) .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Input structure(s) : Specify input atomic structure(s).
Sampling rate (Å/px): Sampling rate (Angstroms/pixel)
Use a volume as an empty template?: Use an existing volume to define the size and origin for the output volume. If this optionis selected, make sure that "Center PDB" in advanced parameters is set to *No*.
Input volume : The origin and the final size of the output volume will be taken from this volume.
Set final size?: None
Box side size (px): This size should apply to all volumes
Final size (px) Z: Final size in Z in pixels. If no value is provided, protocol will estimate it.
Final size (px) Y: Final size in Y in pixels. If no value is provided, protocol will estimate it.
Final size (px) X: Final size in X in pixels. If desired output size is x = y = z you can only fill this field. If no value is provided, protocol will estimate it.
Center PDB: Center PDB with the center of mass.
Store centered PDB: Set to 'Yes' if you want to save centered PDB. It will be stored in the output directory of this protocol.
Convert CIF to PDB: If set to true and input atom struct file is a CIF, it will get converted to PDB.
Clean tmp files: Delete all non-output files once the protocol has finished producing them.

The protocol named "core analysis" can be found at the xmipp3 plugin.
Its help description is:
  Analyzes the core of a 2D classification. The core is calculated through
    the Mahalanobis distance from each image to the center of the class. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input classes: Set of input classes to be analyzed
Junk Zscore: Which is the average Z-score to be considered as junk. Typical values go from 1.5 to 3. For the Gaussian distribution 99.5% of the data is within a Z-score of 3. Lower Z-scores reject more images. Higher Z-scores accept more images.
PCA Zscore: Which is the PCA Z-score to be considered as junk. Typical values go from 1.5 to 3. For the Gaussian distribution 99.5% of the data is within a Z-score of 3. Lower Z-scores reject more images. Higher Z-scores accept more images.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "create gallery" can be found at the xmipp3 plugin.
Its help description is:
 
    Create a gallery of projections from a volume.
    This gallery of projections may help to understand the images
    observed in the microscope.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: None
Symmetry group: Seehttps://github.com/I2PC/xmipp-portal/wiki/Symmetry for a description of the symmetry groups format. If no symmetry is present, give c1
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Maximum frequency: Normalized to 0.5
Shift sigma: In pixels

The protocol named "create 2d mask" can be found at the xmipp3 plugin.
Its help description is:
  Create a 2D mask.
    The mask can be created with a given geometrical shape (Circle, Rectangle,
    Crown...) or it can be obtained from operating on a 2d image or a previuous
    mask. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Sampling Rate (Å/px): None
Mask size (px): Select the mask dimensions in pixels. The mask will be size x size pixels
Mask type: None
Radius (px): Mask radius, if -1, the radius will be MaskSize/2
Box size: Mask box size, if -1, the box size will be MaskSize/2
Inner radius (px): Inner radius in pixels
Outer radius (px): Outer radius in pixels, if -1, the outer radius will be MaskSize/2
Sigma (px): Gaussian sigma in pixels. If -1, sigma will be MaskSize/6
Border decay (px): This is the fall-off of the two borders of the crown
Shift Center: Shift Mask Center to a new origin.
X center offset: New x center coordinate
Y center offset: New y center coordinate

The protocol named "create 3d mask" can be found at the xmipp3 plugin.
Its help description is:
  Create a 3D mask.
    The mask can be created with a given geometrical shape (Sphere, Box,
    Cylinder...) or it can be obtained from operating on a 3d volume or a
    previous mask.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Mask source: None
Input volume: Select the volume that will be used to create the mask
Operation: None
Threshold: Select the threshold. Gray values lesser than the thresholdwill be set to zero, otherwise will be one (mask area).
Segmentation type: None
Number of voxels: None
Number of aminoacids: None
Mass (Da): None
Sampling Rate (Å/px): None
Mask size (px): Select the mask dimensions in voxels. The mask will be size x size x size voxels
Mask type: None
Radius (px): Mask radius, if -1, the radius will be MaskSize/2
Shift center of the mask?: None
X: None
Y: None
Z: None
Box size: Mask box size, if -1, the box size will be MaskSize/2
Inner radius (px): Inner radius in pixels
Outer radius (px): Outer radius in pixels, if -1, the outer radius will be MaskSize/2
Height (px): Cylinder height in pixels. If -1, height will be MaskSize
Sigma (px): Gaussian sigma in pixels. If -1, sigma will be MaskSize/6
Border decay (px): This is the fall-off of the two borders of the crown
Feature File: Create a mask using a feature file. Follows an example of feature file 
# XMIPP_STAR_1 *
# Type of feature (sph, blo, gau, Cyl, dcy, cub, ell, con)(Required)
# The operation after adding the feature to the phantom (+/=) (Required)
# The feature density (Required)
# The feature center (Required)
# The vector for special parameters of each vector (Required)
# Sphere: [radius] 
# Blob : [radius alpha m] Gaussian : [sigma]
# Cylinder : [xradius yradius height rot tilt psi]
# DCylinder : [radius height separation rot tilt psi]
# Cube : [xdim ydim zdim rot tilt psi]
# Ellipsoid : [xradius yradius zradius rot tilt psi]
# Cone : [radius height rot tilt psi]
data_block1
 _dimensions3D  '34 34 34' 
 _phantomBGDensity  0.
 _scale  1.
data_block2
loop_
 _featureType
 _featureOperation
 _featureDensity
 _featureCenter
 _featureSpecificVector
sph + 1 '3.03623188  0.02318841 -5.04130435' '7'

Remove small objects: To remove small clusters of points. The input mask has to be binary.
Minimum size: Connected components whose size is smaller than this number in voxels will be removed
Keep largest component: To keep cluster greater than a given size. The input mask has to be binary
Symmetrize mask: None
Symmetry group: To obtain a symmetric mask. See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry 
for a description of the symmetry groups format. 
If no symmetry is present, give c1
Apply morphological operation: Dilation (dilate white region). 
Erosion (erode white region). 
Closing (Dilation+Erosion, removes black spots). 
Opening (Erosion+Dilation, removes white spots). 

Operation: None
Structural element size: The larger this value, the more the effect will be noticed
Invert the mask: None
Smooth borders: Smoothing is performed by convolving the mask with a Gaussian.
Gaussian sigma (px): The larger this value, the more the effect will be noticed

The protocol named "crop/resize particles" can be found at the xmipp3 plugin.
Its help description is:
  Crop or resize a set of particles .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles/Mask: Input particles or 2D Mask to be cropped/resized.
Resize particles?: If you set to *Yes*, you should provide a resize option.
Resize option: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Dimensions_: Set the output dimensions. Resize operation can be done in Fourier space.
_Factor_: Set a resize factor to resize. 
 _Pyramid_: Use positive level value to expand and negative to reduce. 
Pyramid uses spline pyramids for the interpolation. All the rest uses normally interpolation
(cubic B-spline or bilinear interpolation). If you set the method to dimensions, you may choose
between interpolation and Fourier cropping.
Resize sampling rate (Å/px): Set the new output sampling rate.
Use fourier method to resize?: If you set to *True*, the final dimensions must be lower than the original ones.
New image size (px): Size in pixels of the particle images <x> <y=x> <z=x>.
Resize factor: New size is the old one x resize factor.
Pyramid level: Use positive value to expand and negative to reduce.
Huge file: If the file is huge, very likely you may have problems doing the antialiasing filter (because there is no memory for the input and its Fourier tranform). This option removes the antialiasing filter (meaning you will get aliased results), and performs a bilinear interpolation (to avoid having to produce the B-spline coefficients).
Apply a window operation?: If you set to *Yes*, you should provide a window option.
Window operation: Select how to change the size of the particles.
_cls.RESIZE_: provide the new size (in pixels) for your particles.
_crop_: choose how many pixels to crop from each border.

Crop size (px): Amount of pixels cropped from each border.
e.g: if you set 10 pixels, the dimensions of the
object (SetOfParticles, Volume or SetOfVolumes) will be
reduced in 20 pixels (2 borders * 10 pixels)
Window size (px): Size in pixels of the output object. It will be expanded or cutted in all directions such that the origin remains the same.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "crop/resize volumes" can be found at the xmipp3 plugin.
Its help description is:
  Crop or resize a set of volumes .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: Can be a density volume or a SetOfVolumes.
Resize volumes?: If you set to *Yes*, you should provide a resize option.
Resize option: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Dimensions_: Set the output dimensions. Resize operation can be done in Fourier space.
_Factor_: Set a resize factor to resize. 
 _Pyramid_: Use positive level value to expand and negative to reduce. 
Pyramid uses spline pyramids for the interpolation. All the rest uses normally interpolation
(cubic B-spline or bilinear interpolation). If you set the method to dimensions, you may choose
between interpolation and Fourier cropping.
Resize sampling rate (Å/px): Set the new output sampling rate.
Use fourier method to resize?: If you set to *True*, the final dimensions must be lower than the original ones.
New image size (px): Size in pixels of the particle images <x> <y=x> <z=x>.
Resize factor: New size is the old one x resize factor.
Pyramid level: Use positive value to expand and negative to reduce.
Huge file: If the file is huge, very likely you may have problems doing the antialiasing filter (because there is no memory for the input and its Fourier tranform). This option removes the antialiasing filter (meaning you will get aliased results), and performs a bilinear interpolation (to avoid having to produce the B-spline coefficients).
Apply a window operation?: If you set to *Yes*, you should provide a window option.
Window operation: Select how to change the size of the particles.
_cls.RESIZE_: provide the new size (in pixels) for your particles.
_crop_: choose how many pixels to crop from each border.

Crop size (px): Amount of pixels cropped from each border.
e.g: if you set 10 pixels, the dimensions of the
object (SetOfParticles, Volume or SetOfVolumes) will be
reduced in 20 pixels (2 borders * 10 pixels)
Window size (px): Size in pixels of the output object. It will be expanded or cutted in all directions such that the origin remains the same.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "deep center" can be found at the xmipp3 plugin.
Its help description is:
 Predict the center particles using deep learning..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Input Image set: The set of particles to predict
Train models: Choose if you want to train a model using a centered set of particles
Number of models: The maximum number of model available in xmipp is 5.
Input train set: The set of particles to train the models
Number of epochs: Number of epochs for training.
Batch size for training: Batch size for training.
Learning rate: Learning rate for training.
Image shifting: A measure of the number of pixels that particles can be shifted in each direction from the center.
Patience: Training will be stopped if the number of epochs without improvement is greater than patience.
Tolerance in pixels: Max difference between predictions and their mean value.
Maximum number of models dropped per particle: If more models are dropped, the particle is discarded.

The protocol named "deep denoising" can be found at the xmipp3 plugin.
Its help description is:
 None.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. In case to use several GPUs separate with comas:0,1,2
Train or predict model: *Train*: Train the model using noisy particles or their projections in an initial volume*Predict*: The particles are denoised with a pretrained model
Continue training? (or train from scratch): Setting "yes" you can continue training from pretrained model  or your previous executions. If you choose"no" the model will be trained from scratch. yes option is experimental
Use your own model (or use pretrained): Setting "yes" you can choose your own model trained. If you choose"no" a general model pretrained will be assign
Set your model: Choose the protocol where your model is trained
Select model type: If you set to *GAN*, GAN will be employed employed. If you set to *U-Net* U-Net will be used instead
Input projections to train (mandatory)/compare (optional): use the protocol generate reprojections to generate the projections. If compare reprojections protocol output is used as "Input noisy particles", this field is ignored
Input noisy particles to denoise: Input noisy particles from the protocol generate reprojections if you are training or from any other protocol if you are predicting. If compare reprojections protocol output is used as "Input noisy particles", "Input projections to train" is ignored
Input "empty" particles (optional): Input "empty" particles to learn how to deal with pure noise
Scale images to (px): Scale particles to desired size to improve trainingThe recommended particle size is 128 px. The size must be even.Do not use loss=perceptualLoss or loss=Both if  96< size <150.
Number of epochs: Number of epochs for neural network training. GAN requires much more epochs (>100) to obtain succesfull results
Learning rate: Learning rate for neural network training
Model depth: Indicate the model depth. For 128-64 px images, 4 is the recommend value.  larger images may require bigger models
Regularization strength: Indicate the regularization strength. Make it bigger if sufferening overfitting and smaller if suffering underfitting
Select how to generate training set: *ParticlesAndSyntheticNoise*: Train using particles and synthetic noise
or
*OnlyParticles*: using only particles
or
*Both*: Train using both strategies
Select loss for training: *MSE*: Train using mean squered error or
*PerceptualLoss*: Train using DeepConsensus perceptual loss
 or
*Both*: Train using both DeepConsensus perceptual loss and mean squered error

D/G trainig ratio: Indicate the number of times the discriminator is trained for each generator training step. If discriminator loss is going to 0, make it smaller, whereas if the discriminator is not training, make it bigger
D/G loss ratio: Indicate the 10^lossRatio times that the generator loss is stronger than  the discriminator loss. If discriminator loss is going to 0, make it smaller, whereas if the generator is not training, make it bigger
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "deep global assignment" can be found at the xmipp3 plugin.
Its help description is:
 Predict Euler Angles using deep learning..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Input Image set: The set of particles to predict
Train models: Choose if you want to train a model using a centered set of particles
Number of models: The maximum number of model available in xmipp is 5.
Input train set: The set of particles to train the models
Number of epochs: Number of epochs for training.
Batch size for training: Batch size for training.
Learning rate: Learning rate for training.
Image shifting: A measure of the number of pixels that particles can be shifted in each direction from the center.
Patience: Training will be stopped if the number of epochs without improvement is greater than patience.
Tolerance in pixels: Max difference between predictions and their mean value.
Maximum number of models dropped per particle: If more models are dropped, the particle is discarded.
Order of symmetry: Order of the group of the molecule.

The protocol named "deep hand" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to returns handedness of structure from trained deep learning model
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: Volume to process
Mask Threshold: Threshold for mask creation
Alpha Threshold: Threshold for alpha helix determination
Hand Threshold: Hand threshold to flip volume

The protocol named "deep micrograph cleaner" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to remove coordinates in carbon zones or large impurities.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the SetOfCoordinates 
Micrographs source: By default, the micrographs from which the computation will be performed will be the ones used in the picking step ( _same as coordinates_ option ). 
If you select other option, you must provide a different set of micrographs to evaluate its regions. 
*Note*: In the _other_ case, ensure that provided micrographs and coordinates are related by micName or by micId. Difference in pixel size will be handled automatically.
*Note2*: *Particles must be dark* over a bright background. If not, use the _other_ option to provide an inverted setOfMicrograph.
Input micrographs: Select the SetOfMicrographs from which to extract.
Coordinates scale: If you select _same as coordinates_ option output coordinates will be mapped to the original micrographs and thus, they will preserve the scale.
If you select _scale to micrographs_ option, output coordinates will be mapped to the new micrographs and rescaled accordingly.
Threshold: Deep learning goodness score to select/discard coordinates. The bigger the threshold the more coordiantes will be ruled out. Ranges from 0 to 1. Use -1 to skip thresholding. Manual thresholding can be performed after execution through analyze results button. 
0.75 <= Recommended threshold <= 0.9
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*0*    Put in the same step all the items  available.
 *>1*   The number of items that will be grouped into a step. -1, automatic decission
saveMasks: Save predicted masks?
: This protocol has both CPU and GPU implementation. Select the one you want to use. CPU may become quite slow.
: Add a list of GPU devices that can be used.

The protocol named "local deepRes" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a map the protocol assigns local resolutions to each voxel of the map.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Input Volume: Select a volume for determining its local resolution.
Mask: Binary mask. The mask determines which points are specimen and which are not
Expected resolutions range: The program uses a trained network to determine resolutions between 2.5Å-13.0Å  or resolutions between 1.5Å-6.0Å

The protocol named "deepEMhancer" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a map the protocol performs automatic deep post-processing to enhance visualization. Usage guide at
    https://github.com/rsanchezgarc/deepEMhancer
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. Select the GPU ID in which the protocol will run (select only 1 GPU)
Would you like to use half maps?: DeepEMhancer uses either half maps or non-sharpened non-masked input volumes. Please, select the type of input map(s) you will provide
Are the half maps included in the volume?: When you import a map, you can associate half maps to it. Select *yes* if the half maps are associatedto the input volume. If half maps are not associated, select *No* andyou will be able to provide then as regular maps
Volume Half 1: Select half map 1 to apply deep postprocessing. 
Volume Half 2: Select half map 2 to apply deep postprocessing. 
Input Volume: Select a volume to apply deep postprocessing. Unmasked, non-sharpened input required
Input normalization: Input normalization is critical for the algorithm to work.
If you select *Automatic normalization* input will beautomatically normalized (generally works but may fail).
If you select *Normalization from statistics* input will benormalized according the statistics of the noise of the volume and thus, you will need to providethe mean and standard deviation of the noise. Additionally, a binary mask (1 protein, 0 not protein) for the protein can be used for normalization if you select *Normalization from binary mask* . The mask should be as tight as possible.
nBad results may be obtained if normalization does not work, so you may want to try different options if not good enough results are observerd
binary mask: The mask determines which voxels are protein (1) and which are not (0)
noise mean: The mean of the noise used to normalize the input
noise standard deviation: The standard deviation of the noise used to normalize the input
Model power: Select the deep learning model to use.
If you select *tight target* the postprocessing will be more sharpen, but some regions of the protein could be masked out.
If you select *wide target* input will be less sharpen but most of the regions of the protein will be preserved
Option *highRes*,  is recommended for high resolution volumes
Remove small CC after processing: If you set to *Yes*, a post-processing step will be launched to remove small connected componentsthat are likely noise. This step may remove protein in some unlikely situations, but generally, itslighly improves results
Relative size (0. to 1.) CC to remove: The relative size of a small connected component to be removed, as the fraction of total voxels>0 
Batch size: Number of cubes to process simultaneously. Make it lower if CUDA Out Of Memory error happens and increase it if low GPU performance observed

The protocol named "denoise particles" can be found at the xmipp3 plugin.
Its help description is:
  Remove particles noise by filtering them. 
    This filtering process is based on a projection over a basis created
    from some averages (extracted from classes). This filtering is not 
    intended for processing particles. The huge filtering they will be 
    passed through is known to remove part of the signal with the noise. 
    However this is a good method for clearly see which particle are we 
    going to process before it's done.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: Input images you want to filter. It is important that the images have alignment information with respect to the chosen set of classes. This is the standard situation after CL2D or ML2D.
Input Classes: Select the input classes for the basis construction against images will be projected to.
Max. number of classes: Maximum number of classes.
Number of PCA bases: Number of PCA bases.
Number of PCA bases on which to project: Number of PCA bases on which to project.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "eliminate empty classes" can be found at the xmipp3 plugin.
Its help description is:
  Takes a set of classes (or averages) and using statistical methods
    (variances of sub-parts of input image) eliminates those samples,
    where there is no object/particle (only noise is presented there).
    Threshold parameter can be used for fine-tuning the algorithm for
    type of data. Also discards classes with less population than a given
    percentage.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input classes: Select the input averages to be classified.
Threshold used in elimination: Higher threshold => more particles will be eliminated. Set to -1 for no elimination, even so the "xmipp_scoreEmptiness" value will be attached to every paricle for a posterior inspection.
Use class population: Consider class population to reject a class.
Min. population (%): Minimum population to accept a class.
Classes with less population than the mean population times this value will be rejected.
Add features: Add features used for the ranking to each one of the input particles.
Turning on denoising: Option for turning on denoising method while computing emptiness feature.
Denoising factor:: Factor to be used during Gaussian blurring. Higher value applies stronger denoising, could be more precise but also slower.

The protocol named "eliminate empty particles" can be found at the xmipp3 plugin.
Its help description is:
  Takes a set of particles and using statistical methods
    (variance of variances of sub-parts of input image) eliminates those samples,
    where there is no object/particle (only noise is presented there).
    Threshold parameter can be used for fine-tuning the algorithm for type of data.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input particles to be classified.
Threshold used in elimination:: Higher threshold => more particles will be eliminated. Set to -1 for no elimination, even so the "xmipp_scoreEmptiness" value will be attached to every paricle for a posterior inspection.
Add features: Add features used for the ranking to each one of the input particles.
Turning on denoising: Option for turning on denoising method while computing emptiness feature.
Denoising factor:: Factor to be used during Gaussian blurring. Higher value applies stronger denoising, could be more precise but also slower.

The protocol named "enrich" can be found at the xmipp3 plugin.
Its help description is:
     
    Method to get two volume from different classes (with different conformation)
    and correcting (deforming) all images of one of the volumes (input volume) 
    with respect to the another one as a reference, using optical flow algorithm.
    The output is a setOfParticles contaied deformed reference particles.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
do Gold Standard?: If YES provide half1 and half2 maps for referenceand for input volumes.
Reference volume: This is the volume that will be used as the reference in OF algorithm. If you want to use Gold-Standard provide here half1 map
Reference volume half1: This is the half1 volume that will be used as the reference for half1 in OF algorithm.
Reference volume half2: This is half2 volume that will be used as the reference for half2 in OF algorithm.
Input volume: Volume that we want to process its related particles.
Input volume half1: Volume that we want to process its related particles. It should represent half1 map.
Input volume half2: Volume that we want to process its related particles. It should represent half2 map.
Input particles: Aligned particles related to the input volume. These particles will be processed (deformed) based on the reference volume using OF algorithm.If selected doGoldStandard True the particles have to have  information about the halfId they belong.
Reference and input volumes need to be aligned?: Input and reference volumes must be aligned. If you have not aligned them before choose this option, so protocol will handle it internally.
Use Fast Rotational Matching.: Use Fast Rotational Matching. Before use it you have to install it by scipion install frmThis method for volume alignment is much more fast than exhaustive search
Resolution Limit (A): Resolution limit used to low pass filter both input and reference map(s).Based on previous experimental results, a good value for  seems to be 20A 
Window size: Size of the search window at each pyramid level (shifts are assumed to be constant within this window).
pyramid Scale: Parameter, specifying the image scale (<1) to build pyramids for each image. pyrScale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous one.
Number of Levels: Number of pyramid layers including the initial image; levels=1 means that no extra layers are created and only the original images are used.
Iterations: Number of iterations the algorithm does at each pyramid level.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "extract movie particles" can be found at the xmipp3 plugin.
Its help description is:
  Extract a set of Particles from each frame of a set of Movies.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
Input coordinates: None
Particle box size (px): In pixels. The box size is the size of the boxed particles, actual particles may be smaller than this.
Apply movie alignments to extract?: If the input movies contains frames alignment, you decide whether to use that information for extracting the particles taking into account the shifts between frames.
First: None
Last: None
Fill pixels outside borders: Xmipp by default create blank particles whose boxes fall outside of the micrograph borders. Set this option to True if you want those pixels outside the borders to be filled with the closest pixel value available
Dust removal (Recommended): Sets pixels with unusually large values to random values from a Gaussian with zero-mean and unity-standard deviation.
Threshold for dust removal: Pixels with a signal higher or lower than this value times the standard deviation of the image will be affected. For cryo, 3.5 is a good value. For high-contrast negative stain, the signal itself may be affected so that a higher value may be preferable.
Invert contrast: Invert the contrast if your particles are black over a white background.
Normalize (Recommended): It subtract a ramp in the gray values and normalizes so that in the  background there is 0 mean and standard deviation 1.
Normalization type: OldXmipp (mean(Image)=0, stddev(Image)=1). 
NewXmipp (mean(background)=0, stddev(background)=1)
Ramp (subtract background+NewXmipp).
Background radius (px): Pixels outside this circle are assumed to be noise and their stddev is set to 1. Radius for background circle definition (in pix.). If this value is 0, then half the box size is used.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "extract particles" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to extract particles from a set of coordinates.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the SetOfCoordinates 
Micrographs source: By default the particles will be extracted from the micrographs used in the picking step ( _same as picking_ option ). 
If you select _other_ option, you must provide a different set of micrographs to extract from. 
*Note*: In the _other_ case, ensure that provided micrographs and coordinates are related by micName or by micId. Difference in pixel size will be handled automatically.
Input micrographs: Select the SetOfMicrographs from which to extract.
CTF estimation: Choose some CTF estimation related to input micrographs. 
 CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
Downsampling factor: Select a value greater than 1.0 to reduce the size of micrographs before extracting the particles. If 1.0 is used, no downsample is applied. Non-integer downsample factors are possible. 
Particle box size (px): This is size of the boxed particles (in pixels). Note that if you use downsample option, the particles are boxed out after downsampling. Use the wizard to check boxSize changes after downsampling or using a different pixel size. 
Fill pixels outside borders: Xmipp by default skips particles whose boxes fall outside of the micrograph borders. Set this option to True if you want those pixels outside the borders to be filled with the closest pixel value available
Dust removal (Recommended): Sets pixels with unusually large values to random values from a Gaussian with zero-mean and unity-standard deviation.
Threshold for dust removal: Pixels with a signal higher or lower than this value times the standard deviation of the image will be affected. For cryo, 3.5 is a good value. For high-contrast negative stain, the signal itself may be affected so that a higher value may be preferable.
Invert contrast: Invert the contrast if your particles are black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background. Frealign (up to v9.07) requires black particles over a white background
Phase flipping: Use the information from the CTF to compensate for phase reversals.
Phase flip is recommended in Xmipp or Eman
(even Wiener filtering and bandpass filter are recommended for obtaining better 2D classes)
Otherwise (Frealign, Relion, Spider, ...), phase flip is not recommended.
Normalize (Recommended): It subtract a ramp in the gray values and normalizes so that in the background there is 0 mean and standard deviation 1.
Normalization type: OldXmipp (mean(Image)=0, stddev(Image)=1). 
NewXmipp (mean(background)=0, stddev(background)=1) 
  Ramp (subtract background+NewXmipp).
Background radius (px): Pixels outside this circle are assumed to be noise and their stddev is set to 1. Radius for background circle definition (in pix.). If this value is 0, then half the box size is used.
Patch size for the variance filter (px): Windows size to make the variance filtter and compute the Gini coeff. A twice of the particle size is recommended. Set at -1 applies 1.5*BoxSize.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "extract particle pairs" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to extract particles from a set of tilted pairs coordinates.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates tilted pairs: Select the CoordinatesTiltPairs
Micrographs source: By default the particles will be extracted from the micrographs used in the picking step ( _same as picking_ option ).
If you select _other_ option, you must provide a different set of micrographs to extract from.
*Note*: In the _other_ case, ensure that provided micrographs and coordinates are related by micName or by micId. Difference in pixel size will be handled automatically.
Input tilt pair micrographs: Select the tilt pair micrographs from which to extract.
CTF estimation (untilted mics): Choose some CTF estimation related to input UNTILTED micrographs. 
 CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
CTF estimation (tilted mics): Choose some CTF estimation related to input TILTED micrographs. 
 CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
Downsampling factor: Select a value greater than 1.0 to reduce the size of micrographs before extracting the particles. If 1.0 is used, no downsample is applied. Non-integer downsample factors are possible. 
Particle box size: In pixels. The box size is the size of the boxed particles, actual particles may be smaller than this. If you do downsampling after extraction, provide final box size here.
Fill pixels outside borders: Xmipp by default skips particles whose boxes fall outside of the micrograph borders. Set this option to True if you want those pixels outside the borders to be filled with the closest pixel value available
Dust removal (Recommended): Sets pixels with unusually large values to random values from a Gaussian with zero-mean and unity-standard deviation.
Threshold for dust removal: Pixels with a signal higher or lower than this value times the standard deviation of the image will be affected. For cryo, 3.5 is a good value. For high-contrast negative stain, the signal itself may be affected so that a higher value may be preferable.
Invert contrast: Invert the contrast if your particles are black over a white background. Xmipp, Spider, Relion and Eman require white particles over a black background, Frealign (up to v9.07) requires black particles over a white background
Phase flipping: Use the information from the CTF to compensate for phase reversals.
Phase flip is recommended in Xmipp or Eman
(even Wiener filtering and bandpass filter are recommended for obtaining better 2D classes)
Otherwise (Frealign, Relion, Spider, ...), phase flip is not recommended.
Normalize (Recommended): It subtract a ramp in the gray values and normalizes so that in the background there is 0 mean and standard deviation 1.
Normalization type: OldXmipp (mean(Image)=0, stddev(Image)=1).
NewXmipp (mean(background)=0, stddev(background)=1)
Ramp (subtract background+NewXmipp).
Background radius: Pixels outside this circle are assumed to be noise and their stddev is set to 1. Radius for background circle definition (in pix.). If this value is 0, then half the box size is used.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "extract asymmetric unit" can be found at the xmipp3 plugin.
Its help description is:
  generates files for volumes and FSCs to submit structures to EMDB
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: This volume will be cropped
Symmetry: See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format in Xmipp.
If no symmetry is present, use _c1_.
Symmetry Order: Order of cyclic symmetry.
offset: rotate unit cell around z-axis by offset degrees
Inner Radius (px): inner Mask radius, if -1, the radius will be 0
Outer Radius (px): outer Mask radius, if -1, the radius will be volume_size/2
Expand Factor: Increment cropped region by this factor

The protocol named "resolution fso" can be found at the xmipp3 plugin.
Its help description is:
     
    Given two half maps the protocol estimates Fourier Shell Occupancy to determine the global anisotropy of the map.
    See more information here: https://github.com/I2PC/xmipp/wiki/FSO---Fourier-Shell-Occupancy
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Are the half volumes stored with the input volume?: Usually, the half volumes are stored as properties of the input volume. If this is not the case, set this to False and specify the two halves you want to use.
Input Half Maps: Select a half maps for determining its  resolution anisotropy and resolution.
Half Map 1: Select one map for determining the directional FSC resolution.
Half Map 2: Select the second map for determining the directional FSC resolution.
Mask: The mask determines which points are specimen and which are not
Cone Angle: Angle between the axis of the cone and the generatrix. An angle of 17 degrees is the best angle (see Nat MethodsJL Vilas 2023) to measuare the directional FSCs
Estimate 3DFSC : Set to estimate the 3DFSCD map. This is a 3D function that depends of the resolution.The profile of the 3DFSC along a given direction is the directiontal FSC
FSC Threshold: Threshold for the fsc. By default the standard 0.143. Other common thresholds are 0.5 and 0.3.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "filter particles" can be found at the xmipp3 plugin.
Its help description is:
  Apply Fourier filters to a set of particles  .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Filter space: None
Filter mode: Depending on the filter mode some frequency (freq.) components
are kept and some are removed.
 _low pass_: components below *High freq.* are preserved.
 _high pass_: components above *Low freq.* are preserved.
 _band pass_: components between *Low freq.* and *High freq.* are preserved. 
ctf: apply first CTF in CTFset to all the particles. This is normally for simulated data.
   : This is not a CTF correction.
Filter mode: median: replace each pixel with the median of neighboring pixels.

Filter mode: DAUB4: filter using the DAUB4 wavelet transform.
 
Provide resolution in Angstroms?: If *Yes*, the resolution values for the filter
should be provided in Angstroms. If *No*, the
values should be in normalized frequencies (between 0 and 0.5).
Lowest: None
Highest: None
Decay length: Amplitude decay in a [[https://en.wikipedia.org/wiki/Raised-cosine_filter][raised cosine]]
Lowest: None
Highest: None
Frequency decay: Amplitude decay in a [[https://en.wikipedia.org/wiki/Raised-cosine_filter][raised cosine]]
CTF Object: Object with CTF information if empty it will take the CTF information related with the first particle.
Note that this is normally used with simulated data.
mode: filter mode to be applied in wavelet space
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "filter volumes" can be found at the xmipp3 plugin.
Its help description is:
  Apply Fourier filters to a set of volumes .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: Can be a density volume or a SetOfVolumes.
Filter space: None
Filter mode: Depending on the filter mode some frequency (freq.) components
are kept and some are removed.
 _low pass_: components below *High freq.* are preserved.
 _high pass_: components above *Low freq.* are preserved.
 _band pass_: components between *Low freq.* and *High freq.* are preserved. 
ctf: apply first CTF in CTFset to all the particles. This is normally for simulated data.
   : This is not a CTF correction.
Filter mode: median: replace each pixel with the median of neighboring pixels.

Filter mode: DAUB4: filter using the DAUB4 wavelet transform.
 
Provide resolution in Angstroms?: If *Yes*, the resolution values for the filter
should be provided in Angstroms. If *No*, the
values should be in normalized frequencies (between 0 and 0.5).
Lowest: None
Highest: None
Decay length: Amplitude decay in a [[https://en.wikipedia.org/wiki/Raised-cosine_filter][raised cosine]]
Lowest: None
Highest: None
Frequency decay: Amplitude decay in a [[https://en.wikipedia.org/wiki/Raised-cosine_filter][raised cosine]]
CTF Object: Object with CTF information if empty it will take the CTF information related with the first particle.
Note that this is normally used with simulated data.
mode: filter mode to be applied in wavelet space
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "FlexAlign" can be found at the xmipp3 plugin.
Its help description is:
 
    Wrapper protocol to Xmipp Movie Alignment by cross-correlation
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
from: None
to: None
Use ALIGN frames range to SUM?: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Save aligned micrograph: None
Save movie: Save Aligned movie
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Maximum resolution (A): Maximum resolution in A that will be preserved during correlation.
Compute PSD?: If Yes, the protocol will compute PSD for each movie before and after the alignment
Maximum shift (A): Maximum allowed distance (in A) that each frame can be shifted with respect to the next.
Compute local alignment?: If Yes, the protocol will try to determine local shifts, similarly to MotionCor2.
Auto control points: If on, protocol will automatically determine necessary number of control points.
X: None
Y: None
t: None
Auto patches: If on, protocol will automatically determine necessary number of patches.
X: None
Y: None
Min size of the patch (A): How many A should contain each patch?
Group N frames: Group every specified number of frames by adding them together.                         The alignment is then performed on the summed frames.
Rotate gain reference:: Rotate gain reference counter-clockwise.
Flip gain reference:: Flip gain reference after rotation. For tiff movies, gain is automatically upside-down flipped
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "generate reprojections" can be found at the xmipp3 plugin.
Its help description is:
 Compares a set of classes or averages with the corresponding projections of a reference volume.
    The set of images must have a 3D angular assignment and the protocol computes the residues
    (the difference between the experimental images and the reprojections). The zscore of the mean
    and variance of the residues are computed. Large values of these scores may indicate outliers.
    The protocol also analyze the covariance matrix of the residual and computes the logarithm of
    its determinant [Cherian2013]. The extremes of this score (called zScoreResCov), that is
    values particularly low or high, may indicate outliers..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input images: None
Volume to compare images to: Volume to be used for class comparison
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "gl2d" can be found at the xmipp3 plugin.
Its help description is:
  2D alignment using Xmipp GPU Correlation algorithm. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
: Add a list of GPU devices that can be used
Use a Set of Reference Images ?: If you set to *Yes*, you should provide a set of reference images.
If *No*, the default generation is done by averaging subsets of the input images.
Reference images: Set of images that will serve as class reference
Number of classes:: Number of classes (or references) to be generated
Maximum shift (%):: Maximum shift allowed during the alignment as percentage of the input set size
Number of best images:: Number of classes to assign every input image during the alignment
Number of iterations in split stage:: Maximum number of iterations in split stage
Number of iterations in classify stage:: Maximum number of iterations when the  classification of the whole image set is carried out
Allow attraction ?: If you set to *Yes*, you allow to generate classes with low number of images associated.
If *No*, all the generated classes will be balanced
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "helical symmetry" can be found at the xmipp3 plugin.
Its help description is:
  Estimate helical parameters and symmetrize.
    
    Helical symmetry is defined as V(r,rot,z)=V(r,rot+k*DeltaRot,z+k*Deltaz).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: None
Cylinder inner radius: The helix is supposed to occupy this radius in voxels around the Z axis. Leave it as -1 for symmetrizing the whole volume
Cylinder outer radius: The helix is supposed to occupy this radius in voxels around the Z axis. Leave it as -1 for symmetrizing the whole volume
Apply dihedral symmetry: None
Force the dihedral axis to be in X: If this option is chosen, then the dihedral axis is not searched and it is assumed that it is around X.
Apply Cn symmetry: None
Cn symmetry: None
Height fraction: The helical parameters are only sought using the fraction indicated by this number. In this way, you can avoid including planes that are poorly resolved at the extremes of the volume. However, note that the algorithm can perfectly work with a fraction of 1.
Minimum rotational angle: In degrees
Maximum rotational angle: In degrees
Angular step: In degrees
Minimum shift Z: In Angstroms
Maximum shift Z: In Angstroms
Shift step: In Angstroms
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "operate particles" can be found at the xmipp3 plugin.
Its help description is:
  Apply an operation to two sets of particles  .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Operation: Binary operations: 
*plus*: Sums two images, volumes or adds a numerical value to an image. 
*minus*: Subtracts two images, volumes or subtracts a numerical value to an image. 
*multiply*: Multiplies two images, volumes, or multiplies per a given number. 
*divide*: Divides two images, volumes, or divides per a given number. 
*minimum*: Minimum of two images, volumes, or number (pixel-wise). 
*maximum*: Maximum of two images, volumes, or number (pixel-wise). 
*dot product*: Dot product between two images or volumes. 
Unary operations: 
*log*: Computes the natural logarithm of an image. 
*log10*: Computes the decimal logarithm of an image. 
*sqrt*: Computes the square root of an image 
*abs*: Computes the absolute value of an image. 
*pow*: Computes the power of an image. 
*slice*: Extracts a given slice from a volume (first slice=0). 
*column*: Extracts a given column from a image or volume. 
*row*: Extracts a given row from a image or volume. 
*radial average*: Compute the radial average of an image. 
*reset*: Set the image to 0
Second operand is a value?: Set to true if you want to use a value of the second operand
Input Particles (2nd): Set a SetOfParticles. The particles must be the same dimensions as the input particles.
Input value : Set the desire float value
Input value : This value must be integer
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "operate volumes" can be found at the xmipp3 plugin.
Its help description is:
  Apply an operation to two sets of volumes .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: Can be a density volume or a SetOfVolumes.
Operation: Binary operations: 
*plus*: Sums two images, volumes or adds a numerical value to an image. 
*minus*: Subtracts two images, volumes or subtracts a numerical value to an image. 
*multiply*: Multiplies two images, volumes, or multiplies per a given number. 
*divide*: Divides two images, volumes, or divides per a given number. 
*minimum*: Minimum of two images, volumes, or number (pixel-wise). 
*maximum*: Maximum of two images, volumes, or number (pixel-wise). 
*dot product*: Dot product between two images or volumes. 
Unary operations: 
*log*: Computes the natural logarithm of an image. 
*log10*: Computes the decimal logarithm of an image. 
*sqrt*: Computes the square root of an image 
*abs*: Computes the absolute value of an image. 
*pow*: Computes the power of an image. 
*slice*: Extracts a given slice from a volume (first slice=0). 
*column*: Extracts a given column from a image or volume. 
*row*: Extracts a given row from a image or volume. 
*radial average*: Compute the radial average of an image. 
*reset*: Set the image to 0
Second operand is a value?: Set to true if you want to use a value of the second operand
Input Volumes (2nd): This parameter depends of the input volume(s). If it is set a volume (or a SetOfVolumes) as input, this must be a *Volume* (or *SetOfVolumes*) object.
Input value : Set the desire float value
Input value : This value must be integer
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "kerdensom" can be found at the xmipp3 plugin.
Its help description is:
 
    Classifies a set of images using  Kohonen's Self-Organizing Feature Maps (SOM) 
    and Fuzzy c-means clustering technique (FCM) .
    
    The kerdenSOM algorithm anneals from an initial high regularization factor
    to a final lower one, in a user-defined number of steps.
    
    KerdenSOM is an excellent tool for classification, especially when
    using a large number of data and classes and when the transition between
    the classes is almost continuous, with no clear separation between them.
    
    The input images must be previously aligned.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input images: Select the input images from the project.It should be a SetOfParticles class
Use a Mask ?: If you set to *Yes*, you should provide a mask
Mask: Mask image will serve to enhance the classification
X: None
Y: None
Initial regularization factor: The kerdenSOM algorithm anneals from an initial high regularization factorto a final lower one, in a user-defined number of steps.If the output map is too smooth, lower the regularization factorsIf the output map is not organized, higher the regularization factorsSee [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/KerDenSOM][KerDenSOM]]
Final regularization factor:: None
Regularization steps:: Number of steps to lower the regularization factor
Additional parameters:: Additional parameters for kerdensom program. 
 For a complete descriptionSee [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/KerDenSOM][KerDenSOM]]

The protocol named "localdeblur sharpening" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a resolution map the protocol calculate the sharpened map.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Map: Select a volume for sharpening.
Resolution Map: Select a local resolution map. LocalDeblur has been specially designed to work with resolution maps obtained with MonoRes, however resolution map from ResMap and BlocRes are also accepted.
lambda: Regularization Param.The method determines this parameter automatically. This parameter is directly related to the convergence. Increasing it would accelerate the convergence, however it presents the risk of falling into local minima.
K: K = 0.025 works well for all tested cases. K should be in the 0.01-0.05 range. For maps with FSC resolution lower than 6Å, K = 0.01 can be a good alternative.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "estimate local defocus" can be found at the xmipp3 plugin.
Its help description is:
 Compares a set of particles with the corresponding projections of a reference volume.
    The set of particles must have a 3D angular assignment.
    This protocol refines the CTF, computing local defocus change.
    The maximun allowed defocus is a parameter introduced by the user (advanced).
    The protocol gives back the input set of particles with the refine local defocus and the defocus change with relation to the global defocus..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input images: None
Volume to compare images to: Volume to be used for class comparison
Maximum defocus change (A): None
Maximum gray scale change: The reprojection is modified as a*P+b, a is restricted to the interval [1-maxGrayScale,1+maxGrayScale]
Maximum gray shift change: The reprojection is modified as a*P+b, b is restricted to the interval [-maxGrayShift,maxGrayShift]
Force defocusV to be equal than defocusU: As the CTF usually suffers from astigmatism (it is not spherical but ellipsoidal), the defocus vary if computed in X or Y direction, being defocus U value the defocus in X direction and defocus V value the defocus in Y direction.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "volume local adjustment" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to adjust locally volume intensity to a reference volume. Occupancy volume is saved in protocol folder. Based on 
    https://www.sciencedirect.com/science/article/pii/S1047847723000874?via%3Dihub.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Reference volume: Specify a volume to be used as reference volume.
Input volume: Specify a volume which will be adjusted to the reference volume.
Mask for reference volume: Specify a mask to define region of interest (which is signal in white (1s) and background in black (0s))
Neighborhood (A): Side length (in Angstroms) of a square which will define the region of adjustment
Perform subtraction?: Perform subtraction of reference volume minus input volume in real space

The protocol named "ml2d" can be found at the xmipp3 plugin.
Its help description is:
 
    Perform (multi-reference) 2D-alignment using 
    a maximum-likelihood ( *ML* ) target function.
    
    Initial references can be generated from random subsets of the experimental
    images or can be provided by the user (this can introduce bias). The output
    of the protocol consists of the refined 2D classes (weighted averages over 
    all experimental images). The experimental images are not altered at all.    
    
    Although the calculations can be rather time-consuming (especially for 
    many, large experimental images and a large number of references we 
    strongly recommend to let the calculations converge. 
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input images from the project.
Generate classes?: If you set to *No*, you should provide class images. If *Yes*, the default generation is done by averaging subsets of the input images (less bias introduced).
Number of classes:: Number of classes to be generated.
Class image(s): Image(s) that will serve as initial 2D classes
Use MLF2D instead of ML2D?: None
Use CTF-amplitude correction?: If set to *Yes*, the input images file should contains.
 If set to *No*, provide the images pixel size in Angstrom.
Are the images CTF phase flipped?: You can run MLF with or without having phase flipped the images.
High-resolution limit (Ang): No frequencies higher than this limit will be taken into account.
If zero is given, no limit is imposed.
Also include mirror in the alignment?: Including the mirror transformation is useful if your particleshave a handedness and may fall either face-up or face-down on the grid.
Use the fast version?: If set to *Yes*, a fast approach will be used to avoid
searching in the whole solutions space.             

For details see (and please cite): 
[[http://dx.doi.org/10.1093/bioinformatics/bti1140][Scheres et al., Bioinformatics, 2005]] 
Refine the normalization for each image?: This variant of the algorithm deals with normalization errors. 

For details see (and please cite): 
 [[http://dx.doi.org/10.1107/S0907444909012049][Scheres et al., Acta Crystallogr D Biol Crystallogr, 2009]] 
Maximum number of iterations: If the convergence has not been reached after this numberof iterations, the process will be stopped.
In-plane rotation sampling (degrees): In-plane rotation sampling interval (degrees).
Std for pixel noise: Expected standard deviation for pixel noise.
Std for origin offset: Expected standard deviation for origin offset (pixels).
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "apply 2d mask" can be found at the xmipp3 plugin.
Its help description is:
  Apply mask to a set of particles .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Mask source: Select which type of mask do you want to apply. 
 
Input mask: None
Mask type: None
Radius (px): Mask radius, if -1, the radius will be MaskSize/2
Box size: Mask box size, if -1, the box size will be MaskSize/2
Inner radius (px): Inner radius in pixels
Outer radius (px): Outer radius in pixels, if -1, the outer radius will be MaskSize/2
Sigma (px): Gaussian sigma in pixels. If -1, sigma will be MaskSize/6
Border decay (px): This is the fall-off of the two borders of the crown
Shift Center: Shift Mask Center to a new origin.
X center offset: New x center coordinate
Y center offset: New y center coordinate
Fill with : Select how are you going to fill the pixel values outside the mask. 
Fill value: Value to fill the pixel values outside the mask. 
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "apply 3d mask" can be found at the xmipp3 plugin.
Its help description is:
  Apply mask to a volume .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: Can be a density volume or a SetOfVolumes.
Mask source: Select which type of mask do you want to apply. 
 
Input mask: None
Mask type: None
Radius (px): Mask radius, if -1, the radius will be MaskSize/2
Shift center of the mask?: None
X: None
Y: None
Z: None
Box size: Mask box size, if -1, the box size will be MaskSize/2
Inner radius (px): Inner radius in pixels
Outer radius (px): Outer radius in pixels, if -1, the outer radius will be MaskSize/2
Height (px): Cylinder height in pixels. If -1, height will be MaskSize
Sigma (px): Gaussian sigma in pixels. If -1, sigma will be MaskSize/6
Border decay (px): This is the fall-off of the two borders of the crown
Fill with : Select how are you going to fill the pixel values outside the mask. 
Fill value: Value to fill the pixel values outside the mask. 
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "directional resolution MonoDir" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a map the protocol assigns local resolutions to each voxel of the map.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: Select a volume for determining its local resolution.
Binary Mask: The mask determines which points are specimen and which ones not
Significance: Relution is computed using hipothesis tests, this value determinesthe significance of that test
Resolution Step: The resolution will be sought in steps of this values, with step = 0.3, then 1A, 1.3A, 1.6A,...
Fast Computation: Fast computation is recommended for large volumes.
Is the original premasked?: Sometimes the original volume is masked inside a spherical mask. In this caseplease select yes
Spherical mask radius (px): When the original volume is originally premasked, the noise estimation oughtto be performed inside that premask, and out of the provieded mask asked in the previusbox. The radius value, determines the radius of the spherical premask. By defaultradius = -1 use the half of the volume size as radius
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "local MonoRes" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a map the protocol assigns local resolutions to each voxel of the map.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Would you like to use half volumes?: The noise estimation for determining the local resolution is performed via half volumes.
Are the half volumes stored with the input volume?: Usually, the half volumes are stored as properties of the input volume. If this is not the case, set this to False and specify the two halves you want to use.
Input Volume: Select a volume for determining its local resolution.
Input Half Maps: Select a volume for determining its local resolution.
Volume Half 1: Select the first half of a volume for determining its local resolution.
Volume Half 2: Select the second half of a volume for determining a local resolution.
Binary Mask: The mask determines which points are specimen and which are not
Exclude Area: The mask determines the area of the protein to beexcluded in the estimation of the local resolution
Significance: Resolution is computed using hypothesis tests, this value determines the significance of that test
Mask threshold: If the provided mask is not binary. Then, MonoReswill try to binarize it. Mask values below the thresholdwill be change to 0 and above the thresthol will be 1
Use noise inside protein?: (Yes recommended) the noise distribution will be estimated in the protein region (inside the mask) by means of the difference of both half maps.
Consider noise gaussian?: It assumes the noise in the map as gaussian. Note that this assumption might not be true, despite ,it is  in general.
High: None
Low: None
Step: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "movie dose analysis" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for the dose analysis .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select one or several movies. A dose analysis be calculated for each one of them.
Maximum percentage difference (%): By default, a difference of 5% against the median dose is used to assume that the dose has an incorrect value.
Samples to estimate the median dose: By default, 20 movies are used to compute the global median.
Window step (movies): By default, every 50 movies (window=50) we compute the percentage of incorrect dose analysis to check if there is any anomally in the dose.
Windows maximum faulty percentage (%): By default, if 30% of the movies are discardedit assume that the dose has an incorrect value that endures in time.

The protocol named "movie gain" can be found at the xmipp3 plugin.
Its help description is:
  Estimate the gain image of a camera, directly analyzing one of its movies.
    It can correct the orientation of an external gain image (by comparing it with the estimated).
    Finally, it estimates the residual gain (the gain of the movie after correcting with a gain).
    The gain used in the correction will be preferably the external gain, but can also be the estimated
    gain if the first is not found.
    The same criteria is used for assigning the gain to the output movies (external corrected > external > estimated)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select several movies. A gain image will be calculated for each one of them.
Estimate movies gain: Estimate the gain from a set of movies using the algorith from xmipp
Estimate external gain orientation: Estimate the relative orientation between the estimated and the existing gain
Estimate residual gain: If there is a gain image associated with input movies, you can decide to use it instead of estimating raw/residual gain image. Location of this gain image needs to be indicated in import movies protocol.
Normalize existing gain: Normalize the input gain so that it has a mean of 1
Estimate the sigma parameter: Estimate the sigma parameter for the gain image computation
Frame step: By default, every 5th frame is used to compute the movie gain. If you set this parameter to 2, 3, ..., then only every 2nd, 3rd, ... frame will be used.
Movie step: By default, every 250 movies (movieStep=250) is used to compute the movie gain. If you set this parameter to 2, 3, ..., then every 2nd, 3rd, ... movie will be used.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "movie maxshift" can be found at the xmipp3 plugin.
Its help description is:
 
    Protocol to make an automatic rejection of those movies whose
    frames move more than a given threshold.
        Rejection criteria:
            - *by frame*: Rejects movies with drifts between frames
                              bigger than a certain maximum.
            - *by whole movie*: Rejects movies with a total travel
                                         bigger than a certain maximum.
            - *by frame and movie*: Rejects movies if both conditions
                                                above are met.
            - *by frame or movie*: Rejects movies if one of the conditions
                                             above are met.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously aligned Movies.
Rejection type: Rejection criteria:
 - *by frame*: Rejects movies with drifts between frames bigger than a certain maximum.
 - *by whole movie*: Rejects movies with a total travel bigger than a certain maximmum.
 - *by frame and movie*: Rejects movies if both conditions above are met.
 - *by frame or movie*: Rejects movies if one of the conditions above are met.
Max. frame shift (A): Maximum drift between consecutive frames to evaluate the frame condition.
Max. movie shift (A): Maximum total travel to evaluate the whole movie condition.

The protocol named "movie resize" can be found at the xmipp3 plugin.
Its help description is:
 
    Resize a set of movies. Only downsampling is allowed.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of movies to be resized.
Resize option: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Dimensions_: Set the output dimensions. 
_Factor_: Set a resize factor to resize. 
 
Resize sampling rate (A/px): Set the new output sampling rate.
New image size (px): Size in pixels of the particle images <x> <y=x> <z=x>.
Downsampling factor: New size is the old one x resize factor.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "multireference alignability" can be found at the xmipp3 plugin.
Its help description is:
     
    Performs soft alignment validation of a set of particles confronting them
    against a given 3DEM map. This protocol produces particle alignment
    precision and accuracy parameters.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input volume: Select the input volume(s).
Input particles: Select the input projection images.
Symmetry group: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
Angular Sampling (degrees): Angular distance (in degrees) between neighboring projection points 
Number of Orientations for particle: Parameter to define the number of most similar volume 
    projected images for each projection image
Do not use the weights: Do not use the weights in the clustering calculation
Pseudo symmetry group: Add only in case the map is close to a symmetry different and more restrict than the one reported in the parameter Symmetry group.See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
Minimum allowed tilt angle: Tilts below this value will not be considered for the alignment
Maximum allowed tilt angle without mirror check: Tilts above this value will not be considered for the alignment without mirror check
CTF correction: Perform CTF correction by Wiener filtering.
Isotropic Correction: If true, Consider that there is not astigmatism and then it is performed an isotropic correction.
Padding factor: Padding factor for Wiener correction 
Wiener constant:  Wiener-filter constant (if < 0: use FREALIGN default)
Correct for CTF envelope:  Only in cases where the envelope is well estimated correct for it
Target resolution (A): Low pass filter the particles to this resolution. This usually helps a lot obtaining good alignment. You should have a good reason to modify this value outside the range  [8-10] A
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "multiple fscs" can be found at the xmipp3 plugin.
Its help description is:
 
    Compute the FSCs between a reference volume and a set of input volumes.
    A mask can be provided and the volumes are aligned by default.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Reference volume: The rest of volumes will be compared to this one
Volumes to compare: Set of volumes to compare to the reference volume
Mask: A mask may be provided and it is applied before comparing the different volumes
Align volumes?: Align volumes to reference before comparing. A local alignment is performed so the initial orientation of the volumes should be relatively similar
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "normalize strain" can be found at the xmipp3 plugin.
Its help description is:
 
    Normalize the local strain and rotations amongst several runs
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
input strain calculations: Select the runs of strain calculations to be normalized

The protocol named "optical alignment" can be found at the xmipp3 plugin.
Its help description is:
 
    Wrapper protocol to Xmipp Movie Alignment by Optical Flow
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
from: None
to: None
Use ALIGN frames range to SUM?: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Save aligned micrograph: None
Save movie: Save Aligned movie
: Set to true if you want the GPU implementation of Optical Flow
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Window size: Window size (shifts are assumed to be constant within this window).
Group Size: The number of frames in each group at the last step
Use previous movie alignment to SUM frames?: Input movies could have alignment information froma previous protocol. If you select *Yes*, the previous alignment will be taken into account.
Compute PSD (before/after)?: If Yes, the protocol will compute for each movie the PSD of the average micrograph (without OF alignement) and after that, to compare each PSDs
Keep images in RAM ?: If True, the protocol will increase the demand of RAM, decreasing disc access
Apply Dose filter: Apply a dose-dependent filter to frames before summing them. Pre-exposure and dose per frame should  be specified during movies import.
Save unweighted micrographs?: Yes by default, if you have selected to apply a dose-dependent filter to the frames
Apply Dose filter before alignment?: if *True*, you apply dose filter before perform the alignment; else will apply after alignment.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "manual-picking (step 1)" can be found at the xmipp3 plugin.
Its help description is:
  Picks particles in a set of micrographs
    either manually or in a supervised mode.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
Save discarded particles: Generates an output with the manually discarded particles.
Run in interactive mode: If YES, you can pick particles in differents sessions.
If NO, once an outputCoordinates is created, the protocol finishes. 
(the last can be useful when other protocol waits until this finish -internal scheduled-)

The protocol named "tilt pairs particle picking" can be found at the xmipp3 plugin.
Its help description is:
  Picks particles in a set of untilted-tilted pairs of micrographs. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Micrographs tilt pair: Select the MicrographsTiltPair 

The protocol named "phantom volume" can be found at the xmipp3 plugin.
Its help description is:
  Create phantom volume from a feature description file using xmipp_phantom_create .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Create phantom: create a phantom description: x y z backgroundValue geometry(cyl, sph...) +(superimpose) desnsityValue origin radius height rot tilt psi. See more information in https://web.archive.org/web/20180813105422/http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/FileFormats#Phantom_metadata_file
Sampling rate: None

The protocol named "pick noise" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to pick noise particles.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Set of true particle coordinates. Noise coordinates are chosen so that they are sufficiently far from particles
Number of noise particles: Number of noise particles to extract from each micrograph. Set to -1 for extracting the same amount of noise particles as the number true particles for that micrograph
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "remove duplicates" can be found at the xmipp3 plugin.
Its help description is:
 
    This protocol removes coordinates that are closer than a given threshold.
    The remaining coordinate is the average of the previous ones.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the set of coordinates to compare
Radius: All coordinates within this radius (in pixels) are presumed to correspond to the same particle

The protocol named "preprocess micrographs" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to preprocess a set of micrographs in the project.
    You can crop borders, remove bad pixels, etc. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: Select the SetOfMicrograph to be preprocessed.
Operations are performed in the order shown below: None
Crop borders?: Crop a given amount of pixels from each border.
Pixels to crop: Amount of pixels you want to crop from borders.
Take logarithm?: Depending on your acquisition system you may need to take the logarithm of the pixel values in order to have a linear relationship betweenthe gray values in the image and those in the volume. a - b ln(x+c) by default 4.431-0.4018*LN((P1+336.6)) is applied (right one for nikon coolscan 9000)
a: None
b: None
c: None
Remove bad pixels?: Values will be thresholded to this multiple of standard deviations. Typical values are about 5, i.e., pixel values beyond 5 times the standard deviation will be substituted by the local median. Set this option to -1 for not applying it.
Multiple of Stddev: Multiple of standard deviation.
Invert contrast?: Multiply by -1
Downsample micrographs?: Downsample micrographs by a given factor.
Downsampling factor: Non-integer downsample factors are possible. Must be larger than 1.
Denoising: Apply a denoising method
Max. number of iterations: Max. number of iterations. Higher number = better output but slower calculation. Must be larger than 1.
Gaussian filter: Apply a Gaussian filter in real space
Gaussian sigma (px): The larger this value, the more the effect will be noticed
Highpass filter: Apply a highpass filter in real space
Cutoff frequency: In normalized frequencies (<0.5). For example, if you want to remove patterns larger than 500 pixels, use 1/500=0.002
Transition bandwidth: In normalized frequencies (<0.5). For example, if you want to remove patterns larger than 1000 pixels, use 1/1000=0.001
Lowpass filter: Apply a lowpass filter in real space
Cutoff frequency: In normalized frequencies (<0.5). For example, if you want to remove the crystalline ice at a frequency of 4A and the pixel size is 0.5A, then the cutoff should be 0.5/4=0.125
Transition bandwidth: In normalized frequencies (<0.5). The number of pixels in Fourier will be approximately lowRaised*Xdim
Normalize micrograph?: Normalize micrographs to be zero mean and standard deviation one
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "preprocess particles" can be found at the xmipp3 plugin.
Its help description is:
  Preprocess a set of particles. You can remove dust, normalize, 
        apply threshold, etc .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Dust removal: Sets pixels with unusually large values torandom values from a Gaussian with zero-mean and unity-standard deviation.
Threshold for dust removal: Pixels with a signal higher or lower thanthis value times the standard deviation of the imagewill be affected. For cryo, 3.5 is a good value.For high-contrast negative stain, the signal itselfmay be affected so that a higher value may be preferable.
Randomize phases: Randomize phases beyond a certain frequency.
Maximum Resolution: Angstroms.
Normalize: It subtract a ramp in the gray values and normalizesso that in the background there is 0 mean andstandard deviation 1.
Normalization type: OldXmipp: mean(Image)=0, stddev(Image)=1
NewXmipp: mean(background)=0, stddev(background)=1
Ramp: subtract background + NewXmipp
Background radius: Pixels outside this circle are assumed to be noise andtheir stddev is set to 1. Radius for backgroundcircle definition (in pix.).If this value is 0, then half the box size is used.
Center images: None
Phase flip images: None
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Invert contrast: Invert the contrast if your particles are black overa white background.
Threshold: Remove voxels below a certain value.
Fill with : Select how are you going to fill the pixel valuesoutside the mask.
Threshold value: Grey value below which all voxels should be set to 0.
Substitute by: If you select: value: Selected are substitute by a desired value.            binarize: Selected are set to 0, non-selected to 1.                 avg: Average of non-selected.
Fill value:  Substitute selected pixels by this value.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "preprocess volumes" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for Xmipp-based preprocess for volumes .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: Can be a density volume or a SetOfVolumes.
Change hand: Change hand by applying a mirror along X.
Change icosahedral orientation: Change from one icosahedral standard orientation to another.
from: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] for a description of the symmetry groups format.
to: None
Randomize phases: Randomize phases beyond a certain frequency.
Maximum Resolution: Angstroms.
Symmetrize: Symmetrize the input model.
Symmetry group: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] for a description of the symmetry groups format.If no symmetry is present, set the Symmetrize field to not.
Aggregation mode: Symmetrized volumes can be averaged or summed.
Wrap: by default, the image/volume is wrapped
Apply Laplacian: Laplacian denoising
Mask volume: None
Adjust gray values: Adjust input gray values so that it is compatiblewith a set of projections.
Set of particles: Set of images to which the model should conform.The set of images should have the final pixel sizeand the final size of the model.
Symmetry group: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]]for a description of the symmetry groups format.If no symmetry is present, give c1.
Segment: Separate the molecule from its background.
Segmentation Type: Type of segmentation.
Molecule Mass: In automatic segmentation, set it to -1.
Normalize background: Set background to have zero mean and standard deviation 1.
Mask Radius: In pixels. Set to -1 for half of the size of the volume.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Invert contrast: Invert the contrast if your particles are black overa white background.
Threshold: Remove voxels below a certain value.
Fill with : Select how are you going to fill the pixel valuesoutside the mask.
Threshold value: Grey value below which all voxels should be set to 0.
Substitute by: If you select: value: Selected are substitute by a desired value.            binarize: Selected are set to 0, non-selected to 1.                 avg: Average of non-selected.
Fill value:  Substitute selected pixels by this value.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "projection matching" can be found at the xmipp3 plugin.
Its help description is:
  3D reconstruction and classification using multireference projection matching.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                   Select the one you want to use.
: Add a list of GPU devices that can be used
Input particles: Select the input particles. 
 If you want perform *CTF* correction the input particles 
 should have information about the CTF (hasCTF=True)
Use initial angles/shifts ? : Set to *Yes* if you want to use the projection assignment (angles/shifts) 
 associated with the input particles (hasProjectionAssigment=True)
Initial 3D reference volume: Input 3D reference reconstruction.
Clean up intermediate files?: Save disc space by cleaning up intermediate files. 
 Be careful, many options of the visualization protocol will not work anymore, 
 since all class averages, selfiles etc will be deleted. 
Perform CTF correction?: If set to true, a CTF (amplitude and phase) corrected map will be refined, 
 and the data will be processed in CTF groups. 

 _NOTE_: You cannot combine CTF-correction with re-alignment of the classes. 
 Remember that CTF information should be provided in the images input file. 
 
Make CTF groups automatically?: Make CTF groups based on a maximum differences at a given resolution limit. 
 _NOTE_: If this option is set to false, a docfile with the defocus values where to  

 split the images in distinct defocus group has to be provided (see expert option below) 
 
Maximum difference for grouping: If the difference between the CTF-values up to the resolution limit specified 
 below is larger than the value given here, two images will be placed in 
 distinct CTF groups.
Resolution limit (A) for grouping: Maximum resolution where to consider CTF-differences among different groups. 
 One should use somewhat higher resolutions than those aimed for in the refinement.
Set of defocus: Set with defocus values where to split into groups. 
 This field is compulsory if you do not want to make the CTF groups automatically. 

 _NOTE_: The requested docfile can be made initially with the *xmipp_ctf_group* program, 
 and then it can be edited manually to suit your needs.
Padding factor: Application of CTFs to reference projections and of Wiener filter 
 to class averages will be done using padded images. 
 Use values larger than one to pad the images.
Wiener constant: Term that will be added to the denominator of the Wiener filter. 
 In theory, this value is the inverse of the signal-to-noise ratio 
 If a negative value is taken, the program will use a default value as in FREALIGN 
 (i.e. 10% of average sum terms over entire space)  
 see Grigorieff JSB 157 (2006) pp117-125
Mask reference volumes: Masking the reference volume will increase the signal to noise ratio. 
 Do not provide a very tight mask. 
 
Radius of spherical mask (px): This is the radius (in pixels) of the spherical mask 
Mask Object: The mask file should have the same dimensions as your input particles. 
 The protein region should be 1 and the solvent should be 0.
Number of iterations: Number of iterations to perform.
Inner radius for rotational correlation::  In pixels from the image center
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "8 8 2 2 " 
    specifies 4 iterations, the first two set the value to 8 
    and the last two to 2. An alternative compact notation 
    is ("2x8 2x0", i.e.,
    2 iterations with value 8, and 2 with value 2).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Outer radius for rotational correlation:  In pixels from the image center. Use a negative number to use the entire image.
    *WARNING*: this radius will be use for masking before computing resolution
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "8 8 2 2 " 
    specifies 4 iterations, the first two set the value to 8 
    and the last two to 2. An alternative compact notation 
    is ("2x8 2x0", i.e.,
    2 iterations with value 8, and 2 with value 2).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Available memory to store all references (Gb):  This is only for the storage of the references. If your projections do not fit in memory, 
    the projection matching program will run MUCH slower. But, keep in mind that probably 
    some additional memory is needed for the operating system etc.
    Note that the memory per computing node needs to be given. That is, when using threads, 
    this value will be multiplied automatically by the number of (shared-memory) threads.
    
Angular sampling rate (deg):  Angular distance (in degrees) between neighboring projection  points
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "8 8 2 2 " 
    specifies 4 iterations, the first two set the value to 8 
    and the last two to 2. An alternative compact notation 
    is ("2x8 2x0", i.e.,
    2 iterations with value 8, and 2 with value 2).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Angular search range (deg):  Maximum change in rot & tilt  (in +/- degrees)
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1000 1000 10 10 " 
    specifies 4 iterations, the first two set the value to 1000 (no restriction)
    and the last two to 10degrees. An alternative compact notation 
    is ("2x1000 2x10", i.e.,
    2 iterations with value 1000, and 2 with value 10).
    <Note:> if there are less values than iterations the last value is reused
    <Note:> if there are more values than iterations the extra value are ignored
    
Perturb projection directions?:  If set to 1, this option will result to a Gaussian perturbation to the 
    evenly sampled projection directions of the reference library. 
    This may serve to decrease the effects of model bias.
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1 1 0" 
    specifies 3 iterations, the first two set the value to 1 
    and the last to 0. An alternative compact notation 
    is ("2x1 0", i.e.,
    2 iterations with value 1, and 1 with value 0).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Projection method: select projection method, by default Fourier with padding 1 and interpolation bspline
Padding factor for projection: Increase the padding factor will improve projection quality but 
    projection generation will be slower. In general padding 1 and spline is OK
    
Interpolation kernel for projection:  Interpolation kernel for the generation of projections.
    
Maximum change in origin offset:  Maximum shift allowed per iteration.
    You may specify this option for each iteration.
    This can be done by a sequence of numbers (for instance, "1000 10 5"
    specifies 3 iterations, the first two set the value to 1000
    (almost no restriction) and the last to 5.
    An alternative compact notation
    is ("2x1000 5", i.e.,
    2 iterations with value 1000, and 1 with value 5).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra values are ignored
    
Search range for 5D translational search:  Give search range from the image center for 5D searches (in +/- pixels).
    Values larger than 0 will results in 5D searches (which may be CPU-intensive)
    Give 0 for conventional 3D+2D searches. 
    Note that after the 5D search, for the optimal angles always 
    a 2D exhaustive search is performed anyway (making it ~5D+2D)
    Provide a sequence of numbers (for instance, "5 5 3 0" specifies 4 iterations,
    the first two set the value to 5, then one with 3, resp 0 pixels.
    An alternative compact notation is ("3x5 2x3 0", i.e.,
    3 iterations with value 5, and 2 with value 3 and the rest with 0).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
    
Step size for 5D translational search: " Provide a sequence of numbers (for instance, "2 2 1 1" specifies 4 iterations,
    the first two set the value to 2, then two with 1 pixel.
    An alternative compact notation is ("2x2 2x1", i.e.,
    2 iterations with value 2, and 2 with value 1).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Restrict tilt angle search?: Restrict tilt angle search 
 
Lower-value for restricted tilt angle search: Lower-value for restricted tilt angle search 
 
Higher-value for restricted tilt angle search: Higher-value for restricted tilt angle search 
 
Point group symmetry:  See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] for a description of the symmetry groups format.
If no symmetry is present, give c1. 
Symmetry group for Neighbourhood computations:  If you do not know what this is leave it blank.
    This symmetry will be using for compute neighboring points,
    but not for sampling or reconstruction
    See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]]
    for a description of the symmetry groups format
    If no symmetry is present, give c1
    
compute only closest neighbor: This option is only relevant if symmetryGroupNeighbourhood !=''
    If set to 1 only one neighbor will be computed per sampling point
    You may specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1 1 0" 
    specifies 3 iterations, the first two set the value to 1 
    and the last to 0. An alternative compact notation 
    is ("2x1 0", i.e.,
    2 iterations with value 1, and 1 with value 0).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Discard images?:  
    None : No images will be discarded.
    maxCC  : Minimum Cross Correlation, discard images with CC below a fixed value.
    percentage : Discard percentage of images with less CC.
    classPercentage: Discard percentage of images in each projection direction with less CC.
    Value of each option is set below.
    
discard image if CC below:  
    Discard images with cross-correlation (CC) below this value.
    Provide a sequence of numbers (for instance, "0.3 0.3 0.5 0.5" specifies 4 iterations,
    the first two set the value to 0.3, then two with 0.5.
    An alternative compact notation would be ("2x0.3 2x0.5").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
discard image percentage with less CC:  
    Discard this percentage of images with less cross-correlation (CC)
    Provide a sequence of numbers (for instance, "20 20 10 10" specifies 4 iterations,
    the first two set the value to 20%, then two with 10%
    An alternative compact notation would be ("2x20 2x10").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    Set to zero to prevent discarding any images
    
discard image percentage in class with less CC:  
    Discard this percentage of images in each class(projection direction)
    with less cross-correlation (CC)    
    Provide a sequence of numbers (for instance, "20 20 10 10" specifies 4 iterations,
    the first two set the value to 20%, then two with 10%
    An alternative compact notation would be ("2x20 2x10").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    Set to zero to prevent discarding any images
    
Perform scale search?:  If true perform scale refinement. (UNDER DEVELOPMENT!!!!) 
  
Step scale factors size: Scale step factor size (1 means 0.01 in/de-crements around 1).
    Provide a sequence of numbers (for instance, "1 1 .5 .5" specifies 4 iterations,
    the first two set the value to 1%, then two with .5%
    An alternative compact notation would be ("2x1 2x0.5").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    Set to zero to prevent discarding any images
Number of scale steps:  
    Number of scale steps.
    With default values (ScaleStep='1' and ScaleNumberOfSteps='3'): 1 +/-0.01 | +/-0.02 | +/-0.03.    
    With values ScaleStep='2' and ScaleNumberOfSteps='4' it performs a scale search over:
    1 +/-0.02 | +/-0.04 | +/-0.06 | +/-0.08.    
    In general scale correction should only be applied to the last iteration. Do not use it unless
    your data is fairly well aligned.
    
Additional options for Projection_Matching:  For details see:
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Projection_matching][projection matching]] and
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Mpi_projection_matching][mpi projection matching]]
    try -Ri xx -Ro yy for restricting angular search (xx and yy are
    the particle inner and outter radius)
    
Perform 2D re-alignment: None
Perform 2D re-alignment of classes?:  After performing a 3D projection matching iteration, each of the
    subsets of images assigned to one of the library projections is
    re-aligned using a 2D-alignment protocol.
    This may serve to remove model bias.
    For details see:
    [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Align2d][align 2d]]
    Note that you cannot combine this option with CTF-correction!
    You may specify this option for each iteration. 
    This can be done by a sequence of 0 or 1 numbers (for instance, "1 1 0 0" 
    specifies 4 iterations, the first two applied alig2d while the last 2
    dont. An alternative compact notation is 
    is ("2x1 2x0", i.e.,
    2 iterations with value 1, and 2 with value 0).
    *Note:*if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    *IMPORTANT:* if you set this variable to 0 the output  of the projection
    muching step will be copied as output of align2d
    
Number of align2d iterations::  Use at least 3 iterations
    The number of align iteration may change in each projection matching iteration
    Ffor instance, "4 4 3 3 " 
    specifies 4 alig2d iterations in the first projection matching iteration 
    and  two 3 alig2d iteration in the last 2 projection matching iterations.
    An alternative compact notation 
    is ("2x4 2x3", i.e.,
    2 iterations with value 4, and 2 with value 3).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Maximum change in origin offset (+/- pixels): Maximum change in shift  (+/- pixels)
    You must specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1000 1000 10 10 " 
    specifies 4 iterations, the first two set the value to 1000 (no restriction)
    and the last two to 10degrees. An alternative compact notation 
    is ("2x1000 2x10", i.e.,
    2 iterations with value 1000, and 2 with value 10).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Maximum change in rotation (+/- degrees): Maximum change in shift  (+/- pixels)
    You must specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, "1000 1000 10 10 " 
    specifies 4 iterations, the first two set the value to 1000 (no restriction)
    and the last two to 10degrees. An alternative compact notation 
    is ("2x1000 2x10", i.e.,
    2 iterations with value 1000, and 2 with value 10).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Reconstruction method:  Select what reconstruction method to use.
    fourier: Fourier space interpolation (with griding).
    art: Agebraic reconstruction technique
    wbp : Weight back project method.
    
Initial maximum frequency:  This number is only used in the first iteration. 
    From then on, it will be set to resolution computed in the resolution section
    
Additional parameters for fourier:  For details see:
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Fourier][fourier]]
    
Values of lambda for ART:  *IMPORTANT:* ou must specify a value of lambda for each iteration even
    if ART has not been selected.
    *IMPORTANT:* NOte that we are using the WLS version of ART that 
    uses geater lambdas than the plain art.
    See for details:
    [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Art][xmipp art]]
    You must specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, ".1 .1 .3 .3" 
    specifies 4 iterations, the first two set the value to 0.1 
    (no restriction)
    and the last  two to .3. An alternative compact notation 
    is ("2x.1 2x.3").
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Additional parameters for ART:  For details see:
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Art][xmipp art]]
    
Additional parameters for WBP:  For details see:
    [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Wbp][xmipp wbp]]
    
Compute resolution?:  For details see:
    [[http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Resolution][xmipp resolution]].
    
Split references averages?: In theory each reference average should be splited
    in two when computing the resolution. In this way each
    projection direction will be represented in each of the
    subvolumes used to compute the resolution. A much faster
    but less accurate approach is to split the 
    proyection directions in two but not the averages. We
    recommend the first approach for small volumes and the second for
    large volumes (especially when using small angular
    sampling rates.
    *IMPORTANT:* the second option has ONLY been implemented for FOURIER
    reconstruction method. Other reconstruction methods require this
    flag to be set to True
    You may specify this option for each iteration. 
    This can be done by a sequence of 0 or 1 numbers (for instance, "1 1 0 0" 
    specifies 4 iterations, the first two split the images   while the last 2
    don't. an alternative compact notation is 
    is ("2x1 2x0", i.e.,
    2 iterations with value 1, and 2 with value 0).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more vapplications/scripts/protocols/new_protocol_projmatch.pyalues than iterations the extra value are ignored
    
Low-pass filter the reference?: None
Use estimated resolution for low-pass filtering?:  If set to true, the volume will be filtered at a frecuency equal to
   the  resolution computed with a FSC=0.5 threshold, possibly 
   plus a constant provided by the user in the next input box. 

   If set to false, then the filtration will be made at the constant 
   value provided by the user in the next box (in digital frequency, 
   i.e. pixel^-1: minimum 0, maximum 0.5)
    
Constant to be added to the estimated resolution:  The meaning of this field depends on the previous flag.
    If set to true, then the volume will be filtered at a frequency equal to
    the  resolution computed with resolution_fsc (FSC=0.5) plus the value 
    provided in this field 
    If set to false, the volume will be filtered at the resolution
    provided in this field 
    This value is in digital frequency, or pixel^-1: minimum 0, maximum 0.5
    
    If you detect correlation between noisy regions decrease this value 
    (even to negative values)
    
    You can specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, ".15 .15 .1 .1"
    specifies 4 iterations, the first two set the constant to .15
    and the last two to 0.1. An alternative compact notation 
    is ("2x.15 2x0.1", i.e.,
    4 iterations with value 0.15, and three with value .1).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
Constant to be added to the reconstruction maximum frequency:  The meaning of this field depends on the <use FSC for filter> flag.
    If set to true, then the volume will be reconstructed up to the frequency equal to
    the resolution computed with resolution_fsc (FSC=0.5) plus the value 
    provided in this field 
    If set to false, the volume will be reconstructed up to the resolution
    provided in this field 
    This value is in digital frequency, or pixel^-1: minimum 0, maximum 0.5
    
    You can specify this option for each iteration. 
    This can be done by a sequence of numbers (for instance, ".15 .15 .1 .1" 
    specifies 4 iterations, the first two set the constant to .15
    and the last two to 0.1. An alternative compact notation 
    is ("2x.15 2x0.1", i.e.,
    4 iterations with value 0.15, and three with value .1).
    *Note:* if there are less values than iterations the last value is reused
    *Note:* if there are more values than iterations the extra value are ignored
    
MPI job size: Minimum size of jobs in mpi processes.
    Set to 1 for large images (e.g. 500x500)
    and to 10 for small images (e.g. 100x100)
    
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "random conical tilt" can be found at the xmipp3 plugin.
Its help description is:
 Creates initial volumes by using a set of projections/classes
    from a tilted-pair picking process and using RCT algorithm. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles tilt pair: Select the input particles tilt pair file that will be used.  file. This file is used to associate each micrograph with its tilted equivalent.
Input classes: Select the input images or classes from the project.
Thin Object: If the object is thin, then the tilted projections can be stretched to match the untilted projections
Maximum allowed shift for tilted particles (pixels): Particles that shift more will be discarded. A value larger than the image size will not discard any particle.
Skip tilted translation alignment: If the tilted image quality is very low, then this alignment might result in poor estimates.
Additional reconstruction parameters: See: http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Reconstruct_art_v31
Filter reconstructed volumes?: Filtering may be useful to remove noise, especially when few particles contribute to the reconstruction.
Resolution of the low-pass filter (dig.freq): Resolution of the low-pass filter (dig.freq)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "ransac" can be found at the xmipp3 plugin.
Its help description is:
  
    Computes an initial 3d model from a set of projections/classes 
    using RANSAC algorithm.
    
    This method is based on an initial non-lineal dimensionality
    reduction approach which allows to select representative small 
    sets of class average images capturing the most of the structural 
    information of the particle under study. These reduced sets are 
    then used to generate volumes from random orientation assignments. 
    The best volume is determined from these guesses using a random 
    sample consensus (RANSAC) approach.    
     .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input averages: Select the input images from the project.It should be a SetOfClasses2D object
Symmetry group: See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format in Xmipp.
If no symmetry is present, use _c1_.
Angular sampling rate: In degrees. This sampling defines how fine the projection gallery from the volume is explored.
Number of RANSAC iterations: Number of initial volumes to test by RANSAC
Perform dimensionality reduction: The dimensionality reduction is performed using the Local Tangent SpaceAlignment. See http://www.stat.missouri.edu/~ys873/research/LTSA11.pdf
Number of grids per dimension: Number of squares to sample the classes
Number of random samples: Number of squares to sample the classes
Inliers threshold: Correlation value threshold to determine if an experimental projection is an inlier or outlier.
Number of best volumes to refine: Number of best volumes to refine using projection matching approach and the input classes
Number of iterations to refine the volumes: Number of iterations to refine the best volumes using projection matching approach and the input classes
Initial volume: You may provide a very rough initial volume as a way to constraint the angular search.For instance, when reconstructing a fiber, you may provide a cylinder so that side viewsare assigned to the correct tilt angle, although the rotational angle may be completely wrong
Max frequency of the initial volume:  Max frequency of the initial volume in Angstroms
Use all images to refine:  When refining a RANSAC volume, use all images to refine it instead of only inliers
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "reconstruct fourier" can be found at the xmipp3 plugin.
Its help description is:
     
    Reconstruct a volume using Xmipp_reconstruct_fourier from a given set of particles.
    The alignment parameters will be converted to a Xmipp xmd file
    and used as direction projections to reconstruct.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input particles: Select the input images from the project.
Symmetry group: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
Maximum resolution (A): Maximum resolution (in Angstrom) to consider 
in Fourier space (default Nyquist).
Param *--maxres* in Xmipp.
Projection: None
Volume: None
Legacy version: Use original CPU version of the algorithm. This should not be necessary, but it's present to ensure backward compatibility
Approximative version: If on, an approximation of the original algorithm will be used. This will result in faster processing times, but (slightly) less precise result
Extra parameters: : Extra parameters to *xmipp_(cuda_)reconstruct_fourier* program:

                      --iter () : Subtract projections of this map from the images used for reconstruction
                      
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "highres" can be found at the xmipp3 plugin.
Its help description is:
 This is a 3D refinement protocol whose main input is a volume and a set of particles.
       The set of particles has to be at full size (the finer sampling rate available), but
       the rest of inputs (reference volume and masks) can be at any downsampling factor.
       The protocol scales the input images and volumes to a reasonable size depending on
       the resolution of the previous iteration.
       
       The protocol works with any input volume, whichever its resolution, as long as it
       is a reasonable initial volume for the set of particles. The protocol does not
       resolve the heterogeneous problem (it assumes an homogeneous population),
       although it is somewhat tolerant through the use of particle weights in the
       reconstruction process.
       
       It is recommended to perform several global alignment iterations before entering
       into the local iterations. The switch from global to local should be performed when
       a substantial percentage of the particles do not move from one iteration to the next.
       
       The algorithm reports the cross correlation (global alignment) or cost (local) function
       per defocus group, so that we can see which was the percentile of each particle in its
       defocus group. You may want to perform iterations one by one, and remove from one
       iteration to the next, those particles that worse fit the model..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Continue from a previous run?: If you set to *Yes*, you should select a previousrun of type *XmippProtReconstructHighRes* class and some of the input parameterswill be taken from it.
Full-size Images: Select a set of images at full resolution
Initial volumes: Select a set of volumes with 2 volumes or a single volume. If the input particles have an angular assignment, then you may leave empty this field and a 3D reconstruction of the input images is performed using reconstruct_fourier.
Radius of particle (px): This is the radius (in pixels) of the spherical mask covering the particle in the input images
Select previous run: Select a previous run to continue from.
Symmetry group: If no symmetry is present, give c1
Remove intermediate files: None
Low pass filter?: Apply a low pass filter to the previous iteration whose maximum frequency is the current resolution(A) + resolutionOffset(A). If resolutionOffset>0, then fewer informationis used (meant to avoid overfitting). If resolutionOffset<0, then more information is allowed (meant for a greedy convergence).
FSC criterion: The resolution of the reconstruction is defined as the inverse of the frequency at which the FSC drops below this value. Typical values are 0.143 and 0.5
Resolution offset (A): None
Spherical mask?: Apply a spherical mask of the size of the particle. If the postprocessing indicates that it has helical symmetry,then a cylindrical mask is applied
Positivity?: Remove from the next reference all negative values
Mask: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
Dropout: This is the probability with which voxels are dropped (set to 0.0) inside the binary mask
Next reference command: A command template that is used to generate next reference. The following variables can be used %(sampling)s %(dim)s %(volume)s %(iterDir)s. The command should read Spider volumes and modify the input volume.the command should be accessible either from the PATH or provide the absolute path.
Examples: 
xmipp_transform_filter -i %(volume)s --fourier low_pass 15 --sampling %(sampling)s
/home/joe/myScript %(volume)s sampling=%(sampling)s dim=%(dim)s
Remove reference to save space?: Remove reference volumes once they are not needed any more.
: None
Multiresolution approach: In the multiresolution approach the sampling rate of the images is adapted to the current resolution
Max. shift (%): Maximum shift as a percentage of the image size
Min.: Side views are around 90 degrees, top views around 0
Max.: You may generate redudant galleries by setting this angle to 180, this may help if c1 symmetry is considered
Image alignment: None
Number of iterations: None
Random subset size: Stochastic alignment is performed by taking random subsets of images of this size
Step size: The update is performed as V(k+1)=(1-alpha)*V(k)+alpha*R(k+1), that is, the previous volume weights 1-alpha, while the new one weights alpha
Restrict reconstruction angles: You may reconstruct only with those images falling on a certain range. This is particularly useful for helices where you may want to use projections very close to 90 degrees
Min.: Perform an angular assignment and only use those images whose angles are within these limits
Max.: Perform an angular assignment and only use those images whose angles are within these limits
Max. Target Resolution: In Angstroms. The actual maximum resolution will be the maximum between this number of 0.5 * previousResolution, meaning thatin a single step you cannot increase the resolution more than 1/2
: The gallery of reprojections is randomly perturbed this number of times
: Significant alignment is allowed to replicate each image up to this number of times
Optimize shifts?: Optimize shifts within a limit
Max. shift variation: Percentage of the image size
Optimize scale?: Optimize scale within a limit
Max. scale variation: None
Optimize angles?: Optimize angles within a limit
Optimize gray values?: Optimize gray values. Do not perform this unless the reconstructed volume is gray-compatible with the projections, i.e., the volumes haven been produced from projections
Max. gray scale variation: None
Max. gray shift variation: As a factor of the image standard deviation
Optimize defocus?: None
Max. defocus variation: In Angstroms
Fourier padding factor: The volume is zero padded by this factor to produce projections
Weight by SSNR?: Weight input images by SSNR
Weight by Continuous cost?: Weight input images by angular assignment cost
Weight by angular stability?: Weight input images by angular stability between iterations
Weight by CC percentile?: Weight input images by their fitness (cross correlation) percentile in their defocus group
Minimum CC weight: Weights are between this value and 1. If most of the particles are good, this value should be high (e.g., 0.9)
Mask: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
Symmetrize volume within mask?: None
Mask symmetry: If no symmetry is present, give c1
Mask: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
Apply helical symmetry?: None
Radius: In Angstroms
Dihedral symmetry: None
Min. Rotation: In degrees
Max. Rotation: In degrees
Min. Z shift: In angstroms
Max. Z shift: In angstroms
Post-processing command: A command template that is used to post-process the reconstruction. The following variables can be used %(sampling)s %(dim)s %(volume)s %(iterDir)s. The command should read Spider volumes and modify the input volume.the command should be accessible either from the PATH or provide the absolute path.
Examples: 
xmipp_transform_filter -i %(volume)s --fourier low_pass 15 --sampling %(sampling)s
/home/joe/myScript %(volume)s sampling=%(sampling)s dim=%(dim)s
Significant denoising Real space: None
Significant denoising Fourier space: None
Laplacian denoising: It can only be used if there is a mask
Blind deconvolution: None
Attenuate undershooting: None
Attenuate undershooting (K): Values below avg-K*sigma are attenuated
Evaluate difference: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "reconstruct significant" can be found at the xmipp3 plugin.
Its help description is:
 
    This algorithm addresses the initial volume problem in SPA
    by setting it in a Weighted Least Squares framework and
    calculating the weights through a statistical approach based on
    the cumulative density function of different image similarity measures.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input classes: Select the input classes2D from the project.
It should be a SetOfClasses2D class with  class representative
Symmetry group: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]]for a description of the symmetry groups format. If no symmetry is present, give c1.
Is there a reference volume(s)?: You may use a reference volume to initialize  the calculations. For instance, this is very  useful to obtain asymmetric volumes from symmetric  references. The symmetric reference  is provided as starting point, choose no symmetry  group (c1), and reconstruct_significantwill tend to break the symmetry finding a suitable  volume. The reference volume can also be useful, for instance, when reconstructing a fiber.  Provide in this case a cylinder of a  suitable size.
Initial 3D reference volumes: None
Angular sampling: Angular sampling in degrees for generating the projection gallery.
Minimum tilt (deg): Use the minimum and maximum tilts to limit the  angular search. This can be useful, for instance, in the reconstruction of fibers from side views. 0 degrees is a top view, while 90 degrees is a  side view.
Maximum tilt (deg): Use the minimum and maximum tilts to limit the  angular search. This can be useful, for instance, in the reconstruction of fibers from side views. 0 degrees is a top view, while 90 degrees is a  side view.
Maximum shift (px):: Set to -1 for free shift search
Keep intermediate volumes: Keep all volumes and angular assignments along  iterations
Use new maximum resolution?: You may use a new maximum resolution to simplify the calculations keeping only low frequency information.
Target resolution: Target resolution (A).
Starting significance: 80 means 80% of significance. Use larger numbers to relax the starting significance and have a  smoother landscape of solutions
Number of iterations: Number of iterations to go from the initial  significance to the final one
Final significance: 99.5 means 99.5% of significance. Use smaller  numbers to be more strict and have a sharper  reconstruction. Be aware that if you are too strict, you may end with very few projections  and the reconstruction becomes verynoisy.
Use IMED: Use IMED for the weighting. IMED is an alternative to correlation that can discriminate better among very similar images
Strict direction: If the direction  is strict, then only the most  significant experimental images can contribute  to it. As a consequence, many experimental classes are lost and only the best contribute to the 3D reconstruction. Be aware that only the best can be very few depending on the cases.
Angular neighborhood: Images in an angular neighborhood also determines the weight of each image. It should be at least  twice the angular sampling
Do not apply Fisher: Images are preselected using Fisher's confidence interval on the correlation coefficient. Check this box if you do not want to make this preselection.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "swarm consensus" can be found at the xmipp3 plugin.
Its help description is:
 This is a 3D refinement protocol whose main input is a set of volumes and a set of particles.
       The set of particles has to be at full size (the finer sampling rate available), but
       the rest of inputs (reference volume and masks) can be at any downsampling factor.
       The protocol scales the input images and volumes to a size that depends on the target resolution.

       The input set of volumes is considered to be a swarm of volumes and they try to optimize
       the correlation between the volumes and the set of particles. This is an stochastic maximization
       and only a fraction of the particles are used to update the volumes and evaluate them.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Full-size Images: Select a set of images at full resolution
Initial volumes: Select a set of volumes with 2 volumes or a single volume
Radius of particle (px): This is the radius (in pixels) of the spherical mask covering the particle in the input images
Symmetry group: See http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups formatIf no symmetry is present, give c1
Mask: The mask values must be between 0 (remove these pixels) and 1 (let them pass). Smooth masks are recommended.
Number of iterations: None
Max. Target Resolution: In Angstroms.
Min. Angle: The angular search is limited by this parametr (in degrees).
# Images to update: None
# Images to evaluate: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "resolution 3D" can be found at the xmipp3 plugin.
Its help description is:
  Computes resolution by several methods .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Volume to compare: This volume will be compared to the reference volume.
Calculate FSC and DPR?: If set True calculate FSC and DPR.
Reference volume: Input volume will be compared to this volume.
Calculate B-factor?: If set True the so-called B-factor will be estimated.
The B-factor can be used to sharpen a volume.
The high-resolution features will enhanced, thereby
correcting the envelope functions of the microscope,
detector etc. This implementation follows the
automated mode based on methodology developed by Rosenthal2003

*Note*: after finished, you can apply the B-factor through
   the _Analyze Results_ GUI.

The protocol named "resolution alignment" can be found at the xmipp3 plugin.
Its help description is:
     
    Given two half maps the protocol estimates if the reconstruction presents angular
    alignment errors. To do that, a set of directional FSC along all possible directions
    are estimated. The result is a curve Resolution-radius. If this curve presents a slope
    then the map present angular assignment errors, but it the graph is flat (horizontal), the map
    is error free. Note that this protocol generates a plot, not a Scipion object. Its result
    can only be visualized.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Are the half volumes stored with the input volume?: Usually, the half volumes are stored as properties of the input volume. If this is not the case, set this to False and specify the two halves you want to use.
Input Half Maps: Select a half maps for determining its  resolution anisotropy and resolution.
Half Map 1: Select one map for determining the directional FSC resolution.
Half Map 2: Select the second map for determining the directional FSC resolution.
Mask: The mask determines which points are specimen and which are not
Is a the protein a helix: blablabla
Limit the protein radius: blablabla
use directional fsc: blablabla
Cone Angle: Angle between the axis of the cone and the generatrix. An angle of 17 degrees is the best angle (see publicationVilas 2021) to measuare directional FSCs
FSC Threshold: Threshold for the fsc. By default the standard 0.143. Other common thresholds are 0.5 and 0.3.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "rotate volume" can be found at the xmipp3 plugin.
Its help description is:
  Rotate a volume around x,y,z .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Volume : Specify a volume.
Rotation mode: : Align (x,y,z) with Z axis
Axis: : Align (x,y,z) with Z axis
Degrees: : degrees of rotation in selected axis

The protocol named "rotational symmetry" can be found at the xmipp3 plugin.
Its help description is:
 
    Estimate the orientation of a rotational axis and symmetrize.
    The user should know the order of the axis (two-fold, three-fold, ...)
    If this is unknown you may try several and see the most consistent results.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: None
Symmetry order: 3 for a three-fold symmetry axis, 4 for a four-fold symmetry axis, ...
Search mode: None
Initial rotational angle: In degrees
Initial tilt angle: In degrees. tilt=0 is a top axis while tilt=90 defines a side axis
Min: None
Max: None
Step: None
Min: None
Max: None
Step: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "deep consensus picking" can be found at the xmipp3 plugin.
Its help description is:
  Protocol to compute a smart consensus between different particle picking
        algorithms. The protocol takes several Sets of Coordinates calculated
        by different programs and/or different parameter settings. Let's say:
        we consider N independent pickings. Then, a neural network is trained
        using different subset of picked and not picked cooridantes. Finally,
        a coordinate is considered to be a correct particle according to the
        neural network predictions.
        In streaming, the network is trained and used to predict in batches.
        The network is trained until the number of particles set is reached,
        meanwhile, a preliminary output is generated. Once the threshold is reached,
        the final output is produced by batches.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Set to true if you want to use GPU implementation 
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Select model type: If you set to *New*, a new model randomly initialized will be employed. If you set to *Pretrained* a pretrained model will be used. If you set to *PreviousRun*, a model trained in a previous run, within this project, will be employed
Select previous run: Select a previous run to continue from.
Skip training and score directly with pretrained model?: If you set to *No*, you should provide training set. If set to *Yes* the coordinates will be directly scored using the pretrained/previous model
Input coordinates: Select the set of coordinates to compare
Relative Radius: All coordinates within this radius (as fraction of particle size) are presumed to correspond to the same particle
Tolerance threshold: The method attach a score between 0 and 1, where 0 if for _bad_ particles and 1 for _good_ ones. Introduce -1 to let pass all for posterior inspection.
How to extract particles from micrograph: Our method, internally, uses particles that are extracted from preprocess micrographs. Preprocess steps are:
1) mic donwsampling to the required size such that the particle box size become 128 px. 
   E.g. xmipp_transform_downsample -i in/100_movie_aligned.mrc -o out1/100_movie_aligned.mrc --step newSamplingRate --method fourier
2) mic normalization to 0 mean and 1 std and mic contrast inversion to have white particles.
   E.g.  xmipp_transform_normalize -i out1/101_movie_aligned.mrc -o out2/101_movie_aligned.mrc --method OldXmipp [ --invert ]
3) particles extraction.
   E.g. xmipp_micrograph_scissor  -i out2/101_movie_aligned.mrc --pos particles@Runs/101_movie_aligned.pos -o out3/105_movie_aligned_particles  --Xdim 128 --downsampling newSamplingRate --fillBorders  ( Correct your coordinates with newSamplingRate if needed)
4) OPTIONAL: phase flipping using CTF.
 xmipp_ctf_phase_flip  -i particles/105_movie_aligned_noDust.xmp -o particles/105_movie_aligned_flipped.xmp --ctf ctfPath/105_movie_aligned.ctfParam --sampling newSamplingRate
Did you invert the micrographs contrast (particles are bright now)?: If you invert the contrast, your particles will be white over a black background in the micrograph. We use white particles. Select *No* if you already have inverted the constrast in the micrograph so that we can extract white particles directly
Ignore CTF: Deep Consensus extracts particles. Do you want to ignore CTF for particle extraction
CTF estimation: Choose some CTF estimation related to input micrographs. 
CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
Number of epochs: Number of epochs for neural network training.
Learning rate: Learning rate for neural network training
Auto stop training when convergency is detected?: If you set to *Yes*, the program will automatically stop training if there is no improvement for consecutive 2 epochs, learning rate will be decreased by a factor 10. If learningRate_t < 0.01*learningrate_0 training will stop. Warning: Sometimes convergency seems to be reached, but after time, improvement can still happen. Not recommended for very small data sets (<100 true particles)
Training mean val_acc threshold: Stop training if at any training batch the selected threshold is achieved
Regularization strength: L2 regularization for neural network weights.Make it bigger if suffering overfitting (validation acc decreases but training acc increases)
Typical values range from 1e-1 to 1e-6
Number of models for ensemble: Number of models to fit in order to build an ensamble. Tipical values are 1 to 5. The more the better until a point where no gain is obtained. Each model increases running time linearly
Expected number of particles to use for training: Number of particles for training the CNN. Once surpassed, there will not be more training
Set to -1 to use all the particles found
It will determine the size of the CNNUsually, the bigger the better, but more training data is needed
Three CNN sizes: n < 1500 | 1500 <= n < 20000 | n >= 20000
Perform testing after training?: If you set to *Yes*, you should select a testing positive set and a testing negative set
Set of positive test particles: Select the set of ground true positive particles.
Set of negative test particles: Select the set of ground false positive particles.
Additional training data: If you set to *None*, only the AND and RANDOM will be used for training.
If you set to *Precompiled*, a precompiled additional training set will be added to to the AND and RANDOM sets for training.
If you set to *Custom*, you can provide your own data that will be added to the AND and RANDOM sets for training.

Additional training data: You can provide either particles or coordinates as additional training set.If you provide coordinantes, they have to be picked from the same micrographs that theinputs
 If you provide particles, they have to be processed in the same way that the protocoldoes (128x128 pixels and withe particles). Thus, what the protocol does is to perform the following steps:
1) mic donwsampling to the required size such that the particle box size become 128 px. 
   E.g. xmipp_transform_downsample -i in/100_movie_aligned.mrc -o out1/100_movie_aligned.mrc --step newSamplingRate --method fourier
2) mic normalization to 0 mean and 1 std and mic contrast inversion to have WHITE particles.
 E.g.  xmipp_transform_normalize -i out1/101_movie_aligned.mrc -o out2/101_movie_aligned.mrc --method OldXmipp [ --invert ]
3) particles extraction.
   E.g. xmipp_micrograph_scissor  -i out2/101_movie_aligned.mrc --pos particles@Runs/101_movie_aligned.pos -o out3/105_movie_aligned_particles  --Xdim 128 --downsampling newSamplingRate --fillBorders  ( Correct your coordinates with newSamplingRate if needed)
4) OPTIONAL: phase flipping using CTF.
 xmipp_ctf_phase_flip  -i particles/105_movie_aligned_noDust.xmp -o particles/105_movie_aligned_flipped.xmp --ctf ctfPath/105_movie_aligned.ctfParam --sampling newSamplingRate
Then, particles are extracted with no further alteration.
Please ensure that the additional particles have been preprocessed as indicated before.

Positive train particles 128px (optional): Select a set of true positive particles. Take care of the preprocessing (128x128 pixels, contrast inverted (white particles), possibly CTF corrected
Positive coordinates(optional): Select a set of true coordinates collected from the same microgaphs that the input
Weight of positive additional train data: Select the weigth for the additional train set of positive particles.The weight value indicates internal particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of internal particles
Negative train particles 128px (optional): Select a set of false positive particles. Take care of the preprocessing: 128x128 pixels, contrast inverted (white particles), possibly CTF corrected
Negative coordinates(optional): Select a set of incorrect coordinates collected from the same microgaphs that the input
Weight of negative additional train data: Select the weigth for the additional train set of negative particles. The weight value indicates the number of times each image may be included at most per epoch. Deep consensus internal particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of internal particles
Perform preliminar predictions with on training CNN: The protocol will make preliminar preedictions with the network before it is fully trained
These preliminar results will be stored in a different output set
Extraction batch size: Size of the extraction batches (in number of micrographs)
Training batch size: Size of the training batches (in number of micrographs).The CNN needs a minimum number of particles to train for each batch, if there are not enough particles, the batch size must be increased

The protocol named "screen deep learning" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for screening particles using deep learning. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Set to true if you want to use GPU implementation
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
Use previously trained model?: If you set to *Yes*, you should select a previous run of type *XmippProtScreenDeepLearning* class and some of the input parameters will be taken from it.
Select previous run: Select a previous run to continue from.
Continue training on previously trainedModel?: If you set to *Yes*, you should provide training set
True particles: Select a set of particles that contains mostly true particles
Number of different negative dataset: Data from all negative datasets will be used for training. Maximun number is 4.

Set of negative train particles 1: Select the set of negative particles for training.
Weight of negative train particles 1: Select the weigh for the negative set of particles. The weight value indicates the number of times each image may be included at most per epoch. Positive particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of positive particles
Set of negative train particles 2: Select the set of negative particles for training.
Weight of negative train particles 2: Select the weigh for the negative set of particles. The weight value indicates the number of times each image may be included at most per epoch. Positive particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of positive particles
Set of negative train particles 3: Select the set of negative particles for training.
Weight of negative train particles 3: Select the weigh for the negative set of particles. The weight value indicates the number of times each image may be included at most per epoch. Positive particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of positive particles
Set of negative train particles 4: Select the set of negative particles for training.
Weight of negative train particles 4: Select the weigh for the negative set of particles. The weight value indicates the number of times each image may be included at most per epoch. Positive particles are weighted with 1. If weight is -1, weight will be calculated such that the contribution of additional data is equal to the contribution of positive particles
Set of putative particles to score: Select the set of putative particles to classify as good (score close to 1.0) or bad (score close to 0.0).
Number of epochs: Number of epochs for neural network training.
Learning rate: Learning rate for neural network training
Auto stop training when convergence is detected?: If you set to *Yes*, the program will automatically stop training if there is no improvement for consecutive 2 epochs, learning rate will be decreased by a factor 10. If learningRate_t < 0.01*learningrate_0 training will stop. Warning: Sometimes convergence seems to be reached, but after time, improvement can still happen. Not recommended for very small data sets (<100 true particles)
Regularization strength: L2 regularization for neural network weights.Make it bigger if suffering overfitting. Typical values range from 1e-1 to 1e-6
Number of models for ensemble: Number of models to fit in order to build an ensemble. Tipical values are 1 to 5. The more the better until a point where no gain is obtained. Each model increases running time linearly
Perform testing after training?: If you set to *Yes*, you should select a testing positive set and a testing negative set
Set of positive test particles: Select the set of ground true positive particles.
Set of negative test particles: Select the set of ground false positive particles.

The protocol named "screen particles" can be found at the xmipp3 plugin.
Its help description is:
 Protocol to attach different merit values to every particle metadata for subsequent pruning the set.
There are different merit values to be calculated:
    - zScore evaluates the similarity of a particles with an average (lower zScore -> higher similarity).
    - SSNR evaluates the signal/noise ration in the Fourier space.
    - Variance evaluates the varaince on the micrographs context where the particle was picked.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Automatic rejection by Zscore: zScore evaluates the similarity of a particles with an average. The rejection can be:
  None (no rejection)
  MaxZscore (reject a particle if its zScore is larger than this value).
   Percentage (reject a given percentage for this criteria).
zScore threshold: Maximum Zscore.
Percentage (%): The worse percentage of particles according to metadata labels: ZScoreShape1, ZScoreShape2, ZScoreSNR1, ZScoreSNR2, ZScoreHistogram are automatically disabled.
Automatic rejection by SSNR: SSNR evaluates the signal/noise ration in the Fourier space. The rejection can be:
  None (no rejection)
  Percentage (reject a given percentage of the lowest SSNRs).
Percentage (%): The worse percentage of particles according to SSNR are automatically disabled.
Automatic rejection by Variance: Variance evaluates the varaince on the micrographs context where the particle was picked. The rejection can be:
  None (no rejection)
  Variance (taking into account only the variance)
  Var. and Gini (taking into account also the Gini coeff.)
Add features: Add features used for the ranking to each one of the input particles
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "shift particles" can be found at the xmipp3 plugin.
Its help description is:
  This protocol shifts particles to center them into a point selected in a volume. To do so, it generates new
    shifted images and modify the transformation matrix according to the shift performed..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particles: Select the SetOfParticles with transformation matrix to be shifted.
Select position in volume?: Select the position where the particles will be shifted in a volume displayed in a wizard.
Volume: Volume to select the point (by clicking in the wizard for selecting the new center) that will be the new center of the particles.
x: Use the wizard to select the new center for the shifted particles by shift+click on the blue point a drag it to the desired location while pressing shift.
y: None
z: None
Volume mask: 3D mask to compute the center of mass, the particles will be shifted to the computed center of mass
Apply shift to particles?: Yes: The shift is applied to particle images and zero shift is stored in the metadata. No: The shift is stored in the transformation matrix in the metadata, but not applied to the particle image (i.e. the output images are the same of input images). This option takes less time and the shift could be applied later using protocol "xmipp3 - apply alignment 2d" or by re-extracting the particles.
Use original box size for the shifted particles?: Use input particles box size for the shifted particles.
Final box size: Box size for the shifted particles.
Inverse: Use inverse transformation matrix
Interpolation: Linear: Use bilinear/trilinear interpolation
Spline: Use spline interpolation

The protocol named "shift volume" can be found at the xmipp3 plugin.
Its help description is:
  This protocol shifts a volume according to the input shifts.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Volume: Volume to shift
Use the same shifts as for the particles?: Use output shifts of protocol "shift particles" which should be executed previously
Shift particles protocol: None
x: None
y: None
z: None
Use original box size for the shifted volume?: Use input volume box size for the shifted volume.
Final box size: Box size of the shifted volume.

The protocol named "simulate ctf" can be found at the xmipp3 plugin.
Its help description is:
 
    Simulate the effect of the CTF (no amplitude decay).
    A random defocus is chosen between the lower and upper defocus for each projection.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: None
Voltage (kV): None
Spherical aberration Cs (mm): None
Fraction inelastic scattering: Between 0 and 1
Lower defocus (A): Negative value is overfocus
Upper defocus (A): Negative value is overfocus
Simulate astigmatic CTF?: If yes, defocusU and defocusV will have different values with a difference determined by the user, and there will be a value for angle
Lower defocus angle (degrees): Between 0 and 90
Upper defocus angle (degrees): Between 0 and 90
Lower defocus difference between defocusU and defocusV (A): None
Upper defocus difference between defocusU and defocusV(A): None

The protocol named "solid angles" can be found at the xmipp3 plugin.
Its help description is:
     
    Construct image groups based on the angular assignment. All images assigned within a solid angle
    are assigned to a class. Classes are not exclusive and an image may be assigned to multiple classes
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input volume: Select the input volume.
Input particles: Select the input experimental images with an angular assignment.
Symmetry group: See [[http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry][Symmetry]] page for a description of the symmetries accepted by Xmipp
Angular sampling: In degrees
Angular distance: In degrees. An image belongs to a group if its distance is smaller than this value
Maximum shift: In pixels
Number of directional classes: By default only one class will be computed for each projection direction. More classes could becomputed and this is needed for protocols split-volume. 
Homogeneize groups: Set to -1 for no homogeneization. Set to 0 for homogeneizing to the minimum of class size. Set to any other number to homogeneize to that particular number
Target resolution (A): None
Refine angles: Refine the angles of the classes using a continuous angular assignment
Number of CL2D iterations: None
Split volume: If desired, the protocol can use the directional classes calculated in this protocol to divide the input volume into 2 distinct 3D classes as measured by PCA. If the PCA component is just noise, it means that the algorithm does not find a difference between the 2D classes
Mask: The mask values must be binary: 0 (remove these voxels) and 1 (let them pass).
Number of reconstructions: Number of random reconstructions to perform
Number of images/reconstruction: Number of images per reconstruction. Consider that reconstructions with symmetry c1 will be perfomed
Confidence level: This parameter is alpha. Two volumes, one at alpha/2 and another one at 1-alpha/2, will be generated
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "split frames" can be found at the xmipp3 plugin.
Its help description is:
 
    Wrapper protocol to Xmipp split Odd Even
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input movies: Select a set of movies to be split into two sets (odd and even).It means, the set of frames is split in two subsets.
Sum Frames: Set yes to get a set of micrograms, or no to get a set of movies.

The protocol named "split volume" can be found at the xmipp3 plugin.
Its help description is:
 Split volume in two.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Directional classes: Select a set of particles with angles. Preferrably the output of a run of directional classes
Symmetry group: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
Mask: The mask values must be binary: 0 (remove these voxels) and 1 (let them pass).
Number of reconstructions: Number of random reconstructions to perform
Number of images/reconstruction: Number of images per reconstruction. Consider that reconstructions with symmetry c1 will be perfomed
Confidence level: This parameter is alpha. Two volumes, one at alpha/2 and another one at 1-alpha/2, will be generated

The protocol named "gl2d streaming" can be found at the xmipp3 plugin.
Its help description is:
  2D alignment in full streaming using Xmipp GPU Correlation.
    The set of classes will be growing whilst new particle images are
    received..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
: Add a list of GPU devices that can be used
Maximum shift (%):: Maximum shift allowed during the alignment as percentage of the input set size
Number of best images:: Number of classes to assign every input image during the alignment
Number of iterations in split stage:: Maximum number of iterations in split stage
Number of iterations in classify stage:: Maximum number of iterations when the classification of the whole image set is carried out
Image size: The image size can be downsampled to accelerate the classification
Threshold to split: The threshold in the number of images assigned to one class to make a spliting of that class
Block size: The inputs will be processed in a block-by-block basis of this size
Maximum number of classes: Maximum number of classes to be generated
Use CL2D: If you set to *Yes*, you will use CL2D (CPU) to make the split process
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "gl2d static" can be found at the xmipp3 plugin.
Its help description is:
  2D alignment in semi streaming using Xmipp GPU Correlation.
    A previous set of classes must be provided to include the new images in the
    corresponding class although the representatives will be maintained..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
: Add a list of GPU devices that can be used
Set of references: Set of references that will serve as reference for the classification. This can be a set of classes or set of averages
Maximum shift (px):: Maximum shift allowed during the alignment as percentage of the input set size
Number of best images:: Number of the best images to keep for every class

The protocol named "struct map" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for structure mapping based on correlation distance. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume(s): Select one or more volumes (SetOfClasses3D)
for structure mapping.
Target resolution: In Angstroms, the images and the volume are rescaled so that this resolution is at 2/3 of the Fourier spectrum.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "struct map - Zernike3D" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for structure mapping based on Zernike3D. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                           Select the one you want to use.
: Add a list of GPU devices that can be used
Input volume(s): Select one or more volumes (Volume or SetOfVolumes)
for structure mapping.
Compare two sets?: Useful when two Sets are intended to be compared independently (e.g. comparing EMDBS and Maps coming from PDBs).
Second set of volumes: Select one or more volumes (Volume or SetOfVolumes)
to compare to the first set.
Target resolution: In Angstroms, the images and the volume are rescaled so that this resolution is at 2/3 of the Fourier spectrum.
Multiresolution: Perform the analysis comparing different filtered versions of the volumes. The values specified here will determine the cutoff frequency of the filter in normalized units (normalized to 1/2).
Sphere radius: Radius of the sphere where the spherical harmonics will be computed (in voxels).
Zernike Degree: Degree Zernike Polynomials of the deformation=1,2,3,...
Harmonical Degree: Degree Spherical Harmonics of the deformation=1,2,3,...
Regularization: Penalization to deformations (higher values penalize more the deformation).
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "subtract projection" can be found at the xmipp3 plugin.
Its help description is:
  This protocol computes the subtraction between particles and a reference volume, by computing its projections with the same angles that input particles have. Then, each particle and the correspondent projection of the reference volume are numerically adjusted and subtracted using a mask which denotes the region to keep. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particles : Specify a SetOfParticles
Reference volume : Specify a volume.
Circular mask radius: : Radius of the circular mask to avoid edge artifacts. If -1 it is half the X dimension of the input particles
Maximum resolution: : Maximum resolution (in A) of the data 
Ignore particles with negative beta0 or R2?: : Particles with negative beta0 or R2 will not appear in the output set as they are considered bad particles. Moreover, negative betas will not contribute to mean beta if "mean" option is selected
Limit frequency?: : Limit frequency in the adjustment process to the frequency correspondent to the resolution indicated in "Maximum resolution" field above
Decay of the filter (sigma): : Decay of the filter (sigma) to smooth the mask transition
Fourier padding factor: : The volume is zero padded by this factor to produce projections
Mask : Specify a 3D mask for the region of the input volume that you want to keep or subtract, avoiding masks with 1s in background. If no mask is given, the subtraction is performed in whole images.
Mask contains the part to : None
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tilt analysis" can be found at the xmipp3 plugin.
Its help description is:
  Estimate the tilt of a micrograph, by analyzing the PSD correlations of different segments of the image.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: Select the SetOfMicrograph to be preprocessed.
Window size: By default, the micrograph will be divided into windows of dimensions 512x512, the PSD its correlations will be computed in every segment.
Objective resolution: By default, micrographs PSD will be cropped into a central windows of dimensions (xdim*(sampling rate/objective resolution)) x (ydim*(sampling rate/objective resolution)).
Mean correlation threshold: By default, micrographs will be divided into an output set and a discarded set based on the mean and std threshold
STD correlation threshold: By default, micrographs will be divided into an output set and a discarded set based on the mean and std threshold.
: Save the micrograph segments, the PSD of those segments and the correlation statistics of those segments.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "trigger data" can be found at the xmipp3 plugin.
Its help description is:
 
    Waits until certain number of images is prepared and then
    send them to output.
    It can be done in 3 ways:
        - If "Send all items to output?" is _No_:
            Once the number of items is reached, a setOfImages is returned and
            the protocol finishes (ending the streaming from this point).
        - If "Send all items to output?" is _Yes_ and:
            - If "Split items to multiple sets?" is _Yes_:
                Multiple closed outputs will be returned as soon as
                the number of items is reached.
            - If "Split items to multiple sets?" is _No_:
                Only one output is returned and it is growing up in batches of
                a certain number of items (completely in streaming).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input images: None
Wait for signal to stop the stream?: If NO is selected, normal functionality.
If YES is selected it will wait for a signal to stop the stream.
 For this option, select send all items to output with a minimum size of 1
Minimum output size: How many particles need to be on input to create output set.
Send all items to output?: If NO is selected, only a closed subset of "Output size" items will be send to output.
If YES is selected it will still running in streaming.
Split items to multiple sets?: If YES is selected, multiple closed outputs of "Output size" are returned.
If NO is selected, only one open and growing output is returned
Send signal to stop a stream?: If NO is selected, normal functionality.
If YES is selected it will send a signal to a connected Trigger data protocol.
 For this option, select the option send all items to output.
Trigger data protocol: Select the trigger data protocol that you will send a signal to stop the stream.
Delay (sec): Delay in seconds before checking new output

The protocol named "validate fsc-q" can be found at the xmipp3 plugin.
Its help description is:
 
    The protocol assesses the quality of the fit.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: Select a volume.
Input PDB from file: : None
Refined PDB: : Specify the desired input structure.
PDB File path: : Specify a path to desired PDB structure.
Volume from PDB: : Volume created from the PDB. The volume should be aligned with the reconstruction map. If the volume is not entered, it is automatically created from the PDB.
Soft Mask: The mask determines which points are specimen and which are not. If the mask is not passed, the method creates an automatic mask from the PDB.
window size: Kernel size (slidding window) for determining local resolution (pixels/voxels).
Set origin of coordinates: Option YES:
A new volume will be created with the given ORIGIN of coordinates. 
x: offset along x axis
y: offset along y axis
z: offset along z axis
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "validate_nontilt" can be found at the xmipp3 plugin.
Its help description is:
     
    Ranks a set of volumes according to their alignment reliability obtained from a clusterability test.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input volumes: Select the input volumes.
Input particles: Select the input projection images .
Symmetry group: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Xmipp
Image alignment: None
High: None
Low: None
Angular Sampling (degrees): Angular distance (in degrees) between neighboring projection points 
Number of orientations per particle: Number of possible orientations in which a particle can be 

Significance: Significance of the aligniability with respect to a a set of uniformly distributed random points 

Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "validate overfitting" can be found at the xmipp3 plugin.
Its help description is:
     
    Check how the resolution changes with the number of projections used for 
    3D reconstruction. 

    NOTE:
    Using the output plot, with the reconstruction of aligned gaussian noise,
    you can assess the validity of the reconstruction from your micrograph
    images. Practically, if the resolution of reconstruction based on your
    images is not considerably different from aligned gaussian noise one
    (for less number of particles),your images may not produce a valid
    reconstruction.

    This method has been proposed by:
    B. Heymann "Validation of 3D EM Reconstructions", 2015.
    (see References)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Input particles: Select the input images from the project.
Resize input particles and volume?: If obtaining the best possible reconstruction is not your goal, you can resize your input particales and volume to reduce running time of the protocol
New size (px): Resizing input particles and volumeusing fourier method
Calculate the noise bound for resolution?: Select if you want to obtain the noise bound for resolution. This calculation will increase the computational time of this protocol.
Initial 3D reference volume: Input 3D reference reconstruction to align gaussian noise.
Symmetry group: See [[Xmipp Symmetry][http://www2.mrc-lmb.cam.ac.uk/Xmipp/index.php/Conventions_%26_File_formats#Symmetry]] pagefor a description of the symmetry formataccepted by Xmipp
Number of particles: Number of particles in each subset and consequently number of subsets (for instance, in default values,a number of 6 subsets with given values are chosen)
Note:
The number of particles in each subset should not be larger than 1/2 of the input set of particles. The protocol consider this issue automatically. It means that if the input set of particles are lower than 10,000, you could leave default values unchanged.
Number of times the randomization is performed: None
Maximum resolution (dig.freq): Nyquist is 0.5
Angular sampling rate: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "volumes adjust" can be found at the xmipp3 plugin.
Its help description is:
  This protocol scales a volume in order to assimilate it to another one.
    The volume with the best resolution should be the first one.
    The volumes should be aligned previously and they have to be equal in size.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Volume 1 : Specify a volume.
Mask volumes?: The masks are not mandatory but highly recommendable.
Mask for volume 1: Specify a mask for volume 1.
Filter at resolution: : Resolution (A) at which subtraction will be performed, filtering the input volumes.Value 0 implies no filtering.
Decay of the filter (sigma): : Decay of the filter (sigma parameter) to smooth the mask transition
Number of iterations: : None
Relaxation factor (lambda): : Relaxation factor for Fourier amplitude projector (POCS), it should be between 0 and 1, being 1 no relaxation and 0 no modification of volume 2 amplitudes
Match the rotationally averaged Fourier amplitudes?: Match the rotationally averaged Fourier amplitudes when adjusting the amplitudes instead of taking them directly from the reference volume. For subtraction and consensus it is recommended to set it to True but for sharpening it is recommended to set it to False
Compute energy?: Compute energy difference between the different adjustment steps and iterations to see if the method reaches convergence
Volume 2 : Specify a volume.
Mask for volume 2: Specify a mask for volume 1.

The protocol named "volume consensus" can be found at the xmipp3 plugin.
Its help description is:
  This protocol performs a fusion of all the input volumes, which should be preprocessed with protocol 'volume
    substraction' saving volume 2, in order to be as similar as possible before the fusion. The output of
    this protocol is the consensus volume and another volume which indicates the maximun difference between input
    volumes in each voxel..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Volumes: Select the volumes for the consensus.

The protocol named "volumes subtraction" can be found at the xmipp3 plugin.
Its help description is:
  This protocol scales a volume in order to adjust it to another one. Then, it can calculate the subtraction
    of the two volumes. Second input can be a pdb. The volumes should be aligned previously and they have to
    be equal in size.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Volume 1 : Specify a volume.
Mask volumes?: The masks are not mandatory but highly recommendable.
Mask for volume 1: Specify a mask for volume 1.
Filter at resolution: : Resolution (A) at which subtraction will be performed, filtering the input volumes.Value 0 implies no filtering.
Decay of the filter (sigma): : Decay of the filter (sigma parameter) to smooth the mask transition
Number of iterations: : None
Relaxation factor (lambda): : Relaxation factor for Fourier amplitude projector (POCS), it should be between 0 and 1, being 1 no relaxation and 0 no modification of volume 2 amplitudes
Match the rotationally averaged Fourier amplitudes?: Match the rotationally averaged Fourier amplitudes when adjusting the amplitudes instead of taking them directly from the reference volume. For subtraction and consensus it is recommended to set it to True but for sharpening it is recommended to set it to False
Compute energy?: Compute energy difference between the different adjustment steps and iterations to see if the method reaches convergence
Is the second input a PDB?: If yes, the protocol will generate and store in folder "extra" of this protocol a volume and a mask from the pdb. This is not the recommended option, as the automatic conversion of the PDB into a density map may not be successful due to origin mismatches. We recommend to convert previously the PDB, inspect the converted map and use the map as input. If not, a second volume has to be input and optionally (but highly recommendable), a mask for it.
Retrieve PDB from: Retrieve PDB data from server, use a pdb Object, or a local file
Input pdb : Specify a pdb object. This is not the recommended option, as the automatic conversion of the PDB into a density map may not be successful due to origin mismatches. We recommendto convert previously the PDB, inspect the converted map and use the map as input.
File path: Specify a path to desired PDB structure.
Volume 2 : Specify a volume.
Mask for volume 2: Specify a mask for volume 1.
Save intermediate files?: Save input volume 1 filtered and input volume 2 adjusted, whichare the volumes that are really subtracted.

The protocol named "volume deform - Zernike3D" can be found at the xmipp3 plugin.
Its help description is:
  Protocol for volume deformation based on Zernike3D. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation.                           Select the one you want to use.
: Add a list of GPU devices that can be used
Volume 1: None
Volume 2: None
Multiresolution: Perform the analysys comparing different filtered versions of the volumes
Target resolution: In Angstroms, the images and the volume are rescaled so that this resolution is at 2/3 of the Fourier spectrum.
Sphere radius: Radius of the sphere where the spherical harmonics will be computed.
Zernike Degree: Degree Zernike Polynomials of the deformation=1,2,3,...
Harmonical Degree: Degree Spherical Harmonics of the deformation=1,2,3,...
Regularization: Penalization to deformations (higher values penalize more the deformation).
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "calculate strain" can be found at the xmipp3 plugin.
Its help description is:
 Compare two states of a volume to analyze the local strains and rotations.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Initial state: Initial state of the structure, it will be deformed to fit into the final state
Final state: Initial state of the structure, it will be deformed to fit into the final state
Mask for the final state: Binary mask that defines where the strains and rotations will be calculated
Symmetry group: See http://xmipp.cnb.uam.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups formatIf no symmetry is present, give c1

The protocol named "local resolution/local bfactor" can be found at the xmipp3 plugin.
Its help description is:
     
    Given a local resolution map and an atomic model, this protocols provides the matching between the
    local resolution with the local bfactor per residue.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Atomic model: Select an atomic model. The atom positions will be taken to estimate the local resolution around them and then, the  local resolution associated to each residue.
Normalize Resolution: The normalizedlocal resolution map is defined as(LR - FSC)/FSC, where LR is the local resolution of agiven voxel, and FSC is the FSC resolution in A. This map provides information about whether the local resolution isgreater or lesser than the FSC. The local resolution normalized map is used to carry out the matching with the localbfactor per residue. Yes means that the local resolution will benormalized by the algorithm. No means that the input local resolution map is already a normalized local resolution map.
Local Resolution Map: Select a local resolution map. Alternatively, the input. can be a normalized local resolution map, in this caseset the Normalize resolution to No
Normalized Local Resolution Map: Select a normalized local resolution map. The local resolution normalized map is defined as (LR - FSC)/FSC, where LR is the local resolution of agiven voxel, and FSC is the FSC resolution in A
FSC resolution (A): The global resolution of the map in A
Use median: The local resolution per residue can be estimated usingthe mean (by default - No) or the median (yes)
is the atomic centered: True if the atomic model centered in midle of the local resolution map
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "assign alignment" can be found at the pwem plugin.
Its help description is:
  Assign the alignment calculated for a set of particles to another set.
    This protocol will take into account the differences of pixel size (A/pix)
    between the two sets and multiply by the right factor the shifts.
    The particles with the alignment can also be a subset of the other images
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the particles that you want to update the new alignment.
Input alignments: Select the particles with alignment to be apply to the other particles.
Assign random subsets?: If yes, the random subset information from the assignment input will be transferred to the output particles.
Ignore fractional shifts: When extracting coordinates, the integer part of the shifts from the alignment can be transferred to the 2d coordinate. The remaining decimal part is stored as xFrac and yFrac in the particles. Leave this active if you want current alignment shifts to be used, IGNORING the decimal fraction that might be annotated in case this set comes from an "extract coordinates" and you chose to "Apply particle shifts?"
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "invert hand" can be found at the pwem plugin.
Its help description is:
  Modify the transformation matrix of a set of particles
    So that the handedness changes
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the particles that you want to update the new alignment.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "average frames" can be found at the pwem plugin.
Its help description is:
 
    Very simple protocol to align all the frames of a given data collection
    session. It can be used as a sanity check.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.

The protocol named "box size checkpoint" can be found at the pwem plugin.
Its help description is:
 
    Protocol to make a validation operations on particle picking boxsize.
    For sanity check all the generated outputs are even numbers.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particle box size reference (px): This is the reference size of the boxed particles (in pixels).
For sanity check if it is not, it will be transform to an even number.
Particle box size secondary reference (px): This is a secondary size of the boxed particles (in pixels).
For sanity check if it is not, it will be transform to an even number.
Maximum proportional difference: This proportion is calulated with the following formula:
Proportional diff = 1 - min(boxSize1, boxSize2)/max(boxSize1, boxSize2)
If disagreed stayed with the primary reference?: Select yes if you want to use the primary reference as output.
Average the particle boxsize?: Select yes if you want to use an average of the box sizes as output.
Use timer?: Select yes if you want to use a timer to take the decision.
Time to wait:: Time in seconds that the protocol will remain running. A correct format is an integer number in seconds or the following syntax: {days}d {hours}h {minutes}m {seconds}s separated by spaces e.g: 1d 2h 20m 15s,  10m 3s, 1h, 20s or 25.

The protocol named "box size related parameters" can be found at the pwem plugin.
Its help description is:
 
    Protocol to make mathematical operations on particle picking boxsize.
    For sanity check all the generated outputs are even numbers.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: Select the SetOfMicrographs from where we extract the sampling rate
Particle box size (px): This is size of the boxed particles (in pixels).
For sanity check if it is not, it will be transform to an even number.
Extract particles boxsize?: Select yes if you want to generate these parameters.
Factor to multiply the box size (px): Extraction box size (px) = picking box size (px) * *factor*
Calculate gautomatch picking parameters?: Select yes if you want to generate these parameters.
Factor to obtain the particle radius (A): Particle radius in Angstrom. Default will be equal to 75% of reference size (box size).
Particle radius (A) = picking box size (px) * sampling_rate (A/px) * *factor*
Factor to obtain the min inter-particle distance (A): Minimum distance between particles in Angstrom
 Use value of 0.9~1.1X diameter; can be 0.3~0.5X for filament-like particle.
Min inter-particle distnace (A) = picking box size (px) * sampling_rate (A/px) * *factor*
Factor to obtain the local sigma diameter (A): Diameter for estimation of local sigma, in Angstrom.
Usually this diameter could be 0.5-2x of your particle diameter according to several factors. When using bigger values, normally you should decrease *Local sigma cut-off*. For smaller and sharper high density contamination/ice/metal particles you could use a smaller diameter and larger *Local sigma cut-off*.
Local sigma diameter (A) = picking box size (px) * sampling_rate (A/px) * *factor*
Factor to obtain the local average diameter (A): Diameter for estimation of local average, in Angstrom. 1.5~2.0X particle diameter suggested.
However, if you have sharp/small ice or any dark/bright dots, using a smaller value will be much better to get rid of these areas.
Local average diameter (A) = picking box size (px) * sampling_rate (A/px) * *factor*
Calculate relion picking parameters?: Select yes if you want to generate these parameters.
Factor to obtain the Min diameter for LoG filter (A): This should correspond to the smallest size of your particles projections in Ångstroms.
Min diameter for LoG filter (A) = picking box size (px) * sampling_rate (A/px) * *factor*
Factor to obtain the Max diameter for LoG filter (A): This should correspond to the largest size of your particles projections in Ångstroms.
Max diameter for LoG filter (A) = picking box size (px) * sampling_rate (A/px) * *factor*
Calculate topaz picking parameters?: Select yes if you want to generate these parameters.
Factor to obtain the particle radius (px): Pixel radius around particle centers to consider.
Particle radius (px) = picking box size (px) * *factor*
Number of particles per image: Expected number of particles per micrograph.
 If -1 it will be estimated for you.
Calculate picking consensus parameters?: Select yes if you want to generate these parameters.
Factor to obtain the particle radius (px): Pixel radius around particle centers to consider.
Particle radius (px) = picking box size (px) * *factor*
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "assign ctf" can be found at the pwem plugin.
Its help description is:
  This protocol assigns a CTF estimation to a particular
    set of particles producing a new set. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input type:: Select the type of objects that you want to assign the CTF.
Input set: Select the images (micrographs or particles) that you want to update the CTF parameters.
Input CTF: Select the CTFs that will be used to update particles. It can be another set of particles
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "numeric classes extractor" can be found at the pwem plugin.
Its help description is:
  Extracts items from a SetOfClasses based on number of items assigned to the class
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input classes: Set of classes to extract items from.
Extract representative?: Set to true if you want to extract the image that represents the class otherwise all items supporting the class will be extracted.
Biggest N classes: Will take the N biggest classes. Those having most element supporting them.

The protocol named "create stream data" can be found at the pwem plugin.
Its help description is:
  create  setofXXXX in streaming mode.
        micrograph -> read a micrograph in memory and writes it nDim times
        movie      -> read a movie in memory and writes it nDim times
        randomMicrographs -> creates a micrograph with random values
        and applies a random CTF
        particles  -> read nDim particles in memory and writes it in streaming
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
set Of: create set of
movie: This movie will be copied "number of items" times
micrograph: This micrograph will be copied "number of items" times
xdim: X dim 
ydim: Y dim 
SetOfParticles: These particles will be written in streaming
SetOfCoordinates: These Coordinates will be written in streaming
groups: How many items will be created every iteration
number of items: setofXX size
samplingRate: Sampling rate
Create Object each (sec): create one object each creationInterval seconds
Extra random seconds interval: Each object will be generated in a random time uniformly picked from the interval defined by[baseInterval, baseInterval+extraInterval]
delay (sec): wait this seconds before creating stream data
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Crossed subset" can be found at the pwem plugin.
Its help description is:
 
    Create a subset of the main set based on a matching field in another set. e.g.: Use _micName field (in both fields)
    to select micrographs (main set) present in a set of coordinates (secondary set)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Main set: Set to be reduced
Main field: Field in the main set that contains the values in common with the secondary set. Use any of the metadata viewers to find the field name.
Secondary set: Set holding the matching field. e.g: Set of Coordinates hold the micName that can be used to filter a set of micrographs (main set)
Secondary field: Field in the secondary set that contains the values in common with the main set. Use any of the metadata viewers to find the field name.

The protocol named "export to emdb/pdb" can be found at the pwem plugin.
Its help description is:
  generates files for elements to submit structures to EMDB/PDB.
        Since mmcif/pdb is only partially supported by some software
        the protocol creates 4 versions of the atomic struct file with the hope that at least
        one of them will work.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Main EM map to export: This EM map is mandatory for EMDB and it will be exported using mrc format. If this map is associated to their respective half maps, they will be exported as well.
Additional maps to export?: Select YES if you want to add some more EM maps to export.
Additional EM maps to export: These additional EM maps will be also exported using mrc format.
FSC file to export: This FSCs will be exported using XML format
Masks to export?: Select YES if you want to add some  masks to export.
Masks to export: These mask will be exported using mrc format
Atomic structure to export: This atomic structure will be exported using mmCIF format
Image to export: This image is mandatory for EMDB
symmetry group: symmetry group of the map.
Symmetry Order: Order of cyclic symmetry.
Export to directory: Directory where the files will be generated.

The protocol named "extract coordinates" can be found at the pwem plugin.
Its help description is:
  
    Extract the coordinates information from a set of particles.
    
    This protocol is useful when we want to re-extract the particles
    (maybe resulting from classification and cleaning) with the 
    original dimensions. It can be also handy to visualize the resulting
    particles in their location on micrographs.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the particles from which you want
to extract the coordinates and micrographs.
Input micrographs: Select the micrographs to which you want to
associate the coordinates from the particles.
Apply particle shifts?: Apply particle shifts (ONLY INTEGER PART) from 2D alignment to recalculate new coordinates. This can be useful for re-centering particle coordinates.
IMPORTANT: Only the integer part of the shifts will be applied in order to avoid interpolation. If you are re-extracting particles and want to apply the remaining decimal part of the shifts, set to  "yes" the option "Were particle shifts applied?" in alignment assign protocol.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "import averages" can be found at the pwem plugin.
Its help description is:
 Protocol to import a set of averages to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: You can import particles directly from the binary files, or import from other packages formats. 
Currently, we can import from: emx, xmipp3, relion, scipion, frealign, eman, cryosparc 
Following are the expected import files for each one:
*emx*: particles.emx
*xmipp3*: images.xmd
*relion*: itXX_data.star
*scipion*: particles.sqlite
*eman*: particleSet.lst
*cryosparc*: particles.cs

Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input EMX file: Select the EMX file containing particles information.
 See more about 
[[http://i2pc.cnb.csic.es/emx][EMX format]]
Alignment Type: Is this a 2D alignment, a 3D alignment or a set of projections
Particles metadata file: Select the particles Xmipp metadata file.
It is usually a images.xmd file result
from Xmipp protocols execution.
Star file: Select a *_data.star file from a
previous Relion execution.To detect if the input particles contains alignment information, it is required to have the optimiser.star file corresponding to the data.star
Ignore ID column?: Set this option to True to regenerate 
the id's of the particles. By default 
it is read from metadata file.        
This option can be useful when merging
different metadatas and id's are not  
longer unique.
Particles sqlite file: Select the particles sqlite file.

For Frealign you need to import both stack and .par files.: None
Stack file: Select an stack file with the particles.
Param file: Select a Frealign .par file with the refinement information.
Lst file: Select a *.lst set file from EMAN2 project.
cs file: Select a .cs file.
It is usually a .cs file result from cryoSPARC job execution.
Pixel size (sampling rate) Å/px: None
Have data been phase-flipped?: Set this to Yes if the images have been ctf-phase corrected.
Use the wizard button to import acquisition.: Depending on the import Format, the wizard
will try to import the acquisition values.
If not found, required ones should be provided.
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "import ctf" can be found at the pwem plugin.
Its help description is:
 Common protocol to import a set of ctfs into the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input micrographs: Select the micrographs for which you want to update the CTF parameters.
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "import coordinates" can be found at the pwem plugin.
Its help description is:
  Protocol to import a set of coordinates .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input micrographs: Select the micrographs for which you want to import coordinates.
Box size: None
Scale: Factor to scale coordinates
Invert X: None
Invert Y: Invert Y for EMAN coordinates taken on dm3 or tif micrographs
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "import coordinate pairs" can be found at the pwem plugin.
Its help description is:
  Protocol to import a set of tilt pair coordinates .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
_Auto_ - detects coordinate file type by extension.
_Xmipp_ - provide *.pos files
_Eman_ - provide info/*.json files
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Micrograph .xmd file: Provide input_micrographs.xmd file that contains tilt angles information. This file is usually created alongside the coordinates.
Pattern untilted: Pattern (that can include wildcards) of the files to import.
For example:
  *data/particles/***.spi*
  *~/Micrographs/mic/***.mrc*
Pattern tilted: Pattern (that can include wildcards) of the files to import.
For example:
  *data/particles/***.spi*
  *~/Micrographs/mic/***.mrc*
Input tilt pair micrographs: Select the tilt pair micrographs for which you want to import coordinates.
Box size: None
Scale: Factor to scale coordinates
Invert X: None
Invert Y: None

The protocol named "import mask" can be found at the pwem plugin.
Its help description is:
  Class for import masks from existing files. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Mask path: Select the file path of the mask

Pixel size (sampling rate) Å/px: None

The protocol named "import micrographs" can be found at the pwem plugin.
Its help description is:
 Protocol to import a set of micrographs to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input EMX file: Select the EMX file containing micrographs information.
See more about [[http://i2pc.cnb.csic.es/emx][EMX format]]
Micrographs metadata file: Select the micrographs Xmipp metadata file.
It is usually a _micrograph.xmd_ file result
from import, preprocess or downsample protocols.
Micrographs sqlite file: Select the micrographs sqlite file.

Have data been phase-flipped?: Set this to Yes if the images have been ctf-phase corrected.
Use the wizard button to import acquisition.: Depending on the import Format, the wizard
will try to import the acquisition values.
If not found, required ones should be provided.
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Sampling rate mode: You can specify the sampling rate (pixel size) directly from the image
(A/pixel, Ts) or by specifying the magnification rate (M) and the scanner
pixel size (microns/pixel, Tm).

They are related by  Ts = Tm / M
Pixel size (sampling rate) Å/px: Pixel size
Scanned pixel size (microns/px): 
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 

Reject from Set: Files on this set will not be imported
Reject from: Files acquired after this date will not be imported. Must follow format: YYYY-mm-dd HH:MM:SS 
e.g: 2019-01-14 14:18:05
Reject before: Files acquired before this date will not be imported. Must follow format: YYYY-mm-dd HH:MM:SS 
e.g: 2019-01-14 14:18:05
Rejection file has RegExps: Choose Yes if the rejection file contains regular expressions. Set to No if the rejection file contains file names. Ignore if not using a rejection file
Blacklist File: Reject everything included in this file. If Use RegExps is True,lines will be interpreted as regular expressions. E.g: 
(.*)GRID_0[1-5](.*)
(.*)/GRID_10/Falcon_2019_01_14-16_(.*)
If Use RegExps is False, lines will be interpreted as file names. E.g.
/path/to/GRID_10/Falcon_2019_01_14-16_51_20_0_movie.mrcs
/path/to/GRID_10/Falcon_2019_01_14-16_55_40_0_movie.mrcs

The protocol named "import tilted micrographs" can be found at the pwem plugin.
Its help description is:
 Protocol to import untilted-tilted pairs of micrographs in the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Pattern untilted: Pattern (that can include wildcards) of the files to import.
For example:
  *data/particles/***.spi*
  *~/Micrographs/mic/***.mrc*
Pattern tilted: Pattern (that can include wildcards) of the files to import.
For example:
  *data/particles/***.spi*
  *~/Micrographs/mic/***.mrc*
Copy files?: None
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Sampling rate mode: You can specify the sampling rate (pixel size) directly from the image
(A/pixel, Ts) or by specifying the magnification rate (M) and the scanner
pixel size (microns/pixel, Tm).

They are related by  Ts = Tm / M
Pixel size (sampling rate) Å/px: Pixel size
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Scanned pixel size (microns/px): None

The protocol named "import movies" can be found at the pwem plugin.
Its help description is:
  Protocol to import a set of movies (from direct detector cameras)
    to the project.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Have data been phase-flipped?: Set this to Yes if the images have been ctf-phase corrected.
Use the wizard button to import acquisition.: Depending on the import Format, the wizard
will try to import the acquisition values.
If not found, required ones should be provided.
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Sampling rate mode: You can specify the sampling rate (pixel size) directly from the image
(A/pixel, Ts) or by specifying the magnification rate (M) and the scanner
pixel size (microns/pixel, Tm).

They are related by  Ts = Tm / M
Pixel size (sampling rate) Å/px: Pixel size
Scanned pixel size (microns/px): 
Initial: None
Per frame: None
Gain image: A gain reference related to a set of movies for gain correction
Dark image: A dark image related to a set of movies
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 

Reject from Set: Files on this set will not be imported
Reject from: Files acquired after this date will not be imported. Must follow format: YYYY-mm-dd HH:MM:SS 
e.g: 2019-01-14 14:18:05
Reject before: Files acquired before this date will not be imported. Must follow format: YYYY-mm-dd HH:MM:SS 
e.g: 2019-01-14 14:18:05
Rejection file has RegExps: Choose Yes if the rejection file contains regular expressions. Set to No if the rejection file contains file names. Ignore if not using a rejection file
Blacklist File: Reject everything included in this file. If Use RegExps is True,lines will be interpreted as regular expressions. E.g: 
(.*)GRID_0[1-5](.*)
(.*)/GRID_10/Falcon_2019_01_14-16_(.*)
If Use RegExps is False, lines will be interpreted as file names. E.g.
/path/to/GRID_10/Falcon_2019_01_14-16_51_20_0_movie.mrcs
/path/to/GRID_10/Falcon_2019_01_14-16_55_40_0_movie.mrcs
Input individual frames?: Select Yes if movies are acquired in individual frame files. 
Number of frames: Provide how many frames are per movie. 
Create movie stacks?: Select Yes if you want to create a new stack for each movies with its frames. 
Write stacks in the project folder?: If Yes, the created stack files will be written in the project folder. By default the movies will be written in the same place where input frames are.
Movie suffix: Suffix added to the output movie filename.Use the extension to select the format (e.g., .mrcs, .stk)
Delete frame files?: Select Yes if you want to remove the individual frame files after creating the movie stack. 
Previous movies to exclude: Select a setOfMovies that are already imported that you want to exclude for this import.

The protocol named "import particles" can be found at the pwem plugin.
Its help description is:
 Protocol to import a set of particles to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: You can import particles directly from the binary files, or import from other packages formats. 
Currently, we can import from: emx, xmipp3, relion, scipion, frealign, eman, cryosparc 
Following are the expected import files for each one:
*emx*: particles.emx
*xmipp3*: images.xmd
*relion*: itXX_data.star
*scipion*: particles.sqlite
*eman*: particleSet.lst
*cryosparc*: particles.cs

Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input EMX file: Select the EMX file containing particles information.
 See more about 
[[http://i2pc.cnb.csic.es/emx][EMX format]]
Alignment Type: Is this a 2D alignment, a 3D alignment or a set of projections
Particles metadata file: Select the particles Xmipp metadata file.
It is usually a images.xmd file result
from Xmipp protocols execution.
Star file: Select a *_data.star file from a
previous Relion execution.To detect if the input particles contains alignment information, it is required to have the optimiser.star file corresponding to the data.star
Ignore ID column?: Set this option to True to regenerate 
the id's of the particles. By default 
it is read from metadata file.        
This option can be useful when merging
different metadatas and id's are not  
longer unique.
Particles sqlite file: Select the particles sqlite file.

For Frealign you need to import both stack and .par files.: None
Stack file: Select an stack file with the particles.
Param file: Select a Frealign .par file with the refinement information.
Lst file: Select a *.lst set file from EMAN2 project.
cs file: Select a .cs file.
It is usually a .cs file result from cryoSPARC job execution.
Have data been phase-flipped?: Set this to Yes if the images have been ctf-phase corrected.
Use the wizard button to import acquisition.: Depending on the import Format, the wizard
will try to import the acquisition values.
If not found, required ones should be provided.
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Pixel size (sampling rate) Å/px: None
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "import atomic structure" can be found at the pwem plugin.
Its help description is:
  Protocol to import an atomic structure  to the project.
Format may be PDB or MMCIF.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import atomic structure from: Import mmCIF data from online server or local file
Atomic structure ID : Type a mmCIF ID (four alphanumeric characters).
File path: Specify a path to desired atomic structure.
Input Volume: Associate this volume to the mmCIF file.

The protocol named "import sequence" can be found at the pwem plugin.
Its help description is:
  Protocol to import an aminoacid/nucleotide sequence file to the
    project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Sequence ID: Write a sequence ID. Otherwise, if the sequence derives from GenBank/UniProt/PDB databases, the respective database ID will be selected as starting sequence ID; examples: if you select GenBank accession AJ520101, SCIPION will assign AJ520101 as sequence ID; if you select UniProt accession P12345, SCIPION will assign P12345 as sequence ID; if you select atomic structure 3lqd.cif, chain B, SCIPION will assign 3lqd_B as sequence ID. In the rest of cases, the Sequence name will be selected as starting Sequence ID.
Sequence name: Write a sequence name.
Sequence description: Write a description for your sequence. Otherwise, if the sequence derives from GenBank/UniProt/PDB databases, the respective database description will be selected as starting sequence description. In the rest of cases, no sequence description will be added.
Import sequence of : Select the type of sequence to import.
From : Select one of the four options: write the aminoacid sequence or import it from a previously loaded atomic structure, a local file or an online server.
IUPAC Protein alphabet: : Your raw sequence will be cleaned according a certain alphabet, i.e., only the letters contained in the alphabet will be maintained in the sequence. Select thus the type of protein alphabet in order to accomplish the cleaning:

Protein alphabet: IUPAC protein alphabet of the 20 standard amino acids; uppercase and single letter: *ACDEFGHIKLMNPQRSTVWY*.

Extended Protein alphabet: Extended uppercase IUPAC protein single letter alphabet including X etc.
In addition to the standard 20 single letter protein codes, this includes:
*B = Asx*; Aspartic acid (R) or Asparagine (N)
*X = Xxx*"; Unknown or other amino acid
*Z = Glx*; Glutamic acid (E) or Glutamine (Q)
*J = Xle*; Leucine (L) or Isoleucine (I), used in mass-spec (NMR)
*U = Sec*; Selenocysteine
*O = Pyl*; Pyrrolysine
This alphabet is not intended to be used with X for Selenocysteine (an ad-hoc standard prior to the IUPAC adoption of U instead).

UniProt name/ID : Write a UniProt ID (six or ten alphanumeric characters; examples: A2BC19, P12345, A0A022YWF9, DGAL_ECOLI).
 You can convert other database identifiers to UniProt accession codes by using the "ID Mapping" tab on https://www.uniprot.org/
From : Select one of the five options: write the nucleic acid sequence or import it from a local file or an online server.
IUPAC Nucleic acid alphabet: : Your raw sequence will be cleaned according a certain alphabet, i.e., only the letters contained in the alphabet will be maintained in the sequence. Select thus the type of nucleic acid alphabet in order to accomplish the cleaning:

 Ambiguous DNA alphabet: Uppercase IUPAC ambiguous DNA: *GATCRYWSMKHBVDN*.

Unambiguous DNA alphabet: Uppercase IUPAC unambiguous DNA (letters *GATC* only).

Extended DNA: Extended IUPAC DNA alphabet.
In addition to the standard letter codes GATC, this includes:
*B* = 5-bromouridine
*D* = 5,6-dihydrouridine
*S* = thiouridine
*W* = wyosine

Ambiguous RNA: Uppercase IUPAC ambiguous RNA; *GAUCRYWSMKHBVDN*

Unambigous RNA alphabet: Generic single letter RNA alphabet.


Write your sequence here:: Write the aminoacid or nucleotide raw sequence.

Atomic structure from: Import structure data from online server or local file
Atomic structure ID : Type a structure ID (four alphanumeric characters).
File path: Specify a path to desired atomic structure.
Chain : Select a particular chain of the atomic structure.
File path: Specify a path to desired aminoacid or nucleic acid sequence file.
If your file contains more than one sequence, only the first one will be considered.
GenBank accession : Write a GenBank accession.


The protocol named "import set of atomic structures" can be found at the pwem plugin.
Its help description is:
  Protocol to import a set of atomic structure  to the project.
    Format may be PDB or MMCIF.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import atomic structures from: Import mmCIF data from online server or local files
Atomic structure IDs : Type a mmCIF ID (four alphanumeric characters, comma-separated)
i.e: 5ni1, 1ake
Files directory path: : Specify a path to the directory where the files are stored.
The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: : Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.

You may create AtomStruct from PDB (.pdb) or CIF/mmCIF (.cif)

The protocol named "import volumes" can be found at the pwem plugin.
Its help description is:
 Protocol to import a set of volumes to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Import 3D map data from EMDB server or local file
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/project/data/day??_files/
Each '?' represents one unknown character

  ~/project/data/day*_files/
'*' represents any number of unknown characters

  ~/project/data/day##_files/
'##' represents two digits that will be used as file ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
EMDB map ID (integer): Type an EMDB ID (Integer). 
Set half maps: Option YES:
Assign two half maps to the imported map.
Path half map1: Select first half map
Path half map2: Select second half map
Pixel size (sampling rate) Å/px: None
Set origin of coordinates: Option YES:
A new volume will be created with the given ORIGIN of coordinates. This ORIGIN will be set in the map file header.
The ORIGIN of coordinates will be placed at the center of the whole volume if you select n(x)/2, n(y)/2, n(z)/2 as x, y, z coordinates (n(x), n(y), n(z) are the dimensions of the whole volume). However, selecting 0, 0, 0 as x, y, z coordinates, the volume will be placed at the upper right-hand corner.

Option NO:
The ORIGIN of coordinates will be placed at the center of the whole volume (coordinates n(x)/2, n(y)/2, n(z)/2 by default). This ORIGIN will NOT be set in the map file header.

WARNING: In case you want to process the volume with programs requiring a specific symmetry regarding the origin of coordinates, for example the protocol extract unit cell, check carefully that the coordinates of the origin preserve the symmetry of the whole volume. This is particularly relevant for loading fragments/subunits of the whole volume.

x: offset along x axis (Angstroms)
y: offset along y axis (Angstroms)
z: offset along z axis (Angstroms)
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Timeout: Duration after which, if no new file is detected, the protocol will end. When finished, the output Set will be closed and no more data will be added to it. 
Note 1:  The default value is  high (12 hours) to avoid the protocol finishing during the acquisition of the microscope. You can also stop it from right click and press STOP_STREAMING.
Note 2: If you're using individual frames when importing movies, the timeout won't be refreshed until a whole movie is stacked.

File timeout: Duration after which, if a file has not changed, we consider it as a new file. 


The protocol named "manual check point" can be found at the pwem plugin.
Its help description is:
 
    This protocol is kept running for a time determined by a parameter or until
    the user determines it is convenient. This protocol is useful if we want a
    given protocol to be launched at the time the user sees appropriate.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Time to wait:: Time in seconds that the protocol will remain running. A correct format is an integer number in seconds or the following syntax: {days}d {hours}h {minutes}m {seconds}s separated by spaces e.g: 1d 2h 20m 15s,  10m 3s, 1h, 20s or 25.

The protocol named "mathematical operator" can be found at the pwem plugin.
Its help description is:
 
    Protocol to make mathematical operations on different inputs
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input X1:: Write the value you want to consider as X1 or if it is a input pointer select from the list of available inputs.
Input X2:: Write the value you want to consider as X2 or if it is a input pointer select from the list of available inputs.
Formula: : Write the mathematical formula you want to calculate, e.g: (X1 + X2) * X1 * 0.9 
Please note that X1 and X2 would be replaced by the value you selected for each case. It is important to use upper cases when writing the expression.
Result type:: Choose the variable type you want your result to be, e.g: Integer

The protocol named "assign gain to movies" can be found at the pwem plugin.
Its help description is:
  Assign a gain image to a set of movies
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
Gain image: Select a gain image. The movie will be corrected as newMovie=Movie/gain

The protocol named "movie eraser" can be found at the pwem plugin.
Its help description is:
  
    Protocol for removing movies based on different conditions:
    - If the input is SetOfMicrographs, it removes movies already aligned into micrographs.
    - If the input is SetOfCoordinates, it removes movies with unselected particles.
    WARNING: There is no way back. Be sure you understand the consequences.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set: Select the SetOfMicrographs or Coordinates to drive the movie DELETION process.
Movies source: Select the SetOfMovies to locate the movie files. Match will be done by ids!.
Dry mode: None

The protocol named "assign Orig & Sampling" can be found at the pwem plugin.
Its help description is:
  Modify the origin and sampling values assigned to a 3D map
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: A new object volume will be created with the assigned sampling rate and origin. No new binary file will be created
Copy volume: Option Yes:
A new volume file will be copied otherwise a link to the input volume is made
NOTE: if the copy option is selected the new sampling/origin is stored in the header. Otherwise this information  is only stored in Scipion's database
Set sampling rate: Option Yes:
A new volume object will be created with the given SamplingRate. This sampling rate will NOT be set in the map file header.


Pixel size (sampling rate) Å/px: None
Set origin: Option Yes:
A new volume object will be created with the given ORIGIN of coordinates. This ORIGIN will NOT be set in the map file header.


x: offset along x axis (Å)
  y: offset along y axis (Å)
  z: offset along z axis (Å)

The protocol named "pdf report" can be found at the pwem plugin.
Its help description is:
  
    Produce a pdf report from the files in a given directory.
    Supported file formats: *.tex, *.txt, *.jpg, *.png, *.pdf
    Files in the directory are sorted by name alphabetically,
    so if you want them to have the right order a possibility is to name them as
    0010-myText.txt
    0020-aFigure.png
    0030-anotherFigure.jpg
    0040-aPaper.pdf
    0050-anotherText.tex
    ...
    when these files are sorted, they will be sorted by the number in front.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Files directory: Directory with the input files. 
Check protocol help for more details.

The protocol named "picking difference" can be found at the pwem plugin.
Its help description is:
 
    Protocol to compute the difference between a reference SetOfParticles and
    a another set (usually a negative reference).

    The output will be a SetOfCoordinates with the particles in the reference
    input that are not close to coordinates in the negative input.

    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the reference set of coordinates.
Negative coordinates: Negative coordinates that will help to exclude coordinates from the input set. 
Radius (px): Distance radius to consider that two coordinates close enough. If a particle in the input referenceset have any close particle in the negative set, it will not be included in the output set. 
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "edit projection" can be found at the pwem plugin.
Its help description is:
 
    This protocol edits the projection directions of all the items of a set of particles using
    a formula. This could be useful for applying geometrical transformation to a set of
    particles.

    Several predefined operation are offered such as
    * apply the rotation matrix define by an origin vector and a target vector
    * rotate the projection vector around a given vector by  A degrees
    * convert between icosahedral symmetries
    * convert between dihedral symmetries
    * convert between tetrahedral symmetries
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set of particles to edit: Set which items will be modified.Must be a set of particles with transformations.
Select operation: Select operation to be performed in the set.
 *rotate to vector* modifies the alignment matrix  so a reconstruction made from the images produces a  rotated reconstruction
 *convert between icosahedral symmetry* will modify  the alignment matrix so the reconstruction will have  the new symmetry provided
 *convert between dihedral symmetry* will modify  the alignment matrix so the reconstruction will have  the new symmetry provided
 *convert between tetrahedral symmetry* will modify  the alignment matrix so the reconstruction will have  the new symmetry provided

x: X Coordinate 
y: Y dim 
z: Z dim 
x: X Coordinate 
y: Y dim 
z: Z dim 
x: X coordinate 
y: Y coordinate 
z: Z coordinate
angle (degrees): rotation angle 
origin: Source symmetry. 
target: Target symmetry. 
origin: Source symmetry. 
target: Target symmetry. 
origin: Source symmetry. 
target: Target symmetry. 
Symmetry: Symmetry type to use.
Order: Order of the symmetry: 6 for C6, ...

The protocol named "data summary" can be found at the pwem plugin.
Its help description is:
  Aggregates any set data based on its fields.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Any set: Set with the dta to be aggregated
Summary operations: Summary operations to apply to all fields in Fields parameter. e.g: MIN MAX AVG. Possible values are MIN, MAX, COUNT, AVG, SUM, TOTAL, GROUP_CONCAT. For more technical information see: https://www.sqlite.org/lang_aggfunc.html
Fields: Fields to apply operations on. Fields can be found in the metadata viewers. The header of the columns are valid names. e.g: _samplingRate id. Fields listed here should support the operations specified: DO NOT add literal fields.
Group by: Fields to make the group. An empty value will summarize the whole dataset.

The protocol named "edit set" can be found at the pwem plugin.
Its help description is:
 
    Protocol to edit attributes of all the items of a set using a formula.
    This could be useful for editing some values in the set. Use this
    protocol with extreme care, you can easily produce a set that is
    not consistent.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set to edit: Set which items will be modified.
Formula: A python code compatible with eval, where item represents each of the elements of the set. E.g.: item._resolution.set(item._resolution.get() +1).You could also use modules like "import numpy;  item._resolution .... "

The protocol named "filter set" can be found at the pwem plugin.
Its help description is:
 
    Protocol to filter sets based on its attributes through an expression that
    should evaluate to true or false. Some predefined expresions are stored (i.e.
    distance to center, distance between coordinates)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set to filter: Set which items will be filtered.
Select operation: Select operation to be performed in the set.
 *distance to center* keep coordinates that are farther from the center than a given value.
 *distance-between-coordinates* if two coordinates 
 are closer than a given value then keep only one. *formula* will apply the formula to the chosen attribute (i.e, resolution less than 2 )
Passing formula: A python code compatible with eval that should evaluate to True or False, where item represents each of the elements of the set. E.g.: item._resolution.get() < 4).You could also use modules like "import numpy;  item._resolution .... "
distance (A): distance from coordinates to center or distance between coordinates 
keep first coordinate: If 2 or more coordinates are closer than distancekeep the first one or delete all
Threshold: : Number/proportion of items to keep:
	Number: n>=1 
	Proportion: 0<n<1
	Percentage: n%

Higher/lower values of the attribute: 
	Higher: positive number
	Lower: negative number

e.g: "-10%" == "-0.1" == 10% of the items with lower values
e.g: "5" == 5 items with higher values
Ranking field: : Attribute to sort the set by.

The protocol named "split sets" can be found at the pwem plugin.
Its help description is:
  Protocol to split a set in two or more subsets.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set: Select the set of elements (images, etc) that you want to split.
Number of subsets: Select how many subsets do you want to create.
Randomize elements: Put the elements at random in the different subsets.

The protocol named "stress" can be found at the pwem plugin.
Its help description is:
  stress  will  stress  test  a  computer system in various selectable
       ways. Several options require the program stress-ng.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
No. CPU stressors: start N workers spinning on sqrt(rand())
No. memory stressors: start N workers continuously calling mmap(2)/munmap(2) and writing to the allocated memory. It will use 100% per worker 
Memory per stressors (Mb): allocate N bytes per vm worker. each stressors will use 100% of a CPU
No IO stressors: start N workers spinning on sync() (Disk io)
TimeOut (sec): timeout after N seconds. Total execution time is timeout plus delay
delay (sec): wait this seconds before stressing the system seconds
Additional parameters: Additional parameters for stress-ng (http://kernel.ubuntu.com/~cking/stress-ng/)

The protocol named "subset" can be found at the pwem plugin.
Its help description is:
     
    Create a set with the elements of an original set that are also
    referenced in another set.
    
    Usually there is a bigger set with all the elements, and a smaller
    one obtained from classification, cleaning, etc. The desired result
    is a set with the elements from the original set that are also present
    somehow in the smaller set (in the smaller set they may be downsampled
    or processed in some other way).
    
    Both sets should be of the same kind (micrographs, particles, volumes)
    or related (micrographs and CTFs for example).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Full set of items: Even if the operation can be applied to two arbitrary sets,
the most common use-case is to retrieve a subset of
elements from an original full set.
*Note*: the elements of the resulting set will be the same
ones as this input set.
Make random subset: Choose elements randomly form the full set.
Number of elements: How many elements will be taken from the full set.
Make a subset from specific IDs: Choose specific elements form the full set.
IDs range or list: Select the IDs that will be the subset.
You have several ways to specify the IDs.
Example: 
"1,3,5-8,17-20" -> [1,3, 5, 6, 7, 8, 17, 18, 19, 20]

Other set: The elements present in this set will be used to pick 
elements from the input full set.     
This means that the output set will contain elements with 
exact the same information of input full set.

Set operation: if _intersection_ is used,
elements that are both in input and other set
will be included. If _difference_, elements that
are in input but not in other will picked.
Set operation: Set operation: if _intersection_ is used,
elements that are both in input and other set
will be included. If _difference_, elements that
are in input but not in other will picked.

The protocol named "particles subset by coordinates" can be found at the pwem plugin.
Its help description is:
 
    Create a subset of those particles that have a particular set of coordinates
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Set of particles from which the subset will be taken
Input coordinates: Only the particles with this set of coordinates will be output
Coordinate tolerance (px): Two coordinates are supposed to be the same if their X and Y distance is smaller or equal this value

The protocol named "particles subset by micrograph" can be found at the pwem plugin.
Its help description is:
 
    Create a subset of those particles that come from a particular set of micrographs
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Set of particles from which the subset will be taken
Input micrographs: Only the particles in this set of micrographs will be output

The protocol named "parallel test" can be found at the pwem plugin.
Its help description is:
  A parallel test protocol.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Number of iterations: Repeat the insertion of steps N times.
Number of parallel sleeps: How many sleep steps can be done at the same time.
Fail after: If you set an id, the next step should fail
Seconds to sleep: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "join sets" can be found at the pwem plugin.
Its help description is:
  Protocol to join two or more sets of images.
    This protocol allows to select two or more set of images
    and will produce another set joining all elements of the 
    selected sets. It will validate that all sets are of the
    same type of elements (Micrographs, Particles or Volumes) 
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input type:: Select the type of objects that you want to union.
Special case All will allow you to select any type.
Input set: Select two or more sets (of micrographs, particles, volumes, etc.) to be united. If you select 3 sets with 100, 200, 200 elements, the final set will contain a total of 500 elements.
Remove duplicates?: By default, duplicated items found (same ID) within the input sets, will cause renumbering of all the items ids in the output set. This is the case for example when doing several imports (which will cause ids overlapping) but we really want to insert as new items in the output. 
On the other hand, items originated in a previous common protocol (above in the workflow) might have identical items and you would like to remove them. Therefore, set this option to *Yes* to remove duplicates and keep only one copy of the item (the first occurrence).
Force new ids: Perform an automatic renumbering of ids to ensure all objects have unique ids. This will mean new objects will not be associated to the old ones.

The protocol named "wait" can be found at the pwem plugin.
Its help description is:
 
    Auxiliary protocol, it just waits "seconds" seconds and then exits
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
wait(seconds): Number of seconds the protocol waits untill it exits.

The protocol named "auto-picking" can be found at the relion plugin.
Its help description is:
  This protocol runs Relion autopicking (version > 3.0).

    This Relion protocol uses the 'relion_autopick' program to pick particles
    from micrographs, either using references (2D averages or 3D volumes)

    The wrapper implementation does not read/write any FOM maps compared to Relion
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: Select the input micrographs. If using the *Optimize* mode, just a subset of micrographs are used to compute the FOM maps. If in *Compute* mode, all micrographs will be auto-picked.
CTF estimation: Choose some CTF estimation related to the input micrographs.
References: The preferred way to autopick is by providing 2D references images that were obtained by 2D classification. 
The Gaussian blob references may be useful to kickstart a new data set.
Input references: Input references (SetOfAverages) for auto-pick. 

Note that the absolute greyscale needs to be correct, 
so only use images with proper normalization.
Input references: Input volume from which 2D references will be made by projection. Note that the absolute greyscale needs to be correct, so only use maps created by RELION itself from this data set.
Symmetry: Symmetry point group of the 3D reference. Only projections in the asymmetric part of the sphere will be generated.
3D angular sampling (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
For autopicking, 30 degrees is usually fine enough, but for highly symmetrical objects one may need to go finer to adequately sample the asymmetric part of the sphere.
Lowpass filter references (A): Lowpass filter that will be applied to the references before template matching. 
Do NOT use very high-resolution templates to search your micrographs. 
The signal will be too weak at high resolution anyway, and you may find Einstein from noise...
Highpass filter (A): Highpass filter that will be applied to the micrographs. This may be useful to get rid of background ramps due to uneven ice distributions. Give a negative value to skip the highpass filter.  Useful values are often in the range of 200-400 Angstroms.
Angular sampling (deg): Angular sampling in degrees for exhaustive searches of the in-plane rotations for all references.
References have inverted contrast?: Set to Yes to indicate that the reference have inverted contrast with respect to the particles in the micrographs.
Are References CTF corrected?: Set to Yes if the references were created with CTF-correction inside RELION.
If set to Yes, the input micrographs should contain the CTF information.
Ignore CTFs until first peak?: Set this to Yes, only if this option was also used to generate the references.
Picking threshold:: Use lower thresholds to pick more particles (and more junk probably)
Minimum inter-particle distance (A):: Particles closer together than this distance 
will be consider to be a single cluster. 
From each cluster, only one particle will be picked.
Maximum stddev noise:: This is useful to prevent picking in carbon areas, or areas with big contamination features. Peaks in areas where the background standard deviation in the normalized micrographs is higher than this value will be ignored. Useful values are probably in the range 1.0 to 1.2. Set to -1 to switch off the feature to eliminate peaks due to high background standard deviations.
Minimum avg noise:: This is useful to prevent picking in carbon areas, or areas with big contamination features. Peaks in areas where the background standard deviation in the normalized micrographs is higher than this value will be ignored. Useful values are probably in the range -0.5 to 0. Set to -999 to switch off the feature to eliminate peaks due to low average background densities.
Shrink factor: This is useful to speed up the calculations, and to make them less memory-intensive. The micrographs will be downscaled (shrunk) to calculate the cross-correlations, and peak searching will be done in the downscaled FOM maps. When set to 0, the micrographs will de downscaled to the lowpass filter of the references, a value between 0 and 1 will downscale the micrographs by that factor. Note that the results will not be exactly the same when you shrink micrographs!
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Additional arguments:: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "relion_autopick" will print a list of possible options.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "assign optics groups" can be found at the relion plugin.
Its help description is:
  Assign Optics Group name and related parameters to an input set.
     Input set can be: movies, micrographs or particles.

     Warning: all optics parameters from the input set itself are removed!
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set: Select the input set (Movies, Micrographs or Particles) to assign Optics Group parameters.
Input Optics Groups from: Select how to provide information about the optics groups. In the case of single group provide the parameters below, otherwise you need to provide a star file.
Optics group name: Relion-specific option. Name of this optics group. Each group of movies with different optics characteristics for CTF refinement should have a unique name.
MTF-curve file: User-provided STAR-file with the MTF-curve of the detector. Use the wizard to load one of the predefined ones provided at:
- [[https://www3.mrc-lmb.cam.ac.uk/relion/index.php/FAQs#Where_can_I_find_MTF_curves_for_typical_detectors.3F][Relion's Wiki FAQs]]
 - [[https://www.gatan.com/techniques/cryo-em#MTF][Gatan's website]]

Relion param: *--mtf*
X: None
Y: None
Gain reference: A gain reference file is required for gain correction
Gain rotation: Rotate the gain reference by this number times 90 degrees clockwise in relion_display. This is the same as -RotGain in MotionCor2. 
Note that MotionCor2 uses a different convention for rotation so it says 'counter-clockwise'.
Gain flip: Flip the gain reference after rotation. This is the same as -FlipGain in MotionCor2. 0 means do nothing, 1 means flip Y (upside down) and 2 means flip X (left to right).
Defects file: Location of a UCSF MotionCor2-style defect text file or a defect map that describe the defect pixels on the detector. Each line of a defect text file should contain four numbers specifying x, y, width and height of a defect region. A defect map is an image (MRC or TIFF), where 0 means good and 1 means bad pixels. The coordinate system is the same as the input movie before application of binning, rotation and/or flipping.

_Note that the format of the defect text is DIFFERENT from the defect text produced by SerialEM!_
 One can convert a SerialEM-style defect file into a defect map using IMOD utilities e.g.:
*clip defect -D defect.txt -f tif movie.tif defect_map.tif*
See explanations in the SerialEM manual.
Leave empty if you do not have any defects, or do not want to correct for defects on your detector.
Input Star file with optics groups: Provide input star file with Optics groups information. The input Star file should contain: 
- *data_optics* table with values for each group.
- *data_micrographs* table with two columns: 

	rlnMicrographName with the micName associated to the input set.
	rlnOpticsGroup with the group number associated to this micrograph.

If you provide rlnMicrographGainName in the optics table, it has to point to a transformed gain reference (rotated and flipped if necessary).

The protocol named "auto-picking LoG" can be found at the relion plugin.
Its help description is:
 
    This Relion protocol uses 'relion_autopick' program for the
    Laplacian of Gaussian (LoG) option.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: Select the input micrographs. If using the *Optimize* mode, just a subset of micrographs are used to compute the FOM maps. If in *Compute* mode, all micrographs will be auto-picked.
Box size (px): Box size in pixels.
Min diameter (A): None
Max diameter (A): None
Are the particles white?: Set this option to No if the particles are black, and to Yes if the particles are white.
Maximum resolution to consider (A): The Laplacian-of-Gaussian filter will be applied to downscaled micrographs with the corresponding size. Give a negative value to skip downscaling.
Adjust default threshold (stddev): Use this to pick more (negative number -> lower threshold) or less (positive number -> higher threshold) particles compared to the default setting.
Upper threshold (stddev): Use this to discard picks with LoG thresholds that are this many standard deviations above the average, e.g. to avoid high contrast contamination like ice and ethane droplets. Good values depend on the contrast of micrographs and need to be interactively explored; for low contrast micrographs, values of ~ 1.5 may be reasonable, but the same value will be too low for high-contrast micrographs.
Additional arguments:: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "relion_autopick" will print a list of possible options.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "bayesian polishing" can be found at the relion plugin.
Its help description is:
 
    Wrapper protocol for the Relion's Bayesian Polishing.

    As of release 3.0, Relion also implements a new Bayesian approach to beam
    induced motion correction. This approach aims to optimise a regularised
    likelihood, which allows us to associate with each hypothetical set of
    particle trajectories a prior likelihood that favors spatially coherent
    and temporally smooth motion without imposing any hard constraints.
    The smoothness prior term requires three parameters that describe the
    statistics of the observed motion. To estimate the prior that yields the
    best motion tracks for this particular dataset, we can first run the
    program in 'training mode'. Once the estimates have been obtained, one
    can then run the program again to fit tracks for the motion of all
    particles in the data set and to produce adequately weighted averages of
    the aligned movie frames.

    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input ALIGNED movies: Provide a set of movies that have at least global alignment information.
Input particles: Provide a set of particles from 3D auto-refine or CTF refinement.
Input Postprocess: Select a PostProcess job. The mask used for this postprocessing will be applied to the unfiltered half-maps and should encompass the entire complex. The resulting FSC curve will be used for weighting the different frequencies.
first: None
last: None
Extraction size (px in unbinned movie): Size of the extracted particles in the unbinned original movie (in pixels). This should be an even number.
Re-scaled size (px): The re-scaled value needs to be an even number.
Write output in float16?: Relion can write output images in float16 MRC (mode 12) format to save disk space. By default, float32 format is used.
Operation: If *train optimal parameters* , then relion_motion_refine will estimate optimal parameter values for the three sigma values above on a subset of the data (determined by the minimum number of particles to be used below).

If *perform particle polishing* then relion_motion_refine will be run to estimate per-particle motion-tracks using the parameters below, and polished particles will be generated. 
Fraction of Fourier pixels for testing: This fraction of Fourier pixels (at higher resolution) will be used for evaluation of the parameters (test set), whereas the rest (at lower resolution) will be used for parameter estimation itself (work set).
Use this many particles: Use at least this many particles for the meta-parameter optimisation. The more particles the more expensive in time and computer memory the calculation becomes, but the better the results may get.
Sigma for velocity (A/dose): Standard deviation for the velocity regularisation. Smaller values requires the tracks to be shorter.
Sigma for divergence (A): Standard deviation for the divergence of tracks across the micrograph. Smaller values requires the tracks to be spatially more uniform in a micrograph.
Sigma for acceleration (A/dose): Standard deviation for the acceleration regularisation. Smaller values requires the tracks to be straighter.
min: None
max: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "calculate fsc" can be found at the relion plugin.
Its help description is:
 
    Relion protocol to calculate various FSC curves using relion_image_handler.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Select FSC type to compute: 1) FSC overall - between two half-maps
2) FSC model-map - between atomic model and refined map
3) FSC work - model refined against half-map 1, compared to half-map 1
FSC free - model refined against half-map 1, compared to half-map 2
Input half map 1: None
Input half map 2: None
Final map: None
Final atomic model: None
Atomic model refined against half-map 1: None
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "center averages" can be found at the relion plugin.
Its help description is:
 
    Align class averages by their center of mass using *relion_image_handler*.
     (With *--shift_com* option)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input averages: Select the input averages to be centered.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "2D classification" can be found at the relion plugin.
Its help description is:
  This protocol runs Relion 2D classification..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: None
: None
Continue from a previous run?: If you set to *Yes*, you should select a previousrun of type *ProtRelionClassify2D* class and most of the input parameterswill be taken from it.
Input particles: Select the input images from the project.
Consider previous alignment?: If set to Yes, then alignment information from input particles will be considered.
Consider alignment as priors?: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
: None
Particle mask diameter (A): The experimental images will be masked with a soft circular mask with this <diameter>. Make sure this diameter is not set too small because that may mask away part of the signal! If set to a value larger than the image size no masking will be performed.

The same diameter will also be used for a spherical mask of the reference structures if no user-provided mask is specified.
Mask particles with zeros?: If set to <Yes>, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform. This will remove noise and therefore increase sensitivity in the alignment and classification. However, it will also introduce correlations between the Fourier components that are not modelled. When set to <No>, then the solvent area is filled with random noise, which prevents introducing correlations.High-resolution refinements (e.g. in 3D auto-refine) tend to work better when filling the solvent area with random noise, some classifications go better when using zeros.
Select previous run: Select a previous run to continue from.
Continue from iteration: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
Reference averages: This option is not recommended and should be used with care. The provided averages will be used as initial 2D references. If this option is used, the number of classes will be ignored. 
Reference mask (optional): User-provided mask for the references (default is to use spherical mask with particle_diameter)
CTF parameters are not available in continue mode: None
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Have data been phase-flipped?      (Don't answer, see help): The phase-flip status is recorded and managed by Scipion. 
 In other words, when you import or extract particles, 
Scipion will record whether or not phase flipping has been done.

Note that CTF-phase flipping is NOT a necessary pre-processing step 
for MAP-refinement in RELION, as this can be done inside the internal
CTF-correction. However, if the phases have been flipped, the program will handle it.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Do manual grouping ctfs?: Set this to Yes the CTFs will grouping manually.
Defocus range for group creation (in Angstroms): Particles will be grouped by defocus.This parameter is the bin for a histogram.All particles assigned to a bin form a group
minimum size for defocus group: If defocus group is smaller than this value, it will be expanded until number of particles per defocus group is reached
Number of classes:: The number of classes (K) for a multi-reference refinement. These classes will be made in an unsupervised manner from a single reference by division of the data into random subsets during the first iteration.
Regularisation parameter T: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D refinements, values of 1-2 for 2D refinements. Too small values yield too-low resolution structures; too high values result in over-estimated resolutions and overfitting.
Use VDAM algorithm?: If set to Yes, the faster VDAM algorithm will be used. This algorithm was introduced with Relion-4.0. If set to No, then the slower EM algorithm needs to be used.
Number of VDAM mini-batches: Number of mini-batches to be processed using the VDAM algorithm. Using 200 has given good results for many data sets. Using 100 will run faster, at the expense of some quality in the results.
Center class averages?: If set to Yes, every iteration the class average images will be centered on their center-of-mass. This will work only for positive signals, so the particles should be white.
Number of iterations: Number of iterations to be performed. Note that the current implementation does NOT comprise a convergence criterium. Therefore, the calculations will need to be stopped by the user if further iterations do not yield improvements in resolution or classes. If continue option is True, you going to do this number of new iterations (e.g. if *Continue from iteration* is set 3 and this param is set 25, the final iteration of the protocol will be the 28th.
Limit resolution E-step to (A): If set to a positive number, then the expectation step (i.e. the alignment) will be done only including the Fourier components up to this resolution (in Angstroms). This is useful to prevent overfitting, as the classification runs in RELION are not to be guaranteed to be 100% overfitting-free (unlike the _3D auto-refine_ with its gold-standard FSC). In particular for very difficult data sets, e.g. of very small or featureless particles, this has been shown to give much better class averages. In such cases, values in the range of 7-12 Angstroms have proven useful.
Perform image alignment?: If set to No, then rather than performing both alignment and classification, only classification will be performed. This allows the use of very focused masks. This requires that the optimal orientations of all particles are already calculated.
In-plane angular sampling (deg): The sampling rate for the in-plane rotation angle (psi) in degrees.
Using fine values will slow down the program. Recommended value for
most 2D refinements: 5 degrees. 

If auto-sampling is used, this will be the value for the first 
iteration(s) only, and the sampling rate will be increased 
automatically after that.
Initial offset range (pix): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
Initial offset step (pix): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid.
Allow coarser sampling?: If set to Yes, the program will use coarser angular and translational samplings if the estimated accuracies of the assignments is still low in the earlier iterations. This may speed up the calculations.
Use parallel disc I/O?: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
Number of pooled particles:: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Pre-read all particles into RAM?: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
Copy particles to scratch directory: : If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
Combine iterations through disc?: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Over-sampling: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--dont_combine_weights_via_disc
--verb 1
--pad 2

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "3D classification" can be found at the relion plugin.
Its help description is:
 
    Protocol to classify 3D using Relion Bayesian approach.
    Relion employs an empirical Bayesian approach to refinement of (multiple)
    3D reconstructions or 2D class averages in electron cryo-EM. Many
    parameters of a statistical model are learned from the data, which
    leads to objective and high-quality results.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: None
: None
Continue from a previous run?: If you set to *Yes*, you should select a previousrun of type *ProtRelionClassify3D* class and most of the input parameterswill be taken from it.
Input particles: Select the input images from the project.
Consider previous alignment?: If set to Yes, then alignment information from input particles will be considered.
Consider alignment as priors?: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
: None
Particle mask diameter (A): The experimental images will be masked with a soft circular mask with this <diameter>. Make sure this diameter is not set too small because that may mask away part of the signal! If set to a value larger than the image size no masking will be performed.

The same diameter will also be used for a spherical mask of the reference structures if no user-provided mask is specified.
Mask particles with zeros?: If set to <Yes>, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform. This will remove noise and therefore increase sensitivity in the alignment and classification. However, it will also introduce correlations between the Fourier components that are not modelled. When set to <No>, then the solvent area is filled with random noise, which prevents introducing correlations.High-resolution refinements (e.g. in 3D auto-refine) tend to work better when filling the solvent area with random noise, some classifications go better when using zeros.
Select previous run: Select a previous run to continue from.
Continue from iteration: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
Reference averages: This option is not recommended and should be used with care. The provided averages will be used as initial 2D references. If this option is used, the number of classes will be ignored. 
Input volume(s): Initial reference 3D map, it should have the same dimensions and the same pixel size as your input particles.
Reference mask (optional): A volume mask containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask. If no mask is given, a soft spherical mask based on the <radius> of the mask for the experimental images will be applied.

In some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. Check _Advaced_ level and select another volume mask
Second reference mask (optional): For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas.
Use solvent-flattened FSCs?: If set to Yes, then instead of using unmasked maps to calculate the gold-standard FSCs during refinement, masked half-maps are used and a post-processing-like correction of the FSC curves (with phase-randomisation) is performed every iteration. This only works when a reference mask is provided on the I/O tab. This may yield higher-resolution maps, especially when the mask contains only a relatively small volume inside the box.
Is initial 3D map on absolute greyscale?: The probabilities are based on squared differences, so that the absolute grey scale is important. 
Probabilities are calculated based on a Gaussian noise model, which contains a squared difference term between the reference and the experimental image. This has a consequence that the reference needs to be on the same absolute intensity grey-scale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity grey-scale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. Therefore: if the map was reconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No. If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent MAP refinement. Therefore, if in doubt it is recommended to set this option to No.
Symmetry: See [[https://relion.readthedocs.io/en/latest/Reference/Conventions.html#symmetry][Relion Symmetry]] page for a description of the symmetry format accepted by Relion
Initial low-pass filter (A): It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s).
CTF parameters are not available in continue mode: None
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Have data been phase-flipped?      (Don't answer, see help): The phase-flip status is recorded and managed by Scipion. 
 In other words, when you import or extract particles, 
Scipion will record whether or not phase flipping has been done.

Note that CTF-phase flipping is NOT a necessary pre-processing step 
for MAP-refinement in RELION, as this can be done inside the internal
CTF-correction. However, if the phases have been flipped, the program will handle it.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Do manual grouping ctfs?: Set this to Yes the CTFs will grouping manually.
Defocus range for group creation (in Angstroms): Particles will be grouped by defocus.This parameter is the bin for a histogram.All particles assigned to a bin form a group
minimum size for defocus group: If defocus group is smaller than this value, it will be expanded until number of particles per defocus group is reached
Number of classes:: The number of classes (K) for a multi-reference refinement. These classes will be made in an unsupervised manner from a single reference by division of the data into random subsets during the first iteration.
Regularisation parameter T: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D refinements, values of 1-2 for 2D refinements. Too small values yield too-low resolution structures; too high values result in over-estimated resolutions and overfitting.
Number of iterations: Number of iterations to be performed. Note that the current implementation does NOT comprise a convergence criterium. Therefore, the calculations will need to be stopped by the user if further iterations do not yield improvements in resolution or classes. If continue option is True, you going to do this number of new iterations (e.g. if *Continue from iteration* is set 3 and this param is set 25, the final iteration of the protocol will be the 28th.
Use fast subsets (for large data sets)?: If set to Yes, the first 5 iterations will be done with random subsets of only K*100 particles (K being the number of classes); the next 5 with K*300 particles, the next 5 with 30% of the data set; and the final ones with all data. This was inspired by a cisTEM implementation by Niko Grigorieff et al.
Use Blush regularisation?: If set to Yes, relion_refine will use a neural network to perform regularisation by denoising at every iteration, instead of the standard smoothness regularisation.
Limit resolution E-step to (A): If set to a positive number, then the expectation step (i.e. the alignment) will be done only including the Fourier components up to this resolution (in Angstroms). This is useful to prevent overfitting, as the classification runs in RELION are not to be guaranteed to be 100% overfitting-free (unlike the _3D auto-refine_ with its gold-standard FSC). In particular for very difficult data sets, e.g. of very small or featureless particles, this has been shown to give much better class averages. In such cases, values in the range of 7-12 Angstroms have proven useful.
Perform image alignment?: If set to No, then rather than performing both alignment and classification, only classification will be performed. This allows the use of very focused masks. This requires that the optimal orientations of all particles are already calculated.
Initial angular sampling (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
Initial offset range (pix): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
Initial offset step (pix): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid.
Perform local angular search?: If set to Yes, then rather than performing exhaustive angular searches, local searches within the range given below will be performed. A prior Gaussian distribution centered at the optimal orientation in the previous iteration and with a stddev of 1/3 of the range given below will be enforced.
Local angular search range: Local angular searches will be performed within +/- the given amount (in degrees) from the optimal orientation in the previous iteration. A Gaussian prior (also see previous option) will be applied, so that orientations closer to the optimal orientation in the previous iteration will get higher weights than those further away.
Relax symmetry: With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020.
Allow coarser sampling?: If set to Yes, the program will use coarser angular and translational samplings if the estimated accuracies of the assignments is still low in the earlier iterations. This may speed up the calculations.
Use parallel disc I/O?: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
Number of pooled particles:: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Skip padding: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
Pre-read all particles into RAM?: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
Copy particles to scratch directory: : If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
Combine iterations through disc?: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Over-sampling: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--dont_combine_weights_via_disc
--verb 1
--pad 2

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "clean project" can be found at the relion plugin.
Its help description is:
 
    Run Relion gentle clean procedure for the whole project.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Gentle clean procedure will move all intermediate files from finished Relion protocols to Trash folder. For iteration-based jobs, only the last iteration files are kept.: None

The protocol named "estimate gain reference" can be found at the relion plugin.
Its help description is:
 
    Using *relion_convert_to_tiff* to estimate the gain reference from a set of movies.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of movies to be used in the gain estimation.
Subset: Use a subset of the movies for the estimation. If 0, all input movies will be used. 
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "compress movies" can be found at the relion plugin.
Its help description is:
 
    Using *relion_convert_to_tiff* to compress a set of movies.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
Input gain estimation protocol (optional): Provide an estimate gain reference protocol from where the gain file will be taken.
Compression type: None
Deflate level: deflate level. 1 (fast) to 9 (slowest but best compression)
EER fractionation: The number of hardware frames to group into one fraction. This option is relevant only for Falcon4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
EER upsampling: EER upsampling (1 = 4K or 2 = 8K). 8K rendering is not recommended by Relion. See https://relion.readthedocs.io/en/latest/Reference/MovieCompression.html
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "create 3d mask" can be found at the relion plugin.
Its help description is:
  This protocols creates a 3D mask using Relion.
    The mask is created from a 3d volume or by comparing two input volumes.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: Select the volume that will be used to create the mask
Lowpass filter map by (A): Lowpass filter that will be applied to the input map, prior to binarization. To calculate solvent masks, a lowpass filter of 15-20A may work well.
Initial binarisation threshold: This threshold is used to make an initial binary mask from the average of the two unfiltered half-reconstructions. If you don't know what value to use, display one of the unfiltered half-maps in a 3D surface rendering viewer and find the lowest threshold that gives no noise peaks outside the reconstruction.
Compare with another volume to produce a mask?: Logical comparison of two input volumes to produce a mask
Input volume (second): Select the volume that will be compared to the first one
Operation: *AND*: Pixels in the initial mask will be one if the input AND the second volume are above the threshold value.
*OR*: Pixels in the initial mask will be one if the input OR the second volume are above the threshold value.
*AND_NOT*: pixels in the initial mask will be one if the input is above the threshold AND the second volume is below it.
*OR_NOT*: pixels in the initial mask will be one if the input is above the threshold OR the second volume is below it.
Extend binary mask by (px): The initial binary mask is extended this number of pixels in all directions.
Add a soft-edge (px): The extended binary mask is further extended with a raised-cosine soft edge of the specified width.
Invert final mask: Invert the final mask
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "ctf refinement" can be found at the relion plugin.
Its help description is:
  Wrapper protocol for the Relion's CTF refinement. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Provide a set of particles for local CTF refinement.
Input Postprocess: Select a PostProcess job. The mask used for this postprocessing will be applied to the unfiltered half-maps and should encompass the entire complex. The resulting FSC curve will be used for weighting the different frequencies.

Note that for helices it is common practice to use a mask only encompassing the central 30% or so of the box. This gives higher resolution estimates, as it disregards ill-defined regions near the box edges. However, for ctf_refine it is better to use a mask encompassing (almost) the entire box, as otherwise there may not be enough signal. 
Estimate (anisotropic) magnification?: If set to Yes, then relion_ctf_refine will also estimate the (anisotropic) magnification per optics group. This option cannot be done simultaneously with higher-order aberration estimation. It's probably best to estimate the one that is most off first, and the other one second. It might be worth repeating the estimation if both are off.
Perform CTF parameter fitting?: If set to Yes, then relion_ctf_refine will be used to estimate the selected parameters below.
Fit defocus?: If set to per-particle or per-micrograph, then relion_ctf_refine will estimate a defocus values.
Fit astigmatism? : If set to per-particle or per-micrograph, then relion_ctf_refine will estimate astigmatism.
Fit B-factor?: If set to per-particle or per-micrograph, then relion_ctf_refine will estimate B-factors that describe the signal falloff.
Fit phase-shift? : If set to per-particle or per-micrograph, then relion_ctf_refine will estimate astigmatism.
Estimate beamtilt?: If set to Yes, then relion_ctf_refine will also estimate the beamtilt per optics group. This option is only recommended for data sets that extend beyond 4.5 Angstrom resolution.
Also estimate trefoil?: If set to Yes, then relion_ctf_refine will also estimate the trefoil (3-fold astigmatism) per optics group. This option is only recommended for data sets that extend beyond 3.5 Angstrom resolution.
Estimate 4th order aberrations?: If set to Yes, then relion_ctf_refine will also estimate the Cs and the tetrafoil (4-fold astigmatism) per optics group. This option is only recommended for data sets that extend beyond 3 Angstrom resolution.
Minimum resolution for fits (A): The minimum spatial frequency (in Angstrom) used in the beam tilt fit.
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "expand symmetry" can be found at the relion plugin.
Its help description is:
  This protocols wraps relion_particle_symmetry_expand program.

    Given an input set of particles with angular assignment,
    expand the set by applying a pseudo-symmetry.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
Symmetry group: See [[https://relion.readthedocs.io/en/latest/Reference/Conventions.html#symmetry][Relion Symmetry]] page for a description of the symmetry format accepted by Relion
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "export coordinates" can be found at the relion plugin.
Its help description is:
  Export coordinates from Relion to be used outside Scipion. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the SetOfCoordinates 

The protocol named "export ctf" can be found at the relion plugin.
Its help description is:
  Export a SetOfCTF to a Relion STAR file. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input CTF: Select set of CTF that you want to export.
Micrographs source: By default the micrograph used to create theexported STAR files are those used for the CTF estimation. You can selected *other* to use a different set of micrographs (e.g., dose weighted)
Input micrographs: Select the SetOfMicrographs from which to extract.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "export particles" can be found at the relion plugin.
Its help description is:
  Export particles from Relion to be used outside Scipion. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input images from the project.
Write alignment information?: If *Yes* the alignment information (2D or 3D) will be written to the resulting .star file if the particles contains such information.
Binary stack files: If *Don't write stacks* is chosen, only the star files will be written out. Alternatively, you can select to write images into a single stack file or several stacks (one per micrograph). 

The protocol named "particles extraction" can be found at the relion plugin.
Its help description is:
  Protocol to extract particles using a set of coordinates. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the SetOfCoordinates 
Micrographs source: By default the particles will be extracted from the micrographs used in the picking step ( _same as picking_ option ). 
If you select _other_ option, you must provide a different set of micrographs to extract from. 
*Note*: In the _other_ case, ensure that provided micrographs and coordinates are related by micName or by micId. Difference in pixel size will be handled automatically.
Input micrographs: Select the SetOfMicrographs from which to extract.
CTF estimation: Choose some CTF estimation related to input micrographs. 
 CTF estimation is needed if you want to do phase flipping or you want to associate CTF information to the particles.
Particle box size (px): This is size of the boxed particles (in pixels).
Rescale particles?: If set to Yes, particles will be re-scaled. Note that the re-scaled size below will be in the down-scaled images.
Re-scaled size (px): Final size in pixels of the extracted particles. The provided value should be an even number. 
Write output in float16?: Relion can write output images in float16 MRC (mode 12) format to save disk space. By default, float32 format is used.
Invert contrast?: Invert the contrast if your particles are black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background. Frealign (up to v9.07) requires black particles over a white background
Normalize particles?: If set to Yes, particles will be normalized in the way RELION prefers it.
Diameter background circle before scaling (px): Particles will be normalized to a mean value of zero and a standard-deviation of one for all pixels in the background area. The background area is defined as all pixels outside a circle with this given diameter in pixels (before rescaling). When specifying a negative value, a default value of 75% of the Particle box size will be used.
Stddev for white dust removal: : Remove very white pixels from the extracted particles. Pixels values higher than this many times the image stddev will be replaced with values from a Gaussian distribution. 
Use negative value to switch off dust removal.
Stddev for black dust removal: : Remove very black pixels from the extracted particles. Pixels values higher than this many times the image stddev will be replaced with values from a Gaussian distribution. 
Use negative value to switch off dust removal.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "import coordinates" can be found at the relion plugin.
Its help description is:
 
    Import coordinates from a particles star file.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input STAR file path with coordinates: None
Input micrographs: Select the micrographs for which you want to import coordinates.
Box size: None
Scale: Factor to scale coordinates
Invert X: None
Invert Y: Invert Y for EMAN coordinates taken on dm3 or tif micrographs

The protocol named "3D initial model" can be found at the relion plugin.
Its help description is:
  This protocols creates a 3D initial model using Relion.

    Generate a 3D initial model _de novo_ from 2D particles using
    Relion Stochastic Gradient Descent (SGD) algorithm.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Continue from a previous run?: If you set to *Yes*, you should select a previousrun of type *ProtRelionInitialModel* class and most of the input parameters will be taken from it.
Input particles: Select the input images from the project.
Particle mask diameter (A): The experimental images will be masked with a soft circular mask with this <diameter>. Make sure this diameter is not set too small because that may mask away part of the signal! If set to a value larger than the image size no masking will be performed.

The same diameter will also be used for a spherical mask of the reference structures if no user-provided mask is specified.
Select previous run: Select a previous run to continue from.
Continue from iteration: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
CTF parameters are not available in continue mode: None
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Have data been phase-flipped?      (Don't answer, see help): The phase-flip status is recorded and managed by Scipion. 
 In other words, when you import or extract particles, 
Scipion will record whether or not phase flipping has been done.

Note that CTF-phase flipping is NOT a necessary pre-processing step 
for MAP-refinement in RELION, as this can be done inside the internal
CTF-correction. However, if the phases have been flipped, the program will handle it.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Do manual grouping ctfs?: Set this to Yes the CTFs will grouping manually.
Defocus range for group creation (in Angstroms): Particles will be grouped by defocus.This parameter is the bin for a histogram.All particles assigned to a bin form a group
minimum size for defocus group: If defocus group is smaller than this value, it will be expanded until number of particles per defocus group is reached
Number of VDAM mini-batches: How many iterations (i.e. mini-batches) to perform with the VDAM algorithm?
Regularisation parameter T: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D initial model calculations.
Number of classes: The number of classes (K) for a multi-reference ab initio SGD refinement. These classes will be made in an unsupervised manner, starting from a single reference in the initial iterations of the SGD, and the references will become increasingly dissimilar during the in between iterations.
Flatten and enforce non-negative solvent?: If set to Yes, the job will apply a spherical mask and enforce all values in the reference to be non-negative.
Symmetry: The initial model is always generated in C1 and then aligned to and symmetrized with the specified point group. If the automatic alignment fails, please manually rotate run_itNNN_class001.mrc (NNN is the number of iterations) so that it conforms the symmetry convention.
Run in C1 and apply symmetry later?: If set to Yes, the gradient-driven optimisation is run in C1 and the symmetry orientation is searched and applied later. If set to No, the entire optimisation is run in the symmetry point group indicated above.
Use parallel disc I/O?: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
Number of pooled particles:: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Pre-read all particles into RAM?: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
Copy particles to scratch directory: : If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
Combine iterations through disc?: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--dont_combine_weights_via_disc
--verb 1
--pad 2

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "local resolution" can be found at the relion plugin.
Its help description is:
  This protocol does local resolution estimation using Relion.

    This program basically performs a series of post-processing operations
    with a small soft, spherical mask that is moved over the entire map,
    while using phase-randomisation to estimate the convolution effects
    of that mask.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Select a previous refinement protocol: Select any previous refinement protocol to get the 3D half maps. Note that it is recommended that the refinement protocol uses a gold-standard method.
User-provided solvent mask: Provide a mask with values between 0 and 1 around all domains of the complex. ResMap uses this mask for local resolution calculation. RELION does NOT use this mask for calculation, but makes a histogram of local resolution within this mask.
Calibrated pixel size (A): Provide the final, calibrated pixel size in Angstroms. If 0, the input pixel size will be used. This value may be different from the pixel-size used thus far, e.g. when you have recalibrated the pixel size using the fit to a PDB model. The X-axis of the output FSC plot will use this calibrated value.
Provide B-factor:: Probably, the overall B-factor as was estimated in the postprocess is a useful value for here. Use negative values for sharpening. Be careful: if you over-sharpen your map, you may end up interpreting noise for signal!
MTF of the detector: User-provided STAR-file with the MTF-curve of the detector.Relion param: <--mtf>
Original detector pixel size (A): This is the original pixel size (in Angstroms) in the raw (non-super-resolution!) micrographs
Select Advanced level if you want to adjust the parameters: None
Sampling rate (A): Sampling rate (in Angstroms) with which to sample the local-resolution map
Mask radius (A): Radius (in A) of spherical mask for local-resolution map (default = 0.5*sampling)
Edge width (A): Width of soft edge (in A) on masks for local-resolution map (default = sampling)
Randomize phases from (A): Randomize phases from this resolution (in A)
Lowest res limit (A): Lowest local resolution allowed (in A)
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "motion correction" can be found at the relion plugin.
Its help description is:
  Wrapper for the Relion's implementation of motioncor algorithm. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
from: None
to: None
Do dose-weighting?: If set to Yes, the averaged micrographs will be dose-weighted.
Save non-dose weighted as well?: Aligned but non-dose weighted images are sometimes useful in CTF estimation, although there is no difference in most cases. Whichever the choice, CTF refinement job is always done on dose-weighted particles.
Save sum of power spectra?: Sum of non-dose weighted power spectra provides better signal for CTF estimation. The power spectra can be used by CTFFIND4 but not by GCTF.
Sum power spectra every e/A2: McMullan et al. (Ultramicroscopy, 2015) suggests summing power spectra every 4.0 e/A2 gives optimal Thon rings.
Write output in float16?: Relion can write output images in float16 MRC (mode 12) format to save disk space. By default, float32 format is used.
Compute PSD?: If Yes, the protocol will compute for each aligned micrograph the PSD using EMAN2.
Compute micrograph thumbnail?: When using this option, we will compute a micrograph thumbnail with EMAN2 and keep it with the micrograph object for visualization purposes.
Additional arguments: Extra parameters for Relion motion correction. 
Bfactor: The B-factor that will be applied to the micrographs.
X: None
Y: None
Group frames: Average together this many frames before calculating the beam-induced shifts.
Binning factor: Bin the micrographs this much by a windowing operation in the Fourier Transform. Binning at this level is hard to un-do later on, but may be useful to down-scale super-resolution images. Float-values may be used. Do make sure though that the resulting micrograph size is even.
Gain rotation: Rotate the gain reference by this number times 90 degrees clockwise in relion_display. This is the same as -RotGain in MotionCor2. 
Note that MotionCor2 uses a different convention for rotation so it says 'counter-clockwise'.
Gain flip: Flip the gain reference after rotation. This is the same as -FlipGain in MotionCor2. 0 means do nothing, 1 means flip Y (upside down) and 2 means flip X (left to right).
Defects file: Location of a UCSF MotionCor2-style defect text file or a defect map that describe the defect pixels on the detector. Each line of a defect text file should contain four numbers specifying x, y, width and height of a defect region. A defect map is an image (MRC or TIFF), where 0 means good and 1 means bad pixels. The coordinate system is the same as the input movie before application of binning, rotation and/or flipping.

_Note that the format of the defect text is DIFFERENT from the defect text produced by SerialEM!_
 One can convert a SerialEM-style defect file into a defect map using IMOD utilities e.g.:
*clip defect -D defect.txt -f tif movie.tif defect_map.tif*
See explanations in the SerialEM manual.
Leave empty if you do not have any defects, or do not want to correct for defects on your detector.
EER fractionation: The number of hardware frames to group into one fraction. This option is relevant only for Falcon4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
EER upsampling: EER upsampling (1 = 4K or 2 = 8K). 8K rendering is not recommended by Relion. See https://relion.readthedocs.io/en/latest/Reference/MovieCompression.html
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "3D multi-body" can be found at the relion plugin.
Its help description is:
 
    Relion protocol for multi-body refinement.

    This approach models flexible complexes as a user-defined number of rigid
    bodies that move independently of each other.
    Using separate focused refinements with iteratively improved partial
    signal subtraction, improved reconstructions are generated for
    each of the defined bodies.

    Moreover, using PCA on the relative orientations of the bodies
    over all particle images in the data set, we generate movies that describe
    the most important motions in the data.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Continue from a previous run?: If you set to *Yes*, you should select a previous MultiBody protocol and most of the input parameters will be taken from it.
Consensus refinement protocol: Select any previous refinement protocol from where to run the multi-body refinement. The output volume will be used and some parameters from the optimiser.star file. 
Body STAR file: Provide the STAR file with all information about the bodies to be used in multi-body refinement. An example for a three-body refinement would look like this:

data_
loop_
_rlnBodyMaskName
_rlnBodyRotateRelativeTo
_rlnBodySigmaAngles
_rlnBodySigmaOffset
large_body_mask.mrc 2 10 2
small_body_mask.mrc 1 10 2
head_body_mask.mrc 2 10 2


 Where each data line represents a different body, and:
 - rlnBodyMaskName contains the name of a soft-edged mask with values in [0,1] that define the body; the mask name should be relative to the project folder;
 - rlnBodyRotateRelativeTo defines relative to which other body this body rotates (first body is number 1);
 - rlnBodySigmaAngles and _rlnBodySigmaOffset are the standard deviations (widths) of Gaussian priors on the consensus rotations and translations;

 Optionally, there can be a fifth column with _rlnBodyReferenceName. Entries can be 'None' (without the ''s) or the name of a MRC map with an initial reference for that body. In case the entry is None, the reference will be taken from the density in the consensus refinement.

Also note that larger bodies should be above smaller bodies in the STAR file. For more information, see the multi-body paper.
                           
Reconstruct subtracted bodies?: If set to Yes, then the reconstruction of each of the bodies will use the subtracted images. This may give useful insights about how well the subtraction worked. If set to No, the original particles are used for reconstruction (while the subtracted ones are still used for alignment). This will result in fuzzy densities for bodies outside the one used for refinement.
Use Blush regularisation?: If set to Yes, relion_refine will use a neural network to perform regularisation by denoising at every iteration, instead of the standard smoothness regularisation.
Select previous run: Select a previous run to continue from.
Continue from iteration: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
Initial angular sampling (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere. 

Note that this will only be the value for the first few iteration(s): the sampling rate will be increased automatically after that.
Initial offset range (pix): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration. 

Note that this will only be the value for the first few iteration(s): the sampling rate will be increased automatically after that.
Initial offset step (pix): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid. 

Note that this will only be the value for the first few iteration(s): the sampling rate will be increased automatically after that.
Run flexibility analysis?: If set to Yes, after the multi-body refinement has completed, a PCA analysis will be run on the orientations all all bodies in the data set. This can be set to No initially, and then the job can be continued afterwards to only perform this analysis.
Number of eigenvector movies:: Series of ten output maps will be generated along this many eigenvectors. These maps can be opened as a "Volume Series" in UCSF Chimera, and then displayed as a movie. They represent the principal motions in the particles.
Select particles based on eigenvalues?: If set to Yes, a particles.star file is written out with all particles that have the below indicated eigenvalue in the selected range.
Select on eigenvalue:: This is the number of the eigenvalue to be used in the particle subset selection (start counting at 1).
min: None
max: None
Use parallel disc I/O?: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
Number of pooled particles:: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Skip padding: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
Pre-read all particles into RAM?: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
Copy particles to scratch directory: : If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
Combine iterations through disc?: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. They will be appended to the relion_refine command.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "post-processing" can be found at the relion plugin.
Its help description is:
 
    Relion post-processing protocol for automated masking,
    overfitting estimation, MTF-correction and B-factor sharpening.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Start from Relion refinement?: Set to Yes if you wish to use as input a Relion protocol. Otherwise set it to No
Input half map 1: You might want to provide input half maps manually, in case you did not use 3D auto-refine or multi-body protocol that generates them automatically.
Input half map 2: You might want to provide input half maps manually, in case you did not use 3D auto-refine or multi-body protocol that generates them automatically.
Select a previous refinement protocol: Select any previous refinement protocol to get the 3D half maps. Note that it is recommended that the refinement protocol uses a gold-standard method.
Which body to process?: Only relevant if input protocol is 3D multi-body.
Solvent mask: Provide a soft mask where the protein is white (1) and the solvent is black (0). Often, the softer the mask the higher resolution estimates you will get. A soft edge of 5-10 pixels is often a good edge width.
Calibrated pixel size (A): Provide the final, calibrated pixel size in Angstroms. If 0, the input pixel size will be used. This value may be different from the pixel-size used thus far, e.g. when you have recalibrated the pixel size using the fit to a PDB model. The X-axis of the output FSC plot will use this calibrated value.
MTF of the detector: User-provided STAR-file with the MTF-curve of the detector. Use the wizard to load one of the predefined ones provided at:
- [[https://www3.mrc-lmb.cam.ac.uk/relion/index.php/FAQs#Where_can_I_find_MTF_curves_for_typical_detectors.3F][Relion's Wiki FAQs]]
 - [[https://www.gatan.com/techniques/cryo-em#MTF][Gatan's website]]

Relion param: *--mtf*
Original detector pixel size (A): This is the original pixel size (in Angstroms) in the raw (non-super-resolution!) micrographs
Estimate B-factor automatically?: If set to Yes, then the program will use the automated procedure described by Rosenthal and Henderson (2003, JMB) to estimate an overall B-factor for your map, and sharpen it accordingly.
low: None
high: None
Provide B-factor:: User-provided B-factor (in A^2) for map sharpening, e.g. -400. Use negative values for sharpening. Be careful: if you over-sharpen
your map, you may end up interpreting noise for signal!
Relion param: *--adhoc_bfac*
Skip FSC-weighting for sharpening?: If set to No (the default), then the output map will be low-pass filtered according to the mask-corrected, gold-standard FSC-curve. Sometimes, it is also useful to provide an ad-hoc low-pass filter (option below), as due to local resolution variations some parts of the map may be better and other parts may be worse than the overall resolution as measured by the FSC. In such  cases, set this option to Yes and provide an ad-hoc filter as described below.
Ad-hoc low-pass filter (A):: This option allows one to low-pass filter the map at a user-provided frequency (in Angstroms). When using a resolution that is higher than the gold-standard FSC-reported resolution, take care not to interpret noise in the map for signal.
Low-pass filter edge width:: Width of the raised cosine on the low-pass filter edge (in resolution shells)
Relion param: *--filter_edge_width*
Randomize phases threshold: Randomize phases from the resolution where FSC drops below this value
Relion param: *--randomize_at_fsc*
Force mask?: Use the mask even when the masked resolution is worse than the unmasked resolution.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "preprocess particles" can be found at the relion plugin.
Its help description is:
  This protocol wraps relion_preprocess program.

    It is used to perform normalisation, filtering or scaling of
    the particles.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input images from the project.
Normalize: If set to True, particles will be normalized in theway RELION prefers it. It is recommended to *always normalize your particles*, and use a reasonable radius for the circle around your particles outside of which the standard deviation and average values for the noise are calculated.
*Note*: if the particles are re-scaled, the radius for normalize will be taken over the new dimensions.
Background radius (px): Pixels outside this circle are assumed to be noise and their stddev is set to 1. Radius for background circle definition (in pixel).
Remove dust from particles: If there are white or black artifacts on the micrographs (e.g. caused by dust or hot/dead pixels), these may be removed by using a positive value for the dust removal options. All black/white pixels with values above the given parameter times the standard deviation of the noise are replaced by random values from aGaussian distribution. For cryo-EM data, valuesaround 3.5-5 are often useful. Make sure you do not erase part of the true signal.
White: None
Black: None
Invert contrast: Invert the contrast if your particles are black over a white background.
Scale particles?: Re-scale the particles to this size (in pixels).
Scale size (px): New particle size in pixels.
Window particles?: Re-window the particles to this size (in pixels).
Window size (px): New particles windows size (in pixels).
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "reconstruct" can be found at the relion plugin.
Its help description is:
  This protocol reconstructs a volume using Relion.

    Reconstruct a volume from a given set of particles.
    The alignment parameters will be converted to a Relion star file
    and used as direction projections to reconstruct.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input images from the project.
Symmetry group: See [[https://relion.readthedocs.io/en/latest/Reference/Conventions.html#symmetry][Relion Symmetry]] page for a description of the symmetry format accepted by Relion
Maximum resolution (A): Maximum resolution (in Angstrom) to consider 
in Fourier space (default Nyquist).
Padding factor: None
Subset to reconstruct: Subset of images to consider.
Use only this class: Consider only this class (-1: use all classes)
Extra parameters: : Extra parameters to *relion_reconstruct* program. Address to Relion to see full list of options.
Apply CTF correction?: None
Leave CTFs intact until first peak?: None
Correct for Ewald-sphere curvature?: None
Skip masking?: Do not apply real space mask during Ewald sphere correction.
Mask diameter (A): Diameter (in A) of mask for Ewald-sphere curvature correction
Add a soft-edge (px): Width (in pixels) of the soft edge on the mask.
Reverse curvature?: None
New box size (px): Box size of reconstruction after Ewald sphere correction.
Number of sectors: Number of sectors for Ewald sphere correction.
Skip weighting?: Do not apply weighting during during Ewald sphere correction.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "3D auto-refine" can be found at the relion plugin.
Its help description is:
  Protocol to refine a 3D map using Relion.

Relion employs an empirical Bayesian approach to refinement
of (multiple) 3D reconstructions
or 2D class averages in electron cryo-microscopy (cryo-EM). Many
parameters of a statistical model are learned from the data,which
leads to objective and high-quality results.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: None
: None
Continue from a previous run?: If you set to *Yes*, you should select a previousrun of type *ProtRelionRefine3D* class and most of the input parameterswill be taken from it.
Input particles: Select the input images from the project.
Consider previous alignment?: If set to Yes, then alignment information from input particles will be considered.
Consider alignment as priors?: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
: None
Particle mask diameter (A): The experimental images will be masked with a soft circular mask with this <diameter>. Make sure this diameter is not set too small because that may mask away part of the signal! If set to a value larger than the image size no masking will be performed.

The same diameter will also be used for a spherical mask of the reference structures if no user-provided mask is specified.
Mask particles with zeros?: If set to <Yes>, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform. This will remove noise and therefore increase sensitivity in the alignment and classification. However, it will also introduce correlations between the Fourier components that are not modelled. When set to <No>, then the solvent area is filled with random noise, which prevents introducing correlations.High-resolution refinements (e.g. in 3D auto-refine) tend to work better when filling the solvent area with random noise, some classifications go better when using zeros.
Select previous run: Select a previous run to continue from.
Continue from iteration: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
Reference averages: This option is not recommended and should be used with care. The provided averages will be used as initial 2D references. If this option is used, the number of classes will be ignored. 
Input volume: Initial reference 3D map, it should have the same dimensions and the same pixel size as your input particles.
Reference mask (optional): A volume mask containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask. If no mask is given, a soft spherical mask based on the <radius> of the mask for the experimental images will be applied.

In some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. Check _Advaced_ level and select another volume mask
Second reference mask (optional): For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas.
Use solvent-flattened FSCs?: If set to Yes, then instead of using unmasked maps to calculate the gold-standard FSCs during refinement, masked half-maps are used and a post-processing-like correction of the FSC curves (with phase-randomisation) is performed every iteration. This only works when a reference mask is provided on the I/O tab. This may yield higher-resolution maps, especially when the mask contains only a relatively small volume inside the box.
Is initial 3D map on absolute greyscale?: The probabilities are based on squared differences, so that the absolute grey scale is important. 
Probabilities are calculated based on a Gaussian noise model, which contains a squared difference term between the reference and the experimental image. This has a consequence that the reference needs to be on the same absolute intensity grey-scale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity grey-scale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. Therefore: if the map was reconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No. If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent MAP refinement. Therefore, if in doubt it is recommended to set this option to No.
Symmetry: See [[https://relion.readthedocs.io/en/latest/Reference/Conventions.html#symmetry][Relion Symmetry]] page for a description of the symmetry format accepted by Relion
Initial low-pass filter (A): It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s).
CTF parameters are not available in continue mode: None
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Have data been phase-flipped?      (Don't answer, see help): The phase-flip status is recorded and managed by Scipion. 
 In other words, when you import or extract particles, 
Scipion will record whether or not phase flipping has been done.

Note that CTF-phase flipping is NOT a necessary pre-processing step 
for MAP-refinement in RELION, as this can be done inside the internal
CTF-correction. However, if the phases have been flipped, the program will handle it.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Do manual grouping ctfs?: Set this to Yes the CTFs will grouping manually.
Defocus range for group creation (in Angstroms): Particles will be grouped by defocus.This parameter is the bin for a histogram.All particles assigned to a bin form a group
minimum size for defocus group: If defocus group is smaller than this value, it will be expanded until number of particles per defocus group is reached
Perform image alignment?: If set to No, then rather than performing both alignment and classification, only classification will be performed. This allows the use of very focused masks. This requires that the optimal orientations of all particles are already calculated.
Initial angular sampling (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
Initial offset range (pix): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
Initial offset step (pix): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid.
Local search from auto-sampling (deg): In the automated procedure to increase the angular samplings, local angular searches of -6/+6 times the sampling rate will be used from this angular sampling rate onwards.
Relax symmetry: With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020.
Use finer angular sampling faster?: If set to Yes, then let auto-refinement proceed faster with finer angular samplings. Two additional command-line options will be passed to the refine program:

	--auto_ignore_angles lets angular sampling go down despite changes still happening in the angles
	--auto_resol_angles lets angular sampling go down if the current resolution already requires that sampling at the edge of the particle.

This option will make the computation faster, but has not been tested for many cases for potential loss in reconstruction quality upon convergence.
Use Blush regularisation?: If set to Yes, relion_refine will use a neural network to perform regularisation by denoising at every iteration, instead of the standard smoothness regularisation.
Use parallel disc I/O?: If set to Yes, all MPI slaves will read their own images from disc. Otherwise, only the master will read images and send them through the network to the slaves. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many slaves reading in parallel.
Number of pooled particles:: Particles are processed in individual batches by MPI slaves. During each batch, a stack of particle images is only opened and closed once to improve disk access times. All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. The nr_pooled_particles parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together. This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Skip padding: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
Pre-read all particles into RAM?: If set to Yes, all particle images will be read into computer memory, which will greatly speed up calculations on systems with slow disk access. However, one should of course be careful with the amount of RAM available. Because particles are read in float-precision, it will take 
( N * (box_size)^2 * 4 / (1024 * 1024 * 1024) ) Giga-bytes to read N particles into RAM. For 100 thousand 200x200 images, that becomes 15Gb, or 60 Gb for the same number of 400x400 particles. Remember that running a single MPI slave on each node that runs as many threads as available cores will have access to all available RAM.

If parallel disc I/O is set to No, then only the master reads all particles into RAM and sends those particles through the network to the MPI slaves during the refinement iterations.
Copy particles to scratch directory: : If a directory is provided here, then the job will create a sub-directory in it called relion_volatile. If that relion_volatile directory already exists, it will be wiped. Then, the program will copy all input particles into a large stack inside the relion_volatile subdirectory. Provided this directory is on a fast local drive (e.g. an SSD drive), processing in all the iterations will be faster. If the job finishes correctly, the relion_volatile directory will be wiped. If the job crashes, you may want to remove it yourself.
Combine iterations through disc?: If set to Yes, at the end of every iteration all MPI slaves will write out a large file with their accumulated results. The MPI master will read in all these files, combine them all, and write out a new file with the combined results. All MPI slaves will then read in the combined results. This reduces heavy load on the network, but increases load on the disc I/O. This will affect the time it takes between the progress-bar in the expectation step reaching its end (the mouse gets to the cheese) and the start of the ensuing maximisation step. It will depend on your system setup which is most efficient.
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Over-sampling: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--dont_combine_weights_via_disc
--verb 1
--pad 2
--low_resol_join_halves 40 (only not continue mode)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "remove preferential views" can be found at the relion plugin.
Its help description is:
  Protocol to remove preferential views from a particle set.

    Inspired by https://github.com/leschzinerlab/Relion

    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Provide a set of particles.
Number of particles to remove: Number of particles to remove WITHIN the limits below.
min: None
max: None
min: None
max: None
Remove views with specific in-plane rotation?: Particle orientation on Euler sphere is defined by rot and tilt angles. Psi is for in-plane rotation only. Select *Yes* if you want to provide psi limits.
min: None
max: None

The protocol named "crop/resize volumes" can be found at the relion plugin.
Its help description is:
  This protocol rescales/resizes 3D volumes using relion_image_handler. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: Can be a Volume or a SetOfVolumes.
Rescale volumes?: None
New sampling rate (Å/px): None
Resize volumes to a new box?: None
New box size (px): Provide even box size.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "2D class ranker" can be found at the relion plugin.
Its help description is:
 
    Relion protocol to auto-select 2D class averages.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Relion 2D classification: None
Min. threshold for auto-selection: Only classes with a predicted threshold above this value will be selected.
Select at least this many particles: Even if they have scores below the minimum threshold, select at least this many particles with the best scores.
OR: Select at least this many classes: Even if they have scores below the minimum threshold, select at least this many classes with the best scores.

The protocol named "subtract projection" can be found at the relion plugin.
Its help description is:
  Signal subtraction protocol of Relion.

    Subtract volume projections from the experimental particles.
    The particles must have projection alignment in order to
    properly generate volume projections.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Start from Relion protocol?: Set to Yes if you wish to use as input a Relion protocol. Otherwise set it to No
Input Relion protocol: Select the 3D refinement/classification or multi-body run which you want to use for subtraction. It will use the maps from this run for the subtraction.
Input map to be projected: Provide the input volume that will be used to calculate projections, which will be subtracted from the experimental particles. Make sure this map was calculated by RELION from the same particles as above, and preferably with those orientations, as it is crucial that the absolute greyscale is the same as in the experimental particles.
Use all particles from input protocol?: If No, then you need to provide a subset of particles below.
Input particles subset: Select the particles which are a SUBSET of the input protocol provided above.
Input particles: Select the input particles.
Mask of the signal to keep: Provide a soft mask where the protein density you wish to subtract from the experimental particles is black (0) and the density you wish to keep is white (1).
That is: *the mask should INCLUDE the part of the volume that you wish to KEEP.*
Write output in float16?: Relion can write output images in float16 MRC (mode 12) format to save disk space. By default, float32 format is used.
This section is only used if starting from Relion input.: None
Do center subtracted images on mask?: If set to Yes, the subtracted particles will be centered on projections of the center-of-mass of the input mask.
Do center on my coordinates?: If set to Yes, the subtracted particles will be centered on projections of the x,y,z coordinates below. The unit is pixel, not angstrom. The origin is at the center of the box, not at the corner.
X: None
Y: None
Z: None
New box size: Provide a non-negative value to re-window the subtracted particles in a smaller box size.
This section is only used if NOT starting from Relion protocol.: None
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "symmetrize volume" can be found at the relion plugin.
Its help description is:
 
    Symmetrize a volume using Relion programs:
        *relion_align_symmetry* and *relion_image_handler*.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: Select the input volume to be symmetrized. 
Symmetry: Select which symmetry do you want to apply. 
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "2D particles to subtomograms" can be found at the tomo plugin.
Its help description is:
  Protocol to create a set of subtomograms from a selected 2D particles.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set of subtomograms: Select the set of subtomograms 
Input set: Select the 2D classes or a set of particles

The protocol named "2d coordinates to 3d coordinates" can be found at the tomo plugin.
Its help description is:
  Turns 2d coordinates into set of 3d coordinates. Works in coordination with 'tomograms to micrographs' protocol.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomograms: Select the tomograms to be associated to the 3D coordinates
2D Coordinates: Set of 2d coordinates picked on tomogram slices.

The protocol named "assign alignment" can be found at the tomo plugin.
Its help description is:
  Assign the alignment stored in a set of Subtomograms/Coordinates3D
    to another set.
    Both sets should have same pixel size (A/px).
    The Subtomograms/Coordinates3D with the alignment can also be a subset of a bigger set.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input: Select the Subtomograms/Coordinates3D that you want to update the new alignment.
Alignments: Select the Subtomograms/Coordinates3D with alignment to be apply to the other object.

The protocol named "assign tomos to subtomos" can be found at the tomo plugin.
Its help description is:
  This protocol assign tomograms to subtomograms that have been imported before without tomograms.
    Subtomograms should contain the name of the original tomogram in their own file name.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Subtomograms: Select the subtomograms that you want to update with original tomograms as precedents.The subtomograms should contain the original tomogram name in their own filename.
Tomograms: Select the tomograms to be assigned to the subtomograms.

The protocol named "assign tomograms to tomo masks (segmentations)" can be found at the tomo plugin.
Its help description is:
  This protocol assign tomograms to tomomasks (segmentations)..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomo masks (segmentations): Select the tomo masks desired to be referred to the introduced tomograms. The match between both sets is carried out firstly by tsId and if not possible, then it will try to do it by filename.
Tomograms: Select the tomograms to be assigned to the input tomo masks.

The protocol named "Tilt-series assign alignment" can be found at the tomo plugin.
Its help description is:
 
    Assign the transformation matrices from an input set of tilt-series to a target one.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tilt-series from which to take the alignment: Set of tilt-series from which transformation matrices will be obtained.
Tilt-series to assign the alignment to: Set of tilt-series on which transformation matrices will be assigned.
Combine alignments: If this option is selected and the the tilt-series to assign the alignment has a previous alignment, both precious and new alignment are combined.

The protocol named "ctf consensus tomo" can be found at the tomo plugin.
Its help description is:
 
     Validate a set of CTF tomo series and separate into two sets (good and
     bad tomo series )
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input ctf tomo series: None
Input secondary ctf tomo series: CTF tomo series to be compared with reference CTF
Validation type: Global mode: the series with at least one image that does not satisfy the criteria are rejected 
Per tilt mode: the series containing a certain number of images that does not satisfy the criteria are rejected
Number of images to rejected: Number of images taking into account to rejected a ctf series
Defocus tolerance: Validate the defocus deviation taking into account a threshold(tolerance) respect to a defocus expected value.
Tolerance value defocus: Defocus tolerance value calculates as: 
asb(error)/mean_defocus
Astigmatism: Validate the astigmatism taking into account a tolerance value.
Tolerance value astigmatism: Astigmatism tolerance value calculated as: 
asb(error)/mean_astigmatism
Resolution: Validate the resolution taking into account a expected resolution.
Minimum consensus resolution (A): Minimum value for the consensus resolution in Angstroms.
If there are noticeable discrepancies between the two estimations below this resolution, it will be discarded. 'Option for calculating consensus resolution. The algorithm assumes that two CTF are consistent if the phase (wave aberration function) of the two CTFs are closer than 90 degrees.
The reported consensusResolution is the resolution at which the two CTF phases differ in 90 degrees.'
Average equivalent metadata?: If *Yes*, making an average of those metadata present in both CTF estimations (defocus, astigmatism angle...)
 If *No*, the primary estimation metadata will persist.
Include all secondary metadata?: If *Yes*, all metadata in the *Secondary CTF* will be included in the resulting CTF.
 If *No*, only the primary metadata (plus consensus scores) will be in the resulting CTF.

The protocol named "ctf validate" can be found at the tomo plugin.
Its help description is:
 
     Validate a set of CTF tomo series and separate into two sets (good and
     bad tomo series )
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input ctf tomo series: None
Validation type: Global mode: the series with at least one image that does not satisfy the criteria are rejected 
Per tilt mode: the series containing a certain number of images that does not satisfy the criteria are rejected
Number of images to rejected: Number of images taking into account to rejected a ctf series
Defocus tolerance: Validate the defocus deviation taking into account a threshold(tolerance) respect to a defocus expected value.
Expected value (Å): Defocus expected value in Å
Tolerance value (Å): Defocus tolerance value in Å
Astigmatism: Validate the astigmatism taking into account a tolerance value.
Tolerance value: Astigmatism tolerance value
Resolution: Validate the resolution taking into account a expected resolution.
Expected value: Expected resolution value

The protocol named "Compose Tilt Series" can be found at the tomo plugin.
Its help description is:
  Compose in streaming a set of tilt series based on a set of micrographs and mdoc files.
    Two time parameters are available for the streaming behaviour:
    Time to next tilt and time to next tilt series
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input micrographs: Select the SetOfMicrographs to import
Path with the *.mdoc files for each tilt series: Root directory of the tilt-series. Use of * will work for multiple characters or ? for a single one. Also [] can specify ranges.
Mdoc pattern: Pattern that should match for mdoc files.Use of * will work for multiple characters or ? for a single one. Also [] can specify ranges.
Exclusion words: Space separated words that will be used to exclude mdoc files that could be listed with the above parameters.
mdoc bug Correction: Setting True, the mdoc generated by SerialEM will be read considering the bug
Process data in streaming?: Select this option if you want import data as it is generated and process on the fly by next protocols. In this case the protocol will keep running to check new files and will update the output Set, which can be used right away by next steps.
Time for next Tilt (secs): Delay (in seconds) until the next tilt is registered in the mdoc file. After timeout, if there is no new tilt, the tilt series is considered as completed.Minimum time recommended 20 secs
Time for next tilt series (secs): Interval of time (in seconds) after which, if no new tilt series is detected, the protocol will end. The default value is  high (30 min) to avoid the protocol finishes during the acq of the microscope. You can also stop it from right click and press STOP_STREAMING.

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Tilt-series consensus alignment" can be found at the tomo plugin.
Its help description is:
 
    Perform a consensus of a set of alignments for the same tilt series. Returns the average alignment matrix of the
    consensus alignments and its standard deviation of shift and angle.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tilt series: Select several sets of tilt-series where to evaluate the consensus in their alignment. Output set will bring the information from the first selected set.
Shift tolerance (A): Maximum shift difference between alignments to consider them as equal. it is measured in Angstroms.
Angle tolerance (degrees): Maximum angle difference between alignments to consider them as equal. It is measured in degrees
Consensus: Criteria for consensus alignment. If local, consensus will be performed to the tilt-images individually (different consensus applied individually) and if there is no consensus in some image the series will be discarded. If global, consensus will be performed at the level o tilt-series (the whole pair of alignments must agree).

The protocol named "consensus classes subtomo" can be found at the tomo plugin.
Its help description is:
  Compare several SetOfClassesSubTomograms.
        Return the intersection of the input classes.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Classes: Select several sets of classes where to evaluate the intersections.

The protocol named "import coordinates 3D" can be found at the tomo plugin.
Its help description is:
 Protocol to import a set of tomograms to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Coordinates sampling rate [Å/pix] (opt.): If empty, the coordinates' sampling rate will be considered to be the same as the tomograms'.
*IMPORTANT*: If a value is provided, the ratio of both tomograms and coordinates sampling rate will be used to scale the coordinates properly to the tomograms introduced.
Box Size [pix]: It will be re-scaled to the tomogram size considering the coordinates and tomograms ratio between their corresponding sampling rates.
Input tomograms: Select the tomograms to which the coordinates should be referred to.
The file names of the tomogram and coordinate files must be the same.

The protocol named "import 3D coordinates from scipion" can be found at the tomo plugin.
Its help description is:
 Protocol to import a set of 3d coordinates from Scipion sqlite file.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Scipion sqlite file: None
Input tomograms: Select the tomograms to which the coordinates should be referred to. The matching between coordinates and tomograms is made checking the tsId/tomoId attribute. If no matches are found, then it tries to do it comparing the filenames. *IMPORTANT*: the coordinates will be assumed to be at the same sampling rate as the introduced tomograms.
Box Size [pix]: None

The protocol named "import subtomograms" can be found at the tomo plugin.
Its help description is:
 Protocol to import a set of tomograms to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Pixel size (sampling rate) Å/px: None
Import from: Select the type of import.
Acquisition parameters file: File with the acquisition parameters for each tomogram or subtomogram to import. File must be in plain format. The file must contain a row per file to be imported and have the following parameters in order: 

'File_name AcquisitionAngleMin AcquisitionAngleMax Step TiltAxisAngle' 

An example would be:
subtomo1.em -40 40 3 85
subtomo2.em -45 50 2 85

Acquisition angle max: Enter the positive limit of the acquisition angle
Acquisition angle min: Enter the negative limit of the acquisition angle
Step: Enter the step size for the import
Tilt axis angle (deg.): The rotation angle is the angle from the vertical to the axis of tilting, where counterclockwise is positive.
 See https://bio3d.colorado.edu/imod/doc/tomoguide.html#UnknownAxisAngle
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.

The protocol named "import tilt-series coordinates" can be found at the tomo plugin.
Its help description is:
 Protocol to import a set of tilt-series coordinates 3D.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input set of tilt-series: None

The protocol named "import tomograms" can be found at the tomo plugin.
Its help description is:
 Protocol to import a set of tomograms to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Pixel size (sampling rate) Å/px: None
Import from: Select the type of import.
Acquisition parameters file: File with the acquisition parameters for each tomogram or subtomogram to import. File must be in plain format. The file must contain a row per file to be imported and have the following parameters in order: 

'File_name AcquisitionAngleMin AcquisitionAngleMax Step TiltAxisAngle' 

An example would be:
subtomo1.em -40 40 3 85
subtomo2.em -45 50 2 85

Acquisition angle max: Enter the positive limit of the acquisition angle
Acquisition angle min: Enter the negative limit of the acquisition angle
Step: Enter the step size for the import
Tilt axis angle (deg.): The rotation angle is the angle from the vertical to the axis of tilting, where counterclockwise is positive.
 See https://bio3d.colorado.edu/imod/doc/tomoguide.html#UnknownAxisAngle
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Set origin of coordinates: Option YES:
A new volume will be created with the given ORIGIN of coordinates. This ORIGIN will be set in the map file header.
The ORIGIN of coordinates will be placed at the center of the whole volume if you select n(x)/2, n(y)/2, n(z)/2 as x, y, z coordinates (n(x), n(y), n(z) are the dimensions of the whole volume). However, selecting 0, 0, 0 as x, y, z coordinates, the volume will be placed at the upper right-hand corner.

Option NO:
The ORIGIN of coordinates will be placed at the center of the whole volume (coordinates n(x)/2, n(y)/2, n(z)/2 by default). This ORIGIN will NOT be set in the map file header.

WARNING: In case you want to process the volume with programs requiring a specific symmetry regarding the origin of coordinates, for example the protocol extract unit cell, check carefully that the coordinates of the origin preserve the symmetry of the whole volume. This is particularly relevant for loading fragments/subunits of the whole volume.

From mrc header: Use origin information in mrc headers of the tomograms.
x: offset along x axis (Angstroms)
y: offset along y axis (Angstroms)
z: offset along z axis (Angstroms)

The protocol named "import tomomasks (segmentations)" can be found at the tomo plugin.
Its help description is:
 Protocol to import a set of tomomasks (segmentations) to the project.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Tomograms: Select the tomograms to be assigned to the input tomo masks.

The protocol named "import tilt-series" can be found at the tomo plugin.
Its help description is:
 Protocol to import tilt series..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Files directory: Root directory of the tilt-series (or movies) files.
Pattern: This determines if the tilt series / movies are going to be imported using the mdoc files or the tilt series files. To import from the mdoc files, the word '.mdoc' must appear in the pattern, if not, a tilt series pattern is expected. In the first case, the angular and acquisition data are read from the corresponding mdoc files, while in the second case they are read from the name of the matching files.

*IMPORTING WITH MDOC FILES*

For *tilt series movies*, ONE mdoc per tilt series is expected. The movie files must be located in the same folder as the mdocs. The filenames will be fetched from the _SubFramePath_ value in mdoc. 
Example pattern: _TS*.mdoc_

For *tilt series*, ONE _mrcs_ stack should match ONE mdoc file per each tilt series. To import unstacked images use the filename pattern (see below) instead of mdoc.

*IMPORTING WITH A FILENAME PATTERN (tilt series and movies)*

The pattern can contain wildcards such as *, ?, etc. It should also contain the following special tags:

   *{TS}*: tilt series identifier, which can be any UNIQUE part of the path. This must be an alpha-numeric sequence (avoid dash (-) symbol) and can not start with a number.
   *{TO}*: acquisition order, an integer value (important for dose information).
   *{TA}*: tilt angle, a positive or negative float value.

Example:

To import a set of images (tilt-series or tilt-series movies) like: 
TiltSeries_a_001_0.0.mrc
TiltSeries_a_002_3.0.mrc
TiltSeries_a_003_-3.0.mrc
...
TiltSeries_b_001_0.0.mrc
TiltSeries_b_002_3.0.mrc
TiltSeries_b_003_-3.0.mrc
...
Use pattern TiltSeries_{TS}_{TO}_{TA}.mrc, which will identify:
{TS} as a, b, ...
{TO} as 001, 002, 003, ...
{TA} as 0.0, 3.0, -3.0, ...

Tomo5 mdoc?: If these mdocs were generated by the Tomography 5 software, check this box to ensure that the tilt axis angle is converted properly: -1 * TiltAxisAngle - 90
Exclusion words:: List of words separated by a space that the path should not have
Acquisition values provided below will override the corresponding mdoc values: None
Import angles from: Choose how the tilt angles will be inferred. They can be taken from a range (Min, Max, Step) or from the image header, or from anmdoc or tlt file (should have the SAME filename but with the .mdoc or .tlt or .rawtlt extension at the end). If a tlt or rawtlt file is used, it is optional to pass the accumulated dose as second column beside each angle separated by space
min: None
max: None
step: None
Have images been CTF corrected?: Select Yes if images have been CTF corrected
Have images been aligned?: Select Yes if images have been rotated/interpolated using alignment information.
Import action on files: This parameters determine how the project will deal with imported files. It can be: 
*Copy files*: Input files will be copied into your project. (this will duplicate the raw data).*Absolute symlink*: Create symbolic links to the absolute path of the files.*Relative symlink*: Create symbolic links as relative path from the protocol run folder. 
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Pixel size (sampling rate) Å/px: Pixel size
Tilt axis angle (deg.): The rotation angle is the angle from the vertical to the axis of tilting, where counterclockwise is positive.
 See https://bio3d.colorado.edu/imod/doc/tomoguide.html#UnknownAxisAngle
Initial dose: None
Dose per tilt image: None

The protocol named "import tomo CTFs" can be found at the tomo plugin.
Its help description is:
 Common protocol to import CTF estimation of a tilt-series. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Import from: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Exclusion words:: List of words separated by a space that the path should not have
Input tilt-series: Select the corresponding tilt-series for which you want to update the CTF parameters.

The protocol named "import tilt-series movies" can be found at the tomo plugin.
Its help description is:
 Protocol to import tilt series movies..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Files directory: Root directory of the tilt-series (or movies) files.
Pattern: This determines if the tilt series / movies are going to be imported using the mdoc files or the tilt series files. To import from the mdoc files, the word '.mdoc' must appear in the pattern, if not, a tilt series pattern is expected. In the first case, the angular and acquisition data are read from the corresponding mdoc files, while in the second case they are read from the name of the matching files.

*IMPORTING WITH MDOC FILES*

For *tilt series movies*, ONE mdoc per tilt series is expected. The movie files must be located in the same folder as the mdocs. The filenames will be fetched from the _SubFramePath_ value in mdoc. 
Example pattern: _TS*.mdoc_

For *tilt series*, ONE _mrcs_ stack should match ONE mdoc file per each tilt series. To import unstacked images use the filename pattern (see below) instead of mdoc.

*IMPORTING WITH A FILENAME PATTERN (tilt series and movies)*

The pattern can contain wildcards such as *, ?, etc. It should also contain the following special tags:

   *{TS}*: tilt series identifier, which can be any UNIQUE part of the path. This must be an alpha-numeric sequence (avoid dash (-) symbol) and can not start with a number.
   *{TO}*: acquisition order, an integer value (important for dose information).
   *{TA}*: tilt angle, a positive or negative float value.

Example:

To import a set of images (tilt-series or tilt-series movies) like: 
TiltSeries_a_001_0.0.mrc
TiltSeries_a_002_3.0.mrc
TiltSeries_a_003_-3.0.mrc
...
TiltSeries_b_001_0.0.mrc
TiltSeries_b_002_3.0.mrc
TiltSeries_b_003_-3.0.mrc
...
Use pattern TiltSeries_{TS}_{TO}_{TA}.mrc, which will identify:
{TS} as a, b, ...
{TO} as 001, 002, 003, ...
{TA} as 0.0, 3.0, -3.0, ...

Tomo5 mdoc?: If these mdocs were generated by the Tomography 5 software, check this box to ensure that the tilt axis angle is converted properly: -1 * TiltAxisAngle - 90
Exclusion words:: List of words separated by a space that the path should not have
Acquisition values provided below will override the corresponding mdoc values: None
: Angles will be parsed from the filename pattern.The special token {TA} should be specified as  part of the pattern.
Import action on files: This parameters determine how the project will deal with imported files. It can be: 
*Copy files*: Input files will be copied into your project. (this will duplicate the raw data).*Absolute symlink*: Create symbolic links to the absolute path of the files.*Relative symlink*: Create symbolic links as relative path from the protocol run folder. 
Microscope voltage (kV): Microscope voltage
Spherical aberration (mm): Optical effect due to the increased refraction of light rays when they
strike the lens near its edge, in comparison with those that strike near
the center.
Amplitude Contrast: Produced by the loss of amplitude (i.e. electrons) from the beam.

For a weak phase and weak amplitude object, the amplitude contrast ratio Qo
is automatically computed. It should be a positive number, typically between
0.05 and 0.3.
Magnification rate: Electron optical magnification (M). It can be used to compute the Image Pixel
Size ("Sampling Rate") (Ts) using the Scanner Pixel Size (Tm), Ts = Tm / M.
Pixel size (sampling rate) Å/px: Pixel size
Tilt axis angle (deg.): The rotation angle is the angle from the vertical to the axis of tilting, where counterclockwise is positive.
 See https://bio3d.colorado.edu/imod/doc/tomoguide.html#UnknownAxisAngle
Initial dose: None
Dose per tilt image: None
Gain image: A gain reference related to a set of movies for gain correction
Dark image: A dark image related to a set of movies

The protocol named "meshes from tomoMask" can be found at the tomo plugin.
Its help description is:
 
    Creates meshes based on segmentations (TomoMasks) voxels values.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomo Masks: Set of tomo mask from which the meshes will be created
Lowest: None
Highest: None
Percentage of density : This parameter goes from 0 - 100 and defines the percentage of voxel of the tomoMask thatwill be considered as points of the mesh.

The protocol named "Astigmatism rotation" can be found at the tomo plugin.
Its help description is:
 
    Rotate the astigmatism of a set of ctf tilt-series estimation given a set of transformation matrices coming from
    a set of tilt series.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set of tilt-series from which get transform: Set of tilt-series from which transformation matrices will be obtained.
input tilt-series CTF estimation: Select the CTF estimation whose astigmatism estimation will be rotated.

The protocol named "split even/odd tomos/subtomos" can be found at the tomo plugin.
Its help description is:
  Protocol to split set of tomograms or subtomograms in even/odd sets by element id.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set to split: Select the set of tomograms or subtomograms that you want to split in even/odd sets.

The protocol named "extract 3D coordinates" can be found at the tomo plugin.
Its help description is:
 
    Extract the coordinates information from a set of subtomograms.

    This protocol is useful when we want to re-extract the subtomograms
    (maybe resulting from classification) with the
    original dimensions. It can be also handy to visualize the resulting
    subtomograms in their location on the tomograms.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Subtomograms or 3D coordinates: Select the subtomograms from which you want
to extract the coordinates. The coordinate belonging to each subtomogram should be already associated to an initial tomogram.
Tomograms: Select the tomograms to which you want to
associate the coordinates from the subtomograms.
Box Size: Determine the box size of the extracted coordinates. By default, the program assigns the box size directly from the coordinates associated to the subtomograms.
Execution host: Select in which of the available do you want to launch this protocol.

The protocol named "Landmarks to 2D coordinates" can be found at the tomo plugin.
Its help description is:
  Converts a set of landmark models into SPA 2d objects. Landmarks will become
    a SetOfCoordinates2D and the tilt series associated will become a micrograph set associated
    to the coordinates. Since SPA methods will not handle micrograph in stacks, tilt series files will
    be unstacked..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Landmarks: Set of Landmarks to convert

The protocol named "misalign tilt-series " can be found at the tomo plugin.
Its help description is:
 
    Introduce misalignment in the transformation matrix of a tilt-series.
    NOTE: The Interpolated tilt series in this case resembles a not aligned tilt series
    or an aligned one in case you want to apply the inverse of the misalignment
    transformation matrix.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Introduce misalignment in shift X?: Introduce noise in the shift alignment value in the X axis. Characterize the noise behaviour through the parameters in the following formula:

dx = a0 + a1 * i + a2 * sin((i + a3) / S * pi) + a4 * sin((i + a5) / S * 2 * pi) + N(0,a6)

Being i the index position of the image inside the tilt-series, S the size of it and N a normal distribution.These parameters characterize the following behaviours:
- Constant (a0): an offset error (a0) is introduced in every image of the tilt-series.
- Incremental (a1): a constant incremental error (a1) is propagated through the tilt-series.
- Sine lobe (a2, a3): the introduced error presents a half sine shape, characterized by the error amplitude (a2) and the phase to displace the error function a given number of images inside the tilt-series (a3).
- Sine cycle (a4, a5): the introduced error presents a full sine cycle shape, characterized by the error amplitude (a4) and the phase to displace the error function a given number of images inside the tilt-series (a5).
- Random (a6): a random error is introduced in every image of the tilt-series given a sigma value (a6).

Offset error (a0): Offset shift error introduced in the X axis for every image of the tilt-series.
Incremental error (a1): Incremental shift error introduced in the X axis for every image of the tilt-series.
Sine lobe error amplitude (a2): Maximum amplitude of the sine lobe error function introduced in the X axis.
Sine lobe error phase (a3): Phase (displacement) of the sine lobe error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
Sine error amplitude (a4): Maximum amplitude of the sine error function introduced in the X axis.
Sine error phase (a5): Phase (displacement) of the sine error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
Random error sigma (a6): Sigma value for the random error introduced in the shift X.
Introduce misalignment in shift Y?: Introduce noise in the shift alignment value in the Y axis. Characterize the noise behaviour through the parameters in the following formula:

dY = b0 + b1 * i + b2 * sin((i + b3) / S * pi) + b4 * sin((i + b5) / S * 2 * pi) + N(0,b6)

Being i the index position of the image inside the tilt-series, S the size of it and N a normal distribution.These parameters characterize the following behaviours:
- Constant (b0): an offset error (b0) is introduced in every image of the tilt-series.
- Incremental (b1): a constant incremental error (b1) is propagated through the tilt-series.
- Sine lobe (b2, b3): the introduced error presents a half sine shape, characterized by the error amplitude (b2) and the phase to displace the error function a given number of images inside the tilt-series (b3).
- Sine cycle (b4, b5): the introduced error presents a full sine cycle shape, characterized by the error amplitude (b4) and the phase to displace the error function a given number of images inside the tilt-series (b5).
- Random (b6): a random error is introduced in every image of the tilt-series given a sigma value (b6).

Offset error (b0): Offset shift error introduced in the Y axis for every image of the tilt-series.
Incremental error (b1): Incremental shift error introduced in the Y axis for every image of the tilt-series.
Sine lobe error amplitude (b2): Maximum amplitude of the sine lobe error function introduced in the Y axis.
Sine lobe error phase (b3): Phase (displacement) of the sine lobe error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
Sine error amplitude (b4): Maximum amplitude of the sine error function introduced in the Y axis.
Sine error phase (b5): Phase (displacement) of the sine error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
Random error sigma (b6): Sigma value for the random error introduced in the shift Y.
Introduce misalignment in angle?: Introduce noise in the angle alignment value. Characterize the noise behaviour through the parameters in the following formula:

dA = c0 + c1 * i + c2 * sin((i + c3) / S * pi) + c4 * sin((i + c5) / S * 2 * pi) + N(0,c6)

Being i the index position of the image inside the tilt-series, S the size of it and N a normal distribution.These parameters characterize the following behaviours:
- Constant (c0): an offset error (c0) is introduced in every image of the tilt-series.
- Incremental (c1): a constant incremental error (c1) is propagated through the tilt-series.
- Sine lobe (c2, c3): the introduced error presents a half sine shape, characterized by the error amplitude (c2) and the phase to displace the error function a given number of images inside the tilt-series (c3).
- Sine cycle (c4, c5): the introduced error presents a full sine cycle shape, characterized by the error amplitude (c4) and the phase to displace the error function a given number of images inside the tilt-series (c5).
- Random (c6): a random error is introduced in every image of the tilt-series given a sigma value (c6).

Offset error (c0): Constant angle error to add for every image of the tilt-series. Angles are measured in degrees.
Incremental error (c1): Initial angle error value for the first image (lowest angle) of the tilt-series. Angles are measured in degrees.
Sine lobe error amplitude (c2): Maximum amplitude of the sine lobe error function introduced in the angle. Angles are measured in degrees.
Sine lobe error phase (c3): Phase (displacement) of the sine lobe error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
Sine error amplitude (c4): Maximum amplitude of the sine error function introduced in the angle. Angles are measured in degrees.
Sine error phase (c5): Phase (displacement) of the sine error function. The introduced number corresponds to the number of images from the tilt-series that the origin of the error function will be displaced.
Random error sigma (c6): Sigma value for random error introduced in the angle. Angles are measured in degrees.
Generate interpolated tilt-series: Generate tilt-series applying theobtained misalignment transformation matrix.
With inverted matrix: Save the inverse of the misalignment transformation matrix in the interpolated set.

The protocol named "tomograms to micrographs" can be found at the tomo plugin.
Its help description is:
  Turns tomograms into set of micrographs to apply SPA picking methods..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomograms: Select the tomograms to be turned into micrographs
Slices gap: Number of slices to skip when turning tomogram slices into micrographs.
No. slices to sum: For each slice corresponding to the slices gap introduced, the introduced number of adjacent slices will be considered to sum. For example, if the number is 5, the slices considered for each sum will be the corresponding to the slice gap indices plus 2 slices above and 2 slices below. If set to 1, no sum will be performed.

The protocol named "average tilt-series movies" can be found at the tomo plugin.
Its help description is:
 
    Simple protocol to average TiltSeries movies as basic
    motion correction. It is used mainly for testing purposes.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tilt-Series (movies): Select input tilt-series movies that you wantto correct for beam-induced motion. 
from: None
to: None
Use ALIGN frames range to SUM?: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Tilt-series convert coords3D" can be found at the tomo plugin.
Its help description is:
 
    Scipion protocol to convert a set of tilt-series coordinates 3d to a set of coordinates 3d associated to a set of
    tomograms.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of coordinates 3D: Set of 3D coordinates indicating the position in space of the fiducials. This set should be obtained from the previous alignment step of the tilt-series.
Input set of tomograms: None

The protocol named "fit vesicles" can be found at the tomo plugin.
Its help description is:
  This protocol adjust a SetOfSubtomograms with coordinates assigned or a SetOfCoordinates3D, to a vesicle
    (ellipsoid), defining regions of interest (SetOfMeshes) for each vesicle as output..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Subtomograms/Coordinates3D: Subtomograms or coordinates3D picked in vesicles. If there are more than one vesicle per tomogram, input subtomograms or coordinates should have assigned groupId.

The protocol named "align transformations" can be found at the xmipptomo plugin.
Its help description is:
 Protocol to rotate a series of alignments to a common reference defined by a
    Subtomogram Average.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Reference Subtomogram Average: None
Moving Subtomogram Average: None
Moving Subtomograms: None

The protocol named "apply alignment subtomo" can be found at the xmipptomo plugin.
Its help description is:
  Apply alignment matrix and produce a new setOfSubtomograms, with each subtomogram aligned to its reference. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set of subtomograms: Set of subtomograms to be alignment

The protocol named "apply alignment tilt-series" can be found at the xmipptomo plugin.
Its help description is:
 
    Compute the interpolated tilt-series from its transform matrix.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None

The protocol named "connected components to ROIs" can be found at the xmipptomo plugin.
Its help description is:
  This protocol adjust a SetOfCoordinates (which usually will come from a
    connected componnent) to a ROI (region of interest) previously defined.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Connected components: Select the Connected components (SetOfCoordinates3D).
ROIs: Select the ROIs (Regions Of Interest) they are SetOfMeshes
Selection: Selection options:
*Connected component*: It takes the whole connected component (cc) if a percentage of the points (introduced in the next field) in the cc belongs to the ROI. 
*Points*: It takes just the points of the cc which belongs to the roi
Percentage of coordinates in ROI: Percentage of coordinates from a connected component that should be inside the ROI to consider that connected component.
Distance: Maximum euclidean distance (in pixels) between ROI vertex and a coordinate to consider that it belongs to the ROI.

The protocol named "cltomo" can be found at the xmipptomo plugin.
Its help description is:
  Averages a set of subtomograms taking into account the missing edge. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set of volumes: Set of volumes to align
Number of references: How many references are computed at the end of the process
Number of iterations: How many iterations at each of the Clustering levels
Generate aligned subvolumes: If set to true, it will be created a new set of volumes with all of them aligned
Align: Do not align if volumes are already aligned, only classify
Generate initial volume: Let CLTomo to automatically generate the initial references
Number of initial references: How many initial volumes. If set to 1, all subvolumes are aligned to a single reference, and then they are classified
Randomize orientation: Use this option if all the input volumes have the same missing wedge or if they have not been previously aligned.
Set of initial volumes: Set of initial volumes
Symmetry group: See http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/Symmetry for a description of the symmetry groups format.If no symmetry is present, give c1
Spatial mask: None
Maximum resolution (pixels^-1): The maximum (Nyquist) resolution is 0.5. Use smaller values, e.g. 0.45, to prevent high-resolution artifacts.
Sparsity in Fourier space: A value of 90 drops 90% of the smallest Fourier coefficients
Sparsity in wavelet space: A value of 95 drops 95% of the smallest wavelet coefficients
Maximum rotational angle: In degrees
Maximum tilt angle: In degrees
Maximum in-plane angle: In degrees
Maximum shift X: In voxels
Maximum shift Y: In voxels
Maximum shift Z: In voxels
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "local confidence maps" can be found at the xmipptomo plugin.
Its help description is:
 
    This protocol can be used with tilt series or with tomograms
    Tilt series: The algorithm estimates the local probabilities of each signal
    Tomograms:
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Has odd-even associated?: (True) The odd-even SetOfTiltSeries or the SetOfTomograms are internally associatedto the input SetOfTiltSeries or SetOfTomograms. (False) The user have to provide in the input the odd and even sets.
Input TiltSeres/Tomograms: Select the odd tomogram for estimating the confidence tomogram.
Odd tilt series/tomogram: Select the odd tilt series/tomogram for estimating the confidence tomogram.
Even tilt series/tomogram: Select the even tilt series/tomogram for estimating the  confidence map.
median filter: The mask determines which points are specimen and which are not.
Locality: Edge of the square local windows where local distribution of noise will be measured.
sigma: The mask determines which points are specimen and which are not.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "connected components" can be found at the xmipptomo plugin.
Its help description is:
  This protocol takes a set of coordinates and identifies connected
    components among the picked particles..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates: Select the SetOfCoordinates3D.
Distance: Maximum radial distance (in voxels) between particles to consider that they are in the same connected component. Wizard returns three times the box size of the input coordinates.

The protocol named "crop tomograms" can be found at the xmipptomo plugin.
Its help description is:
 
    Protocol to crop tomograms using xmipp_transform_window.
    The protocol allows to change the size of a tomogram/s, by removing the
    borders defined by the users
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tomograms: Select a set of tomograms to be cropped.
from: None
to: None
from: None
to: None
from: None
to: None

The protocol named "detect misalignment from fiducials" can be found at the xmipptomo plugin.
Its help description is:
 
    Wrapper protocol to Xmipp xmipp_deep_misalignment_detection for misalignment detection
    in tomographic reconstructions based on artifacted landmarks
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Fiducial 3D coordinates: 3D coordinates indicating the location of the fiducials (gold beads) in the tomogram. These fiducails will be the ones used to study misalignment artifacts over them. The coordinate denotes the center of the subtomogram
Tomogram source: By default the subtomograms will be extracted from the tomogram used in the picking step ( _same as picking_ option ). 
If you select _other_ option, you must provide a different tomogram to extract from. 
*Note*: In the _other_ case, ensure that provided tomogram and coordinates are related 
Input tomograms: Tomograms from which extract the fiducials (gold beads) at the specified coordinates locations.
Use misalignment threshold?: Threshold to settle if a tomogram presents weak or strong misalignment. If this value is not provided two output set of tomograms are generated, those discarded which present strong misalignment and those which do not. If this value is provided the second group of tomograms is splitted into two, using this threshold to settle if the tomograms presentor not a weak misalignment.
Misalignment threshold: Threshold value to settle if a tomogram presents weak or strong misalignment. Value ranged between (0, 1).
Model for weak misalignment estimation: Choose model for weak misalignment estimation. By default, strict model is picked in order to avoid false positives. In case loose model is chosen, less good aligned tomograms are lost. As a tradeoff, the number of false positives will increase.
Misalignment criteria: Criteria used for making a decision on the presence of misalignment on the tomogram based on the individual scores of each subtomogram. By default the mean of this scores is calculated. The other option is to implement a voting system based on if each subtomo score is closer to 0 o 1.

The protocol named "Dose filter" can be found at the xmipptomo plugin.
Its help description is:
 
    Tilt-series' dose filtering based on  T. Grant, N. Grigorieff, eLife 2015
    More info:
        https://doi.org/10.7554/eLife.06980
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series to be filtered.: None
Initial dose (e/sq A): Dose applied before any of the images in the input file were taken; this value will be added to all the prior dose values, however they were obtained.

The protocol named "extract particle stacks" can be found at the xmipptomo plugin.
Its help description is:
 
    Extract a set of particle stacks from a set of tilt series given a set of coordinates in the tomogram.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates: 3D coordinates to use in the extraction process.The coordinate denotes the center of the particle stack (subtomogram position)
Tilt Series: The particle stacks will be extracted from this set.
Box size: The particle stack are extracted as squares. The box size defines the edge of the square
Invert Contrast: Normally, tilt series has the contrast inverted with respect to standard for tilt series particles. It means, in the tomograms/recosntructions the structure is black and the noise is white. Generally, thetilt series particles are white with a black background. This means that the tilt series particles have the contrast inverted with respect to the tilt series. Put this flag as True if the contrastneed to be inverted.
Extract as SPA particles: False for a pure tilt series particles averaging treatment of the problem. True if the extractted particles will be used ina single Particle Analysis workflow.

The protocol named "extract subtomos" can be found at the xmipptomo plugin.
Its help description is:
 
    Extract a set of subtomograms from a set of tomograms given a set of coordinates.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates: 3D coordinates to use in the extraction process.The coordinate denotes the center of the subtomogram
Tomograms (Optional): The subtomograms will be extracted from this set.
Box size: The subtomograms are extracted as a cube. The box size defines the edge of the cube. This is the final size of the boxsize if downsampling is applied. The wizard selects same box size as picking
Dowsampling factor: The subtomograms are extracted as a cube. The box size defines the edge of the cubeThe wizard selects same box size as picking
Invert Contrast: Normally, tomograms has the contrast inverted with respect to standard for subtomograms. It means, in the tomograms the structure is black and the noise is white. Generally, thesubtomograms are white with a black background. This means that the subtomograms has the contrast inverted with respect to the tomograms. Put this flag as True if the contrastneed to be inverted.

The protocol named "Filter coordinates by map" can be found at the xmipptomo plugin.
Its help description is:
 Filter coordinate by map both given a mask or a resolucion map from a tomogram.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input 3D coordinates: Select the set of 3D coordinates to be filtered
Input Tomogram: Select the Set Of Tomograms to be used. The coordinatesmake references to their corresponding tomograms, then, thestatistics of the the enviroment of each coordinates willbe calculated. Thus it is possible to associate a mean, anda standard deviation to each coordinate.
Radius: Radius of the ball with center at the coordinate
Filter option: Select an option to filter the coordinates: 
 _Average_: Filter by Average value. 
_StandardDeviation_: Filter by Standard deviation value.
Average: Average value as threshold
std: std value as threshold
keep greater than the threshold: Set true if you want to keep values greater than the threshold. And set falseif the values lesser than the threshold will be discarded

The protocol named "half maps" can be found at the xmipptomo plugin.
Its help description is:
  Create half maps from a SetOfSubtomograms and its alignment .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Set of subtomograms: Set of subtomograms to be split into even and odd stacks

The protocol named "local Resolution MonoTomo" can be found at the xmipptomo plugin.
Its help description is:
 
    Given a tomogram the protocol assigns local resolutions to each voxel of the tomogram.
    To do that, thje protocol makes use of two half tomograms, called odd and even.
    These tomograms are reconstructed with the same alignment parameter but using the
    half of the data. For instance, the odd/even-images of the tilt series, or much
    better usign the odd/even frames of the movies (recommended). The result is a
    tomogram with the values of local resolution.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Odd tomogram: Select the odd tomogram for determining the local resolution tomogram.
Even Tomogram: Select the even tomogram for determining the  local resolution tomogram.
Use mask?: The mask determines which points are specimen and which are not.
Binary Mask: The mask determines which points are specimen and which are not
Significance: Relution is computed using hypothesis tests, this value determines the significance of that test
High: None
Low: None
Step: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "peak high contrast" can be found at the xmipptomo plugin.
Its help description is:
 
    Wrapper protocol to Xmipp image peak high contrast applied to any volume
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tomograms: Select a set of volumes to peak high contrast regions.
Fiducial size (nm): Size of the fiducial markers (or any other object) to be peaked in nanometers.
Box size: Size of the box containing the high contrast feature in pixels.
Run in relaxed mode?: If this option is selected coordinates are kept when none of them pass the mirror correlation filter. If not, and empty output is possible. This second case might happen if the tomogram does not present any gold bead or if it presents misalignment
Relaxed mode threshold: Minimum number of surviving coordinates to enter in relaxed mode.
Number of sampling slices: Number of slices used as a sample to calculate the threshold pixel value, for posterior high contrast regions detection.
Threshold for initial coordinates (SD): Number of standard deviations (SD) that a coordinate value must be over the mean in other to consider it a member of a high contrast feature.
Number of coordinates threshold: Number of coordinates that must be attracted by a center of mass to consider it a plausible high contrast feature.
Minimum mirror correlation: Minimum correlation between a feature and its mirror to consider it a fiducial.
Mahalanobis distance threshold: Maximum Mahalanobis distance of the radial average of the gold bead between all the peaked coordinates.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "phantom create subtomo" can be found at the xmipptomo plugin.
Its help description is:
  Create subtomogram phantoms .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
 : Import a volume or create 'base' phantom manually
Input volume: Volume used as 'base' phantom
Phantom description: create a phantom description: x y z backgroundValue geometry(cyl, sph...) +(superimpose) density value origin radius height rot tilt psi. More info at https://web.archive.org/web/20180813105422/http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/FileFormats#Phantom_metadata_file
Simulating tilt series: None
Sampling rate (A/px): None
Number of subtomograms: How many phantom subtomograms
Apply missing wedge?: Apply a filter to simulate the missing wedge along Y axis.
Missing wedge angle: Missing wedge (along y) for data between +- this angle.
Force a randomization seed: Activate to force same random results (useful for tests).
Apply rotation?: Apply a random rotation to the generated subtomograms. The subtomograms will present a randomorientation.
Randomly distributed?: Apply a random rotation to the generated subtomograms. The subtomograms will present a randomorientation.
Introduce random error with std: It introduces angular assignment errors with standard deviation given by the introduced valueIt is assumed that the errors are Gaussian.
std: It introduces angular assignment errors with standard deviation given by the introduced valueIt is assumed that the errors are Gaussian.
Min: None
Max: None
Min: None
Max: None
Min: None
Max: None
Apply random shift?: Apply a random shit to the generated subtomograms. The subtomograms will present a randomdisplacement from the center of the box.
Min (px): None
Max (px): None
Min (px): None
Max (px): None
Min (px): None
Max (px): None
Assign random coordinates?: Create random x, y, z coordinates for each subtomogram.
Tomograms: Tomograms to get dimension for random creation of coordinates
Add gaussian noise to subtomograms?: Select true to generate noisy subtomograms, and False to obtain clean subtomograms.
Add variable gaussian noise to subtomograms?: (False) Each subtomogram will follow a different noise distribution. All distribution are Gaussian, the noise of twodifferent subtomograms will follow two different Gaussian distributions. It means, given two subtomogramsA and B, the noise of the subtomogram A will follow a Gaussian distribution with mean mu_A, and std s_A,in contrast, the subtomograms B will follow also a Gaussian distribution but with different mean, mu_B, and different standard deviation s_B. If True, the noise of both subtomograms will follow the same Gaussiandistribution
Min: None
Max: None
mean: None
std: None

The protocol named "phantom tomograms" can be found at the xmipptomo plugin.
Its help description is:
  Create phantom tomograms with phantom particles and its coordinates with the right Scipion transformation matrix .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomogram dimensions: Tomogram dimensions: X, Y, Z
Sampling rate: None
Number of particles: How many particles in each tomogram
Number of tomograms: How many tomograms
Missing wedge angle: Missing wedge (along y) for data between +- this angle.
Add noise to the tomogram.: Add noise using xmipp_transform.
2 particles?: Add 2 different particles to allow for 3d classification
Min rot angle: Minimum and maximum range for each Euler angle in degrees
Max rot angle: None
Min tilt angle: None
Max tilt angle: None
Min psi angle: None
Max psi angle: None

The protocol named "project subtomograms" can be found at the xmipptomo plugin.
Its help description is:
 Extracts proyections from subtomograms.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Set of subtomograms: Set of subtomograms whose projections will be generated.
Clean temporary files: : Clean temporary files after finishing the execution.
This is useful to reduce unnecessary disk usage.
Transform method: : Select the algorithm that will be used to obtain the projections.
Tilt range start:: The initial value of the range of angles the projection will be produced on.
Defaults to -60º.
Tilt range end:: The final value of the range of angles the projection will be produced on.
Defaults to 60º.
Type of sample generation: : Select either the number of samples to be taken or the separation in degrees between each sample.
Number of samples:: Number of samples to be produced.
It has to be 1 or greater.
Step:: Number of degrees each sample will be separated from the next.
It has to be greater than 0.

The protocol named "reconstruct tomogram" can be found at the xmipptomo plugin.
Its help description is:
 
    Given a set of Tilt series with the corresponding alignment parameters. This protocol
    will reconstruct the tomograms associated to the tilt series..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tilt Series: Select the Set of Tilt Series that will be used to reconstruct the tomograms.
Reconstruction Algorithm: Select an option to reconstruct tomograms: 
 _ART_: Arithmetic reconstruction technique. 
_SIRT_: (only with MPI) Simultaneous Iterative Reconstruction Technique. 
 
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "resize tilt-series" can be found at the xmipptomo plugin.
Its help description is:
 
    Wrapper protocol to Xmipp image resize applied on tilt-series
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: Select a set of tilt-series to be resized.
Resize option: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Factor_: Set a resize factor to resize. 
 _Pyramid_: Use positive level value to expand and negative to reduce. 
Pyramid uses spline pyramids for the interpolation. All the rest uses normally 
interpolation (cubic B-spline or bilinear interpolation).
Resize sampling rate (Å/px): Set the new output sampling rate.
Resize factor: New size is the old one x resize factor.
Pyramid level: Use positive value to expand and negative to reduce.
Huge file: If the file is huge, very likely you may have problems doing the antialiasing filter (because there is no memory for the input and its Fourier transform). This option removes the antialiasing filter (meaning you will get aliased results), and performs a bilinear interpolation (to avoid having to produce the B-spline coefficients).

The protocol named "resize tomograms" can be found at the xmipptomo plugin.
Its help description is:
 
    Protocol to to resize tomograms using xmipp_image_resize.
    The protocol allows to change the size of a tomogram/s by means
    of different methods
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tomograms: Select a set of tomograms to be resized.
Resize option: Select an option to resize the images: 
 _Sampling Rate_: Set the desire sampling rate to resize. 
_Factor_: Set a resize factor to resize. 
 _Pyramid_: Use positive level value to expand and negative to reduce. 
Pyramid uses spline pyramids for the interpolation. All the rest uses normally 
interpolation (cubic B-spline or bilinear interpolation).
Resize sampling rate (Å/px): Set the new output sampling rate.
Resize factor: New size is the old one x resize factor.
Pyramid level: Use positive value to expand and negative to reduce.
Huge file: If the file is huge, very likely you may have problems doing the antialiasing filter (because there is no memory for the input and its Fourier transform). This option removes the antialiasing filter (meaning you will get aliased results), and performs a bilinear interpolation (to avoid having to produce the B-spline coefficients).

The protocol named "imagej roi" can be found at the xmipptomo plugin.
Its help description is:
  Tomogram ROI selection in IJ .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select tomograms.

The protocol named "score/filter coordinates" can be found at the xmipptomo plugin.
Its help description is:
 Scoring and (optional) filtering of coordinates based on different scoring
    functions (carbon distance, neighbour distance).
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input 3D coordinates: Select the set of 3D coordinates to compare
Operation mode: Determine whether to retrieve all the coordinates scored or to filter out unwanted coordinates based on a threshold
Score outluiers?: None
Outliers distance threshold: Z-Score value from 0 to infinite. Only coordinates with a Z-Score smaller than or equal to the threshold will be kept in the output
Score carbon closeness?: None
Carbon distance threshold: Score value between 0 and 1. Only coordinates with a score larger than or equal to the threshold will be kept in the output

The protocol named "subtomo alignment consensus" can be found at the xmipptomo plugin.
Its help description is:
 Protocol to score a series of alignments stored in a SetOfSubtomograms by
    quaternion distance analysis.

    xmipp_alignmentDistance ranges from 0º to 180º. Therefore, a 0º distance is the best and means alignment is the same.
    The lower the score the more similar is the alignment.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
First Subtomograms to compare: None
Second Subtomograms to compare: None

The protocol named "split tilt-series" can be found at the xmipptomo plugin.
Its help description is:
 
    Wrapper protocol to Xmipp split Odd Even on tilt-series
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: Select a set of tilt-series to be split into two sets (odd and even).It means, the set of tilt-series is split in two subsets.

The protocol named "map back subtomos" can be found at the xmipptomo plugin.
Its help description is:
  This protocol takes a tomogram, a reference subtomogram and a metadata with geometrical parameters
   (x,y,z) and places the reference subtomogram on the tomogram at the designated locations (map back).
   It has different representation options..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Select input type: Class: input is a class generated previously in Scipion.
Subtomograms: input is a set of subtomograms previously aligned.
Class: Subtomogram class from which the coordinates of the subtomograms and the reference will be used. It should be a SetOfClassesSubTomograms with just 1 item.
Subtomograms/coordinates: Subtomograms to be mapped back, they should have alignment and coordinates.
Reference: Subtomogram reference, average, representative or initial model of the subtomograms.
Original tomograms: Original tomograms from which the subtomograms were extracted
Invert reference contrast: Invert the contrast if the reference is black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background. 
Painting mode: The program has several painting options:
*Copy*: Copying the reference onto the tomogram.
*Average*: Setting the region occupied by the reference in the tomogram to the average value of that region.
*Highlight*: Add the reference multiplied by a constant to the location specified.
*Binarize*: Copy a binarized version of the reference onto the tomogram.
Remove background: Set tomogram to 0
Threshold: threshold applied to tomogram
Multiplier: constant to multiply the reference
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "subtomo projection" can be found at the xmipptomo plugin.
Its help description is:
 
    Project a set of volumes or subtomograms to obtain their X, Y or Z projection of the desired range of slices.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volumes: This protocol can *not* work with .em files *if* the input is a set of tomograms or a set of volumes, 
Compute radial average?: Compute the radial average with respect to Z of the input volumes and from them, it computes their projections in the desired direction
Projection direction: None
Range of slices: Range of slices used to compute the projection, where 0 is the central slice.
Slices: Crop this amount of voxels in each side of the selected direction.
Ignore orientations: Activate to ignore particle orientation information.

The protocol named "subtomo subtraction" can be found at the xmipptomo plugin.
Its help description is:
  This protocol subtracts a subtomogram average to a SetOfSubtomograms, which are internally aligned and
    numerically adjusted in order to obtain reliable results. The adjustment and subtraction is perfomed by
    xmipp_volume_subtraction program. A mask can be provided if the user wants to perform the subtraction in a
    determined region..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Subtomograms : Select the SetOfSubTomograms with transform matrix which will be subtracted.
Average subtomogram : Select an average subtomogram to be subtracted.
Mask subtomograms?: The mask are not mandatory but highly recommendable.
Average mask: Specify a mask for the average.
Subtraction mask: Optional, specify a mask for the region of subtraction
Filter at resolution: : Resolution (A) at which subtraction will be performed, filtering the input volumes.Value 0 implies no filtering.
Decay of the filter (sigma): : Decay of the filter (sigma parameter) to smooth the mask transition
Number of iterations: : None
Relaxation factor (lambda): : Relaxation factor for Fourier amplitude projector (POCS), it should be between 0 and 1, being 1 no relaxation and 0 no modification of volume 2 amplitudes
Save intermediate files?: Save input volume 1 (first subtomogram of the set) filtered and input volume 2 (average) adjusted, which are the volumes that are really subtracted.

The protocol named "tiltseries FlexAlign" can be found at the xmipptomo plugin.
Its help description is:
 
    Simple protocol to average TiltSeries movies as basic
    motion correction. It is used mainly for testing purposes.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tilt-Series (movies): Select input tilt-series movies that you wantto correct for beam-induced motion. 
from: None
to: None
Use ALIGN frames range to SUM?: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Save aligned micrograph: None
Save movie: Save Aligned movie
Split & sum odd/even frames?: Generate odd and even sums using odd and even frames respectively when this option is enabled.
: This protocol has both CPU and GPU implementation.                       Select the one you want to use.
: Add a list of GPU devices that can be used
Maximum resolution (A): Maximum resolution in A that will be preserved during correlation.
Compute PSD?: If Yes, the protocol will compute PSD for each movie before and after the alignment
Maximum shift (A): Maximum allowed distance (in A) that each frame can be shifted with respect to the next.
Compute local alignment?: If Yes, the protocol will try to determine local shifts, similarly to MotionCor2.
Auto control points: If on, protocol will automatically determine necessary number of control points.
X: None
Y: None
t: None
Auto patches: If on, protocol will automatically determine necessary number of patches.
X: None
Y: None
Min size of the patch (A): How many A should contain each patch?
Group N frames: Group every specified number of frames by adding them together.                         The alignment is then performed on the summed frames.
Rotate gain reference:: Rotate gain reference counter-clockwise.
Flip gain reference:: Flip gain reference after rotation. For tiff movies, gain is automatically upside-down flipped

The protocol named "Apply transformation" can be found at the imod plugin.
Its help description is:
 
    Compute the interpolated tilt-series from its transform matrix.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/newstack.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Binning: Binning to be applied to the interpolated tilt-series in IMOD convention. Images will be binned by the given factor. Must be an integer bigger than 1
Apply to odd/even: If True, the full tilt series and the associated odd/even tilt series will be processed. The transformations applied to the odd/even tilt series will be exactly the same.

The protocol named "CTF estimation (auto)" can be found at the imod plugin.
Its help description is:
 
    CTF estimation of a set of input tilt-series using the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/ctfplotter.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: This should be a *raw stack*, not an aligned stack, because the interpolation used to make an aligned stack attenuates high frequencies and the noise power spectra would no longer match.
Defocus tolerance (nm): Defocus tolerance in nanometers defining the center strips. The center strips are taken from the central region of a view that has defocus difference less than this tolerance. These kind of center strips from all views within AngleRange are considered to have a constant defocus and are used to compute the initial CTF after being further tessellated into tiles.
Input expected defocus as:: None
Expected defocus value (nm): This value will be applied as the expected defocus in nanometers for every tilt-series from the set.
Expected defocus file: File containing the expected defocus in nanometers for each tilt-series belonging to the set.

The format of the text file must be two columns, the first one being the tilt series ID and the second the defocus value.

An example of this file comes as follows:
TS_01 4000
TS_02 1500
...
Left defocus tolerance (nm): Defocus tolerance in nanometers for strips to the left of the center strip.
Right defocus tolerance (nm): Defocus tolerance in nanometers for strips to the right of the center strip.
Tile size (px): The tile size each strip will be tessellated into. The size is in pixels and the tiles are square. Each view is first divided into strips that are considered to have constant defocus.
Angle step: Step size between ranges. A value of zero for the step will make it fit to each single image separately, regardless of the value for the range.
Angle range: Size of the angle range for which the CTF is estimated.
Start: Starting frequency (X1 starts)
End: Ending frequency (X2 ends)
Extra zeros to fit: By default, the ending frequency of the fitting range is set to the expected location of the second zero. With this entry, the range will be extended by the given multiple of the interval between first and seconds zeros. For example, entries of 1 and 2 will fit approximately to the third and fourth zeros, respectively. An entry of more than 0.5 will trigger fitting to two exponentials, which is important for fitting multiple peaks between zeros.
Skip astigmatic phase views?: Skip or break views only when finding astigmatism or phase shift
Search astigmatism?: Search for astigmatism when fitting.
Maximum astigmatism (um): Maximum astigmatism, in microns. During the fitting to wedge spectra, the defocus is allowed to vary from the global value by more than half of this amount.
Number of sectors: Number of sectors for astigmatism analysis.  A power spectrum is stored separately for each sector; spectra can then be computed fairly quickly for wedges of any size that is a multiple of the sector size. The default is 36, giving 5 degree sectors.
Minimum views astigmatism: Minimum number of views for finding astigmatism.
Search phase shift?: Search for phase shift when fitting.
Minimum views phase shift: Minimum number of views for finding phase shift.
Search cut-on frequency?: Search for cut-on frequency when finding phase shift.
Maximum astigmatism (1/nm): Maximum frequency to test when searching for cut-on frequency, in reciprocal nanometers.  The default is the frequency of the first zero at the expected defocus and phase shift. To use the default value set box to -1.

The protocol named "CTF correction" can be found at the imod plugin.
Its help description is:
 
    CTF correction of a set of input tilt-series using the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/ctfphaseflip.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tilt-series: Select the set of tilt-series to be CTF corrected. Usually this will be the tilt-series with alignment information.
Input CTF estimation: Select the CTF estimation for the set of tilt-series.
Defocus tolerance (nm): The value introduced must be the same used for CTF estimation with IMOD.

Defocus tolerance in nanometers defining the center strips. The center strips are taken from the central region of a view that has defocus difference less than this tolerance. These kind of center strips from all views within AngleRange are considered to have a constant defocus and are used to compute the initial CTF after being further tessellated into tiles.
Interpolation width (px): The distance in pixels between the center lines of two consecutive strips. A pixel inside the region between those two center lines resides in both strips. As the two strips are corrected separately, that pixel will have 2 corrected values. The final value for that pixel is a linear interpolation of the 2 corrected values. If a value of 1 is entered, there is no such interpolation. For a value greater than one, the entered value will be used whenever the strip width is less than 256 (i.e., at high tilt), and the value will be scaled proportional to the strip width for widths above 256.  This scaling keeps the computational time down and is reasonable because the defocus difference between adjacent wide strips at wider intervals is still less than that between the narrower strips at high tilt. However, strips at constant spacing can still be obtained by entering the negative of the desired spacing, which disables the scaling of the spacing.
: This protocol has both CPU and GPU implementation.Select the one you want to use.
: GPU ID. To pick the best available one set 0. For a specific GPU set its number ID (starting from 1).
Correct odd/even: If True, the full tilt series and the associated odd/even tilt series will be processed. The CTF correction applied to the odd/even tilt series will be exactly the same.

The protocol named "Dose filter" can be found at the imod plugin.
Its help description is:
 
    Tilt-series dose filtering based on the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/mtffilter.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Initial dose (e/sq. Å): Dose applied before any of the images in the input file were taken; this value will be added to all the dose values.
Input dose source: Where to find the dose information:
- Scipion import: use the dose provided during import of the tilt-series
- Fixed dose: manually input fixed dose for each image of the input file, in electrons/square Ångstrom.
Fixed dose (e/sq Å): Fixed dose for each image of the input file, in electrons/square Ångstrom.
Filter odd/even: If True, the full tilt series and the associated odd/even tilt series will be processed. The applied dose for the odd/even tilt series will be exactly the same.

The protocol named "Etomo interactive" can be found at the imod plugin.
Its help description is:
 
    Simple wrapper around etomo to manually reconstruct a Tomogram.

    More info:
        https://bio3d.colorado.edu/imod/doc/etomoTutorial.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: Input set of tilt-series to be processed with eTomo.
Fiducial markers diameter (nm): Diameter of gold beads in nanometers.
Apply transformation matrix?: Apply the transformation matrix if inputtilt series have it.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Exclude views" can be found at the imod plugin.
Its help description is:
 
    excludeviews - Reversibly remove views from a tilt series stack

    By default, the protocol will remove disabled tilt images from the input TS.
    Alternatively, you can provide a text file with a list of tilts to exclude.

    If you use this protocol, make sure this output tilt series is use for everything else
    CTF estimation, per particle per tilt, tomogram reconstruction....
    More info:
        https://bio3d.colorado.edu/imod/doc/man/excludeviews.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Exclude views file: File containing the views to be excluded for each tilt-series belonging to the set.

The format of the text file must be two columns, the first one being the tilt series ID of the series from which the views will be excluded and the second the views to exclude, numbered from 1. The syntax for this exclude list is a comma separated list of ranges with no spaces between them (e.g., 1,4-5,60-70). 

An example of this file comes as follows:
TS_01 1,4-6,8,44-47
TS_02 3,10-12,24
...

The protocol named "Fiducial alignment" can be found at the imod plugin.
Its help description is:
 
    Construction of a fiducial model and alignment of tilt-series based
    on the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/tiltalign.html
        https://bio3d.colorado.edu/imod/doc/man/model2point.html
        https://bio3d.colorado.edu/imod/doc/man/imodtrans.html
        https://bio3d.colorado.edu/imod/doc/man/newstack.html
        https://bio3d.colorado.edu/imod/doc/man/ccderaser.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of fiducial models.: None
Find beads on two surfaces?: Track fiducials differentiating in which side of the sample are located.
IMPORTANT: It is highly recommended to match the option selected in the generation of the fiducial models. In case they do not match, it is not intended to fail but could be missing the whole potential of the algorithm. In case the algorithm used fot he calculationof the fiducial models does not consider this option it is algo recomended to set this option to 'No'.
Generate interpolated tilt-series?: Generate and save the interpolated tilt-series applying the obtained transformation matrices.
Binning: Binning to be applied to the interpolated tilt-series in IMOD convention. Images will be binned by the given factor. Must be an integer bigger than 1
Rotation solution type: Type of rotation solution.
Group size: Size of the rotation group
Magnification solution type: Type of magnification solution.
Group size: Size of the magnification group
Tilt angle solution type: Type of tilt angle solution.
Group size: Size of the tilt angle group
Distortion solution type: Type of distortion solution.
X stretch group size: Basic grouping size for X stretch
Skew group size: Size of the skew group
Erase gold beads: Remove the gold beads detected during fiducial alignment with *ccderaser* program. This option will generate an interpolated tilt series with the gold beads erased and interpolated with the calculated transformation matrices form the alignment.
Bead diameter (px): For circle objects, this entry specifies a radius to use for points without an individual point size instead of the object's default sphere radius. This entry is floating point and can be used to overcome the limitations of having an integer default sphere radius. If there are multiple circle objects, enter one value to apply to all objects or a value for each object.

The protocol named "Generate fiducial model" can be found at the imod plugin.
Its help description is:
 
    Construction of a fiducial model and alignment of tilt-series based
    on the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/autofidseed.html
        https://bio3d.colorado.edu/imod/doc/man/beadtrack.html
        https://bio3d.colorado.edu/imod/doc/man/model2point.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Fiducial diameter (nm): Fiducials diameter to be tracked for alignment.
Find beads on two surfaces?: Track fiducials differentiating in which side of the sample are located.
Number of fiducials: Number of fiducials to be tracked for alignment.
Track with fiducial model as seed: Turn the tracked model into new seed and repeat tracking.
Shifts near zero fraction: Fraction of the tracking box size above which to supply shifts near zero tilt to Beadtrack. The dominant net shifts in the bead positions between views are found as described above, and if one of the shifts is larger than this fraction of the -BoxSizeXandY entry to Beadtrack, then the shifts are provided when running Beadtrack on the initial seed models. Also, a command file will be written with modified parameters, named as the root name of the input command file followed by '_adjusted' and its extension. Enter 0 or a large value to disable this analysis.
Refine center with Sobel filter?: Use edge-detecting Sobel filter to refine the bead positions.
Sobel sigma relative to bead size: Sigma for gaussian kernel filtering of single beads before Sobel filtering, as fraction of bead diameter. The default sigma is 0.5 pixels regardless of bead size. A value of around 0.12 diameters is needed for higher noise (eg. cryo) data.

The protocol named "Gold bead picker 3D" can be found at the imod plugin.
Its help description is:
 
    3-dimensional gold bead picker using the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/findbeads3d.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tomograms: Input set of tomograms from which gold beads will be picked. A tomogram needs to be thicker than normal because the program cannot find beads too close to the surfaces of a tomogram.
Fiducials diameter (px): Diameter of beads in pixels.
Bead contrast: Contrast of the gold beads:
-Dark: beads are dark on light background.
-Light: beads are light on dark background.
Minimum relative strength: Minimum relative peak strength for keeping a peak in the analysis.  The square root of the specified value is used for comparing with the square root of peak strength, for compatibility with existing command files. The default is 0.05, which corresponds to a relative square root peak strength of 0.22. Too many weak peaks can prevent a dip from showing up in the smoothed histogram of strengths.  If the program fails to find a histogram dip, one strategy is to try raising this value.
Minimum spacing: Minimum spacing between peaks as a fraction of the bead size. When two peaks are closer than this distance apart, the weaker one is eliminated unless the -both option is entered. The default is 0.9. A value less than 1 is helpful for picking both beads in a pair.

The protocol named "Import transformation matrix" can be found at the imod plugin.
Its help description is:
 
    Import the transformation matrices assigned to an input set of tilt-series
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Exclusion words:: List of words separated by a space that the path should not have
Input set of tilt-series: Set of tilt-series on which transformation matrices will be assigned.
Transformation matrix binning: Binning of the tilt series at which the transformation matrices were calculated.
Tilt-series binning: Binning of the tilt-series.

The protocol named "CTF estimation (manual)" can be found at the imod plugin.
Its help description is:
 
    CTF estimation of a set of input tilt-series using the IMOD procedure.
    Runs the protocol through the interactive GUI. The resulting defocus values
    MUST BE SAVED manually by the user.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/ctfplotter.html

    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: This should be a *raw stack*, not an aligned stack, because the interpolation used to make an aligned stack attenuates high frequencies and the noise power spectra would no longer match.
Defocus tolerance (nm): Defocus tolerance in nanometers defining the center strips. The center strips are taken from the central region of a view that has defocus difference less than this tolerance. These kind of center strips from all views within AngleRange are considered to have a constant defocus and are used to compute the initial CTF after being further tessellated into tiles.
Input expected defocus as:: None
Expected defocus value (nm): This value will be applied as the expected defocus in nanometers for every tilt-series from the set.
Expected defocus file: File containing the expected defocus in nanometers for each tilt-series belonging to the set.

The format of the text file must be two columns, the first one being the tilt series ID and the second the defocus value.

An example of this file comes as follows:
TS_01 4000
TS_02 1500
...
Left defocus tolerance (nm): Defocus tolerance in nanometers for strips to the left of the center strip.
Right defocus tolerance (nm): Defocus tolerance in nanometers for strips to the right of the center strip.
Tile size (px): The tile size each strip will be tessellated into. The size is in pixels and the tiles are square. Each view is first divided into strips that are considered to have constant defocus.

The protocol named "Tilt-series preprocess" can be found at the imod plugin.
Its help description is:
 
    Normalize input tilt-series and change its storing formatting.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/newstack.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Binning: Binning to be applied to the normalized tilt-series in IMOD convention. Images will be binned by the given factor. Must be an integer bigger than 1
Apply transformation matrix: Apply the tilt series transformation matrix if tilt series have them
Adjust densities mode: Adjust densities of sections individually:
-Default: no adjustment performed
-Mode 1: sections fill the data range
-Mode 2: sections scaled to common mean and standard deviation.
-Mode 3: sections shifted to a common mean without scaling
-Mode 4: sections shifted to a common mean and then rescale the resulting minimum and maximum densities to the Min and Max values specified
Storage data type: Apply one density scaling to all sections to map current min and max to the given Min and Max. The storage mode of the output file. The default is the mode of the first input file, except for a 4-bit input file, where the default is to output as bytes
Set scaling range values?: This option will rescale the densities of all sections by the same factors so that the original minimum and maximum density will be mapped to the Min and Max values that are entered
Max.: Maximum value for the rescaling
Min.: Minimum value for the rescaling
Antialias method:: Type of antialiasing filter to use when reducing images.
The available types of filters are:

None
Blackman - fast but not as good at antialiasing as slower filters
Triangle - fast but smooths more than Blackman
Mitchell - good at antialiasing, smooths a bit
Lanczos 2 lobes - good at antialiasing, less smoothing than Mitchell
Lanczos 3 lobes - slower, even less smoothing but more risk of ringing
The default is Lanczos 3 as of IMOD 4.7. Although many people consider Lanczos 2 the best compromise among the various factors, that sentiment may be based on images of natural scenes where there are sharp edges.
Set mean and SD?: Set mean and SD values
Mean: Mean value for the rescaling
SD: Standard deviation value for the rescaling
Max.: Maximum value for the rescaling
Min.: Minimum value for the rescaling
Apply to odd/even: If True, the full tilt series and the associated odd/even tilt series will be processed. The transformations applied to the odd/even tilt series will be exactly the same.

The protocol named "Tomo preprocess" can be found at the imod plugin.
Its help description is:
 
    Normalize input tomogram and change its storing formatting.
    More info:
        https://bio3D.colorado.edu/imod/doc/newstack.html
        https://bio3D.colorado.edu/imod/doc/binvol.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tomograms: None
Binning: Binning to be applied to the normalized tomograms in IMOD convention. Volumes will be binned by the given factor. Must be an integer bigger than 1
Adjust densities mode: Adjust densities of sections individually:
-Default: no adjustment performed
-Mode 1: sections fill the data range
-Mode 2: sections scaled to common mean and standard deviation.
-Mode 3: sections shifted to a common mean without scaling
-Mode 4: sections shifted to a common mean and then rescale the resulting minimum and maximum densities to the Min and Max values specified
Storage data type: Apply one density scaling to all sections to map current min and max to the given Min and Max. The storage mode of the output file. The default is the mode of the first input file, except for a 4-bit input file, where the default is to output as bytes
Set scaling range values?: This option will rescale the densities of all sections by the same factors so that the original minimum and maximum density will be mapped to the Min and Max values that are entered
Max.: Maximum value for the rescaling
Min.: Minimum value for the rescaling
Antialias method:: Type of antialiasing filter to use when reducing images.
The available types of filters are:

None
Blackman - fast but not as good at antialiasing as slower filters
Triangle - fast but smooths more than Blackman
Mitchell - good at antialiasing, smooths a bit
Lanczos 2 lobes - good at antialiasing, less smoothing than Mitchell
Lanczos 3 lobes - slower, even less smoothing but more risk of ringing
The default is Lanczos 3 as of IMOD 4.7. Although many people consider Lanczos 2 the best compromise among the various factors, that sentiment may be based on images of natural scenes where there are sharp edges.
Set mean and SD?: Set mean and SD values
Mean: Mean value for the rescaling
SD: Standard deviation value for the rescaling
Max.: Maximum value for the rescaling
Min.: Minimum value for the rescaling
Process odd/even?: If True, the full tilt series and the associated odd/even tilt series will be processed. The transformations applied to the odd/even tilt series will be exactly the same.

The protocol named "Tomo projection" can be found at the imod plugin.
Its help description is:
 
    Re-project a tomogram given a geometric description (axis and angles).
    More info:
        https://bio3d.colorado.edu/imod/doc/man/xyzproj.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tomograms: None
Minimum angle of rotation: Minimum angle of the projection range
Maximum angle of rotation: Maximum angle of the projection range
Step angle: Step angle of the projection range
Rotation axis for projection: Axis to tilt around (X, Y, or Z). Y axis usually corresponds to the typical rotation axis acquisition.

The protocol named "Tomo reconstruction" can be found at the imod plugin.
Its help description is:
 
    Tomogram reconstruction procedure based on the IMOD procedure.

    More info:
        https://bio3d.colorado.edu/imod/doc/man/tilt.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Tomogram thickness (voxels): Size in voxels of the tomogram in the z axis (beam direction).
Tomogram shift in X: This entry allows one to shift the reconstructed slice in X before it is output.  If the X shift is positive, the slice will be shifted to the right, and the output will contain the left part of the whole potentially reconstructable area.
Tomogram width (voxels): Number of pixels to cut out in X, centered on the middle in X. Leave 0 for default X.
Tomogram shift in Z: This entry allows one to shift the reconstructed slice in Z before it is output. If the Z shift is positive, the slice is shifted upward. The Z entry is optional and defaults to 0 when omitted.
Angle offset: Apply an angle offset in degrees to all tilt angles. This offset positively rotates the reconstructed sections anticlockwise.
Tilt axis offset: Apply an offset to the tilt axis in a stack of full-sized projection images, cutting the X-axis at  NX/2. + offset instead of NX/2. The DELXX entry is optional and defaults to 0 when omitted.
Super-sampling factor: Compute slices in pixels smaller by this factor to reduce artifacts.
Iterations of a SIRT-like equivalent filter: Modify the radial filter to produce a reconstruction equivalent to the one produced by the given number of iterations of SIRT. The Gaussian filter is applied at the high-frequency end of the filter. The functioning of this filter is described in: 
	https://bio3d.colorado.edu/imod/doc/man/tilt.html
First parameter: Linear region value
Second parameter: Gaussian fall-off parameter
: This protocol has both CPU and GPU implementation. Select the one you want to use.
: GPU ID. To pick the best available one set 0. For a specific GPU set its number ID (starting from 1).
Reconstruct odd/even?: If True, the full tilt series and the associated odd/even tilt series will be reconstructed. The alignment applied to the odd/even tilt series will be exactly the same.

The protocol named "Coarse prealignment" can be found at the imod plugin.
Its help description is:
 
    Tilt-series cross correlation alignment based on the IMOD procedure.
    More info:
        https://bio3d.colorado.edu/imod/doc/man/tiltxcorr.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Use cumulative correlation?: With this option, the program will take the image at zero tilt as the firstreference, and correlate it with the image at the next most negative tilt.It will then add the aligned image to the first reference to make the reference for the next tilt.  At each tilt, the reference will be the sum of images that have already been aligned. When the most negative tilt angle is reached, the procedure is repeated from the zero-tilt view to more positive tilt angles.
Generate interpolated tilt-series?: Generate and save the interpolated tilt-series applying the obtained transformation matrices.
Binning for the interpolated: Binning to be applied to the interpolated tilt-series in IMOD convention. Images will be binned by the given factor. Must be an integer bigger than 1
Tilt axis angle detected from import. In case another value is desired please adjust the number below: None
Tilt axis angle (degrees): The tilt axis angle is the tilt axis rotation relative to the Y axis of the image.If it was not properly set in the import of the tilt series, or the importedinformation is not correct you have the chance to correct at in this point.Usually, it will be 90 degrees less than the RotationAngle in a system with no axis inversions
left: None
right: None
top: None
botton: None
Filter radius 1: None
Filter sigma 1: None
Filter radius 2: None
Filter sigma 2: None

The protocol named "X-rays eraser" can be found at the imod plugin.
Its help description is:
 
    Erase X-rays from aligned tilt-series based on the IMOD procedure.
    More info:
            https://bio3d.colorado.edu/imod/doc/man/ccderaser.html
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Peak criterion: Criterion # of SDs above local mean for erasing peak based on intensity (the default is 8 SDs)
Difference criterion: Criterion # of SDs above mean pixel-to-pixel difference for erasing a peak based on differences (the default is 6 SDs).
Maximum radius (px): Maximum radius of peak area to erase (the default is 4.2 pixels).
Big difference criterion: An extra-large peak will be erased only if the value for the maximum difference between adjacent pixels, averaged over the most extreme one-fourth of the pixels in the patch, exceeds this criterion, evaluated as the number of SDs above the mean absolute difference between adjacent pixels in the scan area. The default is 19.  This high a value is needed to prevent gold erasure on low-noise data sets with small gold particles, and a lower value may be needed to make extra-large peak removal useful.
Apply to odd/even: If True, the full tilt series and the associated odd/even tilt series will be processed. The filter applied to the odd/even tilt series will be exactly the same.

The protocol named "import 3D coordinates" can be found at the reliontomo plugin.
Its help description is:
 Protocol to import a 3D coordinates from a relion star file as the one provided in the tutorial.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Star file: None
Tomograms: Tomograms to which the coordinates will be referred.
Coordinates sampling rate [Å/pix] (opt.): If empty, the protocol will try to read it from the label "_rrlnDetectorPixelSize" if it is present in the introduced star file. If not find, it will be considered to be the same as the tomograms. The ratio of both tomograms and coordinates sampling rate will be used to scale the coordinates properly to the tomograms introduced if they are different
Box Size [pix]: None

The protocol named "import subtomograms from a star file" can be found at the reliontomo plugin.
Its help description is:
 Protocol to import a set of subtomograms from a star file.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Star file: None
Tomograms: Tomograms to which the coordinates will be referred.
Coordinates sampling rate [Å/pix] (opt.): If empty, the protocol will try to read it from the label "_rrlnDetectorPixelSize" if it is present in the introduced star file. If not find, it will be considered to be the same as the tomograms. The ratio of both tomograms and coordinates sampling rate will be used to scale the coordinates properly to the tomograms introduced if they are different
Box Size [pix]: None

The protocol named "3D Classification of subtomograms" can be found at the reliontomo plugin.
Its help description is:
 3D Classification of subtomograms..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Reference volume: Initial reference 3D map, it should have the same dimensions and the same pixel size as your input particles.
Reference mask (optional): A volume mask containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask. If no mask is given, a soft spherical mask based on the <radius> of the mask for the experimental images will be applied.

In some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. Check _Advaced_ parameters to select another volume mask.
Second reference mask (optional): For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas.
Is initial 3D map on absolute greyscale?: Perform CC-calculation in the first iteration (use this if references are not on the absolute intensity scale). See detailed explanation below:

 Probabilities are calculated based on a Gaussian noise model,which contains a squared difference term between the reference and the experimental image.

 This has a consequence that the reference needs to be on the same absolute intensity greyscale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity greyscale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. But, if the map wasreconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No.

If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent map refinement. Therefore, if in doubt it is recommended to set this option to No.
Initial low-pass filter (A): It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s).
Symmetry group: Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Number of classes to be defined: None
Regularisation parameter T: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. If it's set to 0, no regularisation will be applied. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D initial model calculations.
Number of iterations: Number of iterations to be performed. Note that the current implementation of 2D class averaging and 3D classification does NOT comprise a convergence criterium. Therefore, the calculations will need to be stopped by the user if further iterations do not yield improvements in resolution or classes.
Use fast subsets (for large data sets)?: If set to Yes, the first 5 iterations will be done with random subsets of only K*1500 particles (K being the number of classes); the next 5 with K*4500 particles, the next 5 with 30% of the data set; and the final ones with all data. This was inspired by a cisTEM implementation by Niko Grigorieff et al.
Circular mask diameter (Å): Diameter of the circular mask that will be applied to the experimental images (in Angstroms)
Mask individual particles with zeros?: If set to Yes, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform.

This will remove noise and therefore increase sensitivity in the alignment and classification.

However, it will also introduce correlations between the Fourier components that are not modelled. When set to No, then the solvent area is filled with random noise, which prevents introducing correlations.

High-resolution refinements (e.g. ribosomes or other large complexes in 3D auto-refine) tend to work better when filling the solvent area with random noise (i.e. setting this option to No), refinements of smaller complexes and most classifications go better when using zeros (i.e. setting this option to Yes).
Limit resolution E-step to (Å): If set to a positive number, then the expectation step (i.e. the alignment) will be done only including the Fourier components up to this resolution (in Angstroms).

This is useful to prevent overfitting, as the classification runs in RELION are not guaranteed to be 100% overfitting-free (unlike the 3D auto-refine with its gold-standard FSC). In particular for very difficult data sets, e.g. of very small or featureless particles, this has been shown to give much better class averages. 

In such cases, values in the range of 7-12 Angstroms have proven useful.
Perform image alignment?: If set to No, then rather than performing both alignment and classification, only classification will be performed. This allows the use of very focused masks. It requires that the optimal orientations of all particles are already stored in the input STAR file.
Initial angular sampling interval (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
Initial offset range (pix.): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
Initial offset step (pix.): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluatedon a 2x coarser grid.
Perform local angular searches?: If set to Yes, then rather than performing exhaustive angular searches, local searches within the range given below will be performed.

A prior Gaussian distribution centered at the optimal orientation in the previous iteration and with a stddev of 1/3 of the range given below will be enforced.
Local angular search range (deg.): Local angular searches will be performed within +/- the given amount (in degrees) from the optimal orientation in the previous iteration.

A Gaussian prior (also see previous option) will be applied, so that orientations closer to the optimal orientation in the previous iteration will get higher weights than those further away.
Symmetry to be relaxed: With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020 cited in the About dialog.

Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
Allow coarser sampling?: If set to Yes, the program will use coarser angular and translational samplings if the estimated accuracies of the assignments are still low in the earlier iterations. This may speed up the calculations.
Use parallel disc I/O?: If set to Yes, all MPI followers will read their own images from disc. Otherwise, only the leader will read images and send them through the network to the followers. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many followers reading in parallel. If your datasets contain particles with different box sizes, you have to say Yes.
Number of pooled particles: Particles are processed in individual batches by MPI followers. During each batch, a stack of particle images is only opened and closed once to improve disk access times.

All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. This parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together.

This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Skip griding?: Skip gridding in the Maximization step in the Expectation-Maximization algorithm. If this option is set to Yes, more memory will be consumed during the protocol execution, but it will be faster.
Pre-read all particles into RAM?: If set to Yes, the leader process read all particles into memory. Be careful you have enough RAM for large data sets!
Combine iterations through disc?: If set to Yes, the large arrays of summed weights will be sent through the MPI network instead of writing large files to disc.
Copy particles to scratch directory: If provided, particle stacks will be copied to this local scratch disk prior for refinement.
Skip padding?: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
Use GPU acceleration?: If set to Yes, it will use available gpu resources for some calculations.
GPUs to use:: It can be used to provide a list of which GPUs (e. g. "0:1:2:3") to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Keep only files from last iteration?: If Yes is chosen, only the files which correspond to the last iteration will be saved in the protocol's extra directory. Otherwise, files corresponding to each iteration will be kept.
Over-sampling: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
Consider alignment as priors?: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--verb 1
--pad 2

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Tomo CTF refine" can be found at the reliontomo plugin.
Its help description is:
 Tomo CTF refine.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Volume to get the halves: None
Input reference mask: None
Box size for estimation (pix): Box size to be used for the estimation. Note that this can be larger than the box size of the reference map. A sufficiently large box size allows more of the high-frequency signal to be captured that has been delocalized by the CTF.
Refine defocus?: If set to Yes, then estimate the defoci of the individual tilt images.
Defocus search range (Å): None
Do defocus regularisation?: Apply defocus regularisation.

High-tilt images do not offer enough signal to recover the defocus value precisely. The regularisation forces the estimated defoci to assume similar values within a given tilt series, which prevents those high-tilt images from overfitting.
Defocus regularisation scale: None
Refine contrast scale?: If set to Yes, then estimate the signal scale or ice thickness.
Refine scale per frame?: If set to Yes, then estimate the signal-scale parameter independently for each tilt. If not specified, the ice thickness, beam luminance and surface normal are estimated instead. Those three parameters then imply the signal intensity for each frame. Due to the smaller number of parameters, the ice thickness model is more robust to noise. By default, the ice thickness and surface normal will be estimated per tilt-series, and the beam luminance globally.
Refine scale per tomogram?: If set to Yes, then the beam luminance will be estimated separately for each tilt series. This is not recommended.
Refine even aberrations?: If set to Yes, then even higher-order aberrations will be estimated.
Max order of even aberrations: None
Refine odd aberrations?: If set to Yes, then odd higher-order aberrations will be estimated.
Max order of odd aberrations: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "De novo 3D initial model" can be found at the reliontomo plugin.
Its help description is:
 Generate a de novo 3D initial model from the pseudo-subtomograms..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Number of VDAM mini-batches: How many iterations (i.e. mini-batches) to perform with the VDAM ((variable metric gradient descent with adaptive moments) algorithm. Using 200 (default) has given good results for many data sets. Using 100 will run faster, at the expense of some quality in the results.
Regularisation parameter T: Bayes law strictly determines the relative weight between the contribution of the experimental data and the prior. However, in practice one may need to adjust this weight to put slightly more weight on the experimental data to allow optimal results. If it's set to 0, no regularisation will be applied. Values greater than 1 for this regularisation parameter (T in the JMB2011 paper) put more weight on the experimental data. Values around 2-4 have been observed to be useful for 3D initial model calculations.
Number of classes to be defined: None
Circular mask diameter (Å): Diameter of the circular mask that will be applied to the experimental images (in Angstroms)
Flatten and enforce non-negative solvent?: If set to Yes, the job will apply a spherical mask and enforce all values in the reference to be non-negative.
Symmetry group: Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
Run in C1 and apply symmetry later?: If set to Yes, the gradient-driven optimisation is run in C1 and the symmetry orientation is searched and applied later. If set to No, the entire optimisation is run in the symmetry point group indicated above.
Initial angular sampling interval (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
Initial offset range (pix.): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
Initial offset step (pix.): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluatedon a 2x coarser grid.
Use parallel disc I/O?: If set to Yes, all MPI followers will read their own images from disc. Otherwise, only the leader will read images and send them through the network to the followers. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many followers reading in parallel. If your datasets contain particles with different box sizes, you have to say Yes.
Number of pooled particles: Particles are processed in individual batches by MPI followers. During each batch, a stack of particle images is only opened and closed once to improve disk access times.

All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. This parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together.

This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Skip griding?: Skip gridding in the Maximization step in the Expectation-Maximization algorithm. If this option is set to Yes, more memory will be consumed during the protocol execution, but it will be faster.
Pre-read all particles into RAM?: If set to Yes, the leader process read all particles into memory. Be careful you have enough RAM for large data sets!
Combine iterations through disc?: If set to Yes, the large arrays of summed weights will be sent through the MPI network instead of writing large files to disc.
Copy particles to scratch directory: If provided, particle stacks will be copied to this local scratch disk prior for refinement.
Use GPU acceleration?: If set to Yes, it will use available gpu resources for some calculations.
GPUs to use:: It can be used to provide a list of which GPUs (e. g. "0:1:2:3") to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Keep only files from last iteration?: If Yes is chosen, only the files which correspond to the last iteration will be saved in the protocol's extra directory. Otherwise, files corresponding to each iteration will be kept.
Over-sampling: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
Consider alignment as priors?: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--verb 1
--pad 2

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Apply operation to Relion particles" can be found at the reliontomo plugin.
Its help description is:
 Operate on the particles star file.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Perform centering of particles: Perform centering of particles according to a position in the reference.
Average of subtomogram (optional): None
Reference mask (optional): None
X (pix.): X-coordinate in the reference to center particles on (in pix)
Y (pix.): Y-coordinate in the reference to center particles on (in pix)
Z (pix.): Z-coordinate in the reference to center particles on (in pix)
Choose operation: None
Value to operate the selected labels: None
Operate with: None
X (pix.): None
Y (pix.): None
Z (pix.): None
Shift X (pix.): None
Shift Y (pix.): None
Shift Z (pix.): None
Rot (deg.): None
Tilt (deg.): None
Psi (deg.): None

The protocol named "Make pseudo-subtomograms" can be found at the reliontomo plugin.
Its help description is:
 Make pseudo-subtomograms.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Box size (pix.): Box size, in pixels,  of the reconstruction. Note that this is independent of the box size used to refine the particle. This allows the user to construct a 3D map of arbitrary size to gain an overview of the structure surrounding the particle. A sufficiently large box size also allows more of the high-frequency signal to be captured that has been delocalized by the CTF.
Cropped box size (pix.): Cropped box size in pixels. If set, the program will output an additional set of maps that have been cropped to this size. This is useful if a map is desired that is smaller than the box size required to retrieve the CTF-delocalized signal.
Binning factor: Downsampling (binning) factor. Note that this does not alter the box size. The reconstructed region instead becomes larger.
Apply cone weight?: Down weight a cone in Fourier space along the Z axis (as defined by the coordinate system of the particle). This is useful for particles embedded in a membrane, as it can prevent the alignment from being driven by the membrane signal (the signal of a planar membrane is localised within one line in 3D Fourier space). Note that the coordinate system of a particle is given by both the subtomogram orientation (if defined) and the particle orientation. This allows the user to first obtain a membrane-driven alignment, and to then specifically suppress the signal in that direction.
Cone angle (deg.): It is the (full) opening angle of the cone to be suppressed, given in degrees. This angle should  include both the uncertainty about the membrane orientation and its variation across the region represented in the subtomogram.
Write output in float16?: If set to Yes, this program will write output images in float16 MRC format. This will save a factor of two in disk space compared to the default of writing in float32. Note that RELION and CCPEM will read float16 images, but other programs may not (yet) do so.

The protocol named "postprocessing" can be found at the reliontomo plugin.
Its help description is:
 Sharpen a 3D reference map and estimate the gold-standard FSC curves for subtomogram averaging.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Use halves from this refined volume: It will provide the two unfiltered half-reconstructions that were output upon convergence of a 3D auto-refine run.
Solvent mask: Provide a soft mask where the protein is white (1) and the solvent is black (0). Often, the softer the mask the higher resolution estimates you will get. A soft edge of 5-10 pixels is often a good edge width.
Calibrated pixel size (Å/pix): Provide the final, calibrated pixel size in Angstroms. This value may be different from the pixel-size used thus far, e.g. when you have recalibrated the pixel size using the fit to a PDB model. The X-axis of the output FSC plot will use this calibrated value.
Estimate B-factor automatically?: If set to Yes, then the program will use the automated procedure described by Rosenthal and Henderson (2003, JMB) to estimate an overall B-factor for your map, and sharpen it accordingly. Note that your map must extend well beyond the lowest resolution included in the procedure below, which should not be set to resolutions much lower than 10 Angstroms. 
Lowest resolution for auto-B fit: This is the lowest frequency (in Angstroms) that will be included in the linear fit of the Guinier plot as described in Rosenthal and Henderson (2003, JMB). Dont use values much lower or higher than 10 Angstroms. If your map does not extend beyond 10 Angstroms, then instead of the automated procedure use your own B-factor.
Use your own B-factor?: Instead of using the automated B-factor estimation, provide your own value. Use negative values for sharpening the map. This option is useful if your map does not extend beyond the 10A needed for the automated procedure, or when the automated procedure does not give a suitable value (e.g. in more disordered parts of the map).
User-provided B-factor: Use negative values for sharpening. Be careful: if you over-sharpen your map, you may end up interpreting noise for signal!
Skip FSC-weighting?: If set to No, then the output map will be low-pass filtered according to the mask-corrected, gold-standard FSC-curve. Sometimes, it is also useful to provide an ad-hoc low-pass filter, as due to local resolution variations some parts of the map may be better and other parts may be worse than the overall resolution as measured by the FSC. In such cases, set this option to Yes and provide an ad-hoc filter as described below.
Ad-hoc low-pass filter (Å): This option allows one to low-pass filter the map at a user-provided frequency (in Angstroms). When using a resolution that is higher than the gold-standard FSC-reported resolution, take care not to interpret noise in the map for signal.
MTF of the detector: User-provided STAR-file with the MTF-curve of the detector. Use the wizard to load one of the predefined ones provided at:
- [[https://www3.mrc-lmb.cam.ac.uk/relion/index.php/FAQs#Where_can_I_find_MTF_curves_for_typical_detectors.3F][Relion's Wiki FAQs]]
 - [[https://www.gatan.com/techniques/cryo-em#MTF][Gatan's website]]

Relion param: *--mtf*
Original detector pixel size ((Å)/pix): This is the original pixel size (in Angstroms) in the raw (non-super-resolution!) micrographs.

The protocol named "Prepare data for Relion 4" can be found at the reliontomo plugin.
Its help description is:
 Prepare data for Relion 4
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input CTF tomo series: None
Does focus decrease with Z distance?: It is the handedness of the tilt geometry and it is used to describe whether the focus increases or decreases as a function of Z distance.
Input coordinates: None
Input tilt series: Tilt series with alignment (non interpolated) used in the tomograms reconstruction.
Flip Z coordinate?: This option is generally False if your coordinates are displayed correctly in Scipion. You may want to check this to True only if you see that the extracted subtomograms are wrong.
Has tomogram been flipped along Y and Z?: This option is generally True if the slices of your tomogram are displayed on slice Z in Imod. Usually, a tomogram is flipped along Y and Z (i.e. rotated around X with 90 degrees) after the reconstruction and before the particles have been picked. This will tell Relion to apply the same transformation to the coordinate system.
Has the Z axis been flipped?: This option is generally True when you apply reconstrucion in Imod. This is usually used together with the flipYZ option.
Swap X with Y dimensions of the tilt series: This may be a trial and error parameter. Depending of the reconstruction path of your tomograms we you may need to deactivate this option to get good results. This option will be deprecated in the future

The protocol named "Average from tilt series" can be found at the reliontomo plugin.
Its help description is:
 Reconstructs/averages from the tilt series projected particles.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Box size (pix.): Box size, in pixels,  of the reconstruction. Note that this is independent of the box size used to refine the particle. This allows the user to construct a 3D map of arbitrary size to gain an overview of the structure surrounding the particle. A sufficiently large box size also allows more of the high-frequency signal to be captured that has been delocalized by the CTF.
Cropped box size (pix.): Cropped box size in pixels. If set, the program will output an additional set of maps that have been cropped to this size. This is useful if a map is desired that is smaller than the box size required to retrieve the CTF-delocalized signal.
Binning factor: Downsampling (binning) factor. Note that this does not alter the box size. The reconstructed region instead becomes larger.
Symmetry group: Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
FSC solvent mask (opt.): Provide a soft mask to automatically estimate the postprocess FSC.
Apply a Wiener filter with this SNR: If set to a positive value, apply a Wiener filter with this signal-to-noise ratio. If omitted, the reconstruction will use a heuristic to prevent divisions by excessively small numbers. Please note that using a low (even though realistic) SNR might wash out the higher frequencies, which could make the map unsuitable to be used for further refinement.

The protocol named "Auto-refinement of subtomograms" can be found at the reliontomo plugin.
Its help description is:
 Auto-refinement of subtomograms..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Reference volume: Initial reference 3D map, it should have the same dimensions and the same pixel size as your input particles.
Reference mask (optional): A volume mask containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask. If no mask is given, a soft spherical mask based on the <radius> of the mask for the experimental images will be applied.

In some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. Check _Advaced_ parameters to select another volume mask.
Second reference mask (optional): For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas.
Is initial 3D map on absolute greyscale?: Perform CC-calculation in the first iteration (use this if references are not on the absolute intensity scale). See detailed explanation below:

 Probabilities are calculated based on a Gaussian noise model,which contains a squared difference term between the reference and the experimental image.

 This has a consequence that the reference needs to be on the same absolute intensity greyscale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity greyscale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. But, if the map wasreconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No.

If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent map refinement. Therefore, if in doubt it is recommended to set this option to No.
Initial low-pass filter (A): It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s).
Symmetry group: Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
Do CTF-correction?: If set to Yes, CTFs will be corrected inside the MAP refinement. The resulting algorithm intrinsically implements the optimal linear, or Wiener filter. Note that input particles should contains CTF parameters.
Ignore CTFs until first peak?: If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended.
Circular mask diameter (Å): Diameter of the circular mask that will be applied to the experimental images (in Angstroms)
Mask individual particles with zeros?: If set to Yes, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform.

This will remove noise and therefore increase sensitivity in the alignment and classification.

However, it will also introduce correlations between the Fourier components that are not modelled. When set to No, then the solvent area is filled with random noise, which prevents introducing correlations.

High-resolution refinements (e.g. ribosomes or other large complexes in 3D auto-refine) tend to work better when filling the solvent area with random noise (i.e. setting this option to No), refinements of smaller complexes and most classifications go better when using zeros (i.e. setting this option to Yes).
Use solvent-flattened FSCs?: If set to Yes, then instead of using unmasked maps to calculate the gold-standard FSCs during refinement, masked half-maps are used and a post-processing-like correction of the FSC curves (with phase-randomisation) is performed every iteration.

This only works when a reference mask is provided. This may yield higher-resolution maps, especially when the mask contains only a relatively small volume inside the box.
Initial angular sampling interval (deg): There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
Initial offset range (pix.): Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
Initial offset step (pix.): Translations will be sampled with this step-size (in pixels). Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluatedon a 2x coarser grid.
Local searches from auto-sampling: Minimum healpix order (before oversampling) from which autosampling procedure will use local searches.

In the automated procedure to increase the angular samplings, local angular searches of -6/+6 times the sampling rate will be used from this angular sampling rate onwards. For most lower-symmetric particles a value of 1.8 degrees will be sufficient. Perhaps icosahedral symmetries may benefit from a smaller value such as 0.9 degrees.
Symmetry to be relaxed: With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020 cited in the About dialog.

Symmetry libraries have been copied from XMIPP. As such, with the exception of tetrahedral symmetry, they comply with https://relion.readthedocs.io/en/latest/Reference/Bibliography.html#id23. Possible values [notation label] are described below:

[
 {
  "group": "Asymmetric",
  "notation": "C1",
  "origin": "User-defined",
  "orientation": "User-defined"
 },
 {
  "group": "Cyclic",
  "notation": "C<n>",
  "origin": "On symm axis, Z user-defined",
  "orientation": "Symm axis on Z"
 },
 {
  "group": "Dihedral",
  "notation": "D<n>",
  "origin": "Intersection of symm axes",
  "orientation": "principle symm axis on Z, 2-fold on X"
 },
 {
  "group": "Tetrahedral",
  "notation": "T",
  "origin": "Intersection of symm axes",
  "orientation": "3-fold axis on Z (deviating from Heymann et al!)"
 },
 {
  "group": "Octahedral",
  "notation": "O",
  "origin": "Intersection of symm axes",
  "orientation": "4-fold axes on X, Y, Z"
 },
 {
  "group": "Icosahedral",
  "notation": "I<n>",
  "origin": "Intersection of symm axes",
  "orientation": "**"
 }
]
Use finer angular sampling faster?: If set to Yes, then let auto-refinement proceed faster with finer angular samplings. Two additional conditions will be considered:

 	-Angular sampling will go down despite changes still happening in the angles.
	-Angular sampling will go down if the current resolution already requires that sampling
	 at the edge of the particle.

This option will make the computation faster, but hasn't been tested for many cases for potential loss in reconstruction quality upon convergence.
Use parallel disc I/O?: If set to Yes, all MPI followers will read their own images from disc. Otherwise, only the leader will read images and send them through the network to the followers. Parallel file systems like gluster of fhgfs are good at parallel disc I/O. NFS may break with many followers reading in parallel. If your datasets contain particles with different box sizes, you have to say Yes.
Number of pooled particles: Particles are processed in individual batches by MPI followers. During each batch, a stack of particle images is only opened and closed once to improve disk access times.

All particle images of a single batch are read into memory together. The size of these batches is at least one particle per thread used. This parameter controls how many particles are read together for each thread. If it is set to 3 and one uses 8 threads, batches of 3x8=24 particles will be read together.

This may improve performance on systems where disk access, and particularly metadata handling of disk access, is a problem. It has a modest cost of increased RAM usage.
Skip griding?: Skip gridding in the Maximization step in the Expectation-Maximization algorithm. If this option is set to Yes, more memory will be consumed during the protocol execution, but it will be faster.
Pre-read all particles into RAM?: If set to Yes, the leader process read all particles into memory. Be careful you have enough RAM for large data sets!
Combine iterations through disc?: If set to Yes, the large arrays of summed weights will be sent through the MPI network instead of writing large files to disc.
Copy particles to scratch directory: If provided, particle stacks will be copied to this local scratch disk prior for refinement.
Skip padding?: If set to Yes, the calculations will not use padding in Fourier space for better interpolation in the references. Otherwise, references are padded 2x before Fourier transforms are calculated. Skipping padding (i.e. use --pad 1) gives nearly as good results as using --pad 2, but some artifacts may appear in the corners from signal that is folded back.
Use GPU acceleration?: If set to Yes, it will use available gpu resources for some calculations.
GPUs to use:: It can be used to provide a list of which GPUs (e. g. "0:1:2:3") to use. MPI-processes are separated by ":", threads by ",". For example: "0,0:1,1:0,0:1,1"
Keep only files from last iteration?: If Yes is chosen, only the files which correspond to the last iteration will be saved in the protocol's extra directory. Otherwise, files corresponding to each iteration will be kept.
Over-sampling: Adaptive oversampling order to speed-up calculations (0=no oversampling, 1=2x, 2=4x, etc)
Consider alignment as priors?: If set to Yes, then alignment information from input particles will be considered as PRIORS. This option can be used to do restricted local search within a range centered around those priors.
Additional arguments: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program, e.g: 
--verb 1
--pad 2

Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Average from subtomograms" can be found at the reliontomo plugin.
Its help description is:
  This protocol reconstructs a volume using Relion.
    Reconstruct a volume from a given set of subtomograms.
    The alignment parameters will be converted to a Relion star file
    and used as direction projections to reconstruct.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input subtomograms: Select the input subtomograms from the project.
Symmetry group: See [[Relion Symmetry][http://www2.mrc-lmb.cam.ac.uk/relion/index.php/Conventions_%26_File_formats#Symmetry]] page for a description of the symmetry format accepted by Relion
Maximum resolution (A): Maximum resolution (in Angstrom) to consider 
in Fourier space (default Nyquist).
Padding factor: None
Subset to reconstruct: Subset of images to consider.
Use only this class: Consider only this class (-1: use all classes)
Extra parameters: : Extra parameters to *relion_reconstruct* program. Address to Relion to see full list of options.
Apply CTF correction?: None
Leave CTFs intact until first peak?: None
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Tomo frame align" can be found at the reliontomo plugin.
Its help description is:
 Tomo frame align.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Relion particles: None
Volume to get the halves: None
Input reference mask: None
Box size for estimation (pix): Box size to be used for the estimation. Note that this can be larger than the box size of the reference map. A sufficiently large box size allows more of the high-frequency signal to be captured that has been delocalized by the CTF.
Max position error (pix): Maximal assumed error in the initial 2D particle-positions (distances between the projected 3D positions and their true positions in the images), given in pixels.
Align by shift only?: If set to Yes, tilt series projection shifts are refined based on cross-correlation. Useful for very badly aligned frames. No iterative optimisation.
Alignment model: If set to "Only particles", it estimates rigid shift by aligning only the particles instead of by predicting entire micrographs. In this case, only misalignments smaller than half the box size of the particle can be corrected.
Fit per particle motion?: If set to Yes, then the subtomogram version of Bayesian polishing will be used to fit per-particle (3D) motion tracks, besides the rigid part of the motion in the tilt series.
Sigma for velocity (Å/dose): The expected amount of motion (i.e. the std. deviation of particle positions in Angstroms after 1 electron per A^2 of radiation).
Sigma for divergence (Å): The expected spatial smoothness of the particle trajectories in angstroms (a greater value means spatially smoother motion.
Use Gaussian decay?: If set to Yes, then it is assumed that the correlation of the velocities of two particles decays as a Gaussian over their distance, instead of as an exponential. This will produce spatially smoother motion and result in a shorter program runtime.
Estimate 2D deformations?: If set to Yes, then the subtomogram version of Bayesian polishing will be used to fit per-particle (3D) motion tracks, besides the rigid part of the motion in the tilt series.
Horizontal sampling points: Number of horizontal sampling points for the deformation grid.
Vertical sampling points: Number of vertical sampling points for the deformation grid.
Alignment model: Type of model to use (linear, spline or Fourier).
Deformation regularisation scale: None
Refine deformations per frame?: If set to Yes, it models deformations per tilt frame instead of per tilt series.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "Reconstruct tomograms from prepare data prot" can be found at the reliontomo plugin.
Its help description is:
  This protocol reconstructs a single tomogram using Relion. It is very useful
    to check if the protocol "Prepare data" has been applied correctly (in terms of flip
    options, for example).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Prepare Data protocol: It is very usefulto check if the protocol "Prepare data" has been applied correctly (in terms of flip options, for example)
Choose a reconstruction option: None
Tomogram to be reconstructed: None
Binning factor: The binning will be applied concerning the size of the tomograms used for the picking.
Width: If -1, the width considered will be of the original tilt series after having applied the introduced binning factor.
Height: If -1, the height considered will be of the original tilt series after having applied the introduced binning factor.
Thickness: If -1, the thickness considered will be of the original tilt series after having applied the introduced binning factor.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Matching coordinates" can be found at the reliontomo plugin.
Its help description is:
 
    Protocol to generate a set of pseudosubtomograms taking into account the
    intersection of  a set of 3D coordinates and a set of pseudosubtomograms
    as input.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input pseudoubtomograms: Select the input pseudosubtomograms from the project.
Subtomograms or 3D coordinates: Select the subtomograms or 3D coordinates that we want to match with the pseudosubtomogram

The protocol named "ctf estimation" can be found at the emantomo plugin.
Its help description is:
 
    Protocol for CTF estimation from tilt series using e2spt_tomoctf.py
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tilt Series: None
min: None
max: None
Step: None
Do phase shift search?: None
min: None
max: None
Step: None
Size of tile to calculate FFT: None
Number of references: Using N tilt images near the center tilt to estimate the range of defocus for all images.
Step in X direction: Number of tiles to generate on x-axis (different defocus)
Step in Y direction: Number of tiles to generate on y-axis (same defocus)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Multi-reference classification pppt" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_refinemulti_new.py* EMAN2 program.
    Multi-reference classification for the new (2021) SPT refinement protocol.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Aligned particles: None
Mask the references prior to to classif. (opt.): None
Max. resolution (Å): Maximum resolution (the smaller number) to consider in alignment (in Å).
Since gold-standard validation is not used here, setting this parameter is mandatory.
Min. resolution (Å): Minimum resolution (the larger number) to consider in alignment (in Å).
Number of classes: None
Reference volume (opt.): None
No. iterations: None
Sym. to apply to the average: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Break specified symmetry: If empty, no symmetry will be broken.
Do alignment?: If set to No (default), it will skip the alignment entirely when aligned particles are provided. Otherwise a local orientation search will still be performed.
Apply mask to the 3D alignment ref. in each iter. (opt.): Not applied to the average, which will follow normal EMAN's masking routine.
Maximum angular diff. (deg.): maximum angle difference for local alignment (in degrees)
Maximum shift (px): If set to -1, it will be estimated as maxShift=boxSize/6.
Threads for post-processing: None
Do make3d in threading mode with shared memory?: Safer for large boxes.
Extra params: Here you can add any extra parameters to run Eman's  new subtomogram refinement. Parameters should be written in Eman's command line format (--param val)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "average subtomograms" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_average.py* EMAN2 program.
    Computes the average a selected subset of a SetOfSubtomograms in the predetermined orientation
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input SubTomograms: Select the set of subtomograms to perform the reconstruction.
Symmetry: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Missing wedge threshold: Threshold for identifying missing data in Fourier space in terms of standard deviation of each Fourier shell. Default 3.0. If set to 0.0, missing wedge correction will be skipped
Skip post process steps (fsc, mask and filters): None
Keep hdf files?: If set to Yes, the generated files will be saved in both HDF and MRC formats. They are generated in HDF and then converted into MRC. The HDF files are deleted by default to save storage.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Extraction from TS" can be found at the emantomo plugin.
Its help description is:
 Extract 2D subtilt particles from the tilt series, and reconstruct 3D subvolumes..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates or 3D particles: The corresponding tomograms data will be accessed from the provided coordinates or the coordinates associated to the 3D particles.
CTF tomo series: Estimated CTF for the tilt series associates to the tomograms used to pick the input coordinates. The corresponding tilt series data will be also accessed through them.
Tilt series: Tilt series with alignment (non interpolated) used in the tomograms reconstruction.
Flip Z axis in tomogram?: If the reconstruction was carried out with EMAN, it would be set to No.
Box size unbinned (px): The subtomograms are extracted as a cubic box of this size.
Particles binning factor: For example, if the unbinned box size is 160 pix and the particles binning factor introduced is 4, the 2D tilt particles will be cropped on the tilt series with a box of 160 x 160 pix, and then shrink to 160 / 4 = 40 pix. Thus, both resulting 2D and 3D sets of particles will be of size 40 pix.
Max tilt: None
Tilt fraction to keep: Keep a fraction of tilt images with good score determined from tomogram reconstruction
Contrast threshold for 2D particle removal: Remove 2d particles with high contrast object beyond N sigma at 100Å. Note that this may result in generating fewer particles than selected. Default is -1 (include all particles). 0.5 might be a good choice for removing gold beads.
Padding factor: If set to 0, no padding will be considered. If your particles are deeply buried in other densities, using a bigger padtwod may help, but doing so may significantly increase the memory usage and slow down the process.
Minimum distance between particles (Å): None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Template matching picking" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_tempmatch.py* EMAN2 program.
    It is a reference-based picking (template matching).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomograms: Specify tomograms containing reference-like particles to be exctracted. These should be "dark contrast".
Reference volume: This should be 'light contrast'.
Maximum no. particles picked among the tomograms: If a higher number of particles is detected, the program will take the best N, being N the value of the current parameter.
Anglular sampling to rotate the reference (deg.: The lower value, the higher number of orientations that will be checked.
Distance threshold (Å): Particles closer than the value introduced will be removed. If default =-1, it will be considered as half of the box size of the reference.
Template matching threshold (n sigma): Particles with score lower than the introduced value will be removed. Admitted values are [1, 10], where 1 means very insensitive picking (pick a lot of particles with a high probability of having a a high number of false positives) and 10 means very sensitive picking (strict picking, with less particles picked and very low presence of false positives, but with high probability of some or even a lot of particles not to be picked.
Minimum peak volume: If default=-1, this filter is not applied.
Maximum peak volume: If default=-1, this filter is not applied.
Symmetry of the reference: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Remove particles on the edge?: None
Remove particles near gold fiducials?: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Manual picking" can be found at the emantomo plugin.
Its help description is:
  Manual picker for Tomo. Uses EMAN2 e2spt_boxer.py.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select the Tomogram to be used during picking.
Modify previous coordinates?: This option allows to add and/or remove coordinates to a previous SetOfCoordinates
Input Coordinates: Select the previous SetOfCoordinates you want to modify

The protocol named "clip tomograms" can be found at the emantomo plugin.
Its help description is:
 Make the output have this size by padding/clipping and re-centered using e2proc3d.py. Both
    new center and new dimensions are referred to the original position and dimensions, respectively..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tomograms: None
cx: None
cy: None
cz: None
dx: None
dy: None
dz: None

The protocol named "Subtomograms extraction from tomogram" can be found at the emantomo plugin.
Its help description is:
  Extraction for Tomo. Uses EMAN2 e2spt_boxer_old.py..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates/Subtomograms: Choose coordinates or subtomograms derived from 3d coordinates.
Tomogram source: By default the subtomograms will be extracted from the tomogram used in the picking step ( _same as picking_ option ). 
If you select _other_ option, you must provide a different tomogram to extract from. 
*Note*: In the _other_ case, ensure that provided tomogram and coordinates are related 
Input tomogram: Select the tomogram from which to extract.
Box size: The subtomograms are extracted as a cubic box of this size. The wizard will select the box size considering the sampling rate ratio between the introduced coordinates and the tomograms that will br used for the extraction.
Invert contrast?: Invert the contrast if your tomogram is black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background. Frealign (up to v9.07) requires black particles over a white background
Normalize subtomogram?: Normalization processor applied to subtomograms before extraction.
Normalize method: Use normalize.edgemean if the particles have a clear solvent background (i.e., they are not part of a larger complex or embeded in a membrane)

The protocol named "Initial model" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_sgd.py* EMAN2 program.

    It will take a set of subtomograms (particles) and a subtomogram(reference)
    and build a subtomogram suitable for use as initial models in tomography.
    It also builds a set of subtomograms that contains the original particles
    plus the score, coverage and align matrix per subtomogram .
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particles: Select the set of subtomograms to build an initial model
Reference volume: Specify a 3D volume
Mask: Select a 3D Mask to be applied to the initial model
Symmetry: Specify the symmetry.
Choices are: c(n), d(n), h(n), tet, oct, icos.
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry
for a detailed description of symmetry in Eman.
Filterto: Filter map to frequency after each iteration. Default is 0.02
Fourier: Gradient descent in fourier space
Batch Size: SGD batch size. Increasing batchsize will use more cores (if you have more than 12), and may cause it to converge to the correct answer in fewer iterations, but each iteration will not become faster.
Learn Rate: Learning Rate. Default is 0.1
Number of iterations to perform: The total number of refinement iterations to perform.
Number of batches: Number of batches per iteration
Shrink factor: Using a box-size >64 is not optimal for making initial models. Suggest using this option to shrink the input particles by an integer amount prior to reconstruction. Default = 1, no shrinking
Apply Symmetry: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.

The protocol named "Initial model pppt" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_sgd_new.py* EMAN2 program.
    It generates an initial model from subtomograms using stochastic gradient descent.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particles: Select the set of subtomograms to build an initial model
Reference volume (opt.): None
Binning factor: This option can be used to shrink the input particles by an integer amount prior to reconstruction, making them smaller. Default = 1 means no shrinking
No. iterations: None
No. classes: None
Symmetry: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Target resolution (Å): None
Batch Size: SGD batch size. Increasing batch size will use more cores (if you have more than 12), and may cause it to converge to the correct answer in fewer iterations, but each iteration will not become faster.
Fraction of particles to keep: It will actually align more particles and use the number of particles specified by the batch size parameter. Default = 1 means that all the particles are kept.
Learning Rate: In the context of stochastic gradient descent (SGD), the learning rate is a hyperparameter that determines the step size at each iteration when updating the model's parameters.

In other words, the learning rate controls how much the parameters are adjusted in the direction of the gradient, which is the direction of steepest descent of the loss function. A higher learning rate leads to larger updates and faster convergence, but it may also cause the algorithm to overshoot the optimal solution and fail to converge. On the other hand, a lower learning rate leads to smaller updates and slower convergence, but it may also help the algorithm avoid overshooting and find a more precise optimum.

Choosing an appropriate learning rate is important for achieving good performance in SGD. It typically involves a trade-off between convergence speed and accuracy, and may require tuning through trial and error or more advanced optimization techniques such as adaptive learning rate methods.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "subtomogram refinement" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_refine.py* EMAN2 program.

    Protocol to performs a conventional iterative subtomogram averaging
    using the full set of particles.
    It will take a set of subtomograms (particles) and a subtomogram(reference,
    potentially coming from the initial model protocol)
    and 3D reconstruct a subtomogram.
    It also builds a set of subtomograms that contains the original particles
    plus the score, coverage and align matrix per subtomogram .
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input SubTomograms: Select the set of subtomograms to perform the reconstruction.
Input Ref SubTomogram: 3D reference for initial model generation.No reference is used by default.
Number of iterations: The number of iterations to perform.
Mass:: Mass normalization. Default=-1 Ignores mass
Particle keep:: Fraction of particles to keep
Gold standard:: initial resolution for gold standard refinement
Gold continue: continue from an existing gold standard refinement
Mask file: Mask file to be applied to initial model
Structure factor: Select the structure factor
Symmetry: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Local filter: use tophat local
maxtilt: Explicitly zeroes data beyond specified tilt angle.Assumes tilt axis exactly on Y and zero tilt in X-Yplane. Default 90 (no limit).
Use previous alignments?: None
Maximum angular change: Maximum anglular difference in refine mode (in degrees)
Extra params: Here you can add any extra parameters to run Eman subtomogram refinement. Parameters should be written in Eman command line format (--param=val)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "subtomogram refinement pppt" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2spt_refine_new.py* EMAN2 program.
    This refinement protocol performs subtomogram, subtilt and defocus refinement. The 2D subtilt particles are used
    instead of 3D subvolumes in the subtomogram refinement step. Moreover, this program now can model the localized 2D
    particle motion by considering the motion trajectory of each particle along with its neighbor.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Particles: None
Reference volume (opt.): None
Refinement initial resolution (Å): This will be the maximum resolution considered for the first iteration. In later iterations, the maximum resolution is calculated from the FSC of the previous iteration (unless the parameter max. resolution is specified).
Iteration information: Input types of refinement separated by comma:

	- *p*: 3d particle translation-rotation.
	- *t*: subtilt translation.
	- *r*: subtilt translation-rotation.
	- *d*: subtilt defocus.

Default is p,p,p,t,p,p,t,r,d. Character followed by number is also acceptable. p3 = p,p,p.
Symmetry: Supported symmetries are :

Cn - single rotational n-fold symmetry axis
Dn - dihedral rotational n-fold, eg - GroEL is ~D7
icos - icosahedral, (5,3,2)
oct - octahedral, symmetry of a cube (4,3,2)
tet - tetrahedral, (3,2)
h - helical

See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Particle keep: Fraction of particles to keep. Note that this is controlled at three separate steps.
When default = 0.95, it removes:

	- The worst 5% 3D particles.
	- The 5% 2D subtilt with the worst score.
	- The 5% of subtilt with the largest drift.

Also accept comma separated values 0.9,0.5,0.5 to set different keep thresholds for the three removal operations described before.
3D map filtering: Options to filter the 3D maps:

	- wiener: wiener filter based on FSC curve. default mode in most programs.
	- global: tophat filter across the map at the resolution cutoff 0.143 from fsc_masked_xx.txt.
	- localwiener: wiener filter based on the fsc curve of local regions from the even/odd maps.
	- local: tophat filter based on local resolution calculated from the even/odd maps at 0.143 cutoff.
Max. resolution in alignment (Å): The program will determine maximum resolution each round from the FSC of the previous round by default.
Min. resolution in alignment (Å): None
Do local refine? (only for p iterations): Perform only local search around the solution from the previous alignment.
Maximum angular diff. (deg.): maximum angle difference from starting point for local refine (in degrees)
Maximum shift (px): If set to -1, it will be estimated as maxShift= boxSize/6.
Smooth motion factor: Controls how many of its neighbors are considered to model the local motion. Smoother local motion with larger numbers.
No. neighboring particles used for smoothing: Used to control how many of its neighbors are considered to model the local motion.
Threads for post-processing: None
Do make3d in threading mode with shared memory?: Safer for large boxes.
Extra params: Here you can add any extra parameters to run Eman's  new subtomogram refinement. Parameters should be written in Eman's command line format (--param val)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Alignment and reconstruction" can be found at the emantomo plugin.
Its help description is:
 
    This protocol wraps *e2tomogram.py* EMAN2 program.

    Tilt series alignment and tomogram reconstruction.
    Tomograms are not normally reconstructed at full resolution, generally limited to 1k x 1k or 2k x 2k,
    but the tilt-series are aligned at full resolution. For high resolution subtomogram averaging, the raw
    tilt-series data is used, based on coordinates from particle picking in the downsampled tomograms.
    On a typical workstation reconstruction takes about 4-5 minutes per tomogram.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tilt Series: Select the set of tilt series to be aligned and/or to reconstruct the corresponding tomograms.
Bit compression: Number of bits of precision in outputs with lossless compression. Value -1 means uncompressed float
Keep hdf files?: If set to Yes, the generated files will be saved in both HDF and MRC formats. They are generated in HDF and then converted into MRC. The HDF files are deleted by default to save storage.
Align the tilt series?: None
Generated the interpolated tilt series?: If set to Yes, an additional set of tilt series with the transformation matrix applied will be generated. It can be used to check if the alignment was correctly calculated.

*NOTE*: Depending on the combination of parameters "Align the tilt series" and "Reconstruct the tomogram", the interpolated tilt series generated may be different in terms of size and sampling rate.
The interpolated tilt series generated when the tomogram is requested to be reconstructed is different from the one generated if only align TS is selected (It is part of the reconstruction functionality in the first case, and a temp file part of the alignment step in the second case).
No. landmarks to use: None
Fraction of landmarks to keep in the tracking: None
No. patch tracking iterations: use patch tracking before landmark based alignment. input 0/1/2 as the number of patch tracking iterations.
Box size of the particles for tracking (px): It may be helpful to use a larger one for fiducial-less cases.
Should Eman estimate the tilt angles?: If set to No, a .tlt file will be generated containing the tilt angles read from Scipion imported tilt series metadata and passed to Eman. Default=True will let Eman to estimate the tilt angles, following the Eman original default behavior.
Index of the center tilt: If set -1, it will be estimated by EMAN.
Tilt axis angle: If not provided, it will be read from the tilt series metadata. If it is not contained in the metadata, it will be estimated by EMAN.
Write intermediate results?: They will be generated always the interpolated tilt series are requested.
Reconstruct the tomograms?: None
Size of the output tomograms: None
No. iterations for 500, 1K, 2K, and 8K images: None
Thickness (px): Z thickness of the final tomogram output. default is -1, (5/16 of tomogram length).
Fraction of tilts to keep in the reconstruction: None
Make final tomogram by tiles?: None
Sample more tiles during rec.?: If set to Yes, the processing time will be greater, but it can be useful to reduce the boundary artifacts when the sample is thick.
Correct rotation: Correct for global rotation and position sample flat in tomogram.
Correct drifting along the X axis?: None
Filter final tomogram to target resolution (Å): None
Density value threshold for removing beads: "Density value threshold (of sigma) for removing beads. High contrast objects beyond this value will be removed. Default is -1 for not removing.
Extra pad: Use extra padding for tilted reconstruction. It is slower and costs more memory, but reduces the boundary artifacts when the sample is thick.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "boxer auto" can be found at the eman2 plugin.
Its help description is:
  Automated particle picker for SPA. Uses EMAN2 (versions 2.2+) e2boxer.py
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
: Set to Yes if you want to run Neural Net boxer on GPU. Default is CPU.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on.
Eman boxer can use only one GPU.
Box size (px): Box size in pixels. See http://eman2.org/BoxSize
Particle size (px): Longest axis of particle in pixels (diameter, not radius).
Autopicker mode:: Choose autopicker mode:

 _local search_ - Reference based search by downsampling and 2-D alignment to references.
 _by ref_ - simple reference-based cross-correlation picker with exhaustive rotational search.
 _neural net_ - convolutional neural network boxer.
 _gauss_ - simple reference-free picker.
Threshold: None
Threshold2: None
Threshold low: None
Threshold high: None
Gaussian width: None
Previous e2boxer protocol: Provide previously executed e2boxer protocol that has all 3 types of references and pre-trained neural network.
Good references: Good particle references.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "boxer" can be found at the eman2 plugin.
Its help description is:
  Semi-automated particle picker for SPA. Uses EMAN2 e2boxer.py.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
Box size (px): Box size in pixels.
Particle size (px): Longest axis of particle in pixels (diameter, not radius).
Device: For Convnet training only.
Pick a device to use. Choose from cpu, gpu, or gpuX (X=0,1,...) when multiple gpus are available. Default is cpu.
Invert Y coordinates: In some cases, using dm3 or tiff Y coordinates must be flipped. Check output and activate this if needed.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "ctf auto" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2ctf_auto.py* EMAN2 program.
    It automates the CTF fitting and structure factor
    generation process.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Particles: None
type: Performs CTF processing targeting different resolution:
*hires* - 2-6 Angstrom
*midres* - 7-15 Angstrom
*lores* - 15-30 Angstrom
Min: None
Max: None
Fit from scratch: Force refitting of CTF from scratch, ignoring any previous fits.
Estimate astigmatism: Includes astigmatism in automatic fitting.
Estimate phase shift: Include phase/amplitude contrast in CTF estimation. For use with hole-less phase plates.
Extra padding: If particles were boxed more tightly than EMAN requires, this will add some extra padding.
Invariant type: Which type of invariants to generate
High density : If particles are very close together, this will interfere with SSNR estimation. If set uses an alternative strategy, but may over-estimate SSNR.
Invert contrast: Invert the contrast of the particles in output files (default false)
Constant B-factor: Set B-factor to a fixed value, negative value enables autofitting.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "initial model" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2initialmodel.py* EMAN2 program.

    It will take a set of class-averages/projections and build a set
    of 3-D models suitable for use as initial models in single
    particle reconstruction. The output set is theoretically sorted
    in order of quality (best one is numbered 1), though it's best
    to look at the other answers as well.

    See more details in:
    http://blake.bcm.edu/emanwiki/EMAN2/Programs/e2initialmodel
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input averages: Select the your class averages to build your 3D model.
You can select SetOfAverages or SetOfClasses2D as input.
Symmetry group: Specify the symmetry.
Choices are: c(n), d(n), h(n), tet, oct, icos.
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry
for a detailed description of symmetry in Eman.
Number of iterations to perform: The total number of refinement to perform.
Number of different initial models: The number of different initial models to generate in search of a good one.
Shrink factor: Using a box-size >64 is not optimal for making initial models. Suggest using this option to shrink the input particles by an integer amount prior to reconstruction. Default = 1, no shrinking
Use random orientations?: Instead of seeding with a random volume, seeds by randomizing input orientations
Automask expand (px): Number of voxels of post-threshold expansion in the mask, for use when peripheral features are truncated (default=shrunk boxsize/20)
Additional arguments:: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "e2initialmodel.py -h" will print a list of possible options.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "initial model SGD" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2initialmodel_sgd.py* EMAN2 program.

    This program makes initial models using a (kind of) stochastic gradient
    descent approach. It is recommended that the box size of
    particles is around 100.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Select input type: You can choose either class averages or particles as input.
Input averages: Select the class averages to build your 3D model.
You can select SetOfAverages or SetOfClasses2D as input.
Input particles: Select the particles to build your 3D model.
Symmetry group: Specify the symmetry.
Choices are: c(n), d(n), h(n), tet, oct, icos.
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry
for a detailed description of symmetry in Eman.
Batch size: Batch size of stochastic gradient descent. N particles are randomly selected to generate an initial model at each step.
Number of iterations to perform: The total number of refinement to perform.
Number of different initial models: The number of different initial models to generate in search of a good one.
Target resolution (A): Target resolution in A of the model.
Shrink factor: Using a box-size >64 is not optimal for making initial models. Suggest using this option to shrink the input particles by an integer amount prior to reconstruction. Default = 1, no shrinking
Learning rate: Learning rate is how much the initial model changes toward the gradient direction in each iteration. Ranges from 0.0 to 1.0. Default is 0.3
Learning decay: Learning rate multiplier after each iteration.
Add noise: Add noise on particles at each iteration. Stablize convergence for some reason.
Full coverage: Assume the input particles covers most of the orientation of the model. This gives better performance when the model is relatively featureless, but is more likely to fail when there are incorrect particles in the input.
Write tmp output?: Write output for each iteration.
Additional arguments:: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "e2initialmodel_sgd.py -h" will print a list of possible options.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "reconstruct" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2make3d.py* EMAN2 program.

    Reconstructs 3D volumes using a set of 2D images.
    Euler angles are extracted from the 2D image headers
    and symmetry is imposed. Several reconstruction methods
    are available. The fourier method is the default and
    recommended reconstructor.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input particles: Select the input images from the project.
Skip ctf estimation?: Use this if you want to skip running e2ctf.py. It is not recommended to skip this step unless CTF estimation was already done with EMAN2.
Use old e2make3d?: Use the traditional e2make3d program instead of the new e2make3dpar program.
Number of iterations:: Set the number of iterations. Iterative reconstruction improves the overall normalization of the 2D images as they are inserted into the reconstructed volume, and allows for the exclusion of the poorer quality images.
Symmetry group: Set the symmetry; if no value is given then the model is assumed to have no symmetry. 
Choices are: *i, c, d, tet, icos, or oct* 
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry 
for a detailed description of symmetry in Eman.
X : None
Y : None
X: None
Y: None
Z: None
X: None
Y: None
Z: None
Reconstruction Method:: Reconstructor to use. See e2help.py reconstructors -v 9. Default is fourier:mode=gauss_2.
Mode to Fourier method:: Fourier pixel insertion mode. See e2help.py reconstructors fourier -v 9. Default mode is gauss_2.
Sense of keep:: If *percentage* is selected, *keep* parameter will be interpreted as a percentage. It is the default option.
If *standard deviation* is selected, *keep* parameter will be interpreted as a standard deviation coefficient instead of as a percentage.
If *absolute quality* is selected, *keep* parameter will refer to the absolute quality of the class-average, not a local quality relative to other similar sized classes.
Fraction of slices to keep: The fraction of slices to keep, in fraction, based on quality scores (1.0 = use all slices).
Disable automatic weighting?: This argument turns automatic weighting off causing all images to be weighted by 1. If this argument is False images inserted into the reconstructed volume are weighted by the number of particles that contributed to them (i.e. as in class averages), which is extracted from the image header.
Additional parameters: In this box command-line arguments may be provided that are not generated by the GUI. See e2make3dpar.py -h.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "refine easy" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2refine_easy.py* EMAN2 program.

This is the primary single particle refinement program in EMAN2.1+.
It replaces earlier programs such as e2refine.py and e2refine_evenodd.py.

Major features of this program:

 * While a range of command-line options still exist. You should not
 normally specify more than a few basic requirements. The rest will
 be auto-selected for you.
 * This program will split your data in half and automatically
 refine the halves independently to produce a gold standard resolution
 curve for every step in the refinement.
 * An HTML report file will be generated as this program runs,
 telling you exactly what it decided to do and why, as well as giving
 information about runtime, etc while the job is still running.
 * The gold standard FSC also permits us to automatically filter the
 structure at each refinement step. The resolution you specify is
 a target, NOT the filter resolution.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Continue from a previous run?: If you set to *Yes*, you should select a previous run of type *EmanProtRefine* class and most of the input parameters will be taken from it.
Select previous run: Select a previous run to continue from.
Input particles: Select the input particles.
Initial 3D reference volume: Input 3D reference reconstruction.
Skip ctf estimation?: Use this if you want to skip running e2ctf.py. It is not recommended to skip this step unless CTF estimation was already done with EMAN2.
Number of iterations: The total number of refinement iterations to perform.
Tophat filter?: Instead of imposing a final Wiener filter (tophat = none)), use a tophat filter (global similar to Relion). local determines local resolution and filters. Danger of feature exaggeration.
Symmetry group: Set the symmetry; if no value is given then the model is assumed to have no symmetry. 
Choices are: c(n), d(n), tet, icos, or oct.
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry for a detailed description of symmetry in Eman.
Break symmetry?: If set True, reconstruction will be asymmetric with *Symmetry group* parameter specifying a known pseudosymmetry, not an imposed symmetry.
Target resolution (A): Target resolution in A of this refinement run. Usually works best in at least two steps (low/medium) resolution, then final resolution) when starting with a poor starting model. Usually 3-4 iterations is sufficient.
Molecular mass (kDa): Approximate molecular mass of the particle, in kDa. This is used to run normalize.bymass. Due to resolution effects, not always the true mass.
Use old e2make3d?: Use the traditional e2make3d program instead of the new e2make3dpar program.
Expand mask by (px): Default=boxsize/20. Specify number of voxels to expand mask before soft edge. Use this if low density peripheral features are cut off by the mask.
Supress phase randomization: Suppress independent phase randomization of input map. Only appropriate if input map has been preprocessed in some suitable fashion.
Speed: Balances speed vs precision. Larger values sacrifice a bit of potential resolution for significant speed increases. Set to 1 when really pushing resolution. Set to 7 for initial refinements.
Fraction of particles to use in final average: The fraction of particles to keep in each class,based on the similarity score.
Fraction of class-averages to use in 3-D map: The fraction of slices to keep in reconstruction.
Use bispectra? (experimental): Will use bispectra for orientation determination (EXPERIMENTAL).
Use the setsfref option in class averaging?: This matches the filtration of the class-averages to the projections for easier comparison. May also improve convergence. Disabled when ampcorrect=flatten is used.
Do automask to the class-average?: This will apply an automask to the class-average during iterative alignment for better accuracy. The final class averages are unmasked.
Apply threshold before project the volume?: Applies a threshold to the volume just before generating projections. A sort of aggressive solvent flattening for the reference.
Postprocess parameters: <name>:<parm>=<value>:...  An arbitrary processor (e2help.py processors -v2) to apply to the 3-D map after each iteration. Default=none
Amplitude correction:: Will perform amplitude correction via the specified method. 'flatten' requires a target resolution better than 8 angstroms (experimental). 'none' will disable amplitude correction (experimental).
Additional parameters: In this box command-line arguments may be provided that are not generated by the GUI. See e2refine_easy.py -h.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "refine 2D" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2refine2d.py* EMAN2 program.

    This program is used to produce reference-free class averages
    from a population of mixed, unaligned particle images. These averages
    can be used to generate initial models or assess the structural
    variability of the data. They are not normally themselves used as part
    of the single particle reconstruction refinement process, which
    uses the raw particles in a reference-based classification
    approach. However, with a good structure, projections of the
    final 3-D model should be consistent with the results of
    this reference-free analysis.

    This program uses a fully automated iterative alignment/MSA approach.
    You should normally target a minimum of 10-20 particles per
    class-average, though more is fine.

    Default parameters should give a good start, but are likely not
    optimal for any given system.

    Note that it does have the --parallel option, but a few steps of the
    iterative process are not parallellised, so don't be surprised if
    multiple cores are not always active.
.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Continue from a previous run?: If you set to *Yes*, you should select a previous run of type *EmanProtRefine2D* class. The refinement will resume after the last completed iteration. It is ok to alter other parameters.
Select previous run: Select a previous run to continue from.
Input particles: Select the input particles.
Input class averages: Select starting class averages. If not provided, they will be generated automatically.
Skip ctf estimation?: Use this if you want to skip running e2ctf.py. It is not recommended to skip this step unless CTF estimation was already done with EMAN2.
Number of class-averages: Number of class-averages to generate. Normally you would want a minimum of ~10-20 particles per class on average, but it is fine to have 100-200 for a large data set. If you plan on making a large number (>100) of classes, you should use the *Fast seed* option. Note that these averages are not used for final 3-D refinement, so generating a very large number is not useful in most situations.
Number of iterations: Number of iterations of the overall 2-D refinement process to run. For high contrast data, 4-5 iterations may be more than enough, but for low contrast data it could take 10-12 iterations to converge well.
If running in Continue mode, provide here a number of additional iterations to run.
Number of MSA vectors to use: Number of MSa basis vectors to use when classifying particles.
Number of alignment references: The number of alignment references to use in each iteration. You can look at this as the number of different highly distinct views your particle has. With something like GroEL with mostly side views and top views, 3-4 is sufficient. With something like a ribosome something more like 10-15 would be appropriate.
Normalize projected vectors?: Normalizes each projected vector into the MSA subspace. Note that this is different from normalizing the input images since the subspace is not expected to fully span the image
Use fast seed?: Will seed the k-means loop quickly, but may produce less consistent results. Always use this when generating >~ 100 classes.
Automask class-averages?: This will perform a 2-D automask on class-averages to help with centering. May be useful for negative stain data particularly.
: None
params: None
Additional arguments:: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "e2refine2d.py -h" will print a list of possible options.
These parameters are for advanced users only!
: For help please address to EMAN2 [[http://blake.bcm.edu/emanwiki/EMAN2][Wiki]] or run:
*scipion run e2help.py cmp -v 2* or
*scipion run e2help.py aligners -v 2*
Shrink particles: Optionally shrink the input particles by an integer amount prior to computing similarity scores. For speed purposes.
: None
params: None
: None
params: None
: None
params: None
: None
params: None
: None
params: None
These parameters are for advanced users only!
: For help please address to EMAN2 [[http://blake.bcm.edu/emanwiki/EMAN2][Wiki]] or run:
*scipion run e2help.py cmp -v 2* or
*scipion run e2help.py averagers -v 2*
Number of iterations for class-averages: Number of iterations to use when making class-averages (default=5)
Fraction of particles to keep: The fraction of particles to keep in each class, based on the similarity score generated by cmp (default=0.85)
Keep particles based on sigma?: Change the *keep* criterion from fraction-based to sigma-based
Filter class-averages?: Use setsfref option in class averaging to produce better class averages
Class averager: : The averager used to generated class-averages
: None
params: None
: None
params: The name of a cmp to be used in class averaging (default=ccc)
: None
params: None
: None
params: None
: None
params: None
: None
params: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "refine 2D bispec" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps *e2refine2d_bispec.py* EMAN2 program.

    This program is used to produce reference-free class averages
    from a population of mixed, unaligned particle images. These averages
    can be used to generate initial models or assess the structural
    variability of the data. They are not normally themselves used as part
    of the single particle reconstruction refinement process, which
    uses the raw particles in a reference-based classification
    approach. However, with a good structure, projections of the
    final 3-D model should be consistent with the results of
    this reference-free analysis.

    This variant of the program uses rotational/translational
    invariants derived from the bispectrum of each particle.
.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Choose e2ctf auto protocol: Select EMAN CTF auto protocol that has generated bispectra.
Number of class-averages: Number of class-averages to generate. Normally you would want a minimum of ~10-20 particles per class on average, but it is fine to have 100-200 for a large data set. If you plan on making a large number (>100) of classes, you should use the *Fast seed* option. Note that these averages are not used for final 3-D refinement, so generating a very large number is not useful in most situations.
Number of MSA vectors to use: Number of MSa basis vectors to use when classifying particles.
Normalize projected vectors?: Normalizes each projected vector into the MSA subspace. Note that this is different from normalizing the input images since the subspace is not expected to fully span the image
Align and sort?: This will align and sort the final class-averages based on mutual similarity.
: None
params: None
Additional arguments:: In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. 
The command "e2refine2d_bispec.py -h" will print a list of possible options.
These parameters are for advanced users only!
: For help please address to EMAN2 [[http://blake.bcm.edu/emanwiki/EMAN2][Wiki]] or run:
*scipion run e2help.py cmp -v 2* or
*scipion run e2help.py averagers -v 2*
Number of iterations for class-averages: Number of iterations to use when making class-averages (default=5)
Fraction of particles to keep: The fraction of particles to keep in each class, based on the similarity score generated by cmp (default=0.8)
Keep particles based on sigma?: Change the *keep* criterion from fraction-based to sigma-based
Class averager: : The averager used to generated class-averages
: None
params: None
: None
params: The name of a cmp to be used in class averaging (default=ccc)
: None
params: None
: None
params: None
: None
params: None
: None
params: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tilt validate" can be found at the eman2 plugin.
Its help description is:
 
    This protocol wraps the *e2tiltvalidate.py* EMAN2 program.
    It performs tilt validation using
    the method described in Rosenthal and Henderson, JMB (2003).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volume: Select the input volume that will be validated.
Input tilt pair particles: Select the input set of tilt pair particles.
Symmetry group: Set the symmetry; if no value is given then the model is assumed to have no symmetry. 
Choices are: *i, c, d, tet, icos, or oct* 
See http://blake.bcm.edu/emanwiki/EMAN2/Symmetry
for a detailed description of symmetry in Eman.
Max tilt angle: Maximum tilt angle permitted when finding tilt distances.
Use quaternions: Use quaternions for tilt distance computation
Projection step (deg.): Angular step size for alignment
Shrink particles: Optionally shrink the input particles by an integer amount prior to computing similarity scores. For speed purposes.
Do contour plot?: Also make a contour plot similar to fig. 6 in Henderson paper
Tilt range: The angular tilt range to search
Verbose level: Verbose level from 0 to 9. 
These parameters are for advanced users only!
: For help please address to EMAN2 [[http://blake.bcm.edu/emanwiki/EMAN2][Wiki]] or run:
*e2help.py cmp -v 2* or
*e2help.py aligners -v 2*
type: None
params: None
type: None
params: None
type: None
params: None
type: None
params: None
type: None
params: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "bin tomograms" can be found at the dynamo plugin.
Its help description is:
 Reduce the size of a SetOfTomograms by a binning factor.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: None
Binning Factor: A Binning Factor of 1 means that no binning will be carried out.
Number of slices kept in memory: Maximum number of Z slices that are kept simultaneously in the memory during the binning process. This parameter might be important for larger size tomograms, making possible to process them in vertical slabs of thickness = value introduced in the  current parameter. This procedure can be accelerated using the multiple threads to engage several cores in parallel. However, this will only make sense if the total memory occupied by all the slabs simultaneously in memory in a given time fits in the RAM of the machine.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "vectorial picking" can be found at the dynamo plugin.
Its help description is:
 Manual vectorial picker from Dynamo. After choosing the Tomogram to be picked, the tomo slicer from Dynamo will
     be direclty loaded with all the models previously saved in the disk (if any).
     This picking will save the "user points" defined in a set of models and generate a set of meshes with them. In case
     the user carries out the workflow model for each of the models from the Dynamo GUI, a set of coordinates will be
     also created, containing all the interpolated coordinates, and the calculated orientation. It is possible to
     create several models at once in a given tomogram. Once the coordinates are defined, the models are automatically
     saved in the catalogue and registered..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select the Tomogram to be used during picking.
Box Size: None
Remove the .m files generated after the execution?: It can be useful for developers to check exactly what was .m files were generated by Scipion and executed by Dynamo.

The protocol named "subtomogram extraction" can be found at the dynamo plugin.
Its help description is:
 Extraction of subtomograms using Dynamo.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Coordinates: None
Tomogram source: By default the subtomograms will be extracted from the tomogram used in the picking step ( _same as picking_ option ).
If you select _other_ option, you must provide a different tomogram to extract from.
*Note*: In the _other_ case, ensure that provided tomogram and coordinates are related 
Input tomogram: Select the tomogram from which to extract.
Box size: The subtomograms are extracted as a cubic box of this size. The wizard will select the box size considering the sampling rate ratio between the introduced coordinates and the tomograms that will br used for the extraction.
Invert contrast?: Invert the contrast if your tomogram is black over a white background.  Xmipp, Spider, Relion and Eman require white particles over a black background.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "import subtomograms from tbl files" can be found at the dynamo plugin.
Its help description is:
  This protocol imports subtomograms with metadata generated from Dynamo tables.
    The subtomograms files are generated in the same directory as the .tbl file, one for each tomogram..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Tomograms (opt.): If not provided, the subtomograms won't be referred to any tomogram. If provided, the sampling rate value will be read from them.
Sampling rate [Å/px] (opt.): None

The protocol named "model workflow" can be found at the dynamo plugin.
Its help description is:
 
    Apply a model workflow to a SetOfMeshes generated by Dynamo Boxing protocol.
    This workflow will use the models created by the user to create the
    corresponding cropping meshes needed to extract the crop points.
    Considerations:
        1. The geometry will be automatically approximated from the clicked points.
        2. The meshes for the general models will be calculated treating them as surface models.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Meshes: Input Meshes that will be used to create the cropping geometry and to extract the crop points
Box size: None
Mesh parameter: Intended mesh parameter for the "mesh" that supports the depiction of the model. It governs the number or triangles.
Maximun number of triangles: Maximum number of triangles allowed during generation of a depiction mesh
Refine mesh?: If set to Yes, it will refine both the mesh and the cropped mesh, which means that the depiction grid will be subdivided (each triangle will generate four children). Hence, a higher number of points will be generated, but the computation time will be significantly increased.
Subdivision iterations: Specify the number of times the Mesh geometry will be subdivided. This will increase the number of triangles in the mesh, making it smoother. However, it will also increase the number of cropping points
Cropping parameter: Intended mesh parameter for the "crop_mesh" that defined a cropping geometry on a surface

The protocol named "Average subtomograms" can be found at the dynamo plugin.
Its help description is:
 None.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Subtomograms: None
Do implicit rotation masking? (opt.): If set to Yes, in the rotated particles, the material outside a spherical mask will not be computed. The particles will de facto appear with a spherical mask.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "Subtomogram alignment" can be found at the dynamo plugin.
Its help description is:
 This protocol will align subtomograms using Dynamo.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: This protocol has both CPU and GPU implementation. Select the one you want to use.
: Add a list of GPU devices that can be used
Set of subtomograms: Set of subtomograms to align with dynamo
Template: The size of the template should be equal or smaller than the size of the particles.
Iterations (R): Number of iterations per round (R). Used to identify the number of rounds desired to be carried out.
Particle dimensions (R): If only one round, leave 0 to use the size of your particle. If working with multiple rounds, the size of the particles for each round is expected to be explicitly specified. If not, the size of the input particles will be used for all the rounds. This option can be used, for example, to reduce the particles size for a particular round and increase the speed. E.g.: 64 128 128.
Launch dynamo GUI: Launches Dynamo's alignment project GUI. Do not 'Run' the project, Scipion will do it for you.
Alignment mask (opt): This is the MOST important mask from the different types that can be used by Dynamo. It is used for the local correlation. The template is rotated and shifted (virtually, through fourier acceleration). At each posible combination of rotation angles and shift, the mask is also rotated and shifted, defining a moving region inside the template. The rotated and shifted template is compared to the data particle only inside this moving region. See more details in https://wiki.dynamo.biozentrum.unibas.ch/w/index.php/Alignment_mask.
Fourier mask on template (opt): Used in very few special cases. The Fourier Mask that you define on a template during an alignment project describes the Fourier content of the template, not the one of the data particles. It does not reflect directly the missing wedge of the tomogram. See more details in https://wiki.dynamo.biozentrum.unibas.ch/w/index.php/Fourier_mask_on_template.
Fourier Shell Correlation mask (opt): Used in the context of adaptive bandpass filtering. This procedure needs an automatic evaluation of the attained resolution at each iteration step. This is performed through and FSC computation of the averages computed independently in the different channels of the odd/even computation. See more details in https://wiki.dynamo.biozentrum.unibas.ch/w/index.php/Smoothing_mask
Cone aperture (R): The ‘cone_’ parameters define a set of orientations that will be sampled around a previously determined old orientation. Here we speak of orientations of the vertical axis of the template, not full unconstrained rotations. Allowing this axis to move inside a cone involves only two Euler angles (tdrot and tilt).

‘cone_range’, is the extent of this cone in degrees (360 being the full possible range of axis orientations).
Cone sampling (R): The ‘cone_’ parameters define a set of orientations that will be sampled around a previously determined old orientation. Here we speak of orientations of the vertical axis of the template, not full unconstrained rotations. Allowing this axis to move inside a cone involves only two Euler angles (tdrot and tilt).

’cone_sampling’ is the step inside the cone defined by ´cone_range´, also in degrees. The orientations are generated so as to provide an uniform coverage.
Cone flip (R): Generates a mirrored scanning geometry: the "cone" of directions is complemented with the diametrally oposed cone.
This is useful when averaging elongated particles in the case in which the direction of each one is not certain, i.e., the initial table catches the overall orientation of each particle, but it is not certain on which end is the "head" and which is the "tail", so that the refinement should allow "flippling" the particles (but still produce a scanning set of angles concentrated along the axis of the particle). Values:

	* 0:  No inversion of the cone (default!)
	* 1:  The cone is inverted only for the coarsest level of the multigrid refinement
	* 2:  The cone is inverted for all refinement levels
Azimuth rotation range (R): The ‘inplane_’ parameters complete the set of scanned Euler triplets. After each of the axis reorentations defined by the ‘cone_’ parameters, the template will be rotated about the new orientation of its axis. This involves only the ‘narot’ angle.

‘inplane_range’ defines the angular interval to be scanned around the old value of narot.
Azimuth rotation sampling (R): The ‘inplane_’ parameters complete the set of scanned Euler triplets. After each of the axis reorentations defined by the ‘cone_’ parameters, the template will be rotated about the new orientation of its axis. This involves only the ‘narot’ angle.

The project parameter ‘inplane_range’ defines the angular interval to be scanned around the old value of narot, and ‘inplane_sampling’ defines the interval.
Azimuth flip (R): Flips the set of inplane rotations.
The set of inplane rotations to scan will be the original set plus the flipped orientations.
This is useful when the particles have a directionality, but it is not very well defined. For instance, if you have decorations on a microtubule, you might expect that most of them will have similar orientations along the direction of the tube. However, this direction might not be obvious: if you have particles coming from two different tubes, reducing the span of azimuthal rotations to a narrow set along the estimated direction of the tube might be dangerous, as the particles from the two tubes might be oriented in different directions.Values:

	* 0  :  no flip (default).
	* 1  :  flips the coarsest level  in the multilevel grid.
	* 2  :  flips the full set (all levels).
Refine iterations per particle (R): How many refinement iterations are carried out on each single particle. This refinement when comparing rotations of the reference against the data, takes the best orientation and looks again with a finer sampling. The sampling in the refined search will be half of the sampling used in the original one.  The range of the refined search encompasses all the orientations that neighobur the best orientation found in the original search.
Refine factor (R): Controls the size of the angular neighborhood during the local refinement of the angular grid.
Shift limits (R): Restricts the search area to an sphere of the given radius centered and oriented in the last found position (Ellipsoid will be implemented soon).
Shift limiting way (R): States how exactly the shifts (area search) will be interpreted:

	* 0:  no limitations (can easily produce artifacts if the initial reference is bad).
	* 1:  limits are understood from the center of the particle cube.
	* 2:  limits are understood from the previous estimation on the particle position (i.e., the shifts available) With this option, the origin of the shifts changes at every iteration.
	* 3:  limis are understood from the estimation provided for the first iteration of the round. The origin of the shifts will change at each round.
	* 4:  limis are understood from the estimation provided for the first iteration of the project. The origin of the shifts is thus defined for the full project, and stays static all during the full computation.

Note that options 3 and 4 are useful to avoid particles gradually shifting away from the initially user-entered locations.
Separation in tomogram [pix.] (R): When tuned to  positive number, it will check the relative positions (positions in the tomogram+shifts) of all the particles in each tomogram separately. Whenever two particles are closer together than "separation_in_tomogram", only the particle with the higher correlation will stay.
Threshold parameter (R): Different thresholding policies can be used in order to select which particles are averaged in view of their CC (cross correlation value) . The value of the thresholding parameter defined here  will be interpreted differently depending on the "threshold_modus"
Threshold modus (R): Specify which particles contribute to the average at the end of each iteration. Different thresholding policies can be used to select particles according to their CC value. Thus value of the "threshold" parameter you input  (denoted as THRESHOLD below) will be interpreted differently depending on the "threshold_modus" defined here.

Possible values of the thresholding policy "threshold_modus":

	* 0: no thresholding policy
	* 1: THRESHOLD is an absolute threshold (only particles with CC above this value are selected).
	* 2: effective threshold = mean(CC) * THRESHOLD.
	* 3: effective threshold = mean(CC) + std(CC) * THRESHOLD.
	* 4: THRESHOLD is the total number of particles (ordered by CC ).
	* 5: THRESHOLD ranges between 0 and 1  and sets the fraction of particles.
Second threshold parameter (R): Thresholding II is operated against the average produced by the particles that survivedthe first thresholding.
Second threshold modus (R): Thresholding II is operated against the average produced by the particles that survived the first thresholding. It uses the same syntax as Threshold I
High pass (R): Cut off frequency for high pass filtering. The units are pixels in the Fourier space of the particle (if your template is smaller than the data, the bandpass parameters will be rescaled). The bandpass works with a soft mask, allowing a smoothing window of two pixels around the cut frequency.
Low frequency (R): Cut off frequency for low pass filtering. The units are pixels in the Fourier space of the particle (if your template is smaller than the data, the bandpass parameters will be rescaled). The bandpass works with a soft mask, allowing a smothing window of two pixels around the cut frequency.
Symmetry group (R): Symmetrization is applied at the beginning of the round to the input reference. It is also used during the computation of the [eo_fsc] or the iteration.
First chars in string indicate thetype of symmetry operator:

	* 'c'  rotational symmetry around z.
	* 'h'  helical symmetry around z  (parameters: dpsi; dz).
	* 'ico'  icosahedral symmetry.
	* 'cbo' for cuboctahedral symmetry.
The rest of the string contains the respective parameters. Examples: 'c1', 'h60,5' ,'h[60,5]','h[-60,5]'
Cross-correlation matrix batch: Number of particles to be kept in memory simultaneously during the computation of the ccmatrix. The larger this number, the more efficient the algorithm performance, as more computations can be kept for reuse.However, trying to keep all the particles in memory can lead to saturate it,blocking the CPU. Additionally, a small batch allows to divide the matrix in more blocks. This might be useful in parallel computations.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "ctffind4" can be found at the cistem plugin.
Its help description is:
  Estimate CTF for a set of micrographs with ctffind4.
    
    To find more information about ctffind4 visit:
    https://grigoriefflab.umassmed.edu/ctffind4
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Do recalculate ctf?: None
Input previous run: None
: None
: None
Input micrographs: None
Input movies: None
No. movie frames to average: When estimating parameters from movie frames, enter how many frames should be included in the sub-averages used to calculate the amplitude spectra.
Use power spectra?: If set to Yes, the CTF estimation will be done using power spectra calculated during Relion motion correction.
FFT box size (px): The dimensions (in pixels) of the amplitude spectrum CTFfind will compute. Smaller box sizes make the fitting process significantly faster, but sometimes at the expense of fitting accuracy. If you see warnings regarding CTF aliasing, consider increasing this parameter.
Min: None
Max: None
Min: None
Max: None
Defocus step (A): Step size for the defocus search.
Slower, more exhaustive search?: Select this option if CTF determination fails on images that show clear Thon rings and should therefore yield good CTF parameters, or if you expect noticeably elliptical Thon rings and high noise.
Restrain astigmatism?: Should the amount of astigmatism be restrained during the parameter search and refinement? This option should be selected when astigmatism is expected to be small to produce more reliable fits. Disable this option if you expect large astigmatism.
Tolerated astigmatism (A): When restraining astigmatism, astigmatism values much larger than this will be penalized. Set to negative to remove this restraint. In cases where the amplitude spectrum is very noisy, such a restraint can help achieve more accurate results.
Find additional phase shift?: Was the data recorded using a phase plate with variable phase shift that must be determined together with the defocus parameters?
Minimum phase shift (deg): If finding an additional phase shift, this value sets the lower bound for the search.
Maximum phase shift (deg): If finding an additional phase shift, this value sets the upper bound for the search.
Phase shift search step (deg): If finding an additional phase shift, this value sets the step size for the search.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.

The protocol named "find particles" can be found at the cistem plugin.
Its help description is:
  Protocol to pick particles (ab-initio or reference-based) using cisTEM. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
CTF estimation: Choose some CTF estimation related to the input micrographs.
Picking algorithm: None
Input references: Provide a set of 2D templates to use in the search.
Max particle radius (A): In Angstroms, the maximum radius of the particles to be found. This also determines the minimum distance between picks.
Characteristic particle radius (A): In Angstroms, the radius within which most of the density is enclosed. The template for picking is a soft-edge disc, where the edge is 5 pixels wide and this parameter defines the radius at which the cosine-edge template reaches 0.5.
Threshold peak height: Particle coordinates will be defined as the coordinates of any peak in the search function which exceeds this threshold. In numbers of standard deviations above expected noise variations in the scoring function. See Sigworth (2004) for definition.
Avoid high variance areas: Avoid areas with abnormally high local variance. This can be effective in avoiding edges of support films or contamination.
Particles are white on a dark background?: None
Highest resolution used in picking (A): The template and micrograph will be resampled (by Fourier cropping) to a pixel size of half the resolution given here. Note that the information in the corners of the Fourier transforms (beyond the Nyquist frequency) remains intact, so that there is some small risk of bias beyond this resolution.
Minimum distance from edges (px): No particle shall be picked closer than this distance from the edges of the micrograph. In pixels.
Use radial averages of templates: Say yes if the templates should be rotationally averaged
Rotate each template this many times: If > 0, each template image will be rotated this number of times and the micrograph will be searched for the rotated template.
Avoid areas with abnormal local mean: Avoid areas with abnormally low or high local mean. This can be effective to avoid picking from, e.g., contaminating ice crystals, support film.
Number of background boxes: Number of background areas to use in estimating the background spectrum. The larger the number of boxes, the more accurate the estimate should be, provided that none of the background boxes contain any particles to be picked.
Algorithm to find background areas: Testing so far suggests that areas of lowest variance in experimental micrographs should be used to estimate the background spectrum. However, when using synthetic micrographs this can lead to bias in the spectrum estimation and the alternative (areas with local variances near the mean of the distribution of local variances) seems to perform better
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "classify 2D" can be found at the cistem plugin.
Its help description is:
  Protocol to run 2D classification in cisTEM. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Continue from a previous run?: If you set to *Yes*, you should select a previous run of type *CistemProtRefine2D* class. The refinement will resume after the last completed iteration. It is ok to alter other parameters.
Select previous run: Select a previous run to continue from.
Continue from iteration: Select from which iteration do you want to continue. If you use *last*, then the last iteration will be used. Otherwise, a valid iteration number should be provided.
Input particles: Select the input particles.
Input class averages: Select starting class averages. If not provided, they will be generated automatically.
Are the particles black?: cisTEM requires particles to be black on white.
Number of classes: The number of classes that should be generated. This input is only available when starting a fresh classification run.
Number of cycles ro run: The number of refinement cycles to run. If the option "Auto Percent Used" is selected, 20 cycles are usually sufficient to generate good class averages. If the user decides to set parameters manually, 5 to 10 cycles are usually sufficient for a particular set of parameters. Several of these shorter runs should be used to obtain final class averages, updating parameters as needed (e.g. Percent Used, see example above).
Low resolution limit (A): The data used for classification is usually bandpass-limited to exclude spurious low-resolution features in the particle background. It is therefore good practice to set the low-resolution limit to 2.5x the approximate particle mask radius.
start: None
finish: None
Mask radius (A): The radius of the circular mask applied to the input class averages before classification starts. This mask should be sufficiently large to include the largest dimension of the particle. The mask helps remove noise outside the area of the particle.
Angular search step (deg): The angular step used to generate the search grid when marginalizing over the in-plane rotational alignment parameter. The smaller the value, the finer the search grid and the slower the search. It is often sufficient to set the step to 15deg as the algorithm varies the starting point of the grid in each refinement cycle, thereby covering intermediate in-plane alignment angles. However, users can try to reduce the step to 5deg (smaller is probably not helpful) to see if class averages can be improved further once no further improvement is seen at 15deg.
X: None
Y: None
Smoothing factor [0-1]: A factor that reduces the range of likelihoods used during classification. A reduced range can help prevent the appearance of "empty" classes (no members) early in the classification. Smoothing may also suppress some high-resolution noise. The user should try values between 0.1 and 1 if classification suffers from the disappearance of small classes or noisy class averages.
Exclude blank edges?: Should particle boxes with blank edges be excluded from classification? Blank edges can be the result of particles selected close to the edges of micrographs. Blank edges can lead to errors in the calculation of the likelihood function, which depends on the noise statistics.
Auto percent used?: Should the percent of included particles be adjusted automatically? A classification scheme using initially 300 particles/class, then 30% and then 100% is often sufficient to obtain good classes and this scheme will be used when this option is selected.
Percent used: The fraction of the dataset used for classification. Especially in the beginning, classification proceeds more rapidly when only a small number of particles are used per class, e.g. 300 (see example above). Later runs that refine the class averages should use a higher percentage and the final run(s) should use all the data. This option is only available when "Auto Percent Used" is not selected.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "resample tomogram" can be found at the cistem plugin.
Its help description is:
 
    Resample tomograms by Fourier cropping/padding using cisTEM. This is equivalent to binning/unbinning operations but free of aliasing artifacts.

    More info:
        https://cistem.org
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tomograms: None
New X-Size: Volume will be rescaled to this size in X dimension (voxels)
New Y-Size: Volume will be rescaled to this size in Y dimension (voxels)
New Z-Size: Volume will be rescaled to this size in Z dimension (voxels)

The protocol named "tilt-series ctffind4" can be found at the cistem plugin.
Its help description is:
  CTF estimation on a set of tilt series using CTFFIND4. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tilt series: None
: None
: None
: None
: None
FFT box size (px): The dimensions (in pixels) of the amplitude spectrum CTFfind will compute. Smaller box sizes make the fitting process significantly faster, but sometimes at the expense of fitting accuracy. If you see warnings regarding CTF aliasing, consider increasing this parameter.
Min: None
Max: None
Min: None
Max: None
Defocus step (A): Step size for the defocus search.
Slower, more exhaustive search?: Select this option if CTF determination fails on images that show clear Thon rings and should therefore yield good CTF parameters, or if you expect noticeably elliptical Thon rings and high noise.
Restrain astigmatism?: Should the amount of astigmatism be restrained during the parameter search and refinement? This option should be selected when astigmatism is expected to be small to produce more reliable fits. Disable this option if you expect large astigmatism.
Tolerated astigmatism (A): When restraining astigmatism, astigmatism values much larger than this will be penalized. Set to negative to remove this restraint. In cases where the amplitude spectrum is very noisy, such a restraint can help achieve more accurate results.
Find additional phase shift?: Was the data recorded using a phase plate with variable phase shift that must be determined together with the defocus parameters?
Minimum phase shift (deg): If finding an additional phase shift, this value sets the lower bound for the search.
Maximum phase shift (deg): If finding an additional phase shift, this value sets the upper bound for the search.
Phase shift search step (deg): If finding an additional phase shift, this value sets the step size for the search.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "resample tilt series" can be found at the cistem plugin.
Its help description is:
 
    Resample tilt series by Fourier cropping/padding using cisTEM. This is equivalent to binning/unbinning operations but free of aliasing artifacts.

    More info:
        https://cistem.org
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tilt series: None
New X-Size: Volume will be rescaled to this size in X dimension (voxels)
New Y-Size: Volume will be rescaled to this size in Y dimension (voxels)

The protocol named "unblur" can be found at the cistem plugin.
Its help description is:
  This protocol wraps unblur movie alignment program. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
: None
: None
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
Compute PSD?: If Yes, the protocol will compute for each aligned micrograph the PSD using EMAN2.
Compute micrograph thumbnail?: When using this option, we will compute a micrograph thumbnail with EMAN2 and keep it with the micrograph object for visualization purposes. 
Additional protocol parameters: Here you can provide some extra parameters for the protocol, not the underlying unblur program.You can provide many options separated by space. 

*Options:* 

--use_worker_thread 
 Use an extra thread to compute PSD and thumbnail. This will allow requires an extra CPU. 
Min shift: None
Max shift: None
Exposure filter sums?: If selected the resulting aligned movie sums will be calculated using the exposure filter as described in Grant and Grigorieff (2015). Pre-exposure and dose per frame should  be specified during movies import.
Restore power? : If selected, and the exposure filter is used to calculate the sum then the sum will be high pass filtered to restore the noise power. This is essentially the denominator of Eq. 9 in Grant and Grigorieff (2015).
Termination threshold (A): The frames will be iteratively aligned until either the maximum number of iterations is reached, or if after an alignment round every frame was shifted by less than this threshold.
Max iterations: The maximum number of iterations that can be run for the movie alignment. If reached, the alignment will stop and the current best values will be taken.
B-factor (A^2): This B-Factor is applied to the reference sum prior to alignment. It is intended to low-pass filter the images in order to prevent alignment to spurious noise peaks and detector artifacts.
Horiz. mask (px): None
Vert. mask (px): None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "cryolo tomo picking (manual)" can be found at the sphire plugin.
Its help description is:
  Picks particles or filaments in a set of tomograms using napari_boxmanager. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select the Tomogram to be used during picking.

The protocol named "cryolo picking" can be found at the sphire plugin.
Its help description is:
  Picks particles in a set of micrographs with crYOLO.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
Picking model: : You might use a general network model that consists of
	-cryo: real, simulated, particle free datasets on various grids with contamination
	-negative stain: trained withnegative stain images
and skip training completely,
or,
if you would like to improve the results you can use the model from a previous training step or an imported one.
Input model: Select an existing crYOLO trained model.
Confidence threshold: If you want to pick less conservatively or more conservatively you might want to change the threshold from the default of 0.3 to a less conservative value like 0.2 or more conservative value like 0.4.
Low-pass filter: CrYOLO works on original micrographs but the results will be probably improved by the application of a reasonable low-pass filter.
Cut-off frequency: Specifies the absolute cut-off frequency for the low-pass filter.
Number of CPUs: *Important!* This is different from number of threads above as threads are used for GPU parallelization. Provide here the number of CPU cores for each cryolo process.
Input size: This is the size to which the input is rescaled before passed through the network.For example the default value would be 1024x1024.
Box Size (optional): Box size in pixels. It should be the size of the minimum particle enclosing square in pixel. If introduced value is zero, it is estimated.
Maximum box per image: Maximum number of particles in the image. Only for the memory handling. Keep the default value of 700.
: Set to True if you want to use GPU implementation.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. crYOLO can use multiple GPUs - in that case set to i.e. *0 1 2*.
Adjust estimated box size by: Value to multiply crYOLO estimated box size to be registered with the SetOfCoordinates. It is usually very tight.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.

The protocol named "cryolo tomo picking" can be found at the sphire plugin.
Its help description is:
  Picks particles in a set of tomograms. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select the Tomogram to be used during picking.
Picking model: : You might use a general network model that consists of
	-cryo: real, simulated, particle free datasets on various grids with contamination
	-negative stain: trained withnegative stain images
and skip training completely,
or,
if you would like to improve the results you can use the model from a previous training step or an imported one.
Input model: Select an existing crYOLO trained model.
Confidence threshold: If you want to pick less conservatively or more conservatively you might want to change the threshold from the default of 0.3 to a less conservative value like 0.2 or more conservative value like 0.4.
Low-pass filter: CrYOLO works on original micrographs but the results will be probably improved by the application of a reasonable low-pass filter.
Cut-off frequency: Specifies the absolute cut-off frequency for the low-pass filter.
Number of CPUs: *Important!* This is different from number of threads above as threads are used for GPU parallelization. Provide here the number of CPU cores for each cryolo process.
Input size: This is the size to which the input is rescaled before passed through the network.For example the default value would be 1024x1024.
Box Size (optional): Box size in pixels. It should be the size of the minimum particle enclosing square in pixel. If introduced value is zero, it is estimated.
Maximum box per image: Maximum number of particles in the image. Only for the memory handling. Keep the default value of 700.
: Set to True if you want to use GPU implementation.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. crYOLO can use multiple GPUs - in that case set to i.e. *0 1 2*.
Search range (px): Search range in pixel. On default it will choose 25 percent of the box size (default: -1).
Minimum length: The minimum number of boxes in one trace to be considered as valid particle (default: 5).
Tracing memory: The maximum number of frames during which a particle can vanish, then reappear nearby, and be considered the same particle (default: 0).
Activate filament mode?: None
Box distance (px): Distance in pixels between two boxes
Minimum number of boxes: Minimum number of boxes per filament
Straightness method: Method to measure the straightness of a line.
LINE_STRAIGHTNESS divides the length from start to end by accumulated length between adjacent boxes.
RMSD calculates the root means squared deviation of the line points to line given by start and the endpoint of the filament. Adjust the straightness_method accordingly!
Straightness threshold: Threshold value for the straightness method. The default value works good for LINE_STRAIGHTNESS. Lines with a LINE_STRAIGHTNESS lower than this threshold get split. For RMSD, lines with a RMSD higher than this threshold will be split. A good value for RMSD is 20 percent of your filament width
Search range factor: The search range for connecting boxes is the box size times this factor
Angle delta: Angle delta in degree. This value is good more or less straight filament. More curvy filament might require values around 20
Directional method: Directional method
Filament width (px): None
Mask width: Mask width in pixel. A gaussian filter mask is usedto estimate the direction of the filaments. This parameter defines how elongated the mask is. The default value typically don't has to be changed
Do not merge filaments?: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "cryolo tomo training" can be found at the sphire plugin.
Its help description is:
  Train crYOLO picker using a set of 3D coordinates. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tomograms: Select the SetOfTomograms to be used during picking.
Input coordinates 3D: Please select a set of coordinates 3D, obtained from a previous picking run.
Fine-tune previous model?: Since crYOLO 1.3 you can train a model for your data by fine-tuning the general model.The general model was trained on a lot of particles with a variety of shapes and therefore learned a very good set of generic features.
Use previous model: : You might use a general network model that consists of real, simulated, particle free datasets on various grids with contamination and skip training completely or if you would like to improve the results you can use the model from a previous training step or an imported one.
Input model: Select an existing crYOLO trained model.
Confidence threshold: If you want to pick less conservatively or more conservatively you might want to change the threshold from the default of 0.3 to a less conservative value like 0.2 or more conservative value like 0.4.
Low-pass filter: CrYOLO works on original micrographs but the results will be probably improved by the application of a reasonable low-pass filter.
Cut-off frequency: Specifies the absolute cut-off frequency for the low-pass filter.
Number of CPUs: *Important!* This is different from number of threads above as threads are used for GPU parallelization. Provide here the number of CPU cores for each cryolo process.
Input size: This is the size to which the input is rescaled before passed through the network.For example the default value would be 1024x1024.
Box Size (optional): Box size in pixels. It should be the size of the minimum particle enclosing square in pixel. If introduced value is zero, it is estimated.
Maximum box per image: Maximum number of particles in the image. Only for the memory handling. Keep the default value of 700.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. crYOLO can use multiple GPUs - in that case set to i.e. *0 1 2*.
Early stop patience: The training stops when the 'loss' metric on the validation data does not improve 10 times in a row. This is typically enough. In case want to give the training more time to find the best model you might increase this parameters to a higher value (e.g 15).
Maximum number of iterations: Maximum number of epochs the network will train. Basically never reach this number, as crYOLO stops training if it recognize that the validation loss is not improving anymore.
Learning rates: If the number is too small convergence can be slow.
Batch size: The number of images crYOLO process in parallel during training.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "cryolo training" can be found at the sphire plugin.
Its help description is:
  Train crYOLO picker using a set of coordinates. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
Input coordinates: Please select a set of coordinates, obtained from a previous picking run. Typically the coordinates from ~ 10 micrographs is a good start.
Fine-tune previous model?: Since crYOLO 1.3 you can train a model for your data by fine-tuning the general model.The general model was trained on a lot of particles with a variety of shapes and therefore learned a very good set of generic features.
Use previous model: : You might use a general network model that consists of real, simulated, particle free datasets on various grids with contamination and skip training completely or if you would like to improve the results you can use the model from a previous training step or an imported one.
Input model: Select an existing crYOLO trained model.
Confidence threshold: If you want to pick less conservatively or more conservatively you might want to change the threshold from the default of 0.3 to a less conservative value like 0.2 or more conservative value like 0.4.
Low-pass filter: CrYOLO works on original micrographs but the results will be probably improved by the application of a reasonable low-pass filter.
Cut-off frequency: Specifies the absolute cut-off frequency for the low-pass filter.
Number of CPUs: *Important!* This is different from number of threads above as threads are used for GPU parallelization. Provide here the number of CPU cores for each cryolo process.
Input size: This is the size to which the input is rescaled before passed through the network.For example the default value would be 1024x1024.
Box Size (optional): Box size in pixels. It should be the size of the minimum particle enclosing square in pixel. If introduced value is zero, it is estimated.
Maximum box per image: Maximum number of particles in the image. Only for the memory handling. Keep the default value of 700.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. crYOLO can use multiple GPUs - in that case set to i.e. *0 1 2*.
Early stop patience: The training stops when the 'loss' metric on the validation data does not improve 10 times in a row. This is typically enough. In case want to give the training more time to find the best model you might increase this parameters to a higher value (e.g 15).
Maximum number of iterations: Maximum number of epochs the network will train. Basically never reach this number, as crYOLO stops training if it recognize that the validation loss is not improving anymore.
Learning rates: If the number is too small convergence can be slow.
Batch size: The number of images crYOLO process in parallel during training.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "cryolo import" can be found at the sphire plugin.
Its help description is:
  Protocol to import an existing crYOLO training model.
    The model will be registered as an output of this protocol and
    can be used later for further training or picking.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Training model path: Provide the path of a previous crYOLO training model.

The protocol named "janni denoising" can be found at the sphire plugin.
Its help description is:
  Protocol to denoise a set of micrographs. .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: JANNI works on a single GPU.
Input micrographs: None

The protocol named "annotate particles" can be found at the deepfinder plugin.
Its help description is:
 This protocol allows you to annotate macromolecules in your tomograms, using a visual tool..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select the Tomogram to be used during picking.
Box size: Default box size for the output.

The protocol named "cluster" can be found at the deepfinder plugin.
Its help description is:
 This protocol analyses segmentation maps and outputs particle coordinates and class..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Segmentation maps: Please select the segmentation maps you would like to analyze.
Clustering radius: Should correspond to average radius of target objects (in voxels)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "generate sphere targets" can be found at the deepfinder plugin.
Its help description is:
  This protocol generates segmentation maps from annotations. These segmentation maps will be used as targets
     to train DeepFinder .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: 1 coordinate set per class. A set may contain coordinates from different tomograms.
Sphere radius [pix.]: Sphere radius, in voxels, per class. Should be separated by coma as follows: Rclass1,Rclass2, ...
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "segment" can be found at the deepfinder plugin.
Its help description is:
 This protocol segments tomograms, using a trained neural network..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomograms: Select the Tomogram to be used during picking.
Neural network model: Select a trained DeepFinder neural network.
Patch size: It must be a multiple of 4, due to the network architecture.
: GPU ID, normally it is 0.

The protocol named "train" can be found at the deepfinder plugin.
Its help description is:
  This protocol launches the training procedure .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Training TomoMasks: Training dataset. Please select here your TomoMasks. The corresponding tomograms will be loaded automatically.
Use specific set for Validation?: Recommended value as false. The default value (False) will atuomatically split the set of tomo masks according to the "Validation data fraction". If this parameter  is true, the user can provide a certain set of tomoMask for validating the training.
Validation TomoMasks: (Only available when "Use specific set for Validation" is True.) This is the validation set of tomo Masks to ensure that the network learns properly.
Validation data fraction: Fraction of the "Training Tomomasks" that will be used as validation dataset. The admitted values are [0.1, 0.5], which means from 10% to 50% of the introduced training tomo masks. Only applies if "Validation TomoMasks" is empty.
Coordinates: Select coordinate set.
Patch size: Size of patches loaded into memory for training.
Batch size: Number of patches used to compute average loss.
Number of epochs: At the end of each epoch, evaluation on validation set is performed (useful to check if network overfits).
Steps per epoch: Number of batches trained on per epoch.
Steps per validation: Number of batches used for validation.
Bootstrap: Can remain checked. Useful when in presence of unbalanced classes.
Random shift: (in voxels) Applied to positions in object list when sampling patches. Enhances network robustness. Make sure that objects are still contained in patches when applying shift.
: GPU ID, normally it is 0.

The protocol named "import DeepFinder coordinates" can be found at the deepfinder plugin.
Its help description is:
 Protocol to import a DeepFinder object list as a set of 3D coordinates in Scipion.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
: Select the type of import.
Files directory: Directory with the files you want to import.

The path can also contain wildcards to selectfrom several folders. 

Examples:
  ~/Tomograms/data/day??_tomograms/
Each '?' represents one unknown character

  ~/Tomograms/data/day*_tomograms/
'*' represents any number of unknown characters

  ~/Tomograms/data/day#_tomograms/
'#' represents one digit that will be used as tomogram ID

NOTE: wildcard characters ('*', '?', '#') cannot appear in the actual path.)
Pattern: Pattern of the files to be imported.

The pattern can contain standard wildcards such as
*, ?, etc, or special ones like ### to mark some
digits in the filename as ID.

NOTE: wildcards and special characters ('*', '?', '#', ':', '%') cannot appear in the actual path.
Copy files?: By default the files are not copied into the project to avoid data duplication and to save disk space. Instead of copying, symbolic links are created pointing to original files. This approach has the drawback that if the project is moved to another computer, the links need to be restored.
Input tomograms: Select the tomograms/tomogram for which you want to import coordinates. The file names of the tomogram and coordinate files must be the same.
Box size: Default box size for the output.

The protocol named "Load Training Model" can be found at the deepfinder plugin.
Its help description is:
 Use two data-independent reconstructed tomograms to train a 3D cryo-CARE network..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Model weights file: File which contains the weights for the neural network (.h5 file).
Number of classes: Number of classes corresponding to this model.

The protocol named "alphafold prediction" can be found at the chimerax plugin.
Its help description is:
  Protocol to import atomic structures generated by alphafold.

    If you choose the "Execute alphafold Locally" option you will need 
    a local alphafold NO docker instalation as
    described here: https://github.com/kalininalab/alphafold_non_docker
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Source to retrieve the AlphaFold2 model:: Retrieve the AlphaFold2 model from:
 * EBI database (identical sequence) in case your sequence is already included in the EBI database of AlphaFold2. This database covers the complete human proteome (including fragments for long proteins) and the proteomes of more than 40 other key organisms, as well as the majority of manually curated UniProt entries. Since this database is continuously updating, check the contents in https://alphafold.ebi.ac.uk/.
  If the structure of your sequence is already included in the EBI database you can retrieve it writing the UniProt ID.
 * EBI Database (homologous sequence): In case the structure prediction of your sequence has not been included in the EBI database yet, a Blast will be launched against that database. According to the Blast searching parameters, which you can modify, some homologous sequences of your sequence will be retrieved and you can select one of them as close prediction of your sequence initial model.
* Executing AlphaFold2 in Google-Colab taking advantage of ChimeraX or Phenix notebooks.
* Executing AlphaFold2 Locally (multimer supported)

UniProt name/ID : Write a UniProt ID (six or ten alphanumeric characters; examples: A2BC19, P12345, A0A022YWF9, DGAL_ECOLI).
 You can convert other database identifiers to UniProt accession codes by using the "ID Mapping" tab on https://www.uniprot.org/
Colab Notebook : Execute alphafold in Google-colab.
  Two notebooks are available from
 ChimeraX and Phenix, respectively
 TEST option is for debuging, do not use it
Reference sequence: Input the aminoacid sequence to blast or send to Google-Colab
similarity-matrix: The matrix option indicates which amino acid similarity-matrix to use for scoring the hits: BLOSUM45, BLOSUM50, BLOSUM62 (default), BLOSUM80, BLOSUM90, PAM30, PAM70, PAM250, or IDENTITY
cutoff: The cutoff evalue is the maximum or least significantexpectation value needed to qualify as a hit (default 1e-3).
Use this template: Fill if you want to supply a PDB template to Google-Colab
Skip Amber relaxation: This option allows skipping energy-minimization of the result from alphafold predict, for faster job completion and/or to avoid failures during minimization.
Use templates from PDB: Use this numbers of templates from PDB. If set to -1 no templates are used
Reference sequences: Include here one or more sequences to get the AlphaFold2 prediction of a monomer (one sequence) or a multimer (several sequences). 
Use Template until: Maximum template release date to consider (YYYY-MM-DD)
Is prokaryote?: Optional for multimer system, not used by the single chain system. A boolean specifying true where the target complex is from a prokaryote, and false where it is not, or where the origin is unknown. This value determine the pairing method for the MSA (default: 'None')
Use GPU acceleration?: If set to Yes, the job will try to use GPU acceleration.
Which GPUs to use:: This argument is not necessary. If left empty, the job itself will try to allocate available GPU resources. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use.
Extra flags: # -n <openmm_threads>   OpenMM threads (default: all available cores) -c <db_preset>        Choose preset MSA database configuration - smaller genetic database config (reduced_dbs) or full genetic database config (full_dbs) (default: 'full_dbs')
Extra commands for alphafold: Add extra commands in cmd file. Use for testing
Hide help popup window: If set to Yes no help message will be shown in chimera at start up.
Show results in ChimeraX: Show results in ChimeraX.

The protocol named "model from template" can be found at the chimerax plugin.
Its help description is:
 Protocol to model three-dimensional structures of proteins using Modeller.
        Execute command *scipionwrite #n [prefix stringAddedToFilename] from command line in order
        to transfer the selected
        pdb to scipion. Default value is model=#0,
        model refers to the pdb file..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Do you already have a template?: "Yes": Option by default. Select this option in case you already have a template to model your target sequence.
"No": Select this option if you want to search for a template with which model your target sequence. Generation of multimeric models is not allowed selecting this option.

Atomic structure used as template: PDBx/mmCIF file template used as basic atomic structure to model your specific sequence.
Chain : Select a particular chain of the atomic structure.
Target sequence: Input the aminoacid sequence to align with the structure template sequence.
Protein sequence database:: Select a protein sequence database to search for templates:
PDB: Experimentally determined structures in the Protein Data Bank.
NR: NCBI 'non-redundant'database. It contains GenBank translation proteins, PDB sequences, SwissProt proteins + PIR + PRF. Since NR is much larger than PDB, it takes longer to search.

Similarity matrix:: Select a similarity matrix to use for alignment scoring.

cutoff evalue:: Least significant expectation value needed to qualify the retrieved element as a hit.

Maximum number of sequences:: Maximum number of sequences to retrieve from the database.

Options to improve the alignment:: None: Option by default. Only the template and the target sequences will be included in the alignment. This option is recommendable when these two sequences are very similar. Otherwise, select any of the two additional options:
Additional sequences to align: Select this option if you want to add some more sequences to accomplish the alignment.
Provide your own sequence alignment: Your alignmentshould include both the target and the template sequences.

Sequence alignment input: Input your own sequence alignment.
ChimeraX allowed formats accessible here: https://www.cgl.ucsf.edu/chimerax/docs/user/commands/open.html#sequence 
Other sequences to align: In case you need to load more sequences to align, you can load them here.
Alignment tool for two sequences:: Select a program to accomplish the sequencealignment:

Biophyton module Bio.pairwise2 (http://biopython.org/DIST/docs/api/Bio.pairwise2-module.html). Built-in program to align two sequences. The global alignment algorithm from the EMBOSS suite has been implemented with match/mismatch scores of 3/-1 and gap penalties (open/extend) of 3/2.

Clustal Omega program (http://www.clustal.org/omega/, https://doi.org/10.1038/msb.2011.75): Multiple sequence alignment tool. Install clustalo if you choose this option for the first time by 'sudo apt-get install clustalo'.

MUSCLE program stands for MUltiple Sequence Comparison by Log- Expectation(http://www.drive5.com/muscle/muscle.html, https://doi.org/10.1093/nar/gkh340). Install muscle if you choose this option for the first time by 'sudo apt install muscle'.
Multiple alignment tool:: Select a program to accomplish the sequencealignment:

Clustal Omega program (http://www.clustal.org/omega/, https://doi.org/10.1038/msb.2011.75): Multiple sequence alignment tool. Install clustalo if you choose this option for the first time by 'sudo apt-get install clustalo'.

MUSCLE program stands for MUltiple Sequence Comparison by Log- Expectation(http://www.drive5.com/muscle/muscle.html, https://doi.org/10.1093/nar/gkh340). Install muscle if you choose this option for the first time by 'sudo apt install muscle'.
Additional target sequence to include?: Select YES if you want to add an additional target sequence to model according a different chain of the structure template. This option is recommendable when you want to model the two interacting elements of a particular complex at the same time.
Chain : Select a particular chain of the atomic structure.
Target sequence: Input the aminoacid sequence to align with the structure template sequence.
Options to improve the alignment:: None: Option by default. Only the template and the target sequences will be included in the alignment. This option is recommendable when these two sequences are very similar. Otherwise, select any of the two additional options:
Additional sequences to align: Select this option if you want to add some more sequences to accomplish the alignment.
Provide your own sequence alignment: Your alignmentshould include both the target and the template sequences.

Sequence alignment input: Input your own sequence alignment.
ChimeraX allowed formats accessible here: https://www.cgl.ucsf.edu/chimerax/docs/user/commands/open.html#sequence 
Other sequences to align: In case you need to load more sequences to align, you can load them here.
Alignment tool for two sequences:: Select a program to accomplish the sequencealignment:

Biophyton module Bio.pairwise2 (http://biopython.org/DIST/docs/api/Bio.pairwise2-module.html). Built-in program to align two sequences. The global alignment algorithm from the EMBOSS suite has been implemented with match/mismatch scores of 3/-1 and gap penalties (open/extend) of 3/2.

Clustal Omega program (http://www.clustal.org/omega/, https://doi.org/10.1038/msb.2011.75): Multiple sequence alignment tool. Install clustalo if you choose this option for the first time by 'sudo apt-get install clustalo'.

MUSCLE program stands for MUltiple Sequence Comparison by Log- Expectation(http://www.drive5.com/muscle/muscle.html, https://doi.org/10.1093/nar/gkh340). Install muscle if you choose this option for the first time by 'sudo apt install muscle'.
Multiple alignment tool:: Select a program to accomplish the sequencealignment:

Clustal Omega program (http://www.clustal.org/omega/, https://doi.org/10.1038/msb.2011.75): Multiple sequence alignment tool. Install clustalo if you choose this option for the first time by 'sudo apt-get install clustalo'.

MUSCLE program stands for MUltiple Sequence Comparison by Log- Expectation(http://www.drive5.com/muscle/muscle.html, https://doi.org/10.1093/nar/gkh340). Install muscle if you choose this option for the first time by 'sudo apt install muscle'.
Extra commands for chimera viewer: Add extra commands in cmd file. Use for testing

The protocol named "contacts" can be found at the chimerax plugin.
Its help description is:
 Identifies interatomic clashes and contacts based on van der Waals radii
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Atomic Structure:: Input atomic structure.
Chain Labeling: Dictionary that maps chains to labels.
Example: {'A':'h1', 'B':'h1', 'E':'h2'}
Contacts are calculated between two chains with distinct labels. Two chains with the same label are considered as a group. Contacts will be computed between any chain included in this group and any other group/chain. However, no contacts among members of the group will be calculated.
Apply symmetry:: 'Symmetry = Yes' indicates that symmetry will be applied, and then contacts will be computed between any two chains of the atomic structure (the unit cell) and between a chain of the unit cell and another chain of a neigbour unit cell. Output results will show only non redundant contatcs, i.e., contacts than you can infer by symmetry will not be shown.
'Symmetry = No' indicates that symmetry will not be applied, and then  contacts will only be calculated between chains within the atomic structure. Output results will show all contacts between any couple of interacting chains.

Symmetry: https://scipion-em.github.io/docs/release-2.0.0/docs/developer/symmetries.html?highlight=symmetrySymmetry for a description of the symmetry groups format in CHIMERA.
If no symmetry is present, use _c1_.More information: 
https://www.cgl.ucsf.edu/chimera/current/docs/UsersGuide/midas/sym.html
Symmetry Order: Select the order of cyclic or dihedral symmetry.
cutoff (Angstroms): : Large positive cutoff identifies the more severe clashes, whereas negative cutoff indicates favorable contacts:
default contact rule: -0.4 (from 0.0 to -1.0)
default clash rule: 0.6 (from 0.4 to 1.0)
More information: 
https://www.cgl.ucsf.edu/chimerax/docs/user/commands/clashes.html#top
allowance (Angstroms): : default contact rule: 0.0
default clash rule: 0.4
More information: 
https://www.cgl.ucsf.edu/chimerax/docs/user/commands/clashes.html#top

The protocol named "operate" can be found at the chimerax plugin.
Its help description is:
 This protocol provides access to Chimera and allows to save the result in Scipion framework.
            Execute command *scipionwrite #n [prefix stringAddedToFilename]
            model refers to the pdb file.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: Volume to process
Input additional Volumes: Other Volumes
Atomic structure: PDBx/mmCIF file that you can save after operating with it.
Other atomic structures: In case you need to load more PDBx/mmCIF files, you can load them here and save them after operating with them.
Extra commands for chimera viewer: Add extra commands in cmd file. Use for testing

The protocol named "restore session" can be found at the chimerax plugin.
Its help description is:
 This protocol opens Chimera and restores a session
      that has been stored each time a 3Dmap or an atomic structure 
      by using `scipionwrite` or `scipionss` commad.
      Execute command *scipionwrite #n [prefix stringAddedToFilename]
      model refers to the pdb file.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input protocols: protocol to be reloaded
Extra commands for chimera viewer: Add extra commands in cmd file. Use for testing

The protocol named "rigid fit" can be found at the chimerax plugin.
Its help description is:
 Protocol to perform rigid fit using Chimera.
            Execute command *scipionwrite #n [prefix stringAddedToFilename]
            model refers to the pdb file.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Volume: Volume to process
Input additional Volumes: Other Volumes
Atomic structure to be fitted: PDBx/mmCIF file to be fitted. 
Other reference atomic structures: Other PDBx/mmCIF files used as reference.
Extra commands for chimera viewer: Add extra commands in cmd file. Use for testing

The protocol named "map subtraction" can be found at the chimerax plugin.
Its help description is:
 Protocol to subtract two volumes.
        One of these volumes can be derived from an atomic structure.
        Execute command *scipionwrite #n [prefix stringAddedToFilename]*
        from command line in order to transfer the generated maps and models to scipion.
        In addition to maps and models that the protocol saves by default,
        the user can generate and save some others.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input 3D Map: Difference 3D map = minuend − subtrahend.
Input here the minuend of the subtraction.
Select the operation to perform: You can select "Subtract" to get the result minuend − subtrahend, or "Mask" to mask the minuend.
This mask is created with all those points that belong to the subtrahend and are greater than the level (0 level is not supplied).
Contour level (subtrahend): Difference 3D map = minuend − subtrahend.
"Calculation are made for those voxels inside a region created by this contour level
Empty value -> chimera computes the level.
Subtraction/Mask of: Difference 3D map = minuend − subtrahend.
Subtrahend 3D map may be provided by the user (choose '3D map') or created from an atomic coordinates file (choose 'atomic structure').
 If 3D Map is chosen, the sampling rate of the minuend should be equal to the sampling rate of the subtrahend.
Map to subtract (subtrahend): Map that has to be subtracted from the minuend 3D map.
Map resolution (A)::  The atomic structure file wil be used to create a 3D map.  Each atom is described as a 3D Gaussian distribution of  width proportional to the resolution and amplitude proportional  to the atomic number. We recommend half the value of the resolution obtained by FSC
Atomic structure: Atomic structure to derive a 3D map that will be subtracted from the minuend map.
Select a specific chain?: Select 'Yes' if you want to generate the map from a specific chain of the atomic structure.

Chain of the atomic structure: Select a particular chain of the atomic structure.
Remove residues from the atomic structure?: Select 'Yes' to remove a certain number of residues of one of the chains of the atomic structure. These removed residues might help you to establish a control of appropriate levels of map density.
In order to better visualize the area of removed residues, 10 residues will be highligthed before and after the first and the last residues selected, respectively.

Chain : Select a particular chain of the atomic structure.
Residues to remove : Select the first and last residues of the selected atomic structure chain that you want to remove. 
(Use Ctrl for multiple selection)
Apply symmetry to the atomic structure:: 'Symmetry = Yes' indicates that symmetry will be applied. This option is recommended if the atomic structure corresponds to the asymmetrical unit and you want to regenerate the structure of the whole map.
'Symmetry = No' indicates that symmetry will not be applied, and then  the map derived from the atomic structure involves only the atomic structure provided as input.

Symmetry: https://scipion-em.github.io/docs/docs/developer/symmetries
Symmetry for a description of the symmetry groups format in CHIMERA.
If no symmetry is present, use _c1_.More information: 
https://www.cgl.ucsf.edu/chimerax/docs/user/commands/sym.html
Symmetry Order: Select the order of cyclic or dihedral symmetry.
Range of distance: This value allows to generate copies with centers within a certain range of distance of the center of the original molecule model. A models's center is defined as the center of its bounding box.
Other atomic structures: In case you need to load more PDBx/mmCIF files, you can load them here. These structures will NOT be used to create the subtrahend.
Map fraction around the atomic structure?: Select 'Yes' if you want to limit the map to a certain radius around the atomic structure.

Atom radius (A): Set the radius (Angstroms) to select values of grid points farther than that radius from any atom.
Filter to apply to the differential map: Choose the filter to clean the background noise of the differential map.
Gaussian filter width: Set the width of the Gaussian filter.
Extra commands for chimera viewer: Add extra commands in cmd file. Use for testing

The protocol named "2d streamer" can be found at the emfacilities plugin.
Its help description is:
  This protocol will monitor an input set of particles
    (usually in streaming) and will run/schedule many copies
     of a given 2D classification protocol but using subsets
     of the input particles as the 2D classification input.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input 2D protocol: This protocol will serve as the template runthat will be repeated with subsets of the input particles. 
Input particles: Input particles that will be used to executemany 2D classification runs based on the 2D protocol template selected. 
Batch size: How many particles (approximately) you want to group to make the new batch and launch a new 2dclassification job. 
Starting number: Specify a value greater than 0 if you want to skip this amount of particles from the classification batches (e.g, if you have classified them for the initial 2D classification template. 
Update interval (min): After how many minutes the protocol should look for new input data and schedule more 2D classificationjobs if necessary. 

The protocol named "ctf monitor" can be found at the emfacilities plugin.
Its help description is:
  check CPU, mem and IO usage.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input protocols: this protocol will be monitorized
Sampling Interval (sec): Take one sample each SamplinInteval seconds
Raise Alarm if maximum defocus (A) >: Raise alarm if defocus is greater than given value
Raise Alarm if minimum defocus (A) <: Raise alarm if defocus is smaller than given value
Raise Alarm if astigmatism (A) >: Raise alarm if astigmatism is greater than given value
Total Logging time (min): Log during this interval
Enable Email notification?: Allow monitors to notify via email.
From: Provide the sender address for notifications.
To: Provide the destination address for notifications.
SMTP Mail server: Provide the address of SMTP mail server.

The protocol named "movie gain monitor" can be found at the emfacilities plugin.
Its help description is:
  check CPU, mem and IO usage.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input protocol: This protocol will be monitorized
Raise Alarm if residual gain standard deviation >: Raise alarm if residual gain standard deviation is greater than given value
Raise Alarm if the ratio between the 97.5 and 2.5 percentiles >: Raise alarm if the ratio between the 97.5 and 2.5 percentiles is greater than given value
Raise Alarm if the ratio between the maximum gain value and the 97.5 percentile >: Raise alarm if the ratio between the maximum gain value and the 97.5 percentile is greater than given value
Total Logging time (min): Log during this interval
Sampling Interval (sec): Take one sample each SamplinInteval seconds
Enable Email notification?: Allow monitors to notify via email.
From: Provide the sender address for notifications.
To: Provide the destination address for notifications.
SMTP Mail server: Provide the address of SMTP mail server.

The protocol named "monitor summary" can be found at the emfacilities plugin.
Its help description is:
  Provide some summary of the basic steps of the Scipion-Box:
    - Import movies
    - Align movies (global and/or local)
    - CTF estimation
    - Movie gain estimation.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input protocols: this protocol/s will be monitorized
Sampling Interval (sec): Take one sample each *samplingInterval* seconds
Total Logging time (min): Log during this interval. 21 days by default
Raise Alarm if residual gain standard deviation >: Raise alarm if residual gain standard deviation is greater than given value
Raise Alarm if the ratio between the 97.5 and 2.5 percentiles >: Raise alarm if the ratio between the 97.5 and 2.5 percentiles is greater than given value
Raise Alarm if the ratio between the maximum gain value and the 97.5 percentile >: Raise alarm if the ratio between the maximum gain value and the 97.5 percentile is greater than given value
Raise Alarm if maximum defocus (A) >: Raise alarm if defocus is greater than given value
Raise Alarm if minimum defocus (A) <: Raise alarm if defocus is smaller than given value
Raise Alarm if astigmatism >: Raise alarm if astigmatism (defocusU-defocusV)is greater than given value
Raise Alarm if CPU > XX%: Raise alarm if memory allocated is greater than given percentage
Raise Alarm if Memory > XX%: Raise alarm if cpu allocated is greater than given percentage
Raise Alarm if Swap > XX%: Raise alarm if swap allocated is greater than given percentage
Check GPU: Set to true if you want to monitor the GPU
Which GPUs to use:: Provide a list of GPUs (e.g. "0 1 2 3"). Default is to monitor GPU 0 only
Check Network: Set to true if you want to monitor the Network
Interface: Name of the network interface to be checked
Check Disk IO: Set to true if you want to monitor the Disk Acces
Enable Email notification?: Allow monitors to notify via email.
From: Provide the sender address for notifications.
To: Provide the destination address for notifications.
SMTP Mail server: Provide the address of SMTP mail server.
use grafana/influx: Use grafana+influx vs apache for reports
Publish command: Specify a command to publish the template. You can use the special token %(REPORT_FOLDER)s that will be replaced with the report folder. For example: 
rsync -avL %(REPORT_FOLDER)s scipion@webserver:public_html/

The protocol named "system_monitor" can be found at the emfacilities plugin.
Its help description is:
  check CPU, mem and IO usage.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input protocols: this protocol/s will be monitorized
Sampling Interval (sec): Take one sample each *samplingInterval* seconds
Total Logging time (min): Log during this interval
Raise Alarm if CPU > XX%: Raise alarm if memory allocated is greater than given percentage
Raise Alarm if Memory > XX%: Raise alarm if cpu allocated is greater than given percentage
Raise Alarm if Swap > XX%: Raise alarm if swap allocated is greater than given percentage
Enable Email notification?: Allow monitors to notify via email.
From: Provide the sender address for notifications.
To: Provide the destination address for notifications.
SMTP Mail server: Provide the address of SMTP mail server.
Check GPU: Set to true if you want to monitor the GPU
Which GPUs to use:: Providing a list of which GPUs (0,1,2,3, etc). Default is monitor GPU 0 only
Check Network: Set to true if you want to monitor the Network
Interface: Name of the network interface to be checked
Check Disk IO: Set to true if you want to monitor the Disk Access

The protocol named "Track used items" can be found at the emfacilities plugin.
Its help description is:
 
  This protocol will track the items (micrographs, classes2D,...) that has been used in a scipion protocol to
  generate a final volume. If the ids have been maintained, it will also track the not used items.
  .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input volumes: Select the sets of volumes to track their used items
Save images as JPG: Save micrographs and particles as jpg
Track used particles?: The particles used in the final volume reconstruction will be tracked
Original Particles: Set of Particles containing the complete set of original particles, including the used and filtered particles. If None, the set of particles with same sampling rate and furthest to the used particles will be used.
Track used micrographs?: The micrographs with picked particles used in the final volume reconstruction will be tracked and scored according to the number of used particles in them
Original micrographs: Set of micrographs containing the complete set of original mics, including the used and filtered mics. If None, the first protocol with output micrographs will be used. Each of these micrographs will be scored depending on the number of used particles in them
Track used CTFs?: The CTFs from micrographs with picked particles used in the final volume reconstruction will be tracked and scored according to the number of used particles in them
Track used coordinates?: The coordinates used in the final volume reconstruction will be tracked
Original Coordinates: Set of Coordinates where to get the coordinates parameters. If None, the first protocol with output Coordinates will be used
Pick negative coordinates: Picks noise from the micrographs as negative particle examples
Number of noise particles: Number of noise particles to extract from each micrograph. Set to -1 for extracting the same amount of noise particles as the number true particles for that micrograph
Track used Classes2D?: The Classes2D used in the final volume reconstruction will be tracked
Used Classes2D: Set of Classes2D where to track the used items. If None, the newer protocolwith output Classes2D will be used
Track used Classes3D?: The Classes3D used in the final volume reconstruction will be tracked
Used Classes3D: Set of Classes3D where to track the used items. If None, the newer protocolwith output Classes3D will be used
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "fils" can be found at the pyseg plugin.
Its help description is:
 filter a MbGraphMCF (Mean Cumulative Function) object by extracting a filament network.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Graphs: Pointer to graphs protocol.
Filament area: Source or destination (depending if you are in the Sources or Targets tab) area for the filament calculation.
Min: None
Max: None
range: None
Min: None
Max: None
range: None
Min: None
Max: None
range: None
Min: None
Max: None
range: None
Filament area: Source or destination (depending if you are in the Sources or Targets tab) area for the filament calculation.
Min: None
Max: None
range: None
Min: None
Max: None
range: None
Min: None
Max: None
range: None
Min: None
Max: None
range: None
Orientation with respect to the membrane/filament: None
Euclidean distance (STRAIGHT) range of vertices source-target (nm): None
Geodesic distance (CURVED) range of vertices source-target (nm): None
Filament sinuosity range (FLEXIBILITY, normally the ratio geoLen / eucLen): None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "graphs" can be found at the pyseg plugin.
Its help description is:
 analyze a GraphMCF (Mean Cumulative Function) from a segmented membrane.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Pre segmentation: Pointer to preseg protocol.
Vesicles packaging size: The input set of particles will be split into packages of N vesicles. Each package will be processed as a different step, allowing to continue the execution from the last step in case of the protocol fails. On the other hand, more packages implies more calls to PySeg, which can affect to performance.
Keep only required files?: If set to No, all the intermediate Disperse program resulting directories will be kept in the extra folder.
Sigma for gaussian filtering: Sigma for Gaussian foltering input tomograms. It allows to smooth small and irrelevant features and increases teh signal noise ratio (SNR). Higher values will provide less dense graphs (lower execution time), so they should be used when picking large particles, like ribosomes.
Vertex density within membranes (nm³): Vertex density within membranes. It allows to adjust simplification adaptively for every tomogram.
Avg ratio vertex/edge of graph within membrane: Averaged ratio vertex/edge in the graph within membrane.
Maximum distance to membrane (Å): Maximum euclidean distance to membrane in Å.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "picking" can be found at the pyseg plugin.
Its help description is:
 extract particles from a filament network of a oriented single membrane graph.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Fils protocol: Pointer to fils protocol.
Tomograms to refer the coordinates: Tomograms to which the coordinates should be referred to. If empty, it is assumed that the tomograms are the same from were the vesicles were segmented (pre-seg).
Box size (pixels): None
Segmentation area for picking: Area in which the cutting point or cutting point + projections of the filament will be considered for the picking coordinates.
Find on two surfaces: Track fiducials differentiating in which side of the sample are located.
Percentile of points to discard by their density level.: None
Min distance between selected points (nm).: Scale suppression in nm, two selected points cannot be closer than this distance.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "2D classification" can be found at the pyseg plugin.
Its help description is:
 Unsupervised and deterministic classification of membrane-bound particles.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input subtomograms: Select the input subtomograms desired to be classified.
Mask: Mask used for the post processing
Clustering algorithm: None
Filter size (voxels): A value of n means that the voxels will be grouped in groups of size n.
Do 3D radial compensation?: If "No" is selected, the normalized cross correlation (NCC) is made in 2D, otherwise radial average is compensated for doing a NCC in 3D.
Cross correlation metric: Metric used when computing the cross correlation matrix among the 2D particles. Considerations:
	- Mask normalized similarity is referred to negative squared Euclidean distance.
	- Full cross-correlation (slower than ross-correlation within the mask but allows small disalignments between particles).
PCA components for dim. reduction: Number of components (moments) after the reductions.
If 0 or None, then they will be automatically estimated considering the size ob the input subtomograms.
Number of clusters to find: None
Affinity propagation preference (-inf, inf): Preference parameter (-inf, inf).
The smaller value the higher number of potential classes.
If None, the median of the affinity class is considered.
Dumping [0.5, 1): Dumping parameter [0.5, 1), it controls convergence speed.
Maximum number of iterations: None
Iterations for fitting the convergence criteria: None
Reference 2D image used for classes: None
Minimum number of particles per class: Purge classes with less than the specified number of particles. If 0, this filter will not be applied.
Cross-correlation against AP reference filter: Purge classes with the cross correlation against the reference lower than the specified value. If 0, this filter will not be applied.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "posrec" can be found at the pyseg plugin.
Its help description is:
 post-process already reconstructed particles: rot angle randomization and membrane suppression.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input subtomograms: Select the input subtomograms from the project.
Mask: Mask used for the post processing
Mask for membrane supression: None
Membrane suppression factor [0, 1]: Value 0 suppress the area corresponding to the suppression mask, while higher values up to 1 attenuate it.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.

The protocol named "preseg membranes" can be found at the pyseg plugin.
Its help description is:
 Segment membranes into membranes, inner surroundings and outer surroundings.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomomasks (segmentations): Pointer to segmented and annotated tomograms within Scipion.
Offset voxels: Margin to ensure that the desired entities, e. g. membranes, proteins, are included.
Density threshold: All the voxels with density equal to or higher than the threshold are set to 1. The remaining voxels are set to 0.
Size threshold (voxels): It sets the minimal size for a component to be considered as membrane.
Segmented membrane thickness (Å): Value introduced will be divided by 2 internally, because it is expected like that by PySeg.
Segmented membrane neighbours (Å): Thickness around the membrane to represent the in-membrane and out-membrane surroundings desired to be included in the analysis.

The protocol named "picking consensus" can be found at the tomoviz plugin.
Its help description is:
 
    Protocol to estimate the agreement between different particle picking
    algorithms. The protocol takes several Sets of Coordinates calculated
    by different programs and/or different parameter settings. Let's say:
    we consider N independent pickings. Then, a coordinate is considered
    to be a correct particle if M pickers have selected the same particle
    (within a radius in pixels specified in the form).

    If you want to be very strict, then set M=N; that is, a coordinate
    represents a particle if it has been selected by all particles (this
    is the default behaviour). Then you may relax this condition by setting
    M=N-1, N-2, ...

    If you want to be very flexible, set M=1, in this way it suffices that
    1 picker has selected the coordinate to be considered as a particle. Note
    that in this way, the cleaning of the dataset has to be performed by other
    means (screen particles, 2D and 3D classification, ...).
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input 3D coordinates: Select the set of 3D coordinates to compare
Radius: All coordinates within this radius (in pixels) are presumed to correspond to the same particle
Consensus: This parameter can take values from 1 to total number of inputs (being -1 a special case).
*Set to -1* to indicate that it needs to be selected by all algorithms: *AND* operation.
*Set to 1* to indicate that it suffices that only 1 algorithm selects the particle: *OR* operation.
Any other value will determine how many times need a particle to be selected to be considered as a consensus particle.
Consensus mode: If the number of votes to progress to the output must be either (=) strictly speaking equals to the consensus number or (>=) at least equals.

The protocol named "remove duplicates" can be found at the tomoviz plugin.
Its help description is:
 
    This protocol removes coordinates that are closer than a given threshold.
    The remaining coordinate is the average of the previous ones.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input coordinates: Select the set of 3D coordinates to compare
Radius: All coordinates within this radius (in pixels) are presumed to correspond to the same particle

The protocol named "filter by normal" can be found at the tomoviz plugin.
Its help description is:
  This protocol takes surfaces or ROIs (SetOfMeshes) and a SetOfSubtomograms or SetOfCoordinates3D with
    transformation matrix and filters them by different criteria related with the normal direction..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Subtomograms/Coordinates: Coordinates to filter.
Vesicles: Select the vesicles in which the subtomograms/coordinates are.
Filter by tilt angle: Remove items depending on their tilt angle.
Maximum allowed tilt: Remove the items that have a tilt angle bigger than the one specified in here, considering tilt angle between 0 and 180 degrees.
Minimum allowed tilt: Remove the items that have a tilt angle smaller than the one specified in here, considering tilt angle between 0 and 180 degrees.
Filter by normal: Remove the items that have a normal direction not equal to the normal direction of the vesicle in the coordinate of the particle.
Tolerance in degrees: Tolerance (in degrees) when comparing between subtomogram/coordinate and mesh normal directions.

The protocol named "movie alignment" can be found at the motioncorr plugin.
Its help description is:
  This protocol wraps motioncor movie alignment program developed at UCSF.

    Motioncor performs anisotropic drift correction and dose weighting
        (written by Shawn Zheng @ David Agard lab)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
: None
: None
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Split & sum odd/even frames?: Generate odd and even sums using odd and even frames respectively when this option is enabled.
Save aligned movie?: None
Compute PSD?: If Yes, the protocol will compute for each aligned micrograph the PSD using EMAN2.
Compute micrograph thumbnail?: When using this option, we will compute a micrograph thumbnail with EMAN2 and keep it with the micrograph object for visualization purposes. 
Additional protocol parameters: Here you can provide some extra parameters for the protocol, not the underlying motioncor program.You can provide many options separated by space. 

*Options:* 

--dont_use_worker_thread 
 Now by default we use a separate thread to compute PSD and thumbnail (if is required). This allows  more effective use of the GPU card, but requires  an extra CPU. Use this option (NOT RECOMMENDED) if  you want to prevent this behaviour
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. Motioncor can use multiple GPUs - in that case set to i.e. *0 1 2*.
Apply dose filter: Apply a dose-dependent filter to frames before summing them. Pre-exposure and dose per frame should be specified during movies import.
X: None
Y: None
Patches overlap (%): Specify the overlapping between patches. 
For example, overlap=20 means that each patch will have a 20% overlapping 
with its neighboring patches in each dimension.
global align: None
local align: None
Tolerance (px): Tolerance for iterative alignment, default *0.2px*.
Save unweighted images?: Aligned but non-dose weighted images are sometimes useful in CTF estimation, although there is no difference in most cases.
Additional parameters: Extra command line parameters. See MotionCor help.
Rotate gain reference:: Rotate gain reference counter-clockwise.
Flip gain reference:: Flip gain reference after rotation.
Camera defects file: Defect file that stores entries of defects on camera.
Each entry corresponds to a rectangular region in image. The pixels in such a region are replaced by neighboring good pixel values. Each entry contains 4 integers x, y, w, h representing the x, y coordinates, width, and height, respectively.
Camera defects map: 1. Defect map is a binary (0 or 1) map where defective  pixels are assigned value of 1 and good pixels have value of 0.
2. The defective pixels are corrected with a random pick of good pixels in its neighborhood. 
3. This is map must have the same dimension and orientation as the input movie frame.
4. This map can be provided as either MRC or TIFF file that has MRC mode of 0 or 5 (unsigned 8 bit).
These options are ignored for non-EER movies.: None
EER fractionation: The number of hardware frames to group into one fraction. This option is relevant only for Falcon 4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
EER upsampling: EER upsampling (1x = 4K, 2x = 8K, 3x=16K)
Correct anisotropic magnification?: Correct anisotropic magnification by stretching image along the major axis, the axis where the lower magnification is detected.
Major scale factor: None
Minor scale factor: None
Distortion angle (deg): None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tasks" can be found at the motioncorr plugin.
Its help description is:
  This protocol wraps motioncor movie alignment program developed at UCSF.

    Motioncor performs anisotropic drift correction and dose weighting
        (written by Shawn Zheng @ David Agard lab)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Movies: Select a set of previously imported movies.
: None
: None
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Split & sum odd/even frames?: Generate odd and even sums using odd and even frames respectively when this option is enabled.
Save aligned movie?: None
Compute PSD?: If Yes, the protocol will compute for each aligned micrograph the PSD using EMAN2.
Compute micrograph thumbnail?: When using this option, we will compute a micrograph thumbnail with EMAN2 and keep it with the micrograph object for visualization purposes. 
Additional protocol parameters: Here you can provide some extra parameters for the protocol, not the underlying motioncor program.You can provide many options separated by space. 

*Options:* 

--dont_use_worker_thread 
 Now by default we use a separate thread to compute PSD and thumbnail (if is required). This allows  more effective use of the GPU card, but requires  an extra CPU. Use this option (NOT RECOMMENDED) if  you want to prevent this behaviour
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. Motioncor can use multiple GPUs - in that case set to i.e. *0 1 2*.
Apply dose filter: Apply a dose-dependent filter to frames before summing them. Pre-exposure and dose per frame should be specified during movies import.
X: None
Y: None
Patches overlap (%): Specify the overlapping between patches. 
For example, overlap=20 means that each patch will have a 20% overlapping 
with its neighboring patches in each dimension.
global align: None
local align: None
Tolerance (px): Tolerance for iterative alignment, default *0.2px*.
Save unweighted images?: Aligned but non-dose weighted images are sometimes useful in CTF estimation, although there is no difference in most cases.
Additional parameters: Extra command line parameters. See MotionCor help.
Rotate gain reference:: Rotate gain reference counter-clockwise.
Flip gain reference:: Flip gain reference after rotation.
Camera defects file: Defect file that stores entries of defects on camera.
Each entry corresponds to a rectangular region in image. The pixels in such a region are replaced by neighboring good pixel values. Each entry contains 4 integers x, y, w, h representing the x, y coordinates, width, and height, respectively.
Camera defects map: 1. Defect map is a binary (0 or 1) map where defective  pixels are assigned value of 1 and good pixels have value of 0.
2. The defective pixels are corrected with a random pick of good pixels in its neighborhood. 
3. This is map must have the same dimension and orientation as the input movie frame.
4. This map can be provided as either MRC or TIFF file that has MRC mode of 0 or 5 (unsigned 8 bit).
These options are ignored for non-EER movies.: None
EER fractionation: The number of hardware frames to group into one fraction. This option is relevant only for Falcon 4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
EER upsampling: EER upsampling (1x = 4K, 2x = 8K, 3x=16K)
Correct anisotropic magnification?: Correct anisotropic magnification by stretching image along the major axis, the axis where the lower magnification is detected.
Major scale factor: None
Minor scale factor: None
Distortion angle (deg): None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.

The protocol named "align tilt-series movies" can be found at the motioncorr plugin.
Its help description is:
  This protocol wraps motioncor movie alignment program developed at UCSF.

    Motioncor performs anisotropic drift correction
        (written by Shawn Zheng @ David Agard lab)
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tilt-Series (movies): Select input tilt-series movies that you wantto correct for beam-induced motion. 
from: None
to: None
Use ALIGN frames range to SUM?: If *Yes*, the same frame range will be used to ALIGN and to SUM. If *No*, you can selected a different range for SUM (must be a subset).
from: None
to: None
Binning factor: 1x or 2x. Bin stack before processing.
X: None
Y: None
X: None
Y: None
Split & sum odd/even frames?: (Used for denoising data preparation). If set to Yes, 2 additional movies/tilt series will be generated, one generated from the even frames and the other from the odd ones using the same alignment for the whole stack of frames.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
: GPU may have several cores. Set it to zero if you do not know what we are talking about. First core index is 0, second 1 and so on. Motioncor can use multiple GPUs - in that case set to i.e. *0 1 2*.
X: None
Y: None
Patches overlap (%): Specify the overlapping between patches. 
For example, overlap=20 means that each patch will have a 20% overlapping 
with its neighboring patches in each dimension.
global align: None
local align: None
Tolerance (px): Tolerance for iterative alignment, default *0.2px*.
Additional parameters: Extra command line parameters. See MotionCor help.
Rotate gain reference:: Rotate gain reference counter-clockwise.
Flip gain reference:: Flip gain reference after rotation.
Camera defects file: Defect file that stores entries of defects on camera.
Each entry corresponds to a rectangular region in image. The pixels in such a region are replaced by neighboring good pixel values. Each entry contains 4 integers x, y, w, h representing the x, y coordinates, width, and height, respectively.
Camera defects map: 1. Defect map is a binary (0 or 1) map where defective  pixels are assigned value of 1 and good pixels have value of 0.
2. The defective pixels are corrected with a random pick of good pixels in its neighborhood. 
3. This is map must have the same dimension and orientation as the input movie frame.
4. This map can be provided as either MRC or TIFF file that has MRC mode of 0 or 5 (unsigned 8 bit).
These options are ignored for non-EER movies.: None
EER fractionation: The number of hardware frames to group into one fraction. This option is relevant only for Falcon 4 movies in the EER format. Falcon 4 operates at 248 frames/s.
Fractionate such that each fraction has about 0.5 to 1.25 e/A2.
EER upsampling: EER upsampling (1x = 4K, 2x = 8K, 3x=16K)
Correct anisotropic magnification?: Correct anisotropic magnification by stretching image along the major axis, the axis where the lower magnification is detected.
Major scale factor: None
Minor scale factor: None
Distortion angle (deg): None

The protocol named "annotate segmented membranes" can be found at the tomosegmemtv plugin.
Its help description is:
  Manual annotation tool for segmented membranes
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Tomo Masks: Select the Tomogram Masks (segmented tomograms) for the membrane annotation.

The protocol named "Resize segmented or annotated volume" can be found at the tomosegmemtv plugin.
Its help description is:
 Resize segmented volumes or annotated (TomoMasks)..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input segmentations (TomoMasks): None
Input tomograms: These tomograms will be used to be the ones to which the resized TomoMasks will be referred to. Thus, the resized segmentations will be of the same size of those tomograms.

The protocol named "tomogram segmentation" can be found at the tomosegmemtv plugin.
Its help description is:
 Segment membranes in tomograms.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tomograms: None
Membrane thickness (voxels): It basically represents the standard deviation of a Gaussian filtering. In general, any value in a range around that thickness works well. Too low values may make spurious details produce false positives at the local membrane detector while too high values may excessively smear out the membranes, which in turn may produce discontinuities in the segmentation results.
Membrane scale factor (voxels): This defines the effective neighborhood involved in the voting process. Depending on the thickness of the membranes in the tomogram, lower (for thinner membranes) or higher values (for thicker ones) may be more appropriate.
Is black over white?: None
Membrane-strength threshold: Allow the user tune the amount of output membrane points and remove false positives. Only voxels with values of membrane-strength threshold higher than this value will be considered as potential membrane points, and planarity descriptors will be calculated for them. Higher values will generate less membrane points, at the risk of producing gaps in the membranes. Lower values will provide more membrane points, at the risk of generating false positives.
Sigma for the initial gaussian filtering: The input tomogram is subjected to an initial Gaussian filtering aiming at reducing the noise so as to determine the derivatives more robustly. By default, a standard deviation of 1.0 voxel is considered. This option allows fine-tuning of this parameter. If the membranes are very thin or are very close to each other, use lower values (e.g. 0.5)
Sigma for the post-processing gaussian filtering: This option refers to the post-processing Gaussian filtering that is applied to the output tomogram. If sigma is set to 0, no such filtering will be applied and the program will produce 1-voxel-thick membranes. If the filter is desired to be applied, use lower values (e.g 0.5) for membranes that are very thin or are very close to each other.
Keep all the generated files?: If set to Yes, a file will be kept for each step carried out in the protocol. If set to No, only the file corresponding to the last step will be kept. Steps followed and the corresponding generated files are listed below:

   - Scale-space --> *filename_s2.mrc*
   - First tensor voting --> *filename_tv.mrc*
   - Surfaceness --> *filename_surf.mrc*
   - Second tensor voting --> *filename_tv2.mrc*
   - Saliency --> *filename_flt.mrc*
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "compute defocus array" can be found at the novactf plugin.
Its help description is:
 
    Compute defocus array for each tilt-image with novaCTF.

    More info:
            https://github.com/turonova/novaCTF
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of tilt-series: None
Input tilt-series CTF estimation: Select the CTF estimation for the input tilt-series.
Tomogram thickness (voxels): Size of the tomogram in voxels in the Z direction.
Tomogram shift (voxels): Shift of the tomogram in voxels in the Z direction. The shift should be set to zero even if for reconstruction we want to shift the tomogram in z! We assume the defocus to be estimated at the center of mass which should correspond to the shifted tomogram and thus here the shift should be zero.
Defocus step (nm): The space between min and max in Z is sliced by defocus step. 15 nm is default step size. See Fig. 2 in Turonova et al., 2017 for optimal number.
Correction type: CTF correction type to be applied for the tilt-series.
Correct astigmatism: Correct for astigmatism in reconstruction.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "3D CTF correction and reconstruction" can be found at the novactf plugin.
Its help description is:
 
    Tomogram reconstruction with 3D CTF correction by novaCTF.

    More info:
            https://github.com/turonova/novaCTF
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
NovaCTF compute defocus run: None
Apply tilt-series alignment?: None
Erase gold beads: Remove the gold beads from the tilt-series.
Input set of fiducial models: Set of fid. models with no gaps after alignment
Bead diameter (px): For circle objects, this entry specifies a radius to use for points without an individual point size instead of the object's default sphere radius. This entry is floating point and can be used to overcome the limitations of having an integer default sphere radius. If there are multiple circle objects, enter one value to apply to all objects or a value for each object.
Linear region: None
Gaussian fall-off: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "auto-picking" can be found at the gautomatch plugin.
Its help description is:
  Automated particle picker for SPA.

    Gautomatch is a GPU accelerated program for accurate, fast, flexible and
    fully automatic particle picking from cryo-EM micrographs with or without
    templates.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input Micrographs: Select the SetOfMicrographs to be used during picking.
Input References: Template images (2D class averages or reprojections from a reference volume) to be used in picking.
 If not provided, references will be auto-generated. This is fine for *spherical particles* like virus or ribosome.
References have inverted contrast: Set to Yes to indicate that the reference have inverted contrast with respect to the particles in the micrographs.
Keep in mind that auto-generated templates will be WHITE.
Angular step size: Angular step size for picking, in degrees
Micrographs for wizard: Select which micrographs will be used for optimizing the parameters in the wizard. By default, ALL micrograph are used. You can select to use a subset based on defocus values (where micrographs will be taken from different defocus). 
Micrographs for optimization:: Select the number of micrographs that you want to be used for the parameters optimization. 
CTF estimation: Choose some CTF estimation related to the input micrographs to create the subset by defocus values.
Threshold: Particles with CCC above the threshold will be picked
Particle radius (A): Particle radius in Angstrom. Default -1 means it will be equal to 75% of references size if they were provided, otherwise 250 A.
: None
Guess advanced parameters?: By default, the program will optimize advanced parameters by itself, however if you want to modify them, select No
Box size (pix): Box size, in pixels; a suggested value will be automatically calculated using pixel size and particle size
Min inter-particle distance (A): Minimum distance between particles in Angstrom
 Use value of 0.9~1.1X diameter; can be 0.3~0.5X for filament-like particle
Speed: Speed level {0,1,2,3,4}. The bigger the faster, but less accurate.
Suggested values: 2 for >1 MDa complex, 1 for <500 kD complex, 1 or 2 for 500~1000 kD.
0 is not suggested, because the accuracy is simply fitting noise, unless for special noise-free micrographs. Use 3 for huge viruses, but 2 is still preferred. Probably do not use 4 at all, it is not accurate in general.
To adjust these parameters, select "No" for the "Guess advanced parameters?" on the Advanced tab.: None
Local sigma cut-off: Local sigma cut-off (relative value), 1.2~1.5 should be a good range
Normally a value >1.2 will be ice, protein aggregation or contamination.
This option is designed to get rid of sharp carbon/ice edges or sharp metal particles.
Local sigma diameter (A): Diameter for estimation of local sigma, in Angstrom.
Usually this diameter could be 0.5-2x of your particle diameter according to several factors. When using bigger values, normally you should decrease *Local sigma cut-off*. For smaller and sharper high density contamination/ice/metal particles you could use a smaller diameter and larger *Local sigma cut-off*
Min: None
Max: None
Local average diameter (A): Diameter for estimation of local average, in Angstrom. 1.5~2.0X particle diameter suggested.
However, if you have sharp/small ice or any dark/bright dots, using a smaller value will be much better to get rid of these areas
Min: None
Max: None
Pre-filter micrographs?: This band-pass pre-filter is normally not suggested, because it can affect ice/carbon detection. Use it only if you have a severe ice gradient.
Min: None
Max: None
Detect ice/aggregates/carbon?: None
Template normalization type: Template normalization: 1, 2 or 3 allowed.
Do band-pass?: Choose No to skip band-pass filtering.
Exclusive picking?: Exclude user-provided areas. This can be useful in the following cases:

(a) Another cycle of auto-picking after 2D classification: in this case, usually you are pretty sure that some of the particles are completely rubbish, it will be much better to exclude them during picking.
(b) Picking for partial structure: sometimes, you might have two/multiple domain complex, one is severely dominant and affect picking of the other (the rest). If you want to focus on another domain, it might be quite helpful to exclude such good particles from 2D classification.
(c) Strong orientation preference: if your templates were severely biased and mainly picked the preferred views, then it might be nice to exclude the preferred views and focused on rare views.
Coordinates to be excluded: Coordinates can be imported beforehand or generated from particles using scipion - extract coordinates protocol.
Detector defects coordinates: Occasionally you might have detector defects, e.g. a black/white stripe. This will help to get rid of these bad areas.
Write CC files?: Specify to write out cross-correlation files in MRC stack
Write pre-filtered micrographs?: Specify to write out pre-filted micrographs
Write estimated background?: Specify to write out estimated background of the micrographs
Write background-subtracted micrographs?: Specify to write out background-subtracted micrographs
Write local sigma?: Specify to write out local sigma micrographs
Write detected mask?: Specify to write out the auto-detected mask (ice, contamination, aggregation, carbon edges etc.)
The following params are related to how streaming is done in Scipion.: None
Sleep when waiting (secs): If you specify a value greater than zero, it will be the number of seconds that the protocol will sleep when waiting for new input data in streaming mode. 
Batch size: This value allows to group several items to be processed inside the same protocol step. You can use the following values: 
*1*    The default behavior, the items will be processed one by one.
*0*    Put in the same step all the items available. If the sleep time is short, it could be practically the same of one by one. If not, you could have steps with more items. If the steps will be executed in parallel, it is better not to use this option.
*>1*   The number of items that will be grouped into a step.
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tomo reconstruction" can be found at the isonet plugin.
Its help description is:
 
     Isotropic Reconstruction of Electron Tomograms with Deep Learning
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomograms: Select the input tomogram for restoring the missing wedge.
CTF tomo series: Select the CTF estimation for the set of tilt-series.
Acceleration voltage: Acceleration voltage in kV
Spherical aberration: Spherical aberration in mm.
SNR fall rate: SNR fall rate with the frequency. High values means losing more high frequency.If this value is not set, the program will look for the parameter in the star file.If this value is not set and not found in star file, the default value 1.0 will be used.
Strength of the deconvolution: SNR fall rate with the frequency. High values means losing more high frequency.If this value is not set, the program will look for the parameter in the star file.If this value is not set and not found in star file, the default value 1.0 will be used.
Highpass filter: Highpass filter for at very low frequency. We suggest to keep this default value.
The overlapping rate: The overlapping rate for adjecent chunks.
Highpass filter: Highpass filter for at very low frequency. We suggest to keep this default value.
Pixel size (Å): Pixel size in Anstroms. Usually you want to bin your tomograms to about 10Å pixel size.Too large or too small pixel sizes are not recommanded, since the target resolution on Z-axis of corrected tomograms should be about 30Å.
Generate mask?: Generate a mask that include sample area and exclude "empty" area of the tomogram. The masks do not need to be precise. In general, the number of subtomograms (a value in star file) should be lesser if you masked out larger area.
Patch size:  The size of the box from which the max-filter and std-filter are calculated.
Density percentage: The approximate percentage of pixels to keep based on their local pixel density.If this value is not set, the program will look for the parameter in the star file.If this value is not set and not found in star file, the default value 50 will be used.
Std percentage: The approximate percentage of pixels to keep based on their local standard deviation.If this value is not set, the program will look for the parameter in the star file.If this value is not set and not found in star file, the default value 50 will be used.
Z_crop: If exclude the top and bottom regions of tomograms along z axis. For example, "0.2" will mask out the top 20% and bottom 20% region along z axis.
Tomo index:  If this value is set, process only the tomograms listed in this index. e.g. 1,2,4 or 5-10,15,16
Number of subtomograms to be extracted per tomogram: Number of subtomograms to be extracted
Size of cubes: Size of cubes for training, should be divisible by 8, eg. 32, 64. The actual sizes of extracted subtomograms are this value adds 16.This is the size of the cubic volumes used for training. This values should be smaller than the size of subtomogram. And the cube_size should be divisible by 8. If this value isnt set, cube_size is automatically determined as int(subtomo_size / 1.5 + 1)//16 * 16
Crop size: The size of subtomogram, should be larger than the cube_size The default value should be 16+cube_size.
Training model path: A trained neural network model in ".h5" format to start with.
Number of training iterations: Number of training iterations
Number of epoch: Number of epoch for each iteraction
Batch size: Size of the minibatch.If None, batch_size will be the max(2 * number_of_gpu,4). batch_size should be divisible by the number of gpu.
Steps per epoch: Step per epoch. If not defined, the default value will be min(num_of_subtomograms * 6 / batch_size , 200
Level of noise: Level of noise STD(added noise)/STD(data) after the iteration defined in noise_start_iter.
Noise start iter: Iteration that start to add noise of corresponding noise level.
Filter names: Filter names when generating noise volumes, can be 'ramp', 'hamming' and 'noFilter'
Drop out rate: Drop out rate to reduce overfitting
Learning rate: Learning rate for network training.
Number of convolution layer: Number of convolution layer for each depth
Depth of UNet: Depth of UNet.
Kernel for convolution: Kernel for convolution
Filter base: The base number of channels after convolution.
Use batch normalization layer?: Use Batch Normalization layer
Use pooling layer?: Use pooling layer instead of stride convolution layer
Normalize percentile?: Normalize the 5 percent and 95 percent pixel intensity to 0 and 1 respectively. If this is set to False, normalize the input to 0 mean and 1 standard deviation.
Execution host: Select in which of the available do you want to launch this protocol.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.
Choose GPU IDs:: This argument is necessary. By default, the protocol will attempt to launch on GPU 0. You can override the default allocation by providing a list of which GPUs (0,1,2,3, etc) to use. GPU are separated by ",". For example: "0,1,5"

The protocol named "tilt-series align and reconstruct" can be found at the aretomo plugin.
Its help description is:
  Protocol for fiducial-free tilt series alignment, tomogram reconstruction and CTF estimation all in one..
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input set of Tilt-Series: If you choose to skip alignment, the input tilt-series are expected to be already aligned.
Skip alignment?: You can skip alignment if you just want to reconstruct a tomogram from already aligned tilt-series.
Reconstruct the tomograms?: You can skip tomogram reconstruction, so that input tilt-series will be only aligned.
Save interpolated aligned TS?: Choose No to discard aligned stacks.
Use alignment from previous AreTomo run?: None
Previous AreTomo run: Use alignment from a previous AreTomo run. The match is made using *tsId*. This option is useful when working with odd/even tilt-series sets. All other input alignment parameters will be ignored.
Binning: Binning for aligned output tilt-series / volume.
Volume height for alignment (voxels): Specifies Z height (*unbinned*) of the temporary volume reconstructed for projection matching as part of the alignment process. This value plays an important role in alignment accuracy. This Z height should be always smaller than tomogram thickness and should be close to the sample thickness.
Tomogram thickness unbinned (voxels): Z height of the reconstructed volume in *unbinned* voxels.
Refine tilt angles?: You have three options:
a) Disable measure and correction
b) Measure only (default). Correction is done during alignment but not for final reconstruction
c) Measure and correct

Occasionally, the measurement is erroneous and can impair the alignment accuracy. Please note that the orientation of the missing wedge will be changed as a result of the correction of tilt offset. For subtomogram averaging, tomograms reconstructed from tilt series collected within the same tilt range may have different orientations of missing wedges.
Refine tilt axis angle?: Tilt axis determination is a two-step processing in AreTomo. A single tilt axis is first calculated followed by the determination of how tilt axis varies over the entire tilt range. The initial value lets users enter their estimate and AreTomo refines the estimate in [-3º, 3º] range.
Generate extra IMOD output?: 0 - No
1 - generate IMOD files for Relion 4
2 - generate IMOD files for Warp
3 - generate global and local-aligned tilt series stack. High frequencies are enhanced to alleviate the attenuation due to interpolation.
Estimate the CTF?: Activate to make aretomo estimate the CTF.
Do phase shift estimation?: None
min: None
max: None
Do dose-weighting?: None
Reconstruction method: Choose either SART or weighted back projection (WBP).
iterations: None
projections per subset: None
Flip intensity?: By default, the reconstructed volume and the input tilt series use the same grayscale that makes dense structures dark.
Flip volume?: Set to Yes when making a tomogram and No when making a tilt-series. This way the output orientation will be similar to IMOD.
ROI for focused alignment: By default AreTomo assumes the region of interest at the center of 0º projection image. A circular mask is employed to down-weight the area outside ROI during the alignment. When the structures of interest are far away from the tilt axis, the angular error in the determination of tilt axis will significantly amplify the translational error. ROI function can effectively improve the alignment accuracy for the distant structures.
Here you can provide *a pair of x and y coordinates*, representing the center of the region of interest.
The region of interest should be selected from 0º projection image with the origin at the lower left corner. IMOD's Pixel View is a good tool to select the center of region of interest.
Sample type: AreTomo provides two means to correct the local motion, one for isolated sample and the other for well distributed across the field of view.
Coordinate file: A list of x and y coordinates should be put into a two-column text file, one column for x and the other for y. Each pair defines a region of interest (ROI). The origin of the coordinate system is at the image's lower left corner.
X: None
Y: None
Dark tolerance: Set tolerance for removing dark images. The range is in (0, 1). The default value is 0.7. The higher value is more restrictive.
Additional parameters: Extra command line parameters. See AreTomo help.
: None
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "tomo blik" can be found at the blik plugin.
Its help description is:
 
    Tool for visualising and interacting with cryo-ET and subtomogram averaging
    data using napari viewer
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Tomograms: Select the input tomograms

The protocol named "tomogram membrane segmentation" can be found at the membrain plugin.
Its help description is:
 
    Segment membranes in tomograms using MemBrain-seg.

    More info:
        https://github.com/teamtomo/membrain-seg
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input tomograms: None
Threshold for segmentation: Threshold for the membrane segmentation. Only voxels with a membrane score higher than this threshold will be segmented.
Sliding window size: Sliding window size used for inference. Smaller values than 160 consume less GPU, but also lead to worse segmentation results!
Label connected components?: Segmentation will be stored as labelled connected components (automatic annotation).
Threshold for connected components: Components smaller than this size (in voxels) will be removed from the segmentation. A negative value disables this parameter.
Do test-time augmentation?: Use 8-fold test-time augmentation? This improves segmentation quality, but also increases runtime.
Output probability maps?: Stores probability maps obtained from 8-fold test-time augmentation in addition to the segmentations.
: GPU device to be used. If no GPU is found, MemBrain-seg will run on CPU using the number of threads specified (much slower)
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "OFM Corrector" can be found at the ofmcorrection plugin.
Its help description is:
 
    Corrects optical fluorecence microscopy images/channels based on calibration images
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Beads file pattern: Pattern of the beads file name. Must contain this text.
OFM Root folder: Path to the OFM sample images
File finished after: File will be considered finished if it has not been modified for this time. Duration format example: 1d 20h 30m 30s --> 1 day 20 hours 30 minutes and 30 seconds
Scanning waiting time: Time to wait for the next folder scan. Duration format example: 1d 20h 30m 30s --> 1 day 20 hours 30 minutes and 30 seconds
Execution host: Select in which of the available do you want to launch this protocol.
Threads: This option provides shared-memory parallelization on multi-core machines.It does not require any additional software.
MPI processes: This option provides the number of independent processes spawnedin parallel by <mpirun> command in a cluster, usually througha queue system. This will require that you have compile this software with <mpi> support.

The protocol named "AI training" can be found at the tomonet plugin.
Its help description is:
 
    Trains an AI model using a set of Coordinates. Producing a AI model that
    can be used in a later TomoNet tomogram picking step.
    .
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Coordinates: Coordinates to be used in the training
Epochs: Number of "iterations" to run over the training data.

The protocol named "test output" can be found at the pyworkflowtests plugin.
Its help description is:
  Protocol to test scalar output and input linking.
These are the parameters it accepts:
Run name:: Select run name label to identify this run.
Run mode: The <resume> mode will try to start the executionfrom the last successfully finished step if possible.On the contrary, <restart> will delete all previous resultsof this particular run and start from the beginning. This optionshould be used carefully.
Input box size as Integer: None
Nullable Integer: None
Scipion v3.4.0 - Eugenius
